/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * GES-1.0
 */

import type * as Gjs from './Gjs';
import type GstVideo from './GstVideo-1.0';
import type GstBase from './GstBase-1.0';
import type Gst from './Gst-1.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';
import type GModule from './GModule-2.0';
import type GstPbutils from './GstPbutils-1.0';
import type GstAudio from './GstAudio-1.0';
import type Gio from './Gio-2.0';

export namespace GES {

enum AssetLoadingReturn {
    /**
     * Indicates that an error occurred
     */
    ERROR,
    /**
     * Indicates that the loading is being performed
     * asynchronously
     */
    ASYNC,
    /**
     * Indicates that the loading is complete, without
     * error
     */
    OK,
}
/**
 * To be used by subclasses only. This indicate how to handle a change in
 * a child.
 */
enum ChildrenControlMode {
    UPDATE,
    IGNORE_NOTIFIES,
    UPDATE_OFFSETS,
    UPDATE_ALL_VALUES,
    LAST,
}
/**
 * The edges of an object contain in a #GESTimeline or #GESTrack
 */
enum Edge {
    /**
     * Represents the start of an object.
     */
    EDGE_START,
    /**
     * Represents the start of an object.
     */
    START,
    /**
     * Represents the end of an object.
     */
    EDGE_END,
    /**
     * Represents the end of an object.
     */
    END,
    /**
     * Represent the fact we are not working with any edge of an
     *   object.
     */
    EDGE_NONE,
    /**
     * Represent the fact we are not working with any edge of an
     *   object.
     */
    NONE,
}
/**
 * When a single timeline element is edited within its timeline at some
 * position, using ges_timeline_element_edit(), depending on the edit
 * mode, its #GESTimelineElement:start, #GESTimelineElement:duration or
 * #GESTimelineElement:in-point will be adjusted accordingly. In addition,
 * any clips may change #GESClip:layer.
 * 
 * Each edit can be broken down into a combination of three basic edits:
 * 
 * + MOVE: This moves the start of the element to the edit position.
 * + START-TRIM: This cuts or grows the start of the element, whilst
 *   maintaining the time at which its internal content appears in the
 *   timeline data output. If the element is made shorter, the data that
 *   appeared at the edit position will still appear in the timeline at
 *   the same time. If the element is made longer, the data that appeared
 *   at the previous start of the element will still appear in the
 *   timeline at the same time.
 * + END-TRIM: Similar to START-TRIM, but the end of the element is cut or
 *   grown.
 * 
 * In particular, when editing a #GESClip:
 * 
 * + MOVE: This will set the #GESTimelineElement:start of the clip to the
 *   edit position.
 * + START-TRIM: This will set the #GESTimelineElement:start of the clip
 *   to the edit position. To keep the end time the same, the
 *   #GESTimelineElement:duration of the clip will be adjusted in the
 *   opposite direction. In addition, the #GESTimelineElement:in-point of
 *   the clip will be shifted such that the content that appeared at the
 *   new or previous start time, whichever is latest, still appears at the
 *   same timeline time. For example, if a frame appeared at the start of
 *   the clip, and the start of the clip is reduced, the in-point of the
 *   clip will also reduce such that the frame will appear later within
 *   the clip, but at the same timeline position.
 * + END-TRIM: This will set the #GESTimelineElement:duration of the clip
 *   such that its end time will match the edit position.
 * 
 * When editing a #GESGroup:
 * 
 * + MOVE: This will set the #GESGroup:start of the clip to the edit
 *   position by shifting all of its children by the same amount. So each
 *   child will maintain their relative positions.
 * + START-TRIM: If the group is made shorter, this will START-TRIM any
 *   clips under the group that start after the edit position to the same
 *   edit position. If the group is made longer, this will START-TRIM any
 *   clip under the group whose start matches the start of the group to
 *   the same edit position.
 * + END-TRIM: If the group is made shorter, this will END-TRIM any clips
 *   under the group that end after the edit position to the same edit
 *   position. If the group is made longer, this will END-TRIM any clip
 *   under the group whose end matches the end of the group to the same
 *   edit position.
 * 
 * When editing a #GESTrackElement, if it has a #GESClip parent, this
 * will be edited instead. Otherwise it is edited in the same way as a
 * #GESClip.
 * 
 * The layer priority of a #GESGroup is the lowest layer priority of any
 * #GESClip underneath it. When a group is edited to a new layer
 * priority, it will shift all clips underneath it by the same amount,
 * such that their relative layers stay the same.
 * 
 * If the #GESTimeline has a #GESTimeline:snapping-distance, then snapping
 * may occur for some of the edges of the **main** edited element:
 * 
 * + MOVE: The start or end edge of *any* #GESSource under the element may
 *   be snapped.
 * + START-TRIM: The start edge of a #GESSource whose start edge touches
 *   the start edge of the element may snap.
 * + END-TRIM: The end edge of a #GESSource whose end edge touches the end
 *   edge of the element may snap.
 * 
 * These edges may snap with either the start or end edge of *any* other
 * #GESSource in the timeline that is not also being moved by the element,
 * including those in different layers, if they are within the
 * #GESTimeline:snapping-distance. During an edit, only up to one snap can
 * occur. This will shift the edit position such that the snapped edges
 * will touch once the edit has completed.
 * 
 * Note that snapping can cause an edit to fail where it would have
 * otherwise succeeded because it may push the edit position such that the
 * edit would result in an unsupported timeline configuration. Similarly,
 * snapping can cause an edit to succeed where it would have otherwise
 * failed.
 * 
 * For example, in #GES_EDIT_MODE_RIPPLE acting on #GES_EDGE_NONE, the
 * main element is the MOVED toplevel of the edited element. Any source
 * under the main MOVED toplevel may have its start or end edge snapped.
 * Note, these sources cannot snap with each other. The edit may also
 * push other elements, but any sources under these elements cannot snap,
 * nor can they be snapped with. If a snap does occur, the MOVE of the
 * toplevel *and* all other elements pushed by the ripple will be shifted
 * by the same amount such that the snapped edges will touch.
 * 
 * You can also find more explanation about the behaviour of those modes at:
 * [trim, ripple and roll](http://pitivi.org/manual/trimming.html)
 * and [clip management](http://pitivi.org/manual/usingclips.html).
 */
enum EditMode {
    /**
     * The element is edited the normal way (default).
     *  If acting on the element as a whole (#GES_EDGE_NONE), this will MOVE
     *  the element by MOVING its toplevel. When acting on the start of the
     *  element (#GES_EDGE_START), this will only MOVE the element, but not
     *  its toplevel parent. This can allow you to move a #GESClip or
     *  #GESGroup to a new start time or layer within its container group,
     *  without effecting other members of the group. When acting on the end
     *  of the element (#GES_EDGE_END), this will END-TRIM the element,
     *  leaving its toplevel unchanged.
     */
    EDIT_NORMAL,
    /**
     * The element is edited the normal way (default).
     *  If acting on the element as a whole (#GES_EDGE_NONE), this will MOVE
     *  the element by MOVING its toplevel. When acting on the start of the
     *  element (#GES_EDGE_START), this will only MOVE the element, but not
     *  its toplevel parent. This can allow you to move a #GESClip or
     *  #GESGroup to a new start time or layer within its container group,
     *  without effecting other members of the group. When acting on the end
     *  of the element (#GES_EDGE_END), this will END-TRIM the element,
     *  leaving its toplevel unchanged.
     */
    NORMAL,
    /**
     * The element is edited in ripple mode: moving
     *  itself as well as later elements, keeping their relative times. This
     *  edits the element the same as #GES_EDIT_MODE_NORMAL. In addition, if
     *  acting on the element as a whole, or the start of the element, any
     *  toplevel element in the same timeline (including different layers)
     *  whose start time is later than the *current* start time of the MOVED
     *  element will also be MOVED by the same shift as the edited element.
     *  If acting on the end of the element, any toplevel element whose start
     *  time is later than the *current* end time of the edited element will
     *  also be MOVED by the same shift as the change in the end of the
     *  edited element. These additional elements will also be shifted by
     *  the same shift in layers as the edited element.
     */
    EDIT_RIPPLE,
    /**
     * The element is edited in ripple mode: moving
     *  itself as well as later elements, keeping their relative times. This
     *  edits the element the same as #GES_EDIT_MODE_NORMAL. In addition, if
     *  acting on the element as a whole, or the start of the element, any
     *  toplevel element in the same timeline (including different layers)
     *  whose start time is later than the *current* start time of the MOVED
     *  element will also be MOVED by the same shift as the edited element.
     *  If acting on the end of the element, any toplevel element whose start
     *  time is later than the *current* end time of the edited element will
     *  also be MOVED by the same shift as the change in the end of the
     *  edited element. These additional elements will also be shifted by
     *  the same shift in layers as the edited element.
     */
    RIPPLE,
    /**
     * The element is edited in roll mode: swapping its
     *  content for its neighbour's, or vis versa, in the timeline output.
     *  This edits the element the same as #GES_EDIT_MODE_TRIM. In addition,
     *  any neighbours are also TRIMMED at their opposite edge to the same
     *  timeline position. When acting on the start of the element, a
     *  neighbour is any earlier element in the timeline whose end time
     *  matches the *current* start time of the edited element. When acting on
     *  the end of the element, a neighbour is any later element in the
     *  timeline whose start time matches the *current* start time of the
     *  edited element. In addition, a neighbour have a #GESSource at its
     *  end/start edge that shares a track with a #GESSource at the start/end
     *  edge of the edited element. Basically, a neighbour is an element that
     *  can be extended, or cut, to have its content replace, or be replaced
     *  by, the content of the edited element. Acting on the element as a
     *  whole (#GES_EDGE_NONE) is not defined. The element can not shift
     *  layers under this mode.
     */
    EDIT_ROLL,
    /**
     * The element is edited in roll mode: swapping its
     *  content for its neighbour's, or vis versa, in the timeline output.
     *  This edits the element the same as #GES_EDIT_MODE_TRIM. In addition,
     *  any neighbours are also TRIMMED at their opposite edge to the same
     *  timeline position. When acting on the start of the element, a
     *  neighbour is any earlier element in the timeline whose end time
     *  matches the *current* start time of the edited element. When acting on
     *  the end of the element, a neighbour is any later element in the
     *  timeline whose start time matches the *current* start time of the
     *  edited element. In addition, a neighbour have a #GESSource at its
     *  end/start edge that shares a track with a #GESSource at the start/end
     *  edge of the edited element. Basically, a neighbour is an element that
     *  can be extended, or cut, to have its content replace, or be replaced
     *  by, the content of the edited element. Acting on the element as a
     *  whole (#GES_EDGE_NONE) is not defined. The element can not shift
     *  layers under this mode.
     */
    ROLL,
    /**
     * The element is edited in trim mode. When acting
     *  on the start of the element, this will START-TRIM it. When acting on
     *  the end of the element, this will END-TRIM it. Acting on the element
     *  as a whole (#GES_EDGE_NONE) is not defined.
     */
    EDIT_TRIM,
    /**
     * The element is edited in trim mode. When acting
     *  on the start of the element, this will START-TRIM it. When acting on
     *  the end of the element, this will END-TRIM it. Acting on the element
     *  as a whole (#GES_EDGE_NONE) is not defined.
     */
    TRIM,
    /**
     * The element is edited in slide mode (not yet
     *  implemented): moving the element replacing or consuming content on
     *  each end. When acting on the element as a whole, this will MOVE the
     *  element, and TRIM any neighbours on either side. A neighbour is
     *  defined in the same way as in #GES_EDIT_MODE_ROLL, but they may be on
     *  either side of the edited elements. Elements at the end with be
     *  START-TRIMMED to the new end position of the edited element. Elements
     *  at the start will be END-TRIMMED to the new start position of the
     *  edited element. Acting on the start or end of the element
     *  (#GES_EDGE_START and #GES_EDGE_END) is not defined. The element can
     *  not shift layers under this mode.
     */
    EDIT_SLIDE,
    /**
     * The element is edited in slide mode (not yet
     *  implemented): moving the element replacing or consuming content on
     *  each end. When acting on the element as a whole, this will MOVE the
     *  element, and TRIM any neighbours on either side. A neighbour is
     *  defined in the same way as in #GES_EDIT_MODE_ROLL, but they may be on
     *  either side of the edited elements. Elements at the end with be
     *  START-TRIMMED to the new end position of the edited element. Elements
     *  at the start will be END-TRIMMED to the new start position of the
     *  edited element. Acting on the start or end of the element
     *  (#GES_EDGE_START and #GES_EDGE_END) is not defined. The element can
     *  not shift layers under this mode.
     */
    SLIDE,
}
enum Error {
    /**
     * The ID passed is malformed
     */
    ASSET_WRONG_ID,
    /**
     * An error happened while loading the asset
     */
    ASSET_LOADING,
    /**
     * The formatted files was malformed
     */
    FORMATTER_MALFORMED_INPUT_FILE,
    /**
     * The frame number is invalid
     */
    INVALID_FRAME_NUMBER,
    /**
     * The operation would lead to a negative
     * #GES_TIMELINE_ELEMENT_LAYER_PRIORITY. (Since: 1.18)
     */
    NEGATIVE_LAYER,
    /**
     * The operation would lead to a negative time.
     * E.g. for the #GESTimelineElement:start #GESTimelineElement:duration or
     * #GESTimelineElement:in-point. (Since: 1.18)
     */
    NEGATIVE_TIME,
    /**
     * Some #GESTimelineElement does
     * not have a large enough #GESTimelineElement:max-duration to cover the
     * desired operation. (Since: 1.18)
     */
    NOT_ENOUGH_INTERNAL_CONTENT,
    /**
     * The operation would break one of
     * the overlap conditions for the #GESTimeline. (Since: 1.18)
     */
    INVALID_OVERLAP_IN_TRACK,
    INVALID_EFFECT_BIN_DESCRIPTION,
}
/**
 * Horizontal alignment of the text.
 */
enum TextHAlign {
    /**
     * align text left
     */
    LEFT,
    /**
     * align text center
     */
    CENTER,
    /**
     * align text right
     */
    RIGHT,
    /**
     * align text on xpos position
     */
    POSITION,
    ABSOLUTE,
}
/**
 * Vertical alignment of the text.
 */
enum TextVAlign {
    /**
     * draw text on the baseline
     */
    BASELINE,
    /**
     * draw text on the bottom
     */
    BOTTOM,
    /**
     * draw text on top
     */
    TOP,
    /**
     * draw text on ypos position
     */
    POSITION,
    /**
     * draw text on the center
     */
    CENTER,
    ABSOLUTE,
}
enum VideoStandardTransitionType {
    /**
     * Transition type has not been set,
     */
    NONE,
    /**
     * A bar moves from left to right,
     */
    BAR_WIPE_LR,
    /**
     * A bar moves from top to bottom,
     */
    BAR_WIPE_TB,
    /**
     * A box expands from the upper-left corner to the lower-right corner,
     */
    BOX_WIPE_TL,
    /**
     * A box expands from the upper-right corner to the lower-left corner,
     */
    BOX_WIPE_TR,
    /**
     * A box expands from the lower-right corner to the upper-left corner,
     */
    BOX_WIPE_BR,
    /**
     * A box expands from the lower-left corner to the upper-right corner,
     */
    BOX_WIPE_BL,
    /**
     * A box shape expands from each of the four corners toward the center,
     */
    FOUR_BOX_WIPE_CI,
    /**
     * A box shape expands from the center of each quadrant toward the corners of each quadrant,
     */
    FOUR_BOX_WIPE_CO,
    /**
     * A central, vertical line splits and expands toward the left and right edges,
     */
    BARNDOOR_V,
    /**
     * A central, horizontal line splits and expands toward the top and bottom edges,
     */
    BARNDOOR_H,
    /**
     * A box expands from the top edge's midpoint to the bottom corners,
     */
    BOX_WIPE_TC,
    /**
     * A box expands from the right edge's midpoint to the left corners,
     */
    BOX_WIPE_RC,
    /**
     * A box expands from the bottom edge's midpoint to the top corners,
     */
    BOX_WIPE_BC,
    /**
     * A box expands from the left edge's midpoint to the right corners,
     */
    BOX_WIPE_LC,
    /**
     * A diagonal line moves from the upper-left corner to the lower-right corner,
     */
    DIAGONAL_TL,
    /**
     * A diagonal line moves from the upper right corner to the lower-left corner,
     */
    DIAGONAL_TR,
    /**
     * Two wedge shapes slide in from the top and bottom edges toward the center,
     */
    BOWTIE_V,
    /**
     * Two wedge shapes slide in from the left and right edges toward the center,
     */
    BOWTIE_H,
    /**
     * A diagonal line from the lower-left to upper-right corners splits and expands toward the opposite corners,
     */
    BARNDOOR_DBL,
    /**
     * A diagonal line from upper-left to lower-right corners splits and expands toward the opposite corners,
     */
    BARNDOOR_DTL,
    /**
     * Four wedge shapes split from the center and retract toward the four edges,
     */
    MISC_DIAGONAL_DBD,
    /**
     * A diamond connecting the four edge midpoints simultaneously contracts toward the center and expands toward the edges,
     */
    MISC_DIAGONAL_DD,
    /**
     * A wedge shape moves from top to bottom,
     */
    VEE_D,
    /**
     * A wedge shape moves from right to left,
     */
    VEE_L,
    /**
     * A wedge shape moves from bottom to top,
     */
    VEE_U,
    /**
     * A wedge shape moves from left to right,
     */
    VEE_R,
    /**
     * A 'V' shape extending from the bottom edge's midpoint to the opposite corners contracts toward the center and expands toward the edges,
     */
    BARNVEE_D,
    /**
     * A 'V' shape extending from the left edge's midpoint to the opposite corners contracts toward the center and expands toward the edges,
     */
    BARNVEE_L,
    /**
     * A 'V' shape extending from the top edge's midpoint to the opposite corners contracts toward the center and expands toward the edges,
     */
    BARNVEE_U,
    /**
     * A 'V' shape extending from the right edge's midpoint to the opposite corners contracts toward the center and expands toward the edges,
     */
    BARNVEE_R,
    /**
     * A rectangle expands from the center.,
     */
    IRIS_RECT,
    /**
     * A radial hand sweeps clockwise from the twelve o'clock position,
     */
    CLOCK_CW12,
    /**
     * A radial hand sweeps clockwise from the three o'clock position,
     */
    CLOCK_CW3,
    /**
     * A radial hand sweeps clockwise from the six o'clock position,
     */
    CLOCK_CW6,
    /**
     * A radial hand sweeps clockwise from the nine o'clock position,
     */
    CLOCK_CW9,
    /**
     * Two radial hands sweep clockwise from the twelve and six o'clock positions,
     */
    PINWHEEL_TBV,
    /**
     * Two radial hands sweep clockwise from the nine and three o'clock positions,
     */
    PINWHEEL_TBH,
    /**
     * Four radial hands sweep clockwise,
     */
    PINWHEEL_FB,
    /**
     * A fan unfolds from the top edge, the fan axis at the center,
     */
    FAN_CT,
    /**
     * A fan unfolds from the right edge, the fan axis at the center,
     */
    FAN_CR,
    /**
     * Two fans, their axes at the center, unfold from the top and bottom,
     */
    DOUBLEFAN_FOV,
    /**
     * Two fans, their axes at the center, unfold from the left and right,
     */
    DOUBLEFAN_FOH,
    /**
     * A radial hand sweeps clockwise from the top edge's midpoint,
     */
    SINGLESWEEP_CWT,
    /**
     * A radial hand sweeps clockwise from the right edge's midpoint,
     */
    SINGLESWEEP_CWR,
    /**
     * A radial hand sweeps clockwise from the bottom edge's midpoint,
     */
    SINGLESWEEP_CWB,
    /**
     * A radial hand sweeps clockwise from the left edge's midpoint,
     */
    SINGLESWEEP_CWL,
    /**
     * Two radial hands sweep clockwise and counter-clockwise from the top and bottom edges' midpoints,
     */
    DOUBLESWEEP_PV,
    /**
     * Two radial hands sweep clockwise and counter-clockwise from the left and right edges' midpoints,
     */
    DOUBLESWEEP_PD,
    /**
     * Two radial hands attached at the top and bottom edges' midpoints sweep from right to left,
     */
    DOUBLESWEEP_OV,
    /**
     * Two radial hands attached at the left and right edges' midpoints sweep from top to bottom,
     */
    DOUBLESWEEP_OH,
    /**
     * A fan unfolds from the bottom, the fan axis at the top edge's midpoint,
     */
    FAN_T,
    /**
     * A fan unfolds from the left, the fan axis at the right edge's midpoint,
     */
    FAN_R,
    /**
     * A fan unfolds from the top, the fan axis at the bottom edge's midpoint,
     */
    FAN_B,
    /**
     * A fan unfolds from the right, the fan axis at the left edge's midpoint,
     */
    FAN_L,
    /**
     * Two fans, their axes at the top and bottom, unfold from the center,
     */
    DOUBLEFAN_FIV,
    /**
     * Two fans, their axes at the left and right, unfold from the center,
     */
    DOUBLEFAN_FIH,
    /**
     * A radial hand sweeps clockwise from the upper-left corner,
     */
    SINGLESWEEP_CWTL,
    /**
     * A radial hand sweeps counter-clockwise from the lower-left corner.,
     */
    SINGLESWEEP_CWBL,
    /**
     * A radial hand sweeps clockwise from the lower-right corner,
     */
    SINGLESWEEP_CWBR,
    /**
     * A radial hand sweeps counter-clockwise from the upper-right corner,
     */
    SINGLESWEEP_CWTR,
    /**
     * Two radial hands attached at the upper-left and lower-right corners sweep down and up,
     */
    DOUBLESWEEP_PDTL,
    /**
     * Two radial hands attached at the lower-left and upper-right corners sweep down and up,
     */
    DOUBLESWEEP_PDBL,
    /**
     * Two radial hands attached at the upper-left and upper-right corners sweep down,
     */
    SALOONDOOR_T,
    /**
     * Two radial hands attached at the upper-left and lower-left corners sweep to the right,
     */
    SALOONDOOR_L,
    /**
     * Two radial hands attached at the lower-left and lower-right corners sweep up,
     */
    SALOONDOOR_B,
    /**
     * Two radial hands attached at the upper-right and lower-right corners sweep to the left,
     */
    SALOONDOOR_R,
    /**
     * Two radial hands attached at the midpoints of the top and bottom halves sweep from right to left,
     */
    WINDSHIELD_R,
    /**
     * Two radial hands attached at the midpoints of the left and right halves sweep from top to bottom,
     */
    WINDSHIELD_U,
    /**
     * Two sets of radial hands attached at the midpoints of the top and bottom halves sweep from top to bottom and bottom to top,
     */
    WINDSHIELD_V,
    /**
     * Two sets of radial hands attached at the midpoints of the left and right halves sweep from left to right and right to left,
     */
    WINDSHIELD_H,
    /**
     * Crossfade
     */
    CROSSFADE,
}
/**
 * The test pattern to produce
 */
enum VideoTestPattern {
    /**
     * A standard SMPTE test pattern
     */
    SMPTE,
    /**
     * Random noise
     */
    SNOW,
    /**
     * A black image
     */
    BLACK,
    /**
     * A white image
     */
    WHITE,
    /**
     * A red image
     */
    RED,
    /**
     * A green image
     */
    GREEN,
    /**
     * A blue image
     */
    BLUE,
    /**
     * Checkers pattern (1px)
     */
    CHECKERS_1,
    /**
     * Checkers pattern (2px)
     */
    CHECKERS_2,
    /**
     * Checkers pattern (4px)
     */
    CHECKERS_4,
    /**
     * Checkers pattern (8px)
     */
    CHECKERS_8,
    /**
     * Circular pattern
     */
    CIRCULAR,
    /**
     * Alternate between black and white
     */
    BLINK,
    /**
     * SMPTE test pattern (75% color bars)
     */
    SMPTE75,
    /**
     * Zone plate
     */
    ZONE_PLATE,
    /**
     * Gamut checkers
     */
    GAMUT,
    /**
     * Chroma zone plate
     */
    CHROMA_ZONE_PLATE,
    /**
     * Solid color
     */
    SOLID_COLOR,
}
enum MarkerFlags {
    /**
     * Marker does not serve any special purpose.
     */
    NONE,
    /**
     * Marker can be a snapping target.
     */
    SNAPPABLE,
}
enum MetaFlag {
    /**
     * The metadata is readable
     */
    READABLE,
    /**
     * The metadata is writable
     */
    WRITABLE,
    /**
     * The metadata is readable and writable
     */
    READWRITE,
}
/**
 * The various modes a #GESPipeline can be configured to.
 */
enum PipelineFlags {
    /**
     * Output the #GESPipeline:timeline's
     * audio to the soundcard
     */
    AUDIO_PREVIEW,
    /**
     * Output the #GESPipeline:timeline's
     * video to the screen
     */
    VIDEO_PREVIEW,
    /**
     * Output both the #GESPipeline:timeline's
     * audio and video to the soundcard and screen (default)
     */
    FULL_PREVIEW,
    /**
     * Render the #GESPipeline:timeline with
     * forced decoding (the underlying #encodebin has its
     * #encodebin:avoid-reencoding property set to %FALSE)
     */
    RENDER,
    /**
     * Render the #GESPipeline:timeline,
     * avoiding decoding/reencoding (the underlying #encodebin has its
     * #encodebin:avoid-reencoding property set to %TRUE).
     * > NOTE: Smart rendering can not work in tracks where #GESTrack:mixing
     * > is enabled.
     */
    SMART_RENDER,
}
/**
 * Types of content handled by a track. If the content is not one of
 * `GES_TRACK_TYPE_AUDIO,` `GES_TRACK_TYPE_VIDEO` or `GES_TRACK_TYPE_TEXT,`
 * the user of the #GESTrack must set the type to `GES_TRACK_TYPE_CUSTOM`.
 * 
 * `GES_TRACK_TYPE_UNKNOWN` is for internal purposes and should not be used
 * by users
 */
enum TrackType {
    /**
     * A track of unknown type (i.e. invalid)
     */
    UNKNOWN,
    /**
     * An audio track
     */
    AUDIO,
    /**
     * A video track
     */
    VIDEO,
    /**
     * A text (subtitle) track
     */
    TEXT,
    /**
     * A custom-content track
     */
    CUSTOM,
}
/**
 * Constant to define an undefined frame number
 */
const FRAME_NUMBER_NONE: number
/**
 * The description of the object, to be used in various contexts (string).
 */
const META_DESCRIPTION: string
/**
 * The file extension of files produced by a #GESFormatter (string).
 */
const META_FORMATTER_EXTENSION: string
/**
 * The mimetype used for the file produced by a #GESFormatter (string).
 */
const META_FORMATTER_MIMETYPE: string
/**
 * The name of a formatter, used as the #GESAsset:id for #GESFormatter
 * assets (string).
 */
const META_FORMATTER_NAME: string
/**
 * The rank of a #GESFormatter (a #GstRank).
 */
const META_FORMATTER_RANK: string
/**
 * The version of a #GESFormatter (double).
 */
const META_FORMATTER_VERSION: string
/**
 * The version of the format in which a project is serialized (string).
 */
const META_FORMAT_VERSION: string
/**
 * The ARGB color of a #GESMarker (an AARRGGBB hex as a uint).
 */
const META_MARKER_COLOR: string
/**
 * The volume for a #GESTrack or a #GESLayer (float).
 */
const META_VOLUME: string
/**
 * The default volume for a #GESTrack or a #GESLayer as a float.
 */
const META_VOLUME_DEFAULT: number
const MULTI_FILE_URI_PREFIX: string
const PADDING: number
const PADDING_LARGE: number
/**
 * Layer priority when a timeline element is not in any layer.
 */
const TIMELINE_ELEMENT_NO_LAYER_PRIORITY: number
const VERSION_MAJOR: number
const VERSION_MICRO: number
const VERSION_MINOR: number
const VERSION_NANO: number
function add_missing_uri_relocation_uri(uri: string, recurse: boolean): boolean
function deinit(): void
function edge_name(edge: Edge): string
function edit_mode_name(mode: EditMode): string
function find_formatter_for_uri(uri: string): Asset
function init(): boolean
function init_check(argv?: string[] | null): [ /* returnType */ boolean, /* argv */ string[] | null ]
function is_initialized(): boolean
function list_assets(filter: GObject.Type): Asset[]
function play_sink_convert_frame(playsink: Gst.Element, caps: Gst.Caps): Gst.Sample
function pspec_equal(key_spec_1?: object | null, key_spec_2?: object | null): boolean
function pspec_hash(key_spec?: object | null): number
function track_type_name(type: TrackType): string
function validate_register_action_types(): boolean
function version(): [ /* major */ number, /* minor */ number, /* micro */ number, /* nano */ number ]
/**
 * A function for querying how an effect would translate a time if it had
 * the given child property values set. The keys for `time_properties` will
 * be the same string that was passed to
 * ges_base_effect_register_time_property(), the values will be #GValue*
 * values of the corresponding child properties. You should always use the
 * values given in `time_properties` before using the currently set values.
 */
interface BaseEffectTimeTranslationFunc {
    (effect: BaseEffect, time: Gst.ClockTime, time_property_values: GLib.HashTable): Gst.ClockTime
}
/**
 * A method for creating the core #GESTrackElement of a clip, to be added
 * to a #GESTrack of the given track type.
 * 
 * If a clip may produce several track elements per track type,
 * #GESCreateTrackElementsFunc is more appropriate.
 */
interface CreateTrackElementFunc {
    (clip: Clip, type: TrackType): TrackElement | null
}
/**
 * A method for creating the core #GESTrackElement-s of a clip, to be
 * added to #GESTrack-s of the given track type.
 */
interface CreateTrackElementsFunc {
    (clip: Clip, type: TrackType): TrackElement[]
}
/**
 * Method for checking that an ID is valid for the given #GESExtractable
 * type. If the given ID is considered valid, it can be adjusted into some
 * standard and returned to prevent the creation of separate #GESAsset-s,
 * with different #GESAsset:id, that would otherwise act the same.
 * 
 * Returns (transfer full) (nullable): The actual #GESAsset:id to set on
 * any corresponding assets, based on `id,` or %NULL if `id` is not valid.
 */
interface ExtractableCheckId {
    (type: GObject.Type, id: string): string
}
/**
 * A function that will be called when the nleobject of a corresponding
 * track element needs to be filled.
 * 
 * The implementer of this function shall add the proper #GstElement to `nleobj`
 * using gst_bin_add().
 */
interface FillTrackElementFunc {
    (clip: Clip, track_element: TrackElement, nleobj: Gst.Element): boolean
}
interface FormatterCanLoadURIMethod {
    (dummy_instance: Formatter, uri: string): boolean
}
/**
 * Virtual method for loading a timeline from a given URI.
 * 
 * Every #GESFormatter subclass needs to implement this method.
 */
interface FormatterLoadFromURIMethod {
    (formatter: Formatter, timeline: Timeline, uri: string): boolean
}
/**
 * Virtual method for saving a timeline to a uri.
 * 
 * Every #GESFormatter subclass needs to implement this method.
 */
interface FormatterSaveToURIMethod {
    (formatter: Formatter, timeline: Timeline, uri: string, overwrite: boolean): boolean
}
/**
 * A method to be called on all of a meta container's fields.
 */
interface MetaForeachFunc {
    (container: MetaContainer, key: string, value: any): void
}
interface Extractable_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
}
class Extractable {
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GES-1.0.GES.Extractable */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Extractable, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Extractable, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Extractable_ConstructProps)
    _init (config?: Extractable_ConstructProps): void
    static $gtype: GObject.Type
}
class MetaContainer {
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: MetaContainer, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: MetaContainer, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    static name: string
}
interface Asset_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Asset */
    /**
     * The #GESExtractable object type that can be extracted from the asset.
     */
    extractable_type?: GObject.Type
    /**
     * The ID of the asset. This should be unique amongst all assets with
     * the same #GESAsset:extractable-type. Depending on the associated
     * #GESExtractable implementation, this id may convey some information
     * about the #GObject that should be extracted. Note that, as such, the
     * ID will have an expected format, and you can not choose this value
     * arbitrarily. By default, this will be set to the type name of the
     * #GESAsset:extractable-type, but you should check the documentation
     * of the extractable type to see whether they differ from the
     * default behaviour.
     */
    id?: string
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy?: Asset
}
class Asset {
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Asset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Asset, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Asset, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Asset, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::proxy", callback: (($obj: Asset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: Asset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: Asset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: Asset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Asset_ConstructProps)
    _init (config?: Asset_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Indicate that an existing #GESAsset in the cache should be reloaded
     * upon the next request. This can be used when some condition has
     * changed, which may require that an existing asset should be updated.
     * For example, if an external resource has changed or now become
     * available.
     * 
     * Note, the asset is not immediately changed, but will only actually
     * reload on the next call to ges_asset_request() or
     * ges_asset_request_async().
     */
    static needs_reload(extractable_type: GObject.Type, id?: string | null): boolean
    /**
     * Returns an asset with the given properties. If such an asset already
     * exists in the cache (it has been previously created in GES), then a
     * reference to the existing asset is returned. Otherwise, a newly created
     * asset is returned, and also added to the cache.
     * 
     * If the requested asset has been loaded with an error, then `error` is
     * set, if given, and %NULL will be returned instead.
     * 
     * Note that the given `id` may not be exactly the #GESAsset:id that is
     * set on the returned asset. For instance, it may be adjusted into a
     * standard format. Or, if a #GESExtractable type does not have its
     * extraction parametrised, as is the case by default, then the given `id`
     * may be ignored entirely and the #GESAsset:id set to some standard, in
     * which case a %NULL `id` can be given.
     * 
     * Similarly, the given `extractable_type` may not be exactly the
     * #GESAsset:extractable-type that is set on the returned asset. Instead,
     * the actual extractable type may correspond to a subclass of the given
     * `extractable_type,` depending on the given `id`.
     * 
     * Moreover, depending on the given `extractable_type,` the returned asset
     * may belong to a subclass of #GESAsset.
     * 
     * Finally, if the requested asset has a #GESAsset:proxy, then the proxy
     * that is found at the end of the chain of proxies is returned (a proxy's
     * proxy will take its place, and so on, unless it has no proxy).
     * 
     * Some asset subclasses only support asynchronous construction of its
     * assets, such as #GESUriClip. For such assets this method will fail, and
     * you should use ges_asset_request_async() instead. In the case of
     * #GESUriClip, you can use ges_uri_clip_asset_request_sync() if you only
     * want to wait for the request to finish.
     */
    static request(extractable_type: GObject.Type, id?: string | null): Asset | null
    /**
     * Requests an asset with the given properties asynchronously (see
     * ges_asset_request()). When the asset has been initialized or fetched
     * from the cache, the given callback function will be called. The
     * asset can then be retrieved in the callback using the
     * ges_asset_request_finish() method on the given #GAsyncResult.
     * 
     * Note that the source object passed to the callback will be the
     * #GESAsset corresponding to the request, but it may not have loaded
     * correctly and therefore can not be used as is. Instead,
     * ges_asset_request_finish() should be used to fetch a usable asset, or
     * indicate that an error occurred in the asset's creation.
     * 
     * Note that the callback will be called in the #GMainLoop running under
     * the same #GMainContext that ges_init() was called in. So, if you wish
     * the callback to be invoked outside the default #GMainContext, you can
     * call g_main_context_push_thread_default() in a new thread before
     * calling ges_init().
     * 
     * Example of an asynchronous asset request:
     * ``` c
     * // The request callback
     * static void
     * asset_loaded_cb (GESAsset * source, GAsyncResult * res, gpointer user_data)
     * {
     *   GESAsset *asset;
     *   GError *error = NULL;
     * 
     *   asset = ges_asset_request_finish (res, &error);
     *   if (asset) {
     *    gst_print ("The file: %s is usable as a GESUriClip",
     *        ges_asset_get_id (asset));
     *   } else {
     *    gst_print ("The file: %s is *not* usable as a GESUriClip because: %s",
     *        ges_asset_get_id (source), error->message);
     *   }
     * 
     *   gst_object_unref (asset);
     * }
     * 
     * // The request:
     * ges_asset_request_async (GES_TYPE_URI_CLIP, some_uri, NULL,
     *    (GAsyncReadyCallback) asset_loaded_cb, user_data);
     * ```
     */
    static request_async(extractable_type: GObject.Type, id?: string | null, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Fetches an asset requested by ges_asset_request_async(), which
     * finalises the request.
     */
    static request_finish(res: Gio.AsyncResult): Asset
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface AudioSource_ConstructProps extends Source_ConstructProps {
}
class AudioSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.AudioSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: AudioSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: AudioSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: AudioSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: AudioSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: AudioSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: AudioSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: AudioSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: AudioSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: AudioSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: AudioSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: AudioSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: AudioSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: AudioSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: AudioSource_ConstructProps)
    _init (config?: AudioSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface AudioTestSource_ConstructProps extends AudioSource_ConstructProps {
}
class AudioTestSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.AudioTestSource */
    /**
     * Get the current frequency of `self`.
     */
    get_freq(): number
    /**
     * Get the current volume of `self`.
     */
    get_volume(): number
    /**
     * Lets you set the frequency applied on the track element
     */
    set_freq(freq: number): void
    /**
     * Sets the volume of the test audio signal.
     */
    set_volume(volume: number): void
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.AudioTestSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.AudioSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: AudioTestSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: AudioTestSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: AudioTestSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: AudioTestSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: AudioTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: AudioTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: AudioTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: AudioTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: AudioTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: AudioTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: AudioTestSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: AudioTestSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: AudioTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: AudioTestSource_ConstructProps)
    _init (config?: AudioTestSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface AudioTrack_ConstructProps extends Track_ConstructProps {
}
class AudioTrack {
    /* Properties of GES-1.0.GES.Track */
    /**
     * Current duration of the track
     * 
     * Default value: O
     */
    readonly duration: number
    /**
     * The #nlecomposition:id of the underlying #nlecomposition.
     */
    id: string
    /**
     * Whether the track should support the mixing of #GESLayer data, such
     * as composing the video data of each layer (when part of the video
     * data is transparent, the next layer will become visible) or adding
     * together the audio data. As such, for audio and video tracks, you'll
     * likely want to keep this set to %TRUE.
     */
    mixing: boolean
    /**
     * The capabilities that specifies the final output format of the
     * #GESTrack. For example, for a video track, it would specify the
     * height, width, framerate and other properties of the stream.
     * 
     * You may change this property after the track has been added to a
     * #GESTimeline, but it must remain compatible with the track's
     * #GESTrack:caps.
     * 
     * Default value: #GST_CAPS_ANY.
     */
    restriction_caps: Gst.Caps
    /* Properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward: boolean
    /* Fields of GES-1.0.GES.Track */
    readonly parent: Gst.Bin
    /**
     * The #GESTrack:track-type of the track
     */
    readonly type: TrackType
    /* Fields of Gst-1.0.Gst.Bin */
    readonly element: Gst.Element
    /**
     * the number of children in this bin
     */
    readonly numchildren: number
    /**
     * the list of children in this bin
     */
    readonly children: Gst.Element[]
    /**
     * updated whenever `children` changes
     */
    readonly children_cookie: number
    /**
     * internal bus for handling child messages
     */
    readonly child_bus: Gst.Bus
    /**
     * queued and cached messages
     */
    readonly messages: Gst.Message[]
    /**
     * the bin is currently calculating its state
     */
    readonly polling: boolean
    /**
     * the bin needs to recalculate its state (deprecated)
     */
    readonly state_dirty: boolean
    /**
     * the bin needs to select a new clock
     */
    readonly clock_dirty: boolean
    /**
     * the last clock selected
     */
    readonly provided_clock: Gst.Clock
    /**
     * the element that provided `provided_clock`
     */
    readonly clock_provider: Gst.Element
    /* Fields of Gst-1.0.Gst.Element */
    readonly object: Gst.Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    readonly state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    readonly state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    readonly state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    readonly target_state: Gst.State
    /**
     * the current state of an element
     */
    readonly current_state: Gst.State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    readonly next_state: Gst.State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    readonly pending_state: Gst.State
    /**
     * the last return value of an element state change
     */
    readonly last_return: Gst.StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    readonly bus: Gst.Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    readonly clock: Gst.Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    readonly base_time: Gst.ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    readonly start_time: Gst.ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    readonly numpads: number
    /**
     * list of pads
     */
    readonly pads: Gst.Pad[]
    /**
     * number of source pads of the element.
     */
    readonly numsrcpads: number
    /**
     * list of source pads
     */
    readonly srcpads: Gst.Pad[]
    /**
     * number of sink pads of the element.
     */
    readonly numsinkpads: number
    /**
     * list of sink pads
     */
    readonly sinkpads: Gst.Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    readonly pads_cookie: number
    /**
     * list of contexts
     */
    readonly contexts: Gst.Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    readonly lock: GLib.Mutex
    /**
     * The name of the object
     */
    readonly name: string
    /**
     * flags for this object
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Track */
    /**
     * See ges_track_add_element(), which also gives an error.
     */
    add_element(object: TrackElement): boolean
    /**
     * Adds the given track element to the track, which takes ownership of the
     * element.
     * 
     * Note that this can fail if it would break a configuration rule of the
     * track's #GESTimeline.
     * 
     * Note that a #GESTrackElement can only be added to one track.
     */
    add_element_full(object: TrackElement): boolean
    /**
     * Commits all the pending changes for the elements contained in the
     * track.
     * 
     * When changes are made to the timing or priority of elements within a
     * track, they are not directly executed for the underlying
     * #nlecomposition and its children. This method will finally execute
     * these changes so they are reflected in the data output of the track.
     * 
     * Any pending changes will be executed in the backend. The
     * #GESTimeline::commited signal will be emitted once this has completed.
     * 
     * Note that ges_timeline_commit() will call this method on all of its
     * tracks, so you are unlikely to need to use this directly.
     */
    commit(): boolean
    /**
     * Get the #GESTrack:caps of the track.
     */
    get_caps(): Gst.Caps
    /**
     * Gets the track elements contained in the track. The returned list is
     * sorted by the element's #GESTimelineElement:priority and
     * #GESTimelineElement:start.
     */
    get_elements(): TrackElement[]
    /**
     * Gets the #GESTrack:mixing of the track.
     */
    get_mixing(): boolean
    /**
     * Gets the #GESTrack:restriction-caps of the track.
     */
    get_restriction_caps(): Gst.Caps
    /**
     * Get the timeline this track belongs to.
     */
    get_timeline(): Timeline | null
    /**
     * See ges_track_remove_element_full(), which also returns an error.
     */
    remove_element(object: TrackElement): boolean
    /**
     * Removes the given track element from the track, which revokes
     * ownership of the element.
     */
    remove_element_full(object: TrackElement): boolean
    /**
     * Sets the #GESTrack:mixing for the track.
     */
    set_mixing(mixing: boolean): void
    /**
     * Sets the #GESTrack:restriction-caps for the track.
     * 
     * > **NOTE**: Restriction caps are **not** taken into account when
     * > using #GESPipeline:mode=#GES_PIPELINE_MODE_SMART_RENDER.
     */
    set_restriction_caps(caps: Gst.Caps): void
    /**
     * Informs the track that it belongs to the given timeline. Calling this
     * does not actually add the track to the timeline. For that, you should
     * use ges_timeline_add_track(), which will also take care of informing
     * the track that it belongs to the timeline. As such, there is no need
     * for you to call this method.
     */
    set_timeline(timeline: Timeline): void
    /**
     * Updates the #GESTrack:restriction-caps of the track using the fields
     * found in the given caps. Each of the #GstStructure-s in `caps` is
     * compared against the existing structure with the same index in the
     * current #GESTrack:restriction-caps. If there is no corresponding
     * existing structure at that index, then the new structure is simply
     * copied to that index. Otherwise, any fields in the new structure are
     * copied into the existing structure. This will replace existing values,
     * and may introduce new ones, but any fields 'missing' in the new
     * structure are left unchanged in the existing structure.
     * 
     * For example, if the existing #GESTrack:restriction-caps are
     * "video/x-raw, width=480, height=360", and the updating caps is
     * "video/x-raw, format=I420, width=500; video/x-bayer, width=400", then
     * the new #GESTrack:restriction-caps after calling this will be
     * "video/x-raw, width=500, height=360, format=I420; video/x-bayer,
     * width=400".
     */
    update_restriction_caps(caps: Gst.Caps): void
    /* Methods of Gst-1.0.Gst.Bin */
    /**
     * Adds the given element to the bin.  Sets the element's parent, and thus
     * takes ownership of the element. An element can only be added to one bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is added to the bin.
     * 
     * > When you add an element to an already-running pipeline, you will have to
     * > take care to set the state of the newly-added element to the desired
     * > state (usually PLAYING or PAUSED, same you set the pipeline to originally)
     * > with gst_element_set_state(), or use gst_element_sync_state_with_parent().
     * > The bin or pipeline will not take care of this for you.
     */
    add(element: Gst.Element): boolean
    /**
     * Recursively looks for elements with an unlinked pad of the given
     * direction within the specified bin and returns an unlinked pad
     * if one is found, or %NULL otherwise. If a pad is found, the caller
     * owns a reference to it and should use gst_object_unref() on the
     * pad when it is not needed any longer.
     */
    find_unlinked_pad(direction: Gst.PadDirection): Gst.Pad | null
    /**
     * Looks for an element inside the bin that implements the given
     * interface. If such an element is found, it returns the element.
     * You can cast this element to the given interface afterwards.  If you want
     * all elements that implement the interface, use
     * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
     */
    get_by_interface(iface: GObject.Type): Gst.Element | null
    /**
     * Gets the element with the given name from a bin. This
     * function recurses into child bins.
     */
    get_by_name(name: string): Gst.Element | null
    /**
     * Gets the element with the given name from this bin. If the
     * element is not found, a recursion is performed on the parent bin.
     */
    get_by_name_recurse_up(name: string): Gst.Element | null
    get_suppressed_flags(): Gst.ElementFlags
    /**
     * Looks for all elements inside the bin with the given element factory name.
     * The function recurses inside child bins. The iterator will yield a series of
     * #GstElement.
     */
    iterate_all_by_element_factory_name(factory_name: string): Gst.Iterator | null
    /**
     * Looks for all elements inside the bin that implements the given
     * interface. You can safely cast all returned elements to the given interface.
     * The function recurses inside child bins. The iterator will yield a series
     * of #GstElement.
     */
    iterate_all_by_interface(iface: GObject.Type): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     */
    iterate_elements(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     * This iterator recurses into GstBin children.
     */
    iterate_recurse(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SINK flag set.
     */
    iterate_sinks(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin in topologically
     * sorted order. This means that the elements are returned from
     * the most downstream elements (sinks) to the sources.
     * 
     * This function is used internally to perform the state changes
     * of the bin elements and for clock selection.
     */
    iterate_sorted(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SOURCE flag set.
     */
    iterate_sources(): Gst.Iterator | null
    /**
     * Queries `bin` for the current latency and reconfigures this latency on all the
     * elements using a LATENCY event.
     * 
     * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
     * is posted on the bus.
     * 
     * This function simply emits the #GstBin::do-latency signal so any custom latency
     * calculations will be performed.
     */
    recalculate_latency(): boolean
    /**
     * Removes the element from the bin, unparenting it as well.
     * Unparenting the element means that the element will be dereferenced,
     * so if the bin holds the only reference to the element, the element
     * will be freed in the process of removing it from the bin.  If you
     * want the element to still exist after removing, you need to call
     * gst_object_ref() before removing it from the bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is removed from the bin.
     */
    remove(element: Gst.Element): boolean
    /**
     * Suppresses the given flags on the bin. #GstElementFlags of a
     * child element are propagated when it is added to the bin.
     * When suppressed flags are set, those specified flags will
     * not be propagated to the bin.
     */
    set_suppressed_flags(flags: Gst.ElementFlags): void
    /**
     * Synchronizes the state of every child of `bin` with the state
     * of `bin`. See also gst_element_sync_state_with_parent().
     */
    sync_children_states(): boolean
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     */
    add_pad(pad: Gst.Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     */
    call_async(func: Gst.ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     */
    continue_state(ret: Gst.StateChangeReturn): Gst.StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     */
    foreach_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_sink_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_src_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): Gst.ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Gst.Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Gst.Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     */
    get_compatible_pad(pad: Gst.Pad, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     */
    get_compatible_pad_template(compattempl: Gst.PadTemplate): Gst.PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     */
    get_context(context_type: string): Gst.Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     */
    get_context_unlocked(context_type: string): Gst.Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Gst.Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): Gst.ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): Gst.ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): Gst.ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     */
    get_pad_template(name: string): Gst.PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): Gst.PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     */
    get_request_pad(name: string): Gst.Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): Gst.ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     */
    get_static_pad(name: string): Gst.Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Gst.Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link(dest: Gst.Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link_filtered(dest: Gst.Element, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     */
    link_pads(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     */
    link_pads_filtered(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     */
    link_pads_full(srcpadname: string | null, dest: Gst.Element, destpadname: string | null, flags: Gst.PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     */
    message_full(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     */
    message_full_with_details(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Gst.Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    query(query: Gst.Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     */
    query_convert(src_format: Gst.Format, src_val: number, dest_format: Gst.Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     */
    query_duration(format: Gst.Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     */
    query_position(format: Gst.Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     */
    release_request_pad(pad: Gst.Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     */
    remove_pad(pad: Gst.Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    request_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     */
    request_pad_simple(name: string): Gst.Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     */
    seek(rate: number, format: Gst.Format, flags: Gst.SeekFlags, start_type: Gst.SeekType, start: number, stop_type: Gst.SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     */
    seek_simple(format: Gst.Format, seek_flags: Gst.SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    send_event(event: Gst.Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     */
    set_base_time(time: Gst.ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    set_context(context: Gst.Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     */
    set_start_time(time: Gst.ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    set_state(state: Gst.State): Gst.StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     */
    unlink(dest: Gst.Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     */
    unlink_pads(srcpadname: string, dest: Gst.Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     */
    add_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): Gst.ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     */
    get_g_value_array(property_name: string, timestamp: Gst.ClockTime, interval: Gst.ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Gst.Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     */
    get_value(property_name: string, timestamp: Gst.ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_as_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     */
    has_as_parent(parent: Gst.Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Gst.Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     */
    remove_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     */
    set_control_rate(control_rate: Gst.ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     */
    set_parent(parent: Gst.Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): Gst.ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     */
    sync_values(timestamp: Gst.ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gst-1.0.Gst.ChildProxy */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    get_children_count(): number
    /**
     * Gets a single property using the GstChildProxy mechanism.
     * You are responsible for freeing it by calling g_value_unset()
     */
    get_property(name: string): /* value */ any
    /**
     * Looks up which object and #GParamSpec would be effected by the given `name`.
     */
    lookup(name: string): [ /* returnType */ boolean, /* target */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Sets a single property using the GstChildProxy mechanism.
     */
    set_property(name: string, value: any): void
    /* Virtual methods of GES-1.0.GES.AudioTrack */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /* Virtual methods of GES-1.0.GES.Track */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /* Virtual methods of Gst-1.0.Gst.Bin */
    /**
     * Method to add an element to the bin.
     */
    vfunc_add_element(element: Gst.Element): boolean
    /**
     * Method called when an element was added somewhere in the bin hierarchy.
     */
    vfunc_deep_element_added(sub_bin: Gst.Bin, child: Gst.Element): void
    /**
     * Method called when an element was removed somewhere in the bin hierarchy.
     */
    vfunc_deep_element_removed(sub_bin: Gst.Bin, child: Gst.Element): void
    vfunc_do_latency(): boolean
    /**
     * Method called when an element was added to the bin.
     */
    vfunc_element_added(child: Gst.Element): void
    /**
     * Method called when an element was removed from the bin.
     */
    vfunc_element_removed(child: Gst.Element): void
    /**
     * Method to handle a message from the children.
     */
    vfunc_handle_message(message: Gst.Message): void
    /**
     * Method to remove an element from the bin.
     */
    vfunc_remove_element(element: Gst.Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    vfunc_change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    vfunc_get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Gst.Pad): void
    vfunc_pad_removed(pad: Gst.Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    vfunc_post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    vfunc_query(query: Gst.Query): boolean
    vfunc_release_pad(pad: Gst.Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    vfunc_request_new_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    vfunc_send_event(event: Gst.Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    vfunc_set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    vfunc_set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    vfunc_set_context(context: Gst.Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    vfunc_set_state(state: Gst.State): Gst.StateChangeReturn
    vfunc_state_changed(oldstate: Gst.State, newstate: Gst.State, pending: Gst.State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Gst.Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Track */
    /**
     * This signal will be emitted once the changes initiated by
     * ges_track_commit() have been executed in the backend. In particular,
     * this will be emitted whenever the underlying #nlecomposition has been
     * committed (see #nlecomposition::commited).
     */
    connect(sigName: "commited", callback: (($obj: AudioTrack) => void)): number
    connect_after(sigName: "commited", callback: (($obj: AudioTrack) => void)): number
    emit(sigName: "commited"): void
    /**
     * Will be emitted after a track element is added to the track.
     */
    connect(sigName: "track-element-added", callback: (($obj: AudioTrack, effect: TrackElement) => void)): number
    connect_after(sigName: "track-element-added", callback: (($obj: AudioTrack, effect: TrackElement) => void)): number
    emit(sigName: "track-element-added", effect: TrackElement): void
    /**
     * Will be emitted after a track element is removed from the track.
     */
    connect(sigName: "track-element-removed", callback: (($obj: AudioTrack, effect: TrackElement) => void)): number
    connect_after(sigName: "track-element-removed", callback: (($obj: AudioTrack, effect: TrackElement) => void)): number
    emit(sigName: "track-element-removed", effect: TrackElement): void
    /* Signals of Gst-1.0.Gst.Bin */
    /**
     * Will be emitted after the element was added to `sub_bin`.
     */
    connect(sigName: "deep-element-added", callback: (($obj: AudioTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-added", callback: (($obj: AudioTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-added", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from `sub_bin`.
     */
    connect(sigName: "deep-element-removed", callback: (($obj: AudioTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-removed", callback: (($obj: AudioTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-removed", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted when the bin needs to perform latency calculations. This
     * signal is only emitted for toplevel bins or when #GstBin:async-handling is
     * enabled.
     * 
     * Only one signal handler is invoked. If no signals are connected, the
     * default handler is invoked, which will query and distribute the lowest
     * possible latency to all sinks.
     * 
     * Connect to this signal if the default latency calculations are not
     * sufficient, like when you need different latencies for different sinks in
     * the same pipeline.
     */
    connect(sigName: "do-latency", callback: (($obj: AudioTrack) => boolean)): number
    connect_after(sigName: "do-latency", callback: (($obj: AudioTrack) => boolean)): number
    emit(sigName: "do-latency"): void
    /**
     * Will be emitted after the element was added to the bin.
     */
    connect(sigName: "element-added", callback: (($obj: AudioTrack, element: Gst.Element) => void)): number
    connect_after(sigName: "element-added", callback: (($obj: AudioTrack, element: Gst.Element) => void)): number
    emit(sigName: "element-added", element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from the bin.
     */
    connect(sigName: "element-removed", callback: (($obj: AudioTrack, element: Gst.Element) => void)): number
    connect_after(sigName: "element-removed", callback: (($obj: AudioTrack, element: Gst.Element) => void)): number
    emit(sigName: "element-removed", element: Gst.Element): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: AudioTrack) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: AudioTrack) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     */
    connect(sigName: "pad-added", callback: (($obj: AudioTrack, new_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: AudioTrack, new_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Gst.Pad): void
    /**
     * a #GstPad has been removed from the element
     */
    connect(sigName: "pad-removed", callback: (($obj: AudioTrack, old_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: AudioTrack, old_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Gst.Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     */
    connect(sigName: "deep-notify", callback: (($obj: AudioTrack, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: AudioTrack, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Gst.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: AudioTrack, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: AudioTrack, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    /* Signals of Gst-1.0.Gst.ChildProxy */
    /**
     * Will be emitted after the `object` was added to the `child_proxy`.
     */
    connect(sigName: "child-added", callback: (($obj: AudioTrack, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: AudioTrack, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-added", object: GObject.Object, name: string): void
    /**
     * Will be emitted after the `object` was removed from the `child_proxy`.
     */
    connect(sigName: "child-removed", callback: (($obj: AudioTrack, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: AudioTrack, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-removed", object: GObject.Object, name: string): void
    connect(sigName: "notify::duration", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mixing", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mixing", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::restriction-caps", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::restriction-caps", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::async-handling", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::async-handling", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::message-forward", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-forward", callback: (($obj: AudioTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: AudioTrack_ConstructProps)
    _init (config?: AudioTrack_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): AudioTrack
    /* Function overloads */
    static new(type: TrackType, caps: Gst.Caps): AudioTrack
    static new(name?: string | null): AudioTrack
    static $gtype: GObject.Type
}
interface AudioTransition_ConstructProps extends Transition_ConstructProps {
}
class AudioTransition {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.AudioTransition */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Transition */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Operation */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: AudioTransition, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: AudioTransition, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: AudioTransition, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: AudioTransition, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: AudioTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: AudioTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: AudioTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: AudioTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: AudioTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: AudioTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: AudioTransition, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: AudioTransition, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: AudioTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: AudioTransition_ConstructProps)
    _init (config?: AudioTransition_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): AudioTransition
    static $gtype: GObject.Type
}
interface AudioUriSource_ConstructProps extends AudioSource_ConstructProps {
    /* Constructor properties of GES-1.0.GES.AudioUriSource */
    /**
     * The location of the file/resource to use.
     */
    uri?: string
}
class AudioUriSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.AudioUriSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.AudioSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: AudioUriSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: AudioUriSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: AudioUriSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: AudioUriSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: AudioUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: AudioUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: AudioUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: AudioUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: AudioUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: AudioUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: AudioUriSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: AudioUriSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: AudioUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: AudioUriSource_ConstructProps)
    _init (config?: AudioUriSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface BaseEffect_ConstructProps extends Operation_ConstructProps {
}
class BaseEffect {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.BaseEffect */
    /**
     * Get whether the effect is considered a time effect or not. An effect
     * with registered time properties or set translation functions is
     * considered a time effect.
     */
    is_time_effect(): boolean
    /**
     * Register a child property of the effect as a property that, when set,
     * can change the timing of its input data. The child property should be
     * specified as in ges_timeline_element_lookup_child().
     * 
     * You should also set the corresponding time translation using
     * ges_base_effect_set_time_translation_funcs().
     * 
     * Note that `effect` must not be part of a clip, nor can it have
     * #GESTrackElement:has-internal-source set to %TRUE.
     */
    register_time_property(child_property_name: string): boolean
    /**
     * Set the time translation query functions for the time effect. If an
     * effect is a time effect, it will have two sets of coordinates: one
     * at its sink and one at its source. The given functions should be able
     * to translate between these two sets of coordinates. More specifically,
     * `source_to_sink_func` should *emulate* how the corresponding #GstElement
     * would translate the #GstSegment `time` field, and `sink_to_source_func`
     * should emulate how the corresponding #GstElement would translate the
     * seek query `start` and `stop` values, as used in gst_element_seek(). As
     * such, `sink_to_source_func` should act as an approximate reverse of
     * `source_to_sink_func`.
     * 
     * Note, these functions will be passed a table of time properties, as
     * registered in ges_base_effect_register_time_property(), and their
     * values. The functions should emulate what the translation *would* be
     * *if* the time properties were set to the given values. They should not
     * use the currently set values.
     * 
     * Note that `effect` must not be part of a clip, nor can it have
     * #GESTrackElement:has-internal-source set to %TRUE.
     */
    set_time_translation_funcs(source_to_sink_func?: BaseEffectTimeTranslationFunc | null, sink_to_source_func?: BaseEffectTimeTranslationFunc | null): boolean
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.BaseEffect */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Operation */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: BaseEffect, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: BaseEffect, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: BaseEffect, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: BaseEffect, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: BaseEffect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: BaseEffect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: BaseEffect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: BaseEffect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: BaseEffect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: BaseEffect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: BaseEffect, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: BaseEffect, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: BaseEffect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: BaseEffect_ConstructProps)
    _init (config?: BaseEffect_ConstructProps): void
    static $gtype: GObject.Type
}
interface BaseEffectClip_ConstructProps extends OperationClip_ConstructProps {
}
class BaseEffectClip {
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.BaseEffectClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.OperationClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: BaseEffectClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: BaseEffectClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: BaseEffectClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: BaseEffectClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: BaseEffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: BaseEffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: BaseEffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: BaseEffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: BaseEffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: BaseEffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: BaseEffectClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: BaseEffectClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration-limit", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: BaseEffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: BaseEffectClip_ConstructProps)
    _init (config?: BaseEffectClip_ConstructProps): void
    static $gtype: GObject.Type
}
interface BaseTransitionClip_ConstructProps extends OperationClip_ConstructProps {
}
class BaseTransitionClip {
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.BaseTransitionClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.OperationClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: BaseTransitionClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: BaseTransitionClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: BaseTransitionClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: BaseTransitionClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: BaseTransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: BaseTransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: BaseTransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: BaseTransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: BaseTransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: BaseTransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: BaseTransitionClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: BaseTransitionClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration-limit", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: BaseTransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: BaseTransitionClip_ConstructProps)
    _init (config?: BaseTransitionClip_ConstructProps): void
    static $gtype: GObject.Type
}
interface BaseXmlFormatter_ConstructProps extends Formatter_ConstructProps {
}
class BaseXmlFormatter {
    /* Fields of GES-1.0.GES.Formatter */
    readonly parent: GObject.InitiallyUnowned
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Formatter */
    /**
     * Load data from the given URI into timeline.
     */
    load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.BaseXmlFormatter */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Formatter */
    vfunc_can_load_uri(uri: string): boolean
    /**
     * Load data from the given URI into timeline.
     */
    vfunc_load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    vfunc_save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: BaseXmlFormatter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: BaseXmlFormatter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: BaseXmlFormatter_ConstructProps)
    _init (config?: BaseXmlFormatter_ConstructProps): void
    static $gtype: GObject.Type
}
interface Clip_ConstructProps extends Container_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Clip */
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats?: TrackType
}
class Clip {
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Container */
    readonly parent: TimelineElement
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: Clip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: Clip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: Clip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: Clip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: Clip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: Clip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: Clip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: Clip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: Clip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Clip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Clip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Clip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration-limit", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: Clip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Clip_ConstructProps)
    _init (config?: Clip_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClipAsset_ConstructProps extends Asset_ConstructProps {
    /* Constructor properties of GES-1.0.GES.ClipAsset */
    /**
     * The formats supported by the asset.
     */
    supported_formats?: TrackType
}
class ClipAsset {
    /* Properties of GES-1.0.GES.ClipAsset */
    /**
     * The formats supported by the asset.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GES-1.0.GES.Asset */
    readonly parent: GObject.Object
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.ClipAsset */
    /**
     * Converts the given frame number into a timestamp, using the "natural" frame
     * rate of the asset.
     * 
     * You can use this to reference a specific frame in a media file and use this
     * as, for example, the `in-point` or `max-duration` of a #GESClip.
     */
    get_frame_time(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets track types for which objects extracted from `self` can create #GESTrackElement
     */
    get_supported_formats(): TrackType
    /**
     * Sets track types for which objects extracted from `self` can create #GESTrackElement
     */
    set_supported_formats(supportedformats: TrackType): void
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.ClipAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: ClipAsset, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: ClipAsset, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::supported-formats", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: ClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClipAsset_ConstructProps)
    _init (config?: ClipAsset_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface CommandLineFormatter_ConstructProps extends Formatter_ConstructProps {
}
class CommandLineFormatter {
    /* Fields of GES-1.0.GES.Formatter */
    readonly parent: GObject.InitiallyUnowned
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Formatter */
    /**
     * Load data from the given URI into timeline.
     */
    load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.CommandLineFormatter */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Formatter */
    vfunc_can_load_uri(uri: string): boolean
    /**
     * Load data from the given URI into timeline.
     */
    vfunc_load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    vfunc_save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: CommandLineFormatter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: CommandLineFormatter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: CommandLineFormatter_ConstructProps)
    _init (config?: CommandLineFormatter_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Creates a help string based on `commands`.
     * 
     * Result: (transfer full): A help string.
     */
    static get_help(commands: string[]): string
    static get_timeline_uri(timeline: Timeline): string
    static $gtype: GObject.Type
}
interface Container_ConstructProps extends TimelineElement_ConstructProps {
}
class Container {
    /* Properties of GES-1.0.GES.Container */
    /**
     * The span of the container's children's #GESTimelineElement:priority
     * values, which is the number of integers that lie between (inclusive)
     * the minimum and maximum priorities found amongst the container's
     * children (maximum - minimum + 1).
     */
    readonly height: number
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESTimelineElement:parent of the element
     */
    readonly parent: TimelineElement
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: Container, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: Container, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: Container, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: Container, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: Container, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: Container, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: Container, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: Container, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: Container, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Container, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Container, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Container, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::height", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: Container, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Container_ConstructProps)
    _init (config?: Container_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Groups the containers into a single container by merging them. The
     * containers must all belong to the same #GESTimelineElement:timeline.
     * 
     * If the elements are all #GESClip-s then this method will attempt to
     * combine them all into a single #GESClip. This should succeed if they:
     * share the same #GESTimelineElement:start, #GESTimelineElement:duration
     * and #GESTimelineElement:in-point; exist in the same layer; and all of
     * the sources share the same #GESAsset. If this fails, or one of the
     * elements is not a #GESClip, this method will try to create a #GESGroup
     * instead.
     */
    static group(containers?: Container[] | null): Container
    static $gtype: GObject.Type
}
interface Effect_ConstructProps extends BaseEffect_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Effect */
    /**
     * The description of the effect bin with a gst-launch-style
     * pipeline description.
     * 
     * Example: "videobalance saturation=1.5 hue=+0.5"
     */
    bin_description?: string
}
class Effect {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.BaseEffect */
    /**
     * Get whether the effect is considered a time effect or not. An effect
     * with registered time properties or set translation functions is
     * considered a time effect.
     */
    is_time_effect(): boolean
    /**
     * Register a child property of the effect as a property that, when set,
     * can change the timing of its input data. The child property should be
     * specified as in ges_timeline_element_lookup_child().
     * 
     * You should also set the corresponding time translation using
     * ges_base_effect_set_time_translation_funcs().
     * 
     * Note that `effect` must not be part of a clip, nor can it have
     * #GESTrackElement:has-internal-source set to %TRUE.
     */
    register_time_property(child_property_name: string): boolean
    /**
     * Set the time translation query functions for the time effect. If an
     * effect is a time effect, it will have two sets of coordinates: one
     * at its sink and one at its source. The given functions should be able
     * to translate between these two sets of coordinates. More specifically,
     * `source_to_sink_func` should *emulate* how the corresponding #GstElement
     * would translate the #GstSegment `time` field, and `sink_to_source_func`
     * should emulate how the corresponding #GstElement would translate the
     * seek query `start` and `stop` values, as used in gst_element_seek(). As
     * such, `sink_to_source_func` should act as an approximate reverse of
     * `source_to_sink_func`.
     * 
     * Note, these functions will be passed a table of time properties, as
     * registered in ges_base_effect_register_time_property(), and their
     * values. The functions should emulate what the translation *would* be
     * *if* the time properties were set to the given values. They should not
     * use the currently set values.
     * 
     * Note that `effect` must not be part of a clip, nor can it have
     * #GESTrackElement:has-internal-source set to %TRUE.
     */
    set_time_translation_funcs(source_to_sink_func?: BaseEffectTimeTranslationFunc | null, sink_to_source_func?: BaseEffectTimeTranslationFunc | null): boolean
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Effect */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.BaseEffect */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Operation */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: Effect, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: Effect, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: Effect, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: Effect, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: Effect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: Effect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: Effect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: Effect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: Effect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Effect, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Effect, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Effect, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: Effect, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Effect_ConstructProps)
    _init (config?: Effect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(bin_description: string): Effect
    /**
     * Register an element that can change the rate at which media is playing.
     * The property type must be float or double, and must be a factor of the
     * rate, i.e. a value of 2.0 must mean that the media plays twice as fast.
     * Several properties may be registered for a single element type,
     * provided they all contribute to the rate as independent factors. For
     * example, this is true for the "GstPitch::rate" and "GstPitch::tempo"
     * properties. These are already registered by default in GES, along with
     * #videorate:rate for #videorate and #scaletempo:rate for #scaletempo.
     * 
     * If such a rate property becomes a child property of a #GESEffect upon
     * its creation (the element is part of its #GESEffect:bin-description),
     * it will be automatically registered as a time property (see
     * ges_base_effect_register_time_property()) and will have its time
     * translation functions set (see
     * ges_base_effect_set_time_translation_funcs()) to use the overall rate
     * of the rate properties. Note that if an effect contains a rate
     * property as well as a non-rate time property, you should ensure to set
     * the time translation functions to some other methods using
     * ges_base_effect_set_time_translation_funcs().
     * 
     * Note, you can obtain a reference to the GESEffectClass using
     * 
     * ```
     *   GES_EFFECT_CLASS (g_type_class_ref (GES_TYPE_EFFECT));
     * ```
     */
    static register_rate_property(klass: Effect | Function | GObject.Type, element_name: string, property_name: string): boolean
    static $gtype: GObject.Type
}
interface EffectAsset_ConstructProps extends TrackElementAsset_ConstructProps {
}
class EffectAsset {
    /* Properties of GES-1.0.GES.TrackElementAsset */
    track_type: TrackType
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GES-1.0.GES.TrackElementAsset */
    readonly parent: Asset
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElementAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Get the GESAssetTrackType the #GESTrackElement extracted from `self`
     * should get into
     */
    get_track_type(): TrackType
    /**
     * Set the #GESTrackType the #GESTrackElement extracted from `self`
     * should get into
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.EffectAsset */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.TrackElementAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: EffectAsset, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: EffectAsset, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::track-type", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: EffectAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: EffectAsset_ConstructProps)
    _init (config?: EffectAsset_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface EffectClip_ConstructProps extends BaseEffectClip_ConstructProps {
    /* Constructor properties of GES-1.0.GES.EffectClip */
    /**
     * The description of the audio track of the effect bin with a gst-launch-style
     * pipeline description. This should be used for test purposes.
     * 
     * Example: "audiopanorama panorama=1.0"
     */
    audio_bin_description?: string
    /**
     * The description of the video track of the effect bin with a gst-launch-style
     * pipeline description. This should be used for test purposes.
     * 
     * Example: "videobalance saturation=1.5 hue=+0.5"
     */
    video_bin_description?: string
}
class EffectClip {
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.EffectClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.BaseEffectClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.OperationClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: EffectClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: EffectClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: EffectClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: EffectClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: EffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: EffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: EffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: EffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: EffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: EffectClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: EffectClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: EffectClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration-limit", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: EffectClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: EffectClip_ConstructProps)
    _init (config?: EffectClip_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(video_bin_description?: string | null, audio_bin_description?: string | null): EffectClip
    static $gtype: GObject.Type
}
interface Formatter_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
}
class Formatter {
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Formatter */
    /**
     * Load data from the given URI into timeline.
     */
    load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Formatter */
    vfunc_can_load_uri(uri: string): boolean
    /**
     * Load data from the given URI into timeline.
     */
    vfunc_load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    vfunc_save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Formatter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Formatter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Formatter_ConstructProps)
    _init (config?: Formatter_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Checks if there is a #GESFormatter available which can load a #GESTimeline
     * from the given URI.
     */
    static can_load_uri(uri: string): boolean
    /**
     * Returns TRUE if there is a #GESFormatter available which can save a
     * #GESTimeline to the given URI.
     */
    static can_save_uri(uri: string): boolean
    /**
     * Get the default #GESAsset to use as formatter. It will return
     * the asset for the #GESFormatter that has the highest `rank`
     */
    static get_default(): Asset
    static register_metas(klass: Formatter | Function | GObject.Type, name: string, description: string, extensions: string, caps: string, version: number, rank: Gst.Rank): void
    static $gtype: GObject.Type
}
interface Group_ConstructProps extends Container_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Group */
    /**
     * An overwrite of the #GESTimelineElement:duration property. For a
     * #GESGroup, this is the difference between the earliest
     * #GESTimelineElement:start time and the latest end time (given by
     * #GESTimelineElement:start + #GESTimelineElement:duration) amongst
     * its children.
     */
    duration?: number
    /**
     * An overwrite of the #GESTimelineElement:in-point property. This has
     * no meaning for a group and should not be set.
     */
    in_point?: number
    /**
     * An overwrite of the #GESTimelineElement:max-duration property. This
     * has no meaning for a group and should not be set.
     */
    max_duration?: number
    /**
     * An overwrite of the #GESTimelineElement:priority property.
     * Setting #GESTimelineElement priorities is deprecated as all priority
     * management is now done by GES itself.
     */
    priority?: number
    /**
     * An overwrite of the #GESTimelineElement:start property. For a
     * #GESGroup, this is the earliest #GESTimelineElement:start time
     * amongst its children.
     */
    start?: number
}
class Group {
    /* Properties of GES-1.0.GES.Group */
    /**
     * An overwrite of the #GESTimelineElement:duration property. For a
     * #GESGroup, this is the difference between the earliest
     * #GESTimelineElement:start time and the latest end time (given by
     * #GESTimelineElement:start + #GESTimelineElement:duration) amongst
     * its children.
     */
    duration: number
    /**
     * An overwrite of the #GESTimelineElement:in-point property. This has
     * no meaning for a group and should not be set.
     */
    in_point: number
    /**
     * An overwrite of the #GESTimelineElement:max-duration property. This
     * has no meaning for a group and should not be set.
     */
    max_duration: number
    /**
     * An overwrite of the #GESTimelineElement:priority property.
     * Setting #GESTimelineElement priorities is deprecated as all priority
     * management is now done by GES itself.
     */
    priority: number
    /**
     * An overwrite of the #GESTimelineElement:start property. For a
     * #GESGroup, this is the earliest #GESTimelineElement:start time
     * amongst its children.
     */
    start: number
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Container */
    readonly parent: TimelineElement
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Group */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: Group, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: Group, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: Group, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: Group, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: Group, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: Group, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: Group, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: Group, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: Group, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Group, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Group, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Group, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::start", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::start", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: Group, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Group_ConstructProps)
    _init (config?: Group_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Group
    static $gtype: GObject.Type
}
interface ImageSource_ConstructProps extends VideoSource_ConstructProps {
    /* Constructor properties of GES-1.0.GES.ImageSource */
    /**
     * The location of the file/resource to use.
     */
    uri?: string
}
class ImageSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.VideoSource */
    /**
     * Retrieves the natural size of the video stream. The natural size, is
     * the size at which it will be displayed if no scaling is being applied.
     * 
     * NOTE: The sources take into account the potential video rotation applied
     * by the #videoflip element that is inside the source, effects applied on
     * the clip which potentially also rotate the element are not taken into
     * account.
     */
    get_natural_size(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.ImageSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.VideoSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: ImageSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: ImageSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: ImageSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: ImageSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: ImageSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: ImageSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: ImageSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: ImageSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: ImageSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: ImageSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: ImageSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: ImageSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: ImageSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ImageSource_ConstructProps)
    _init (config?: ImageSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface Layer_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Layer */
    /**
     * Whether to automatically create a #GESTransitionClip whenever two
     * #GESSource-s that both belong to a #GESClip in the layer overlap.
     * See #GESTimeline for what counts as an overlap.
     * 
     * When a layer is added to a #GESTimeline, if this property is left as
     * %FALSE, but the timeline's #GESTimeline:auto-transition is %TRUE, it
     * will be set to %TRUE as well.
     */
    auto_transition?: boolean
    /**
     * The priority of the layer in the #GESTimeline. 0 is the highest
     * priority. Conceptually, a timeline is a stack of layers,
     * and the priority of the layer represents its position in the stack. Two
     * layers should not have the same priority within a given GESTimeline.
     * 
     * Note that the timeline needs to be committed (with #ges_timeline_commit)
     * for the change to be taken into account.
     */
    priority?: number
}
class Layer {
    /* Properties of GES-1.0.GES.Layer */
    /**
     * Whether to automatically create a #GESTransitionClip whenever two
     * #GESSource-s that both belong to a #GESClip in the layer overlap.
     * See #GESTimeline for what counts as an overlap.
     * 
     * When a layer is added to a #GESTimeline, if this property is left as
     * %FALSE, but the timeline's #GESTimeline:auto-transition is %TRUE, it
     * will be set to %TRUE as well.
     */
    auto_transition: boolean
    /**
     * The priority of the layer in the #GESTimeline. 0 is the highest
     * priority. Conceptually, a timeline is a stack of layers,
     * and the priority of the layer represents its position in the stack. Two
     * layers should not have the same priority within a given GESTimeline.
     * 
     * Note that the timeline needs to be committed (with #ges_timeline_commit)
     * for the change to be taken into account.
     */
    priority: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Layer */
    /**
     * See ges_layer_add_asset_full(), which also gives an error.
     */
    add_asset(asset: Asset, start: Gst.ClockTime, inpoint: Gst.ClockTime, duration: Gst.ClockTime, track_types: TrackType): Clip
    /**
     * Extracts a new clip from an asset and adds it to the layer with
     * the given properties.
     */
    add_asset_full(asset: Asset, start: Gst.ClockTime, inpoint: Gst.ClockTime, duration: Gst.ClockTime, track_types: TrackType): Clip
    /**
     * See ges_layer_add_clip_full(), which also gives an error.
     */
    add_clip(clip: Clip): boolean
    /**
     * Adds the given clip to the layer. If the method succeeds, the layer
     * will take ownership of the clip.
     * 
     * This method will fail and return %FALSE if `clip` already resides in
     * some layer. It can also fail if the additional clip breaks some
     * compositional rules (see #GESTimelineElement).
     */
    add_clip_full(clip: Clip): boolean
    /**
     * Gets whether the layer is active for the given track. See
     * ges_layer_set_active_for_tracks().
     */
    get_active_for_track(track: Track): boolean
    /**
     * Gets the #GESLayer:auto-transition of the layer.
     */
    get_auto_transition(): boolean
    /**
     * Get the #GESClip-s contained in this layer.
     */
    get_clips(): Clip[]
    /**
     * Gets the clips within the layer that appear between `start` and `end`.
     */
    get_clips_in_interval(start: Gst.ClockTime, end: Gst.ClockTime): Clip[]
    /**
     * Retrieves the duration of the layer, which is the difference
     * between the start of the layer (always time 0) and the end (which will
     * be the end time of the final clip).
     */
    get_duration(): Gst.ClockTime
    /**
     * Get the priority of the layer. When inside a timeline, this is its
     * index in the timeline. See ges_timeline_move_layer().
     */
    get_priority(): number
    /**
     * Gets the timeline that the layer is a part of.
     */
    get_timeline(): Timeline | null
    /**
     * Convenience method to check if the layer is empty (doesn't contain
     * any #GESClip), or not.
     */
    is_empty(): boolean
    /**
     * Removes the given clip from the layer.
     */
    remove_clip(clip: Clip): boolean
    /**
     * Activate or deactivate track elements in `tracks` (or in all tracks if `tracks`
     * is %NULL).
     * 
     * When a layer is deactivated for a track, all the #GESTrackElement-s in
     * the track that belong to a #GESClip in the layer will no longer be
     * active in the track, regardless of their individual
     * #GESTrackElement:active value.
     * 
     * Note that by default a layer will be active for all of its
     * timeline's tracks.
     */
    set_active_for_tracks(active: boolean, tracks?: Track[] | null): boolean
    /**
     * Sets #GESLayer:auto-transition for the layer. Use
     * ges_timeline_set_auto_transition() if you want all layers within a
     * #GESTimeline to have #GESLayer:auto-transition set to %TRUE. Use this
     * method if you want different values for different layers (and make sure
     * to keep #GESTimeline:auto-transition as %FALSE for the corresponding
     * timeline).
     */
    set_auto_transition(auto_transition: boolean): void
    /**
     * Sets the layer to the given priority. See #GESLayer:priority.
     */
    set_priority(priority: number): void
    set_timeline(timeline: Timeline): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Layer */
    vfunc_object_added(object: Clip): void
    vfunc_object_removed(object: Clip): void
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Layer */
    /**
     * Will be emitted whenever the layer is activated or deactivated
     * for some #GESTrack. See ges_layer_set_active_for_tracks().
     */
    connect(sigName: "active-changed", callback: (($obj: Layer, active: boolean, tracks: Track[]) => void)): number
    connect_after(sigName: "active-changed", callback: (($obj: Layer, active: boolean, tracks: Track[]) => void)): number
    emit(sigName: "active-changed", active: boolean, tracks: Track[]): void
    /**
     * Will be emitted after the clip is added to the layer.
     */
    connect(sigName: "clip-added", callback: (($obj: Layer, clip: Clip) => void)): number
    connect_after(sigName: "clip-added", callback: (($obj: Layer, clip: Clip) => void)): number
    emit(sigName: "clip-added", clip: Clip): void
    /**
     * Will be emitted after the clip is removed from the layer.
     */
    connect(sigName: "clip-removed", callback: (($obj: Layer, clip: Clip) => void)): number
    connect_after(sigName: "clip-removed", callback: (($obj: Layer, clip: Clip) => void)): number
    emit(sigName: "clip-removed", clip: Clip): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Layer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Layer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Layer, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Layer, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::auto-transition", callback: (($obj: Layer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-transition", callback: (($obj: Layer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority", callback: (($obj: Layer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority", callback: (($obj: Layer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Layer_ConstructProps)
    _init (config?: Layer_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Layer
    static $gtype: GObject.Type
}
interface Marker_ConstructProps extends GObject.Object_ConstructProps {
}
class Marker {
    /* Properties of GES-1.0.GES.Marker */
    /**
     * Current position (in nanoseconds) of the #GESMarker
     */
    readonly position: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Marker, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Marker, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Marker, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Marker, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::position", callback: (($obj: Marker, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: (($obj: Marker, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Marker_ConstructProps)
    _init (config?: Marker_ConstructProps): void
    static $gtype: GObject.Type
}
interface MarkerList_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of GES-1.0.GES.MarkerList */
    /**
     * Flags indicating how markers on the list should be treated.
     */
    flags?: MarkerFlags
}
class MarkerList {
    /* Properties of GES-1.0.GES.MarkerList */
    /**
     * Flags indicating how markers on the list should be treated.
     */
    flags: MarkerFlags
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.MarkerList */
    add(position: Gst.ClockTime): Marker
    get_markers(): Marker[]
    /**
     * Moves a `marker` in a `list` to a new `position`
     */
    move(marker: Marker, position: Gst.ClockTime): boolean
    /**
     * Removes `marker` from `list,` this decreases the refcount of the
     * marker by 1.
     */
    remove(marker: Marker): boolean
    size(): number
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MarkerList */
    /**
     * Will be emitted after the marker was added to the marker-list.
     */
    connect(sigName: "marker-added", callback: (($obj: MarkerList, position: number, marker: Marker) => void)): number
    connect_after(sigName: "marker-added", callback: (($obj: MarkerList, position: number, marker: Marker) => void)): number
    emit(sigName: "marker-added", position: number, marker: Marker): void
    /**
     * Will be emitted after the marker was moved to.
     */
    connect(sigName: "marker-moved", callback: (($obj: MarkerList, previous_position: number, new_position: number, marker: Marker) => void)): number
    connect_after(sigName: "marker-moved", callback: (($obj: MarkerList, previous_position: number, new_position: number, marker: Marker) => void)): number
    emit(sigName: "marker-moved", previous_position: number, new_position: number, marker: Marker): void
    /**
     * Will be emitted after the marker was removed the marker-list.
     */
    connect(sigName: "marker-removed", callback: (($obj: MarkerList, marker: Marker) => void)): number
    connect_after(sigName: "marker-removed", callback: (($obj: MarkerList, marker: Marker) => void)): number
    emit(sigName: "marker-removed", marker: Marker): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: MarkerList, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: MarkerList, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::flags", callback: (($obj: MarkerList, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: MarkerList, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: MarkerList_ConstructProps)
    _init (config?: MarkerList_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): MarkerList
    static $gtype: GObject.Type
}
interface MultiFileSource_ConstructProps extends VideoSource_ConstructProps {
    /* Constructor properties of GES-1.0.GES.MultiFileSource */
    /**
     * The uri of the file/resource to use. You can set a start index,
     * a stop index and a sequence pattern.
     * The format is <multifile://start:stop\`location-pattern>`.
     * The pattern uses printf string formating.
     * 
     * Example uris:
     * 
     * multifile:///home/you/image\%03d.jpg
     * 
     * multifile://20:50`/`home/you/sequence/\%04d.png
     */
    uri?: string
}
class MultiFileSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.VideoSource */
    /**
     * Retrieves the natural size of the video stream. The natural size, is
     * the size at which it will be displayed if no scaling is being applied.
     * 
     * NOTE: The sources take into account the potential video rotation applied
     * by the #videoflip element that is inside the source, effects applied on
     * the clip which potentially also rotate the element are not taken into
     * account.
     */
    get_natural_size(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.MultiFileSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.VideoSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: MultiFileSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: MultiFileSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: MultiFileSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: MultiFileSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: MultiFileSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: MultiFileSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: MultiFileSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: MultiFileSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: MultiFileSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: MultiFileSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: MultiFileSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: MultiFileSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: MultiFileSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: MultiFileSource_ConstructProps)
    _init (config?: MultiFileSource_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(uri: string): MultiFileSource
    static $gtype: GObject.Type
}
interface Operation_ConstructProps extends TrackElement_ConstructProps {
}
class Operation {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Operation */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: Operation, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: Operation, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: Operation, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: Operation, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: Operation, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: Operation, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: Operation, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: Operation, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: Operation, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Operation, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Operation, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Operation, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: Operation, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Operation_ConstructProps)
    _init (config?: Operation_ConstructProps): void
    static $gtype: GObject.Type
}
interface OperationClip_ConstructProps extends Clip_ConstructProps {
}
class OperationClip {
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.OperationClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: OperationClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: OperationClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: OperationClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: OperationClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: OperationClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: OperationClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: OperationClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: OperationClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: OperationClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: OperationClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: OperationClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: OperationClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration-limit", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: OperationClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: OperationClip_ConstructProps)
    _init (config?: OperationClip_ConstructProps): void
    static $gtype: GObject.Type
}
interface OverlayClip_ConstructProps extends OperationClip_ConstructProps {
}
class OverlayClip {
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.OverlayClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.OperationClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: OverlayClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: OverlayClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: OverlayClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: OverlayClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: OverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: OverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: OverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: OverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: OverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: OverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: OverlayClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: OverlayClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration-limit", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: OverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: OverlayClip_ConstructProps)
    _init (config?: OverlayClip_ConstructProps): void
    static $gtype: GObject.Type
}
interface Pipeline_ConstructProps extends Gst.Pipeline_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Pipeline */
    /**
     * The audio filter(s) to apply during playback in preview mode,
     * immediately before the #GESPipeline:audio-sink. This exposes the
     * #playsink:audio-filter property of the internal #playsink.
     */
    audio_filter?: Gst.Element
    /**
     * The audio sink used for preview. This exposes the
     * #playsink:audio-sink property of the internal #playsink.
     */
    audio_sink?: Gst.Element
    /**
     * The pipeline's mode. In preview mode (for audio or video, or both)
     * the pipeline can display the timeline's content to an end user. In
     * rendering mode the pipeline can encode the timeline's content and
     * save it to a file.
     */
    mode?: PipelineFlags
    /**
     * The timeline used by this pipeline, whose content it will play and
     * render, or %NULL if the pipeline does not yet have a timeline.
     * 
     * Note that after you set the timeline for the first time, subsequent
     * calls to change the timeline will fail.
     */
    timeline?: Timeline
    /**
     * The video filter(s) to apply during playback in preview mode,
     * immediately before the #GESPipeline:video-sink. This exposes the
     * #playsink:video-filter property of the internal #playsink.
     */
    video_filter?: Gst.Element
    /**
     * The video sink used for preview. This exposes the
     * #playsink:video-sink property of the internal #playsink.
     */
    video_sink?: Gst.Element
}
class Pipeline {
    /* Properties of GES-1.0.GES.Pipeline */
    /**
     * The audio filter(s) to apply during playback in preview mode,
     * immediately before the #GESPipeline:audio-sink. This exposes the
     * #playsink:audio-filter property of the internal #playsink.
     */
    audio_filter: Gst.Element
    /**
     * The audio sink used for preview. This exposes the
     * #playsink:audio-sink property of the internal #playsink.
     */
    audio_sink: Gst.Element
    /**
     * The pipeline's mode. In preview mode (for audio or video, or both)
     * the pipeline can display the timeline's content to an end user. In
     * rendering mode the pipeline can encode the timeline's content and
     * save it to a file.
     */
    mode: PipelineFlags
    /**
     * The timeline used by this pipeline, whose content it will play and
     * render, or %NULL if the pipeline does not yet have a timeline.
     * 
     * Note that after you set the timeline for the first time, subsequent
     * calls to change the timeline will fail.
     */
    timeline: Timeline
    /**
     * The video filter(s) to apply during playback in preview mode,
     * immediately before the #GESPipeline:video-sink. This exposes the
     * #playsink:video-filter property of the internal #playsink.
     */
    video_filter: Gst.Element
    /**
     * The video sink used for preview. This exposes the
     * #playsink:video-sink property of the internal #playsink.
     */
    video_sink: Gst.Element
    /* Properties of Gst-1.0.Gst.Pipeline */
    /**
     * Whether or not to automatically flush all messages on the
     * pipeline's bus when going from READY to NULL state. Please see
     * gst_pipeline_set_auto_flush_bus() for more information on this option.
     */
    auto_flush_bus: boolean
    /**
     * Latency to configure on the pipeline. See gst_pipeline_set_latency().
     */
    latency: number
    /* Properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward: boolean
    /* Fields of Gst-1.0.Gst.Pipeline */
    readonly bin: Gst.Bin
    /**
     * The fixed clock of the pipeline, used when
     *               GST_PIPELINE_FLAG_FIXED_CLOCK is set.
     */
    readonly fixed_clock: Gst.Clock
    /**
     * The stream time of the pipeline. A better name for this
     *         property would be the running_time, the total time spent in the
     *         PLAYING state without being flushed. (deprecated, use the start_time
     *         on GstElement).
     */
    readonly stream_time: Gst.ClockTime
    /**
     * Extra delay added to base_time to compensate for computing delays
     *         when setting elements to PLAYING.
     */
    readonly delay: Gst.ClockTime
    /* Fields of Gst-1.0.Gst.Bin */
    readonly element: Gst.Element
    /**
     * the number of children in this bin
     */
    readonly numchildren: number
    /**
     * the list of children in this bin
     */
    readonly children: Gst.Element[]
    /**
     * updated whenever `children` changes
     */
    readonly children_cookie: number
    /**
     * internal bus for handling child messages
     */
    readonly child_bus: Gst.Bus
    /**
     * queued and cached messages
     */
    readonly messages: Gst.Message[]
    /**
     * the bin is currently calculating its state
     */
    readonly polling: boolean
    /**
     * the bin needs to recalculate its state (deprecated)
     */
    readonly state_dirty: boolean
    /**
     * the bin needs to select a new clock
     */
    readonly clock_dirty: boolean
    /**
     * the last clock selected
     */
    readonly provided_clock: Gst.Clock
    /**
     * the element that provided `provided_clock`
     */
    readonly clock_provider: Gst.Element
    /* Fields of Gst-1.0.Gst.Element */
    readonly object: Gst.Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    readonly state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    readonly state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    readonly state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    readonly target_state: Gst.State
    /**
     * the current state of an element
     */
    readonly current_state: Gst.State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    readonly next_state: Gst.State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    readonly pending_state: Gst.State
    /**
     * the last return value of an element state change
     */
    readonly last_return: Gst.StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    readonly bus: Gst.Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    readonly clock: Gst.Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    readonly base_time: Gst.ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    readonly start_time: Gst.ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    readonly numpads: number
    /**
     * list of pads
     */
    readonly pads: Gst.Pad[]
    /**
     * number of source pads of the element.
     */
    readonly numsrcpads: number
    /**
     * list of source pads
     */
    readonly srcpads: Gst.Pad[]
    /**
     * number of sink pads of the element.
     */
    readonly numsinkpads: number
    /**
     * list of sink pads
     */
    readonly sinkpads: Gst.Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    readonly pads_cookie: number
    /**
     * list of contexts
     */
    readonly contexts: Gst.Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    readonly lock: GLib.Mutex
    /**
     * The name of the object
     */
    readonly name: string
    /**
     * this object's parent, weak ref
     */
    readonly parent: Gst.Object
    /**
     * flags for this object
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Pipeline */
    /**
     * Gets the #GESPipeline:mode of the pipeline.
     */
    get_mode(): PipelineFlags
    /**
     * Gets a sample from the pipeline of the currently displayed image in
     * preview, in the specified format.
     * 
     * Note that if you use "ANY" caps for `caps,` then the current format of
     * the image is used. You can retrieve these caps from the returned sample
     * with gst_sample_get_caps().
     */
    get_thumbnail(caps: Gst.Caps): Gst.Sample
    /**
     * Gets a sample from the pipeline of the currently displayed image in
     * preview, in the 24-bit "RGB" format and of the desired width and
     * height.
     * 
     * See ges_pipeline_get_thumbnail().
     */
    get_thumbnail_rgb24(width: number, height: number): Gst.Sample
    /**
     * Gets the #GESPipeline:audio-sink of the pipeline.
     */
    preview_get_audio_sink(): Gst.Element
    /**
     * Gets the #GESPipeline:video-sink of the pipeline.
     */
    preview_get_video_sink(): Gst.Element
    /**
     * Sets the #GESPipeline:audio-sink of the pipeline.
     */
    preview_set_audio_sink(sink: Gst.Element): void
    /**
     * Sets the #GESPipeline:video-sink of the pipeline.
     */
    preview_set_video_sink(sink: Gst.Element): void
    /**
     * Saves the currently displayed image of the pipeline in preview to the
     * given location, in the specified dimensions and format.
     */
    save_thumbnail(width: number, height: number, format: string, location: string): boolean
    /**
     * Sets the #GESPipeline:mode of the pipeline.
     * 
     * Note that the pipeline will be set to #GST_STATE_NULL during this call to
     * perform the necessary changes. You will need to set the state again yourself
     * after calling this.
     * 
     * > **NOTE**: [Rendering settings](ges_pipeline_set_render_settings) need to be
     * > set before setting `mode` to #GES_PIPELINE_MODE_RENDER or
     * > #GES_PIPELINE_MODE_SMART_RENDER, the call to this method will fail
     * > otherwise.
     */
    set_mode(mode: PipelineFlags): boolean
    /**
     * Specifies encoding setting to be used by the pipeline to render its
     * #GESPipeline:timeline, and where the result should be written to.
     * 
     * This method **must** be called before setting the pipeline mode to
     * #GES_PIPELINE_MODE_RENDER.
     */
    set_render_settings(output_uri: string, profile: GstPbutils.EncodingProfile): boolean
    /**
     * Takes the given timeline and sets it as the #GESPipeline:timeline for
     * the pipeline.
     * 
     * Note that you should only call this method once on a given pipeline
     * because a pipeline can not have its #GESPipeline:timeline changed after
     * it has been set.
     */
    set_timeline(timeline: Timeline): boolean
    /* Methods of Gst-1.0.Gst.Pipeline */
    /**
     * Let `pipeline` select a clock automatically. This is the default
     * behaviour.
     * 
     * Use this function if you previous forced a fixed clock with
     * gst_pipeline_use_clock() and want to restore the default
     * pipeline clock selection algorithm.
     * 
     * MT safe.
     */
    auto_clock(): void
    /**
     * Check if `pipeline` will automatically flush messages when going to
     * the NULL state.
     */
    get_auto_flush_bus(): boolean
    /**
     * Gets the #GstBus of `pipeline`. The bus allows applications to receive
     * #GstMessage packets.
     */
    get_bus(): Gst.Bus
    /**
     * Get the configured delay (see gst_pipeline_set_delay()).
     */
    get_delay(): Gst.ClockTime
    /**
     * Gets the latency that should be configured on the pipeline. See
     * gst_pipeline_set_latency().
     */
    get_latency(): Gst.ClockTime
    /**
     * Gets the current clock used by `pipeline`.
     * 
     * Unlike gst_element_get_clock(), this function will always return a
     * clock, even if the pipeline is not in the PLAYING state.
     */
    get_pipeline_clock(): Gst.Clock
    /**
     * Usually, when a pipeline goes from READY to NULL state, it automatically
     * flushes all pending messages on the bus, which is done for refcounting
     * purposes, to break circular references.
     * 
     * This means that applications that update state using (async) bus messages
     * (e.g. do certain things when a pipeline goes from PAUSED to READY) might
     * not get to see messages when the pipeline is shut down, because they might
     * be flushed before they can be dispatched in the main thread. This behaviour
     * can be disabled using this function.
     * 
     * It is important that all messages on the bus are handled when the
     * automatic flushing is disabled else memory leaks will be introduced.
     * 
     * MT safe.
     */
    set_auto_flush_bus(auto_flush: boolean): void
    /**
     * Set the expected delay needed for all elements to perform the
     * PAUSED to PLAYING state change. `delay` will be added to the
     * base time of the elements so that they wait an additional `delay`
     * amount of time before starting to process buffers and cannot be
     * #GST_CLOCK_TIME_NONE.
     * 
     * This option is used for tuning purposes and should normally not be
     * used.
     * 
     * MT safe.
     */
    set_delay(delay: Gst.ClockTime): void
    /**
     * Sets the latency that should be configured on the pipeline. Setting
     * GST_CLOCK_TIME_NONE will restore the default behaviour of using the minimum
     * latency from the LATENCY query. Setting this is usually not required and
     * the pipeline will figure out an appropriate latency automatically.
     * 
     * Setting a too low latency, especially lower than the minimum latency from
     * the LATENCY query, will most likely cause the pipeline to fail.
     */
    set_latency(latency: Gst.ClockTime): void
    /**
     * Force `pipeline` to use the given `clock`. The pipeline will
     * always use the given clock even if new clock providers are added
     * to this pipeline.
     * 
     * If `clock` is %NULL all clocking will be disabled which will make
     * the pipeline run as fast as possible.
     * 
     * MT safe.
     */
    use_clock(clock?: Gst.Clock | null): void
    /* Methods of Gst-1.0.Gst.Bin */
    /**
     * Adds the given element to the bin.  Sets the element's parent, and thus
     * takes ownership of the element. An element can only be added to one bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is added to the bin.
     * 
     * > When you add an element to an already-running pipeline, you will have to
     * > take care to set the state of the newly-added element to the desired
     * > state (usually PLAYING or PAUSED, same you set the pipeline to originally)
     * > with gst_element_set_state(), or use gst_element_sync_state_with_parent().
     * > The bin or pipeline will not take care of this for you.
     */
    add(element: Gst.Element): boolean
    /**
     * Recursively looks for elements with an unlinked pad of the given
     * direction within the specified bin and returns an unlinked pad
     * if one is found, or %NULL otherwise. If a pad is found, the caller
     * owns a reference to it and should use gst_object_unref() on the
     * pad when it is not needed any longer.
     */
    find_unlinked_pad(direction: Gst.PadDirection): Gst.Pad | null
    /**
     * Looks for an element inside the bin that implements the given
     * interface. If such an element is found, it returns the element.
     * You can cast this element to the given interface afterwards.  If you want
     * all elements that implement the interface, use
     * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
     */
    get_by_interface(iface: GObject.Type): Gst.Element | null
    /**
     * Gets the element with the given name from a bin. This
     * function recurses into child bins.
     */
    get_by_name(name: string): Gst.Element | null
    /**
     * Gets the element with the given name from this bin. If the
     * element is not found, a recursion is performed on the parent bin.
     */
    get_by_name_recurse_up(name: string): Gst.Element | null
    get_suppressed_flags(): Gst.ElementFlags
    /**
     * Looks for all elements inside the bin with the given element factory name.
     * The function recurses inside child bins. The iterator will yield a series of
     * #GstElement.
     */
    iterate_all_by_element_factory_name(factory_name: string): Gst.Iterator | null
    /**
     * Looks for all elements inside the bin that implements the given
     * interface. You can safely cast all returned elements to the given interface.
     * The function recurses inside child bins. The iterator will yield a series
     * of #GstElement.
     */
    iterate_all_by_interface(iface: GObject.Type): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     */
    iterate_elements(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     * This iterator recurses into GstBin children.
     */
    iterate_recurse(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SINK flag set.
     */
    iterate_sinks(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin in topologically
     * sorted order. This means that the elements are returned from
     * the most downstream elements (sinks) to the sources.
     * 
     * This function is used internally to perform the state changes
     * of the bin elements and for clock selection.
     */
    iterate_sorted(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SOURCE flag set.
     */
    iterate_sources(): Gst.Iterator | null
    /**
     * Queries `bin` for the current latency and reconfigures this latency on all the
     * elements using a LATENCY event.
     * 
     * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
     * is posted on the bus.
     * 
     * This function simply emits the #GstBin::do-latency signal so any custom latency
     * calculations will be performed.
     */
    recalculate_latency(): boolean
    /**
     * Removes the element from the bin, unparenting it as well.
     * Unparenting the element means that the element will be dereferenced,
     * so if the bin holds the only reference to the element, the element
     * will be freed in the process of removing it from the bin.  If you
     * want the element to still exist after removing, you need to call
     * gst_object_ref() before removing it from the bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is removed from the bin.
     */
    remove(element: Gst.Element): boolean
    /**
     * Suppresses the given flags on the bin. #GstElementFlags of a
     * child element are propagated when it is added to the bin.
     * When suppressed flags are set, those specified flags will
     * not be propagated to the bin.
     */
    set_suppressed_flags(flags: Gst.ElementFlags): void
    /**
     * Synchronizes the state of every child of `bin` with the state
     * of `bin`. See also gst_element_sync_state_with_parent().
     */
    sync_children_states(): boolean
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     */
    add_pad(pad: Gst.Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     */
    call_async(func: Gst.ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     */
    continue_state(ret: Gst.StateChangeReturn): Gst.StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     */
    foreach_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_sink_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_src_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): Gst.ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Gst.Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Gst.Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     */
    get_compatible_pad(pad: Gst.Pad, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     */
    get_compatible_pad_template(compattempl: Gst.PadTemplate): Gst.PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     */
    get_context(context_type: string): Gst.Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     */
    get_context_unlocked(context_type: string): Gst.Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Gst.Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): Gst.ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): Gst.ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): Gst.ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     */
    get_pad_template(name: string): Gst.PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): Gst.PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     */
    get_request_pad(name: string): Gst.Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): Gst.ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     */
    get_static_pad(name: string): Gst.Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Gst.Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link(dest: Gst.Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link_filtered(dest: Gst.Element, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     */
    link_pads(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     */
    link_pads_filtered(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     */
    link_pads_full(srcpadname: string | null, dest: Gst.Element, destpadname: string | null, flags: Gst.PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     */
    message_full(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     */
    message_full_with_details(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Gst.Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    query(query: Gst.Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     */
    query_convert(src_format: Gst.Format, src_val: number, dest_format: Gst.Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     */
    query_duration(format: Gst.Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     */
    query_position(format: Gst.Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     */
    release_request_pad(pad: Gst.Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     */
    remove_pad(pad: Gst.Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    request_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     */
    request_pad_simple(name: string): Gst.Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     */
    seek(rate: number, format: Gst.Format, flags: Gst.SeekFlags, start_type: Gst.SeekType, start: number, stop_type: Gst.SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     */
    seek_simple(format: Gst.Format, seek_flags: Gst.SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    send_event(event: Gst.Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     */
    set_base_time(time: Gst.ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    set_context(context: Gst.Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     */
    set_start_time(time: Gst.ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    set_state(state: Gst.State): Gst.StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     */
    unlink(dest: Gst.Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     */
    unlink_pads(srcpadname: string, dest: Gst.Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     */
    add_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): Gst.ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     */
    get_g_value_array(property_name: string, timestamp: Gst.ClockTime, interval: Gst.ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Gst.Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     */
    get_value(property_name: string, timestamp: Gst.ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_as_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     */
    has_as_parent(parent: Gst.Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Gst.Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     */
    remove_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     */
    set_control_rate(control_rate: Gst.ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     */
    set_parent(parent: Gst.Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): Gst.ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     */
    sync_values(timestamp: Gst.ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of Gst-1.0.Gst.ChildProxy */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    get_children_count(): number
    /**
     * Gets a single property using the GstChildProxy mechanism.
     * You are responsible for freeing it by calling g_value_unset()
     */
    get_property(name: string): /* value */ any
    /**
     * Looks up which object and #GParamSpec would be effected by the given `name`.
     */
    lookup(name: string): [ /* returnType */ boolean, /* target */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Sets a single property using the GstChildProxy mechanism.
     */
    set_property(name: string, value: any): void
    /* Methods of GstVideo-1.0.GstVideo.VideoOverlay */
    /**
     * Tell an overlay that it has been exposed. This will redraw the current frame
     * in the drawable even if the pipeline is PAUSED.
     */
    expose(): void
    /**
     * This will post a "have-window-handle" element message on the bus.
     * 
     * This function should only be used by video overlay plugin developers.
     */
    got_window_handle(handle: number): void
    /**
     * Tell an overlay that it should handle events from the window system. These
     * events are forwarded upstream as navigation events. In some window system,
     * events are not propagated in the window hierarchy if a client is listening
     * for them. This method allows you to disable events handling completely
     * from the #GstVideoOverlay.
     */
    handle_events(handle_events: boolean): void
    /**
     * This will post a "prepare-window-handle" element message on the bus
     * to give applications an opportunity to call
     * gst_video_overlay_set_window_handle() before a plugin creates its own
     * window.
     * 
     * This function should only be used by video overlay plugin developers.
     */
    prepare_window_handle(): void
    /**
     * Configure a subregion as a video target within the window set by
     * gst_video_overlay_set_window_handle(). If this is not used or not supported
     * the video will fill the area of the window set as the overlay to 100%.
     * By specifying the rectangle, the video can be overlayed to a specific region
     * of that window only. After setting the new rectangle one should call
     * gst_video_overlay_expose() to force a redraw. To unset the region pass -1 for
     * the `width` and `height` parameters.
     * 
     * This method is needed for non fullscreen video overlay in UI toolkits that
     * do not support subwindows.
     */
    set_render_rectangle(x: number, y: number, width: number, height: number): boolean
    /**
     * This will call the video overlay's set_window_handle method. You
     * should use this method to tell to an overlay to display video output to a
     * specific window (e.g. an XWindow on X11). Passing 0 as the  `handle` will
     * tell the overlay to stop using that window and create an internal one.
     */
    set_window_handle(handle: number): void
    /* Virtual methods of GES-1.0.GES.Pipeline */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /**
     * Tell an overlay that it has been exposed. This will redraw the current frame
     * in the drawable even if the pipeline is PAUSED.
     */
    vfunc_expose(): void
    /**
     * Tell an overlay that it should handle events from the window system. These
     * events are forwarded upstream as navigation events. In some window system,
     * events are not propagated in the window hierarchy if a client is listening
     * for them. This method allows you to disable events handling completely
     * from the #GstVideoOverlay.
     */
    vfunc_handle_events(handle_events: boolean): void
    vfunc_set_render_rectangle(x: number, y: number, width: number, height: number): void
    /**
     * This will call the video overlay's set_window_handle method. You
     * should use this method to tell to an overlay to display video output to a
     * specific window (e.g. an XWindow on X11). Passing 0 as the  `handle` will
     * tell the overlay to stop using that window and create an internal one.
     */
    vfunc_set_window_handle(handle: number): void
    /* Virtual methods of Gst-1.0.Gst.Bin */
    /**
     * Method to add an element to the bin.
     */
    vfunc_add_element(element: Gst.Element): boolean
    /**
     * Method called when an element was added somewhere in the bin hierarchy.
     */
    vfunc_deep_element_added(sub_bin: Gst.Bin, child: Gst.Element): void
    /**
     * Method called when an element was removed somewhere in the bin hierarchy.
     */
    vfunc_deep_element_removed(sub_bin: Gst.Bin, child: Gst.Element): void
    vfunc_do_latency(): boolean
    /**
     * Method called when an element was added to the bin.
     */
    vfunc_element_added(child: Gst.Element): void
    /**
     * Method called when an element was removed from the bin.
     */
    vfunc_element_removed(child: Gst.Element): void
    /**
     * Method to handle a message from the children.
     */
    vfunc_handle_message(message: Gst.Message): void
    /**
     * Method to remove an element from the bin.
     */
    vfunc_remove_element(element: Gst.Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    vfunc_change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    vfunc_get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Gst.Pad): void
    vfunc_pad_removed(pad: Gst.Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    vfunc_post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    vfunc_query(query: Gst.Query): boolean
    vfunc_release_pad(pad: Gst.Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    vfunc_request_new_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    vfunc_send_event(event: Gst.Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    vfunc_set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    vfunc_set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    vfunc_set_context(context: Gst.Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    vfunc_set_state(state: Gst.State): Gst.StateChangeReturn
    vfunc_state_changed(oldstate: Gst.State, newstate: Gst.State, pending: Gst.State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Gst.Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Bin */
    /**
     * Will be emitted after the element was added to `sub_bin`.
     */
    connect(sigName: "deep-element-added", callback: (($obj: Pipeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-added", callback: (($obj: Pipeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-added", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from `sub_bin`.
     */
    connect(sigName: "deep-element-removed", callback: (($obj: Pipeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-removed", callback: (($obj: Pipeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-removed", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted when the bin needs to perform latency calculations. This
     * signal is only emitted for toplevel bins or when #GstBin:async-handling is
     * enabled.
     * 
     * Only one signal handler is invoked. If no signals are connected, the
     * default handler is invoked, which will query and distribute the lowest
     * possible latency to all sinks.
     * 
     * Connect to this signal if the default latency calculations are not
     * sufficient, like when you need different latencies for different sinks in
     * the same pipeline.
     */
    connect(sigName: "do-latency", callback: (($obj: Pipeline) => boolean)): number
    connect_after(sigName: "do-latency", callback: (($obj: Pipeline) => boolean)): number
    emit(sigName: "do-latency"): void
    /**
     * Will be emitted after the element was added to the bin.
     */
    connect(sigName: "element-added", callback: (($obj: Pipeline, element: Gst.Element) => void)): number
    connect_after(sigName: "element-added", callback: (($obj: Pipeline, element: Gst.Element) => void)): number
    emit(sigName: "element-added", element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from the bin.
     */
    connect(sigName: "element-removed", callback: (($obj: Pipeline, element: Gst.Element) => void)): number
    connect_after(sigName: "element-removed", callback: (($obj: Pipeline, element: Gst.Element) => void)): number
    emit(sigName: "element-removed", element: Gst.Element): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: Pipeline) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: Pipeline) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     */
    connect(sigName: "pad-added", callback: (($obj: Pipeline, new_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: Pipeline, new_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Gst.Pad): void
    /**
     * a #GstPad has been removed from the element
     */
    connect(sigName: "pad-removed", callback: (($obj: Pipeline, old_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: Pipeline, old_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Gst.Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     */
    connect(sigName: "deep-notify", callback: (($obj: Pipeline, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Pipeline, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Gst.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.ChildProxy */
    /**
     * Will be emitted after the `object` was added to the `child_proxy`.
     */
    connect(sigName: "child-added", callback: (($obj: Pipeline, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: Pipeline, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-added", object: GObject.Object, name: string): void
    /**
     * Will be emitted after the `object` was removed from the `child_proxy`.
     */
    connect(sigName: "child-removed", callback: (($obj: Pipeline, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: Pipeline, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-removed", object: GObject.Object, name: string): void
    connect(sigName: "notify::audio-filter", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::audio-filter", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::audio-sink", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::audio-sink", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::timeline", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeline", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::video-filter", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::video-filter", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::video-sink", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::video-sink", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-flush-bus", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-flush-bus", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::latency", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::latency", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::async-handling", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::async-handling", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::message-forward", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-forward", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Pipeline_ConstructProps)
    _init (config?: Pipeline_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Pipeline
    /* Function overloads */
    static new(name?: string | null): Pipeline
    static new(name?: string | null): Pipeline
    /**
     * This helper shall be used by classes implementing the #GstVideoOverlay
     * interface that want the render rectangle to be controllable using
     * properties. This helper will install "render-rectangle" property into the
     * class.
     */
    static install_properties(oclass: GObject.ObjectClass, last_prop_id: number): void
    /**
     * This helper shall be used by classes implementing the #GstVideoOverlay
     * interface that want the render rectangle to be controllable using
     * properties. This helper will parse and set the render rectangle calling
     * gst_video_overlay_set_render_rectangle().
     */
    static set_property(object: GObject.Object, last_prop_id: number, property_id: number, value: any): boolean
    static $gtype: GObject.Type
}
interface PitiviFormatter_ConstructProps extends Formatter_ConstructProps {
}
class PitiviFormatter {
    /* Fields of GES-1.0.GES.Formatter */
    readonly parent: GObject.InitiallyUnowned
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Formatter */
    /**
     * Load data from the given URI into timeline.
     */
    load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.PitiviFormatter */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Formatter */
    vfunc_can_load_uri(uri: string): boolean
    /**
     * Load data from the given URI into timeline.
     */
    vfunc_load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    vfunc_save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: PitiviFormatter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: PitiviFormatter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: PitiviFormatter_ConstructProps)
    _init (config?: PitiviFormatter_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): PitiviFormatter
    static $gtype: GObject.Type
}
interface Project_ConstructProps extends Asset_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Project */
    uri?: string
}
class Project {
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GES-1.0.GES.Asset */
    readonly parent: GObject.Object
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Project */
    /**
     * Adds a #GESAsset to `project,` the project will keep a reference on
     * `asset`.
     */
    add_asset(asset: Asset): boolean
    /**
     * Adds `profile` to the project. It lets you save in what format
     * the project has been renders and keep a reference to those formats.
     * Also, those formats will be saves to the project file when possible.
     */
    add_encoding_profile(profile: GstPbutils.EncodingProfile): boolean
    /**
     * Adds a formatter as used to load `project`
     */
    add_formatter(formatter: Formatter): void
    /**
     * Create and add a #GESAsset to `project`. You should connect to the
     * "asset-added" signal to get the asset when it finally gets added to
     * `project`
     */
    create_asset(id: string | null, extractable_type: GObject.Type): boolean
    /**
     * Create and add a #GESAsset to `project`. You should connect to the
     * "asset-added" signal to get the asset when it finally gets added to
     * `project`
     */
    create_asset_sync(id: string | null, extractable_type: GObject.Type): Asset | null
    get_asset(id: string, extractable_type: GObject.Type): Asset | null
    /**
     * Get the assets that are being loaded
     */
    get_loading_assets(): Asset[]
    /**
     * Retrieve the uri that is currently set on `project`
     */
    get_uri(): string | null
    /**
     * List all `asset` contained in `project` filtering per extractable_type
     * as defined by `filter`. It copies the asset and thus will not be updated
     * in time.
     */
    list_assets(filter: GObject.Type): Asset[]
    /**
     * Lists the encoding profile that have been set to `project`. The first one
     * is the latest added.
     */
    list_encoding_profiles(): GstPbutils.EncodingProfile[] | null
    /**
     * Loads `project` into `timeline`
     */
    load(timeline: Timeline): boolean
    /**
     * remove a `asset` to from `project`.
     */
    remove_asset(asset: Asset): boolean
    /**
     * Save the timeline of `project` to `uri`. You should make sure that `timeline`
     * is one of the timelines that have been extracted from `project`
     * (using ges_asset_extract (`project)`;)
     */
    save(timeline: Timeline, uri: string, formatter_asset: Asset | null, overwrite: boolean): boolean
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Project */
    vfunc_asset_added(asset: Asset): void
    vfunc_asset_loading(asset: Asset): void
    vfunc_asset_removed(asset: Asset): void
    vfunc_loaded(timeline: Timeline): boolean
    vfunc_loading(timeline: Timeline): void
    vfunc_loading_error(error: GLib.Error, id: string, extractable_type: GObject.Type): boolean
    vfunc_missing_uri(error: GLib.Error, wrong_asset: Asset): string
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Project */
    connect(sigName: "asset-added", callback: (($obj: Project, asset: Asset) => void)): number
    connect_after(sigName: "asset-added", callback: (($obj: Project, asset: Asset) => void)): number
    emit(sigName: "asset-added", asset: Asset): void
    connect(sigName: "asset-loading", callback: (($obj: Project, asset: Asset) => void)): number
    connect_after(sigName: "asset-loading", callback: (($obj: Project, asset: Asset) => void)): number
    emit(sigName: "asset-loading", asset: Asset): void
    connect(sigName: "asset-removed", callback: (($obj: Project, asset: Asset) => void)): number
    connect_after(sigName: "asset-removed", callback: (($obj: Project, asset: Asset) => void)): number
    emit(sigName: "asset-removed", asset: Asset): void
    connect(sigName: "error-loading", callback: (($obj: Project, timeline: Timeline, error: GLib.Error) => void)): number
    connect_after(sigName: "error-loading", callback: (($obj: Project, timeline: Timeline, error: GLib.Error) => void)): number
    emit(sigName: "error-loading", timeline: Timeline, error: GLib.Error): void
    /**
     * Informs you that a #GESAsset could not be created. In case of
     * missing GStreamer plugins, the error will be set to #GST_CORE_ERROR
     * #GST_CORE_ERROR_MISSING_PLUGIN
     */
    connect(sigName: "error-loading-asset", callback: (($obj: Project, error: GLib.Error, id: string, extractable_type: GObject.Type) => void)): number
    connect_after(sigName: "error-loading-asset", callback: (($obj: Project, error: GLib.Error, id: string, extractable_type: GObject.Type) => void)): number
    emit(sigName: "error-loading-asset", error: GLib.Error, id: string, extractable_type: GObject.Type): void
    connect(sigName: "loaded", callback: (($obj: Project, timeline: Timeline) => void)): number
    connect_after(sigName: "loaded", callback: (($obj: Project, timeline: Timeline) => void)): number
    emit(sigName: "loaded", timeline: Timeline): void
    connect(sigName: "loading", callback: (($obj: Project, timeline: Timeline) => void)): number
    connect_after(sigName: "loading", callback: (($obj: Project, timeline: Timeline) => void)): number
    emit(sigName: "loading", timeline: Timeline): void
    /**
     * |[
     * static gchar
     * source_moved_cb (GESProject *project, GError *error, GESAsset *asset_with_error)
     * {
     *   return g_strdup ("file:///the/new/uri.ogg");
     * }
     * 
     * static int
     * main (int argc, gchar ** argv)
     * {
     *   GESTimeline *timeline;
     *   GESProject *project = ges_project_new ("file:///some/uri.xges");
     * 
     *   g_signal_connect (project, "missing-uri", source_moved_cb, NULL);
     *   timeline = ges_asset_extract (GES_ASSET (project));
     * }
     * ```
     * 
     */
    connect(sigName: "missing-uri", callback: (($obj: Project, error: GLib.Error, wrong_asset: Asset) => string | null)): number
    connect_after(sigName: "missing-uri", callback: (($obj: Project, error: GLib.Error, wrong_asset: Asset) => string | null)): number
    emit(sigName: "missing-uri", error: GLib.Error, wrong_asset: Asset): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Project, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Project, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Project, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Project, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::proxy", callback: (($obj: Project, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: Project, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: Project, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: Project, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Project_ConstructProps)
    _init (config?: Project_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(uri?: string | null): Project
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface Source_ConstructProps extends TrackElement_ConstructProps {
}
class Source {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: Source, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: Source, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: Source, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: Source, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: Source, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: Source, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: Source, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: Source, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: Source, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Source, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Source, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Source, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: Source, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Source_ConstructProps)
    _init (config?: Source_ConstructProps): void
    static $gtype: GObject.Type
}
interface SourceClip_ConstructProps extends Clip_ConstructProps {
}
class SourceClip {
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.SourceClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: SourceClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: SourceClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: SourceClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: SourceClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: SourceClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: SourceClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: SourceClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: SourceClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: SourceClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: SourceClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: SourceClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: SourceClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration-limit", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: SourceClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SourceClip_ConstructProps)
    _init (config?: SourceClip_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new_time_overlay(): SourceClip
    static $gtype: GObject.Type
}
interface SourceClipAsset_ConstructProps extends ClipAsset_ConstructProps {
}
class SourceClipAsset {
    /* Properties of GES-1.0.GES.ClipAsset */
    /**
     * The formats supported by the asset.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GES-1.0.GES.ClipAsset */
    readonly parent: Asset
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.ClipAsset */
    /**
     * Converts the given frame number into a timestamp, using the "natural" frame
     * rate of the asset.
     * 
     * You can use this to reference a specific frame in a media file and use this
     * as, for example, the `in-point` or `max-duration` of a #GESClip.
     */
    get_frame_time(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets track types for which objects extracted from `self` can create #GESTrackElement
     */
    get_supported_formats(): TrackType
    /**
     * Sets track types for which objects extracted from `self` can create #GESTrackElement
     */
    set_supported_formats(supportedformats: TrackType): void
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.SourceClipAsset */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.ClipAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: SourceClipAsset, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: SourceClipAsset, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::supported-formats", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: SourceClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SourceClipAsset_ConstructProps)
    _init (config?: SourceClipAsset_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface TestClip_ConstructProps extends SourceClip_ConstructProps {
    /* Constructor properties of GES-1.0.GES.TestClip */
    /**
     * The frequency to generate for audio track elements.
     */
    freq?: number
    /**
     * Whether the sound will be played or not.
     */
    mute?: boolean
    /**
     * The volume for the audio track elements.
     */
    volume?: number
    /**
     * Video pattern to display in video track elements.
     */
    vpattern?: VideoTestPattern
}
class TestClip {
    /* Properties of GES-1.0.GES.TestClip */
    /**
     * The frequency to generate for audio track elements.
     */
    freq: number
    /**
     * Whether the sound will be played or not.
     */
    mute: boolean
    /**
     * The volume for the audio track elements.
     */
    volume: number
    /**
     * Video pattern to display in video track elements.
     */
    vpattern: VideoTestPattern
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.SourceClip */
    readonly parent: Clip
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TestClip */
    /**
     * Get the frequency `self` generates.
     */
    get_frequency(): number
    /**
     * Get the volume of the test audio signal applied on `self`.
     */
    get_volume(): number
    /**
     * Get the #GESVideoTestPattern which is applied on `self`.
     */
    get_vpattern(): VideoTestPattern
    /**
     * Let you know if the audio track of `self` is muted or not.
     */
    is_muted(): boolean
    /**
     * Sets the frequency to generate. See audiotestsrc element.
     */
    set_frequency(freq: number): void
    /**
     * Sets whether the audio track of this clip is muted or not.
     */
    set_mute(mute: boolean): void
    /**
     * Sets the volume of the test audio signal.
     */
    set_volume(volume: number): void
    /**
     * Sets which video pattern to display on `self`.
     */
    set_vpattern(vpattern: VideoTestPattern): void
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TestClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.SourceClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: TestClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: TestClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: TestClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: TestClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TestClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TestClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TestClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TestClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TestClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TestClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TestClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TestClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::freq", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::freq", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mute", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mute", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::volume", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::volume", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vpattern", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vpattern", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::duration-limit", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TestClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TestClip_ConstructProps)
    _init (config?: TestClip_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TestClip
    static new_for_nick(nick: string): TestClip
    static $gtype: GObject.Type
}
interface TextOverlay_ConstructProps extends Operation_ConstructProps {
}
class TextOverlay {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TextOverlay */
    /**
     * Get the color used by `source`.
     */
    get_color(): number
    /**
     * Get the pango font description currently set on `source`.
     */
    get_font_desc(): string
    /**
     * Get the horizontal aligment used by `source`.
     */
    get_halignment(): TextHAlign
    /**
     * Get the text currently set on `source`.
     */
    get_text(): string
    /**
     * Get the vertical aligment used by `source`.
     */
    get_valignment(): TextVAlign
    /**
     * Get the horizontal position used by `source`.
     */
    get_xpos(): number
    /**
     * Get the vertical position used by `source`.
     */
    get_ypos(): number
    /**
     * Sets the color of the text.
     */
    set_color(color: number): void
    /**
     * Sets the pango font description of the text this track element
     * will render.
     */
    set_font_desc(font_desc: string): void
    /**
     * Sets the horizontal aligment of the text.
     */
    set_halignment(halign: TextHAlign): void
    /**
     * Sets the text this track element will render.
     */
    set_text(text: string): void
    /**
     * Sets the vertical aligment of the text.
     */
    set_valignment(valign: TextVAlign): void
    /**
     * Sets the horizontal position of the text.
     */
    set_xpos(position: number): void
    /**
     * Sets the vertical position of the text.
     */
    set_ypos(position: number): void
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TextOverlay */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Operation */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: TextOverlay, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: TextOverlay, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: TextOverlay, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: TextOverlay, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TextOverlay, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TextOverlay, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TextOverlay, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TextOverlay, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TextOverlay, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TextOverlay, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TextOverlay, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TextOverlay, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TextOverlay, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TextOverlay_ConstructProps)
    _init (config?: TextOverlay_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TextOverlay
    static $gtype: GObject.Type
}
interface TextOverlayClip_ConstructProps extends OverlayClip_ConstructProps {
    /* Constructor properties of GES-1.0.GES.TextOverlayClip */
    /**
     * The color of the text
     */
    color?: number
    /**
     * Pango font description string
     */
    font_desc?: string
    /**
     * Horizontal alignment of the text
     */
    halignment?: TextHAlign
    /**
     * The text to diplay
     */
    text?: string
    /**
     * Vertical alignent of the text
     */
    valignment?: TextVAlign
    /**
     * The horizontal position of the text
     */
    xpos?: number
    /**
     * The vertical position of the text
     */
    ypos?: number
}
class TextOverlayClip {
    /* Properties of GES-1.0.GES.TextOverlayClip */
    /**
     * The color of the text
     */
    color: number
    /**
     * Pango font description string
     */
    font_desc: string
    /**
     * Horizontal alignment of the text
     */
    halignment: TextHAlign
    /**
     * The text to diplay
     */
    text: string
    /**
     * Vertical alignent of the text
     */
    valignment: TextVAlign
    /**
     * The horizontal position of the text
     */
    xpos: number
    /**
     * The vertical position of the text
     */
    ypos: number
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TextOverlayClip */
    /**
     * Get the color used by `source`.
     */
    get_color(): number
    /**
     * Get the pango font description used by `self`.
     */
    get_font_desc(): string
    /**
     * Get the horizontal aligment used by `self`.
     */
    get_halignment(): TextHAlign
    /**
     * Get the text currently set on `self`.
     */
    get_text(): string
    /**
     * Get the vertical aligment used by `self`.
     */
    get_valignment(): TextVAlign
    /**
     * Get the horizontal position used by `source`.
     */
    get_xpos(): number
    /**
     * Get the vertical position used by `source`.
     */
    get_ypos(): number
    /**
     * Sets the color of the text.
     */
    set_color(color: number): void
    /**
     * Sets the pango font description of the text
     */
    set_font_desc(font_desc: string): void
    /**
     * Sets the horizontal aligment of the text.
     */
    set_halign(halign: TextHAlign): void
    /**
     * Sets the text this clip will render.
     */
    set_text(text: string): void
    /**
     * Sets the vertical aligment of the text.
     */
    set_valign(valign: TextVAlign): void
    /**
     * Sets the horizontal position of the text.
     */
    set_xpos(position: number): void
    /**
     * Sets the vertical position of the text.
     */
    set_ypos(position: number): void
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TextOverlayClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.OverlayClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.OperationClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: TextOverlayClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: TextOverlayClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: TextOverlayClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: TextOverlayClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TextOverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TextOverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TextOverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TextOverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TextOverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TextOverlayClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TextOverlayClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TextOverlayClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::color", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::color", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::font-desc", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-desc", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::halignment", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::halignment", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::text", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::valignment", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::valignment", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::xpos", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::xpos", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ypos", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ypos", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::duration-limit", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TextOverlayClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TextOverlayClip_ConstructProps)
    _init (config?: TextOverlayClip_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TextOverlayClip
    static $gtype: GObject.Type
}
interface Timeline_ConstructProps extends Gst.Bin_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Timeline */
    /**
     * Whether to automatically create a transition whenever two
     * #GESSource-s overlap in a track of the timeline. See
     * #GESLayer:auto-transition if you want this to only happen in some
     * layers.
     */
    auto_transition?: boolean
    /**
     * The distance (in nanoseconds) at which a #GESTimelineElement being
     * moved within the timeline should snap one of its #GESSource-s with
     * another #GESSource-s edge. See #GESEditMode for which edges can
     * snap during an edit. 0 means no snapping.
     */
    snapping_distance?: number
}
class Timeline {
    /* Properties of GES-1.0.GES.Timeline */
    /**
     * Whether to automatically create a transition whenever two
     * #GESSource-s overlap in a track of the timeline. See
     * #GESLayer:auto-transition if you want this to only happen in some
     * layers.
     */
    auto_transition: boolean
    /**
     * The current duration (in nanoseconds) of the timeline. A timeline
     * 'starts' at time 0, so this is the maximum end time of all of its
     * #GESTimelineElement-s.
     */
    readonly duration: number
    /**
     * The distance (in nanoseconds) at which a #GESTimelineElement being
     * moved within the timeline should snap one of its #GESSource-s with
     * another #GESSource-s edge. See #GESEditMode for which edges can
     * snap during an edit. 0 means no snapping.
     */
    snapping_distance: number
    /* Properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward: boolean
    /* Fields of Gst-1.0.Gst.Bin */
    readonly element: Gst.Element
    /**
     * the number of children in this bin
     */
    readonly numchildren: number
    /**
     * the list of children in this bin
     */
    readonly children: Gst.Element[]
    /**
     * updated whenever `children` changes
     */
    readonly children_cookie: number
    /**
     * internal bus for handling child messages
     */
    readonly child_bus: Gst.Bus
    /**
     * queued and cached messages
     */
    readonly messages: Gst.Message[]
    /**
     * the bin is currently calculating its state
     */
    readonly polling: boolean
    /**
     * the bin needs to recalculate its state (deprecated)
     */
    readonly state_dirty: boolean
    /**
     * the bin needs to select a new clock
     */
    readonly clock_dirty: boolean
    /**
     * the last clock selected
     */
    readonly provided_clock: Gst.Clock
    /**
     * the element that provided `provided_clock`
     */
    readonly clock_provider: Gst.Element
    /* Fields of Gst-1.0.Gst.Element */
    readonly object: Gst.Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    readonly state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    readonly state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    readonly state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    readonly target_state: Gst.State
    /**
     * the current state of an element
     */
    readonly current_state: Gst.State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    readonly next_state: Gst.State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    readonly pending_state: Gst.State
    /**
     * the last return value of an element state change
     */
    readonly last_return: Gst.StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    readonly bus: Gst.Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    readonly clock: Gst.Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    readonly base_time: Gst.ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    readonly start_time: Gst.ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    readonly numpads: number
    /**
     * list of pads
     */
    readonly pads: Gst.Pad[]
    /**
     * number of source pads of the element.
     */
    readonly numsrcpads: number
    /**
     * list of source pads
     */
    readonly srcpads: Gst.Pad[]
    /**
     * number of sink pads of the element.
     */
    readonly numsinkpads: number
    /**
     * list of sink pads
     */
    readonly sinkpads: Gst.Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    readonly pads_cookie: number
    /**
     * list of contexts
     */
    readonly contexts: Gst.Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    readonly lock: GLib.Mutex
    /**
     * The name of the object
     */
    readonly name: string
    /**
     * this object's parent, weak ref
     */
    readonly parent: Gst.Object
    /**
     * flags for this object
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Timeline */
    /**
     * Add a layer to the timeline.
     * 
     * If the layer contains #GESClip-s, then this may trigger the creation of
     * their core track element children for the timeline's tracks, and the
     * placement of the clip's children in the tracks of the timeline using
     * #GESTimeline::select-tracks-for-object. Some errors may occur if this
     * would break one of the configuration rules of the timeline in one of
     * its tracks. In such cases, some track elements would fail to be added
     * to their tracks, but this method would still return %TRUE. As such, it
     * is advised that you only add clips to layers that already part of a
     * timeline. In such situations, ges_layer_add_clip() is able to fail if
     * adding the clip would cause such an error.
     */
    add_layer(layer: Layer): boolean
    /**
     * Add a track to the timeline.
     * 
     * If the timeline already contains clips, then this may trigger the
     * creation of their core track element children for the track, and the
     * placement of the clip's children in the track of the timeline using
     * #GESTimeline::select-tracks-for-object. Some errors may occur if this
     * would break one of the configuration rules for the timeline in the
     * track. In such cases, some track elements would fail to be added to the
     * track, but this method would still return %TRUE. As such, it is advised
     * that you avoid adding tracks to timelines that already contain clips.
     */
    add_track(track: Track): boolean
    /**
     * Append a newly created layer to the timeline. The layer will
     * be added at the lowest #GESLayer:priority (numerically, the highest).
     */
    append_layer(): Layer
    /**
     * Commit all the pending changes of the clips contained in the
     * timeline.
     * 
     * When changes happen in a timeline, they are not immediately executed
     * internally, in a way that effects the output data of the timeline. You
     * should call this method when you are done with a set of changes and you
     * want them to be executed.
     * 
     * Any pending changes will be executed in the backend. The
     * #GESTimeline::commited signal will be emitted once this has completed.
     * You should not try to change the state of the timeline, seek it or add
     * tracks to it before receiving this signal. You can use
     * ges_timeline_commit_sync() if you do not want to perform other tasks in
     * the mean time.
     * 
     * Note that all the pending changes will automatically be executed when
     * the timeline goes from #GST_STATE_READY to #GST_STATE_PAUSED, which is
     * usually triggered by a corresponding state changes in a containing
     * #GESPipeline.
     */
    commit(): boolean
    /**
     * Commit all the pending changes of the clips contained in the
     * timeline and wait for the changes to complete.
     * 
     * See ges_timeline_commit().
     */
    commit_sync(): boolean
    /**
     * Freezes the timeline from being committed. This is usually needed while the
     * timeline is being rendered to ensure that not change to the timeline are
     * taken into account during that moment. Once the rendering is done, you
     * should call #ges_timeline_thaw_commit so that comiting becomes possible
     * again and any call to `commit()` that happened during the rendering is
     * actually taken into account.
     */
    freeze_commit(): void
    /**
     * Gets #GESTimeline:auto-transition for the timeline.
     */
    get_auto_transition(): boolean
    /**
     * Get the current #GESTimeline:duration of the timeline
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the element contained in the timeline with the given name.
     */
    get_element(name: string): TimelineElement | null
    /**
     * This method allows you to convert a timeline #GstClockTime into its
     * corresponding #GESFrameNumber in the timeline's output.
     */
    get_frame_at(timestamp: Gst.ClockTime): FrameNumber
    /**
     * This method allows you to convert a timeline output frame number into a
     * timeline #GstClockTime. For example, this time could be used to seek to a
     * particular frame in the timeline's output, or as the edit position for
     * an element within the timeline.
     */
    get_frame_time(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Get the list of #GESGroup-s present in the timeline.
     */
    get_groups(): Group[]
    /**
     * Retrieve the layer whose index in the timeline matches the given
     * priority.
     */
    get_layer(priority: number): Layer | null
    /**
     * Get the list of #GESLayer-s present in the timeline.
     */
    get_layers(): Layer[]
    /**
     * Search for the #GstPad corresponding to the given timeline's track.
     * You can link to this pad to receive the output data of the given track.
     */
    get_pad_for_track(track: Track): Gst.Pad | null
    /**
     * Gets the #GESTimeline:snapping-distance for the timeline.
     */
    get_snapping_distance(): Gst.ClockTime
    /**
     * Search for the #GESTrack corresponding to the given timeline's pad.
     */
    get_track_for_pad(pad: Gst.Pad): Track | null
    /**
     * Get the list of #GESTrack-s used by the timeline.
     */
    get_tracks(): Track[]
    /**
     * Check whether the timeline is empty or not.
     */
    is_empty(): boolean
    /**
     * Loads the contents of URI into the timeline.
     */
    load_from_uri(uri: string): boolean
    /**
     * Moves a layer within the timeline to the index given by
     * `new_layer_priority`.
     * An index of 0 corresponds to the layer with the highest priority in a
     * timeline. If `new_layer_priority` is greater than the number of layers
     * present in the timeline, it will become the lowest priority layer.
     */
    move_layer(layer: Layer, new_layer_priority: number): boolean
    /**
     * Paste an element inside the timeline. `element` **must** be the return of
     * ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting. `element` itself is not
     * placed in the timeline, instead a new element is created, alike to the
     * originally copied element. Note that the originally copied element must
     * also lie within `timeline,` at both the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_element_paste().
     */
    paste_element(element: TimelineElement, position: Gst.ClockTime, layer_priority: number): TimelineElement | null
    /**
     * Removes a layer from the timeline.
     */
    remove_layer(layer: Layer): boolean
    /**
     * Remove a track from the timeline.
     */
    remove_track(track: Track): boolean
    /**
     * Saves the timeline to the given location. If `formatter_asset` is %NULL,
     * the method will attempt to save in the same format the timeline was
     * loaded from, before defaulting to the formatter with highest rank.
     */
    save_to_uri(uri: string, formatter_asset: Asset | null, overwrite: boolean): boolean
    /**
     * Sets #GESTimeline:auto-transition for the timeline. This will also set
     * the corresponding #GESLayer:auto-transition for all of the timeline's
     * layers to the same value. See ges_layer_set_auto_transition() if you
     * wish to set the layer's #GESLayer:auto-transition individually.
     */
    set_auto_transition(auto_transition: boolean): void
    /**
     * Sets #GESTimeline:snapping-distance for the timeline. This new value
     * will only effect future snappings and will not be used to snap the
     * current element positions within the timeline.
     */
    set_snapping_distance(snapping_distance: Gst.ClockTime): void
    /**
     * Thaw the timeline so that comiting becomes possible
     * again and any call to `commit()` that happened during the rendering is
     * actually taken into account.
     */
    thaw_commit(): void
    /* Methods of Gst-1.0.Gst.Bin */
    /**
     * Adds the given element to the bin.  Sets the element's parent, and thus
     * takes ownership of the element. An element can only be added to one bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is added to the bin.
     * 
     * > When you add an element to an already-running pipeline, you will have to
     * > take care to set the state of the newly-added element to the desired
     * > state (usually PLAYING or PAUSED, same you set the pipeline to originally)
     * > with gst_element_set_state(), or use gst_element_sync_state_with_parent().
     * > The bin or pipeline will not take care of this for you.
     */
    add(element: Gst.Element): boolean
    /**
     * Recursively looks for elements with an unlinked pad of the given
     * direction within the specified bin and returns an unlinked pad
     * if one is found, or %NULL otherwise. If a pad is found, the caller
     * owns a reference to it and should use gst_object_unref() on the
     * pad when it is not needed any longer.
     */
    find_unlinked_pad(direction: Gst.PadDirection): Gst.Pad | null
    /**
     * Looks for an element inside the bin that implements the given
     * interface. If such an element is found, it returns the element.
     * You can cast this element to the given interface afterwards.  If you want
     * all elements that implement the interface, use
     * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
     */
    get_by_interface(iface: GObject.Type): Gst.Element | null
    /**
     * Gets the element with the given name from a bin. This
     * function recurses into child bins.
     */
    get_by_name(name: string): Gst.Element | null
    /**
     * Gets the element with the given name from this bin. If the
     * element is not found, a recursion is performed on the parent bin.
     */
    get_by_name_recurse_up(name: string): Gst.Element | null
    get_suppressed_flags(): Gst.ElementFlags
    /**
     * Looks for all elements inside the bin with the given element factory name.
     * The function recurses inside child bins. The iterator will yield a series of
     * #GstElement.
     */
    iterate_all_by_element_factory_name(factory_name: string): Gst.Iterator | null
    /**
     * Looks for all elements inside the bin that implements the given
     * interface. You can safely cast all returned elements to the given interface.
     * The function recurses inside child bins. The iterator will yield a series
     * of #GstElement.
     */
    iterate_all_by_interface(iface: GObject.Type): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     */
    iterate_elements(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     * This iterator recurses into GstBin children.
     */
    iterate_recurse(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SINK flag set.
     */
    iterate_sinks(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin in topologically
     * sorted order. This means that the elements are returned from
     * the most downstream elements (sinks) to the sources.
     * 
     * This function is used internally to perform the state changes
     * of the bin elements and for clock selection.
     */
    iterate_sorted(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SOURCE flag set.
     */
    iterate_sources(): Gst.Iterator | null
    /**
     * Queries `bin` for the current latency and reconfigures this latency on all the
     * elements using a LATENCY event.
     * 
     * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
     * is posted on the bus.
     * 
     * This function simply emits the #GstBin::do-latency signal so any custom latency
     * calculations will be performed.
     */
    recalculate_latency(): boolean
    /**
     * Removes the element from the bin, unparenting it as well.
     * Unparenting the element means that the element will be dereferenced,
     * so if the bin holds the only reference to the element, the element
     * will be freed in the process of removing it from the bin.  If you
     * want the element to still exist after removing, you need to call
     * gst_object_ref() before removing it from the bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is removed from the bin.
     */
    remove(element: Gst.Element): boolean
    /**
     * Suppresses the given flags on the bin. #GstElementFlags of a
     * child element are propagated when it is added to the bin.
     * When suppressed flags are set, those specified flags will
     * not be propagated to the bin.
     */
    set_suppressed_flags(flags: Gst.ElementFlags): void
    /**
     * Synchronizes the state of every child of `bin` with the state
     * of `bin`. See also gst_element_sync_state_with_parent().
     */
    sync_children_states(): boolean
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     */
    add_pad(pad: Gst.Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     */
    call_async(func: Gst.ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     */
    continue_state(ret: Gst.StateChangeReturn): Gst.StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     */
    foreach_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_sink_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_src_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): Gst.ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Gst.Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Gst.Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     */
    get_compatible_pad(pad: Gst.Pad, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     */
    get_compatible_pad_template(compattempl: Gst.PadTemplate): Gst.PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     */
    get_context(context_type: string): Gst.Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     */
    get_context_unlocked(context_type: string): Gst.Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Gst.Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): Gst.ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): Gst.ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): Gst.ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     */
    get_pad_template(name: string): Gst.PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): Gst.PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     */
    get_request_pad(name: string): Gst.Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): Gst.ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     */
    get_static_pad(name: string): Gst.Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Gst.Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link(dest: Gst.Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link_filtered(dest: Gst.Element, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     */
    link_pads(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     */
    link_pads_filtered(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     */
    link_pads_full(srcpadname: string | null, dest: Gst.Element, destpadname: string | null, flags: Gst.PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     */
    message_full(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     */
    message_full_with_details(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Gst.Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    query(query: Gst.Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     */
    query_convert(src_format: Gst.Format, src_val: number, dest_format: Gst.Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     */
    query_duration(format: Gst.Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     */
    query_position(format: Gst.Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     */
    release_request_pad(pad: Gst.Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     */
    remove_pad(pad: Gst.Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    request_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     */
    request_pad_simple(name: string): Gst.Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     */
    seek(rate: number, format: Gst.Format, flags: Gst.SeekFlags, start_type: Gst.SeekType, start: number, stop_type: Gst.SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     */
    seek_simple(format: Gst.Format, seek_flags: Gst.SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    send_event(event: Gst.Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     */
    set_base_time(time: Gst.ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    set_context(context: Gst.Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     */
    set_start_time(time: Gst.ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    set_state(state: Gst.State): Gst.StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     */
    unlink(dest: Gst.Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     */
    unlink_pads(srcpadname: string, dest: Gst.Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     */
    add_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): Gst.ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     */
    get_g_value_array(property_name: string, timestamp: Gst.ClockTime, interval: Gst.ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Gst.Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     */
    get_value(property_name: string, timestamp: Gst.ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_as_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     */
    has_as_parent(parent: Gst.Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Gst.Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     */
    remove_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     */
    set_control_rate(control_rate: Gst.ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     */
    set_parent(parent: Gst.Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): Gst.ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     */
    sync_values(timestamp: Gst.ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gst-1.0.Gst.ChildProxy */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    get_children_count(): number
    /**
     * Gets a single property using the GstChildProxy mechanism.
     * You are responsible for freeing it by calling g_value_unset()
     */
    get_property(name: string): /* value */ any
    /**
     * Looks up which object and #GParamSpec would be effected by the given `name`.
     */
    lookup(name: string): [ /* returnType */ boolean, /* target */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Sets a single property using the GstChildProxy mechanism.
     */
    set_property(name: string, value: any): void
    /* Virtual methods of GES-1.0.GES.Timeline */
    vfunc_group_added(group: Group): void
    vfunc_layer_added(layer: Layer): void
    vfunc_layer_removed(layer: Layer): void
    vfunc_track_added(track: Track): void
    vfunc_track_removed(track: Track): void
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /* Virtual methods of Gst-1.0.Gst.Bin */
    /**
     * Method to add an element to the bin.
     */
    vfunc_add_element(element: Gst.Element): boolean
    /**
     * Method called when an element was added somewhere in the bin hierarchy.
     */
    vfunc_deep_element_added(sub_bin: Gst.Bin, child: Gst.Element): void
    /**
     * Method called when an element was removed somewhere in the bin hierarchy.
     */
    vfunc_deep_element_removed(sub_bin: Gst.Bin, child: Gst.Element): void
    vfunc_do_latency(): boolean
    /**
     * Method called when an element was added to the bin.
     */
    vfunc_element_added(child: Gst.Element): void
    /**
     * Method called when an element was removed from the bin.
     */
    vfunc_element_removed(child: Gst.Element): void
    /**
     * Method to handle a message from the children.
     */
    vfunc_handle_message(message: Gst.Message): void
    /**
     * Method to remove an element from the bin.
     */
    vfunc_remove_element(element: Gst.Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    vfunc_change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    vfunc_get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Gst.Pad): void
    vfunc_pad_removed(pad: Gst.Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    vfunc_post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    vfunc_query(query: Gst.Query): boolean
    vfunc_release_pad(pad: Gst.Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    vfunc_request_new_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    vfunc_send_event(event: Gst.Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    vfunc_set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    vfunc_set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    vfunc_set_context(context: Gst.Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    vfunc_set_state(state: Gst.State): Gst.StateChangeReturn
    vfunc_state_changed(oldstate: Gst.State, newstate: Gst.State, pending: Gst.State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Gst.Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Timeline */
    /**
     * This signal will be emitted once the changes initiated by
     * ges_timeline_commit() have been executed in the backend. Use
     * ges_timeline_commit_sync() if you do not want to have to connect
     * to this signal.
     */
    connect(sigName: "commited", callback: (($obj: Timeline) => void)): number
    connect_after(sigName: "commited", callback: (($obj: Timeline) => void)): number
    emit(sigName: "commited"): void
    /**
     * Will be emitted after the group is added to to the timeline. This can
     * happen when grouping with `ges_container_group`, or by adding
     * containers to a newly created group.
     * 
     * Note that this should not be emitted whilst a timeline is being
     * loaded from its #GESProject asset. You should connect to the
     * project's #GESProject::loaded signal if you want to know which groups
     * were created for the timeline.
     */
    connect(sigName: "group-added", callback: (($obj: Timeline, group: Group) => void)): number
    connect_after(sigName: "group-added", callback: (($obj: Timeline, group: Group) => void)): number
    emit(sigName: "group-added", group: Group): void
    /**
     * Will be emitted after the group is removed from the timeline through
     * `ges_container_ungroup`. Note that `group` will no longer contain its
     * former children, these are held in `children`.
     * 
     * Note that if a group is emptied, then it will no longer belong to the
     * timeline, but this signal will **not** be emitted in such a case.
     */
    connect(sigName: "group-removed", callback: (($obj: Timeline, group: Group, children: Container[]) => void)): number
    connect_after(sigName: "group-removed", callback: (($obj: Timeline, group: Group, children: Container[]) => void)): number
    emit(sigName: "group-removed", group: Group, children: Container[]): void
    /**
     * Will be emitted after the layer is added to the timeline.
     * 
     * Note that this should not be emitted whilst a timeline is being
     * loaded from its #GESProject asset. You should connect to the
     * project's #GESProject::loaded signal if you want to know which
     * layers were created for the timeline.
     */
    connect(sigName: "layer-added", callback: (($obj: Timeline, layer: Layer) => void)): number
    connect_after(sigName: "layer-added", callback: (($obj: Timeline, layer: Layer) => void)): number
    emit(sigName: "layer-added", layer: Layer): void
    /**
     * Will be emitted after the layer is removed from the timeline.
     */
    connect(sigName: "layer-removed", callback: (($obj: Timeline, layer: Layer) => void)): number
    connect_after(sigName: "layer-removed", callback: (($obj: Timeline, layer: Layer) => void)): number
    emit(sigName: "layer-removed", layer: Layer): void
    /**
     * Simplified version of #GESTimeline::select-tracks-for-object which only
     * allows `track_element` to be added to a single #GESTrack.
     */
    connect(sigName: "select-element-track", callback: (($obj: Timeline, clip: Clip, track_element: TrackElement) => Track)): number
    connect_after(sigName: "select-element-track", callback: (($obj: Timeline, clip: Clip, track_element: TrackElement) => Track)): number
    emit(sigName: "select-element-track", clip: Clip, track_element: TrackElement): void
    /**
     * This will be emitted whenever the timeline needs to determine which
     * tracks a clip's children should be added to. The track element will
     * be added to each of the tracks given in the return. If a track
     * element is selected to go into multiple tracks, it will be copied
     * into the additional tracks, under the same clip. Note that the copy
     * will *not* keep its properties or state in sync with the original.
     * 
     * Connect to this signal once if you wish to control which element
     * should be added to which track. Doing so will overwrite the default
     * behaviour, which adds `track_element` to all tracks whose
     * #GESTrack:track-type includes the `track_element'`s
     * #GESTrackElement:track-type.
     * 
     * Note that under the default track selection, if a clip would produce
     * multiple core children of the same #GESTrackType, it will choose
     * one of the core children arbitrarily to place in the corresponding
     * tracks, with a warning for the other core children that are not
     * placed in the track. For example, this would happen for a #GESUriClip
     * that points to a file that contains multiple audio streams. If you
     * wish to choose the stream, you could connect to this signal, and use,
     * say, ges_uri_source_asset_get_stream_info() to choose which core
     * source to add.
     * 
     * When a clip is first added to a timeline, its core elements will
     * be created for the current tracks in the timeline if they have not
     * already been created. Then this will be emitted for each of these
     * core children to select which tracks, if any, they should be added
     * to. It will then be called for any non-core children in the clip.
     * 
     * In addition, if a new track element is ever added to a clip in a
     * timeline (and it is not already part of a track) this will be emitted
     * to select which tracks the element should be added to.
     * 
     * Finally, as a special case, if a track is added to the timeline
     * *after* it already contains clips, then it will request the creation
     * of the clips' core elements of the corresponding type, if they have
     * not already been created, and this signal will be emitted for each of
     * these newly created elements. In addition, this will also be released
     * for all other track elements in the timeline's clips that have not
     * yet been assigned a track. However, in this final case, the timeline
     * will only check whether the newly added track appears in the track
     * list. If it does appear, the track element will be added to the newly
     * added track. All other tracks in the returned track list are ignored.
     * 
     * In this latter case, track elements that are already part of a track
     * will not be asked if they want to be copied into the new track. If
     * you wish to do this, you can use ges_clip_add_child_to_track().
     * 
     * Note that the returned #GPtrArray should own a new reference to each
     * of its contained #GESTrack. The timeline will set the #GDestroyNotify
     * free function on the #GPtrArray to dereference the elements.
     */
    connect(sigName: "select-tracks-for-object", callback: (($obj: Timeline, clip: Clip, track_element: TrackElement) => Track[])): number
    connect_after(sigName: "select-tracks-for-object", callback: (($obj: Timeline, clip: Clip, track_element: TrackElement) => Track[])): number
    emit(sigName: "select-tracks-for-object", clip: Clip, track_element: TrackElement): void
    /**
     * Will be emitted whenever a snapping event ends. After a snap event
     * has started (see #GESTimeline::snapping-started), it can later end
     * because either another timeline edit has occurred (which may or may
     * not have created a new snapping event), or because the timeline has
     * been committed.
     */
    connect(sigName: "snapping-ended", callback: (($obj: Timeline, obj1: TrackElement, obj2: TrackElement, position: number) => void)): number
    connect_after(sigName: "snapping-ended", callback: (($obj: Timeline, obj1: TrackElement, obj2: TrackElement, position: number) => void)): number
    emit(sigName: "snapping-ended", obj1: TrackElement, obj2: TrackElement, position: number): void
    /**
     * Will be emitted whenever an element's movement invokes a snapping
     * event during an edit (usually of one of its ancestors) because its
     * start or end point lies within the #GESTimeline:snapping-distance of
     * another element's start or end point.
     * 
     * See #GESEditMode to see what can snap during an edit.
     * 
     * Note that only up to one snapping-started signal will be emitted per
     * element edit within a timeline.
     */
    connect(sigName: "snapping-started", callback: (($obj: Timeline, obj1: TrackElement, obj2: TrackElement, position: number) => void)): number
    connect_after(sigName: "snapping-started", callback: (($obj: Timeline, obj1: TrackElement, obj2: TrackElement, position: number) => void)): number
    emit(sigName: "snapping-started", obj1: TrackElement, obj2: TrackElement, position: number): void
    /**
     * Will be emitted after the track is added to the timeline.
     * 
     * Note that this should not be emitted whilst a timeline is being
     * loaded from its #GESProject asset. You should connect to the
     * project's #GESProject::loaded signal if you want to know which
     * tracks were created for the timeline.
     */
    connect(sigName: "track-added", callback: (($obj: Timeline, track: Track) => void)): number
    connect_after(sigName: "track-added", callback: (($obj: Timeline, track: Track) => void)): number
    emit(sigName: "track-added", track: Track): void
    /**
     * Will be emitted after the track is removed from the timeline.
     */
    connect(sigName: "track-removed", callback: (($obj: Timeline, track: Track) => void)): number
    connect_after(sigName: "track-removed", callback: (($obj: Timeline, track: Track) => void)): number
    emit(sigName: "track-removed", track: Track): void
    /* Signals of Gst-1.0.Gst.Bin */
    /**
     * Will be emitted after the element was added to `sub_bin`.
     */
    connect(sigName: "deep-element-added", callback: (($obj: Timeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-added", callback: (($obj: Timeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-added", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from `sub_bin`.
     */
    connect(sigName: "deep-element-removed", callback: (($obj: Timeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-removed", callback: (($obj: Timeline, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-removed", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted when the bin needs to perform latency calculations. This
     * signal is only emitted for toplevel bins or when #GstBin:async-handling is
     * enabled.
     * 
     * Only one signal handler is invoked. If no signals are connected, the
     * default handler is invoked, which will query and distribute the lowest
     * possible latency to all sinks.
     * 
     * Connect to this signal if the default latency calculations are not
     * sufficient, like when you need different latencies for different sinks in
     * the same pipeline.
     */
    connect(sigName: "do-latency", callback: (($obj: Timeline) => boolean)): number
    connect_after(sigName: "do-latency", callback: (($obj: Timeline) => boolean)): number
    emit(sigName: "do-latency"): void
    /**
     * Will be emitted after the element was added to the bin.
     */
    connect(sigName: "element-added", callback: (($obj: Timeline, element: Gst.Element) => void)): number
    connect_after(sigName: "element-added", callback: (($obj: Timeline, element: Gst.Element) => void)): number
    emit(sigName: "element-added", element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from the bin.
     */
    connect(sigName: "element-removed", callback: (($obj: Timeline, element: Gst.Element) => void)): number
    connect_after(sigName: "element-removed", callback: (($obj: Timeline, element: Gst.Element) => void)): number
    emit(sigName: "element-removed", element: Gst.Element): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: Timeline) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: Timeline) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     */
    connect(sigName: "pad-added", callback: (($obj: Timeline, new_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: Timeline, new_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Gst.Pad): void
    /**
     * a #GstPad has been removed from the element
     */
    connect(sigName: "pad-removed", callback: (($obj: Timeline, old_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: Timeline, old_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Gst.Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     */
    connect(sigName: "deep-notify", callback: (($obj: Timeline, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Timeline, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Gst.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Timeline, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Timeline, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    /* Signals of Gst-1.0.Gst.ChildProxy */
    /**
     * Will be emitted after the `object` was added to the `child_proxy`.
     */
    connect(sigName: "child-added", callback: (($obj: Timeline, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: Timeline, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-added", object: GObject.Object, name: string): void
    /**
     * Will be emitted after the `object` was removed from the `child_proxy`.
     */
    connect(sigName: "child-removed", callback: (($obj: Timeline, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: Timeline, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-removed", object: GObject.Object, name: string): void
    connect(sigName: "notify::auto-transition", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-transition", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::duration", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::snapping-distance", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::snapping-distance", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::async-handling", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::async-handling", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::message-forward", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-forward", callback: (($obj: Timeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Timeline_ConstructProps)
    _init (config?: Timeline_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Timeline
    /* Function overloads */
    static new(name?: string | null): Timeline
    static new_audio_video(): Timeline
    static new_from_uri(uri: string): Timeline
    static $gtype: GObject.Type
}
interface TimelineElement_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of GES-1.0.GES.TimelineElement */
    /**
     * The duration that the element is in effect for in the timeline (a
     * time difference in nanoseconds using the time coordinates of the
     * timeline). For example, for a source element, this would determine
     * for how long it should output its internal content for. For an
     * operation element, this would determine for how long its effect
     * should be applied to any source content.
     */
    duration?: number
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point?: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration?: number
    /**
     * The name of the element. This should be unique within its timeline.
     */
    name?: string
    /**
     * The parent container of the element.
     */
    parent?: TimelineElement
    /**
     * The priority of the element.
     */
    priority?: number
    /**
     * Whether the element should be serialized.
     */
    serialize?: boolean
    /**
     * The starting position of the element in the timeline (in nanoseconds
     * and in the time coordinates of the timeline). For example, for a
     * source element, this would determine the time at which it should
     * start outputting its internal content. For an operation element, this
     * would determine the time at which it should start applying its effect
     * to any source content.
     */
    start?: number
    /**
     * The timeline that the element lies within.
     */
    timeline?: Timeline
}
class TimelineElement {
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The duration that the element is in effect for in the timeline (a
     * time difference in nanoseconds using the time coordinates of the
     * timeline). For example, for a source element, this would determine
     * for how long it should output its internal content for. For an
     * operation element, this would determine for how long its effect
     * should be applied to any source content.
     */
    duration: number
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * The name of the element. This should be unique within its timeline.
     */
    name: string
    /**
     * The parent container of the element.
     */
    parent: TimelineElement
    /**
     * The priority of the element.
     */
    priority: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /**
     * The starting position of the element in the timeline (in nanoseconds
     * and in the time coordinates of the timeline). For example, for a
     * source element, this would determine the time at which it should
     * start outputting its internal content. For an operation element, this
     * would determine the time at which it should start applying its effect
     * to any source content.
     */
    start: number
    /**
     * The timeline that the element lies within.
     */
    timeline: Timeline
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TimelineElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TimelineElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TimelineElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TimelineElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TimelineElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TimelineElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TimelineElement, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TimelineElement, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::start", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::start", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::timeline", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeline", callback: (($obj: TimelineElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TimelineElement_ConstructProps)
    _init (config?: TimelineElement_ConstructProps): void
    static $gtype: GObject.Type
}
interface TitleClip_ConstructProps extends SourceClip_ConstructProps {
    /* Constructor properties of GES-1.0.GES.TitleClip */
    /**
     * The background of the text
     */
    background?: number
    /**
     * The color of the text
     */
    color?: number
    /**
     * Pango font description string
     */
    font_desc?: string
    /**
     * Horizontal alignment of the text
     */
    halignment?: TextHAlign
    /**
     * The text to diplay
     */
    text?: string
    /**
     * Vertical alignent of the text
     */
    valignment?: TextVAlign
    /**
     * The horizontal position of the text
     */
    xpos?: number
    /**
     * The vertical position of the text
     */
    ypos?: number
}
class TitleClip {
    /* Properties of GES-1.0.GES.TitleClip */
    /**
     * The background of the text
     */
    background: number
    /**
     * The color of the text
     */
    color: number
    /**
     * Pango font description string
     */
    font_desc: string
    /**
     * Horizontal alignment of the text
     */
    halignment: TextHAlign
    /**
     * The text to diplay
     */
    text: string
    /**
     * Vertical alignent of the text
     */
    valignment: TextVAlign
    /**
     * The horizontal position of the text
     */
    xpos: number
    /**
     * The vertical position of the text
     */
    ypos: number
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.SourceClip */
    readonly parent: Clip
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TitleClip */
    /**
     * Get the background used by `self`.
     */
    get_background_color(): number
    /**
     * Get the pango font description used by `self`.
     */
    get_font_desc(): string
    /**
     * Get the horizontal aligment used by `self`.
     */
    get_halignment(): TextHAlign
    /**
     * Get the text currently set on `self`.
     */
    get_text(): string
    /**
     * Get the color used by `self`.
     */
    get_text_color(): number
    /**
     * Get the vertical aligment used by `self`.
     */
    get_valignment(): TextVAlign
    /**
     * Get the horizontal position used by `self`.
     */
    get_xpos(): number
    /**
     * Get the vertical position used by `self`.
     */
    get_ypos(): number
    /**
     * Sets the background of the text.
     */
    set_background(background: number): void
    /**
     * Sets the color of the text.
     */
    set_color(color: number): void
    /**
     * Sets the pango font description of the text.
     */
    set_font_desc(font_desc: string): void
    /**
     * Sets the horizontal aligment of the text.
     */
    set_halignment(halign: TextHAlign): void
    /**
     * Sets the text this clip will render.
     */
    set_text(text: string): void
    /**
     * Sets the vertical aligment of the text.
     */
    set_valignment(valign: TextVAlign): void
    /**
     * Sets the horizontal position of the text.
     */
    set_xpos(position: number): void
    /**
     * Sets the vertical position of the text.
     */
    set_ypos(position: number): void
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TitleClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.SourceClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: TitleClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: TitleClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: TitleClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: TitleClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TitleClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TitleClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TitleClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TitleClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TitleClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TitleClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TitleClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TitleClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::background", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::color", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::color", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::font-desc", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-desc", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::halignment", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::halignment", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::text", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::valignment", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::valignment", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::xpos", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::xpos", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ypos", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ypos", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::duration-limit", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TitleClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TitleClip_ConstructProps)
    _init (config?: TitleClip_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TitleClip
    static $gtype: GObject.Type
}
interface TitleSource_ConstructProps extends VideoSource_ConstructProps {
}
class TitleSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TitleSource */
    /**
     * Get the background used by `source`.
     */
    get_background_color(): number
    /**
     * Get the pango font description used by `source`.
     */
    get_font_desc(): string
    /**
     * Get the horizontal aligment used by `source`.
     */
    get_halignment(): TextHAlign
    /**
     * Get the text currently set on the `source`.
     */
    get_text(): string
    /**
     * Get the color used by `source`.
     */
    get_text_color(): number
    /**
     * Get the vertical aligment used by `source`.
     */
    get_valignment(): TextVAlign
    /**
     * Get the horizontal position used by `source`.
     */
    get_xpos(): number
    /**
     * Get the vertical position used by `source`.
     */
    get_ypos(): number
    /**
     * Sets the color of the background
     */
    set_background_color(color: number): void
    /**
     * Set the pango font description this source will use to render
     * the text.
     */
    set_font_desc(font_desc: string): void
    /**
     * Sets the vertical aligment of the text.
     */
    set_halignment(halign: TextHAlign): void
    /**
     * Sets the text this track element will render.
     */
    set_text(text: string): void
    /**
     * Sets the color of the text.
     */
    set_text_color(color: number): void
    /**
     * Sets the vertical aligment of the text.
     */
    set_valignment(valign: TextVAlign): void
    /**
     * Sets the horizontal position of the text.
     */
    set_xpos(position: number): void
    /**
     * Sets the vertical position of the text.
     */
    set_ypos(position: number): void
    /* Methods of GES-1.0.GES.VideoSource */
    /**
     * Retrieves the natural size of the video stream. The natural size, is
     * the size at which it will be displayed if no scaling is being applied.
     * 
     * NOTE: The sources take into account the potential video rotation applied
     * by the #videoflip element that is inside the source, effects applied on
     * the clip which potentially also rotate the element are not taken into
     * account.
     */
    get_natural_size(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TitleSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.VideoSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: TitleSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: TitleSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: TitleSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: TitleSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TitleSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TitleSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TitleSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TitleSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TitleSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TitleSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TitleSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TitleSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TitleSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TitleSource_ConstructProps)
    _init (config?: TitleSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface Track_ConstructProps extends Gst.Bin_ConstructProps {
    /* Constructor properties of GES-1.0.GES.Track */
    /**
     * The capabilities used to choose the output of the #GESTrack's
     * elements. Internally, this is used to select output streams when
     * several may be available, by determining whether its #GstPad is
     * compatible (see #NleObject:caps for #nlecomposition). As such,
     * this is used as a weaker indication of the desired output type of the
     * track, **before** the #GESTrack:restriction-caps is applied.
     * Therefore, this should be set to a *generic* superset of the
     * #GESTrack:restriction-caps, such as "video/x-raw(ANY)". In addition,
     * it should match with the track's #GESTrack:track-type.
     * 
     * Note that when you set this property, the #GstCapsFeatures of all its
     * #GstStructure-s will be automatically set to #GST_CAPS_FEATURES_ANY.
     * 
     * Once a track has been added to a #GESTimeline, you should not change
     * this.
     * 
     * Default value: #GST_CAPS_ANY.
     */
    caps?: Gst.Caps
    /**
     * The #nlecomposition:id of the underlying #nlecomposition.
     */
    id?: string
    /**
     * Whether the track should support the mixing of #GESLayer data, such
     * as composing the video data of each layer (when part of the video
     * data is transparent, the next layer will become visible) or adding
     * together the audio data. As such, for audio and video tracks, you'll
     * likely want to keep this set to %TRUE.
     */
    mixing?: boolean
    /**
     * The capabilities that specifies the final output format of the
     * #GESTrack. For example, for a video track, it would specify the
     * height, width, framerate and other properties of the stream.
     * 
     * You may change this property after the track has been added to a
     * #GESTimeline, but it must remain compatible with the track's
     * #GESTrack:caps.
     * 
     * Default value: #GST_CAPS_ANY.
     */
    restriction_caps?: Gst.Caps
    /**
     * The track type of the track. This controls the type of
     * #GESTrackElement-s that can be added to the track. This should
     * match with the track's #GESTrack:caps.
     * 
     * Once a track has been added to a #GESTimeline, you should not change
     * this.
     */
    track_type?: TrackType
}
class Track {
    /* Properties of GES-1.0.GES.Track */
    /**
     * Current duration of the track
     * 
     * Default value: O
     */
    readonly duration: number
    /**
     * The #nlecomposition:id of the underlying #nlecomposition.
     */
    id: string
    /**
     * Whether the track should support the mixing of #GESLayer data, such
     * as composing the video data of each layer (when part of the video
     * data is transparent, the next layer will become visible) or adding
     * together the audio data. As such, for audio and video tracks, you'll
     * likely want to keep this set to %TRUE.
     */
    mixing: boolean
    /**
     * The capabilities that specifies the final output format of the
     * #GESTrack. For example, for a video track, it would specify the
     * height, width, framerate and other properties of the stream.
     * 
     * You may change this property after the track has been added to a
     * #GESTimeline, but it must remain compatible with the track's
     * #GESTrack:caps.
     * 
     * Default value: #GST_CAPS_ANY.
     */
    restriction_caps: Gst.Caps
    /* Properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward: boolean
    /* Fields of Gst-1.0.Gst.Bin */
    readonly element: Gst.Element
    /**
     * the number of children in this bin
     */
    readonly numchildren: number
    /**
     * the list of children in this bin
     */
    readonly children: Gst.Element[]
    /**
     * updated whenever `children` changes
     */
    readonly children_cookie: number
    /**
     * internal bus for handling child messages
     */
    readonly child_bus: Gst.Bus
    /**
     * queued and cached messages
     */
    readonly messages: Gst.Message[]
    /**
     * the bin is currently calculating its state
     */
    readonly polling: boolean
    /**
     * the bin needs to recalculate its state (deprecated)
     */
    readonly state_dirty: boolean
    /**
     * the bin needs to select a new clock
     */
    readonly clock_dirty: boolean
    /**
     * the last clock selected
     */
    readonly provided_clock: Gst.Clock
    /**
     * the element that provided `provided_clock`
     */
    readonly clock_provider: Gst.Element
    /* Fields of Gst-1.0.Gst.Element */
    readonly object: Gst.Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    readonly state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    readonly state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    readonly state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    readonly target_state: Gst.State
    /**
     * the current state of an element
     */
    readonly current_state: Gst.State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    readonly next_state: Gst.State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    readonly pending_state: Gst.State
    /**
     * the last return value of an element state change
     */
    readonly last_return: Gst.StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    readonly bus: Gst.Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    readonly clock: Gst.Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    readonly base_time: Gst.ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    readonly start_time: Gst.ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    readonly numpads: number
    /**
     * list of pads
     */
    readonly pads: Gst.Pad[]
    /**
     * number of source pads of the element.
     */
    readonly numsrcpads: number
    /**
     * list of source pads
     */
    readonly srcpads: Gst.Pad[]
    /**
     * number of sink pads of the element.
     */
    readonly numsinkpads: number
    /**
     * list of sink pads
     */
    readonly sinkpads: Gst.Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    readonly pads_cookie: number
    /**
     * list of contexts
     */
    readonly contexts: Gst.Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    readonly lock: GLib.Mutex
    /**
     * The name of the object
     */
    readonly name: string
    /**
     * this object's parent, weak ref
     */
    readonly parent: Gst.Object
    /**
     * flags for this object
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Track */
    /**
     * See ges_track_add_element(), which also gives an error.
     */
    add_element(object: TrackElement): boolean
    /**
     * Adds the given track element to the track, which takes ownership of the
     * element.
     * 
     * Note that this can fail if it would break a configuration rule of the
     * track's #GESTimeline.
     * 
     * Note that a #GESTrackElement can only be added to one track.
     */
    add_element_full(object: TrackElement): boolean
    /**
     * Commits all the pending changes for the elements contained in the
     * track.
     * 
     * When changes are made to the timing or priority of elements within a
     * track, they are not directly executed for the underlying
     * #nlecomposition and its children. This method will finally execute
     * these changes so they are reflected in the data output of the track.
     * 
     * Any pending changes will be executed in the backend. The
     * #GESTimeline::commited signal will be emitted once this has completed.
     * 
     * Note that ges_timeline_commit() will call this method on all of its
     * tracks, so you are unlikely to need to use this directly.
     */
    commit(): boolean
    /**
     * Get the #GESTrack:caps of the track.
     */
    get_caps(): Gst.Caps
    /**
     * Gets the track elements contained in the track. The returned list is
     * sorted by the element's #GESTimelineElement:priority and
     * #GESTimelineElement:start.
     */
    get_elements(): TrackElement[]
    /**
     * Gets the #GESTrack:mixing of the track.
     */
    get_mixing(): boolean
    /**
     * Gets the #GESTrack:restriction-caps of the track.
     */
    get_restriction_caps(): Gst.Caps
    /**
     * Get the timeline this track belongs to.
     */
    get_timeline(): Timeline | null
    /**
     * See ges_track_remove_element_full(), which also returns an error.
     */
    remove_element(object: TrackElement): boolean
    /**
     * Removes the given track element from the track, which revokes
     * ownership of the element.
     */
    remove_element_full(object: TrackElement): boolean
    /**
     * Sets the #GESTrack:mixing for the track.
     */
    set_mixing(mixing: boolean): void
    /**
     * Sets the #GESTrack:restriction-caps for the track.
     * 
     * > **NOTE**: Restriction caps are **not** taken into account when
     * > using #GESPipeline:mode=#GES_PIPELINE_MODE_SMART_RENDER.
     */
    set_restriction_caps(caps: Gst.Caps): void
    /**
     * Informs the track that it belongs to the given timeline. Calling this
     * does not actually add the track to the timeline. For that, you should
     * use ges_timeline_add_track(), which will also take care of informing
     * the track that it belongs to the timeline. As such, there is no need
     * for you to call this method.
     */
    set_timeline(timeline: Timeline): void
    /**
     * Updates the #GESTrack:restriction-caps of the track using the fields
     * found in the given caps. Each of the #GstStructure-s in `caps` is
     * compared against the existing structure with the same index in the
     * current #GESTrack:restriction-caps. If there is no corresponding
     * existing structure at that index, then the new structure is simply
     * copied to that index. Otherwise, any fields in the new structure are
     * copied into the existing structure. This will replace existing values,
     * and may introduce new ones, but any fields 'missing' in the new
     * structure are left unchanged in the existing structure.
     * 
     * For example, if the existing #GESTrack:restriction-caps are
     * "video/x-raw, width=480, height=360", and the updating caps is
     * "video/x-raw, format=I420, width=500; video/x-bayer, width=400", then
     * the new #GESTrack:restriction-caps after calling this will be
     * "video/x-raw, width=500, height=360, format=I420; video/x-bayer,
     * width=400".
     */
    update_restriction_caps(caps: Gst.Caps): void
    /* Methods of Gst-1.0.Gst.Bin */
    /**
     * Adds the given element to the bin.  Sets the element's parent, and thus
     * takes ownership of the element. An element can only be added to one bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is added to the bin.
     * 
     * > When you add an element to an already-running pipeline, you will have to
     * > take care to set the state of the newly-added element to the desired
     * > state (usually PLAYING or PAUSED, same you set the pipeline to originally)
     * > with gst_element_set_state(), or use gst_element_sync_state_with_parent().
     * > The bin or pipeline will not take care of this for you.
     */
    add(element: Gst.Element): boolean
    /**
     * Recursively looks for elements with an unlinked pad of the given
     * direction within the specified bin and returns an unlinked pad
     * if one is found, or %NULL otherwise. If a pad is found, the caller
     * owns a reference to it and should use gst_object_unref() on the
     * pad when it is not needed any longer.
     */
    find_unlinked_pad(direction: Gst.PadDirection): Gst.Pad | null
    /**
     * Looks for an element inside the bin that implements the given
     * interface. If such an element is found, it returns the element.
     * You can cast this element to the given interface afterwards.  If you want
     * all elements that implement the interface, use
     * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
     */
    get_by_interface(iface: GObject.Type): Gst.Element | null
    /**
     * Gets the element with the given name from a bin. This
     * function recurses into child bins.
     */
    get_by_name(name: string): Gst.Element | null
    /**
     * Gets the element with the given name from this bin. If the
     * element is not found, a recursion is performed on the parent bin.
     */
    get_by_name_recurse_up(name: string): Gst.Element | null
    get_suppressed_flags(): Gst.ElementFlags
    /**
     * Looks for all elements inside the bin with the given element factory name.
     * The function recurses inside child bins. The iterator will yield a series of
     * #GstElement.
     */
    iterate_all_by_element_factory_name(factory_name: string): Gst.Iterator | null
    /**
     * Looks for all elements inside the bin that implements the given
     * interface. You can safely cast all returned elements to the given interface.
     * The function recurses inside child bins. The iterator will yield a series
     * of #GstElement.
     */
    iterate_all_by_interface(iface: GObject.Type): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     */
    iterate_elements(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     * This iterator recurses into GstBin children.
     */
    iterate_recurse(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SINK flag set.
     */
    iterate_sinks(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin in topologically
     * sorted order. This means that the elements are returned from
     * the most downstream elements (sinks) to the sources.
     * 
     * This function is used internally to perform the state changes
     * of the bin elements and for clock selection.
     */
    iterate_sorted(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SOURCE flag set.
     */
    iterate_sources(): Gst.Iterator | null
    /**
     * Queries `bin` for the current latency and reconfigures this latency on all the
     * elements using a LATENCY event.
     * 
     * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
     * is posted on the bus.
     * 
     * This function simply emits the #GstBin::do-latency signal so any custom latency
     * calculations will be performed.
     */
    recalculate_latency(): boolean
    /**
     * Removes the element from the bin, unparenting it as well.
     * Unparenting the element means that the element will be dereferenced,
     * so if the bin holds the only reference to the element, the element
     * will be freed in the process of removing it from the bin.  If you
     * want the element to still exist after removing, you need to call
     * gst_object_ref() before removing it from the bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is removed from the bin.
     */
    remove(element: Gst.Element): boolean
    /**
     * Suppresses the given flags on the bin. #GstElementFlags of a
     * child element are propagated when it is added to the bin.
     * When suppressed flags are set, those specified flags will
     * not be propagated to the bin.
     */
    set_suppressed_flags(flags: Gst.ElementFlags): void
    /**
     * Synchronizes the state of every child of `bin` with the state
     * of `bin`. See also gst_element_sync_state_with_parent().
     */
    sync_children_states(): boolean
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     */
    add_pad(pad: Gst.Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     */
    call_async(func: Gst.ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     */
    continue_state(ret: Gst.StateChangeReturn): Gst.StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     */
    foreach_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_sink_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_src_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): Gst.ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Gst.Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Gst.Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     */
    get_compatible_pad(pad: Gst.Pad, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     */
    get_compatible_pad_template(compattempl: Gst.PadTemplate): Gst.PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     */
    get_context(context_type: string): Gst.Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     */
    get_context_unlocked(context_type: string): Gst.Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Gst.Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): Gst.ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): Gst.ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): Gst.ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     */
    get_pad_template(name: string): Gst.PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): Gst.PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     */
    get_request_pad(name: string): Gst.Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): Gst.ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     */
    get_static_pad(name: string): Gst.Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Gst.Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link(dest: Gst.Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link_filtered(dest: Gst.Element, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     */
    link_pads(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     */
    link_pads_filtered(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     */
    link_pads_full(srcpadname: string | null, dest: Gst.Element, destpadname: string | null, flags: Gst.PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     */
    message_full(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     */
    message_full_with_details(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Gst.Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    query(query: Gst.Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     */
    query_convert(src_format: Gst.Format, src_val: number, dest_format: Gst.Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     */
    query_duration(format: Gst.Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     */
    query_position(format: Gst.Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     */
    release_request_pad(pad: Gst.Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     */
    remove_pad(pad: Gst.Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    request_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     */
    request_pad_simple(name: string): Gst.Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     */
    seek(rate: number, format: Gst.Format, flags: Gst.SeekFlags, start_type: Gst.SeekType, start: number, stop_type: Gst.SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     */
    seek_simple(format: Gst.Format, seek_flags: Gst.SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    send_event(event: Gst.Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     */
    set_base_time(time: Gst.ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    set_context(context: Gst.Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     */
    set_start_time(time: Gst.ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    set_state(state: Gst.State): Gst.StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     */
    unlink(dest: Gst.Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     */
    unlink_pads(srcpadname: string, dest: Gst.Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     */
    add_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): Gst.ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     */
    get_g_value_array(property_name: string, timestamp: Gst.ClockTime, interval: Gst.ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Gst.Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     */
    get_value(property_name: string, timestamp: Gst.ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_as_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     */
    has_as_parent(parent: Gst.Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Gst.Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     */
    remove_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     */
    set_control_rate(control_rate: Gst.ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     */
    set_parent(parent: Gst.Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): Gst.ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     */
    sync_values(timestamp: Gst.ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gst-1.0.Gst.ChildProxy */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    get_children_count(): number
    /**
     * Gets a single property using the GstChildProxy mechanism.
     * You are responsible for freeing it by calling g_value_unset()
     */
    get_property(name: string): /* value */ any
    /**
     * Looks up which object and #GParamSpec would be effected by the given `name`.
     */
    lookup(name: string): [ /* returnType */ boolean, /* target */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Sets a single property using the GstChildProxy mechanism.
     */
    set_property(name: string, value: any): void
    /* Virtual methods of GES-1.0.GES.Track */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /* Virtual methods of Gst-1.0.Gst.Bin */
    /**
     * Method to add an element to the bin.
     */
    vfunc_add_element(element: Gst.Element): boolean
    /**
     * Method called when an element was added somewhere in the bin hierarchy.
     */
    vfunc_deep_element_added(sub_bin: Gst.Bin, child: Gst.Element): void
    /**
     * Method called when an element was removed somewhere in the bin hierarchy.
     */
    vfunc_deep_element_removed(sub_bin: Gst.Bin, child: Gst.Element): void
    vfunc_do_latency(): boolean
    /**
     * Method called when an element was added to the bin.
     */
    vfunc_element_added(child: Gst.Element): void
    /**
     * Method called when an element was removed from the bin.
     */
    vfunc_element_removed(child: Gst.Element): void
    /**
     * Method to handle a message from the children.
     */
    vfunc_handle_message(message: Gst.Message): void
    /**
     * Method to remove an element from the bin.
     */
    vfunc_remove_element(element: Gst.Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    vfunc_change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    vfunc_get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Gst.Pad): void
    vfunc_pad_removed(pad: Gst.Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    vfunc_post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    vfunc_query(query: Gst.Query): boolean
    vfunc_release_pad(pad: Gst.Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    vfunc_request_new_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    vfunc_send_event(event: Gst.Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    vfunc_set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    vfunc_set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    vfunc_set_context(context: Gst.Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    vfunc_set_state(state: Gst.State): Gst.StateChangeReturn
    vfunc_state_changed(oldstate: Gst.State, newstate: Gst.State, pending: Gst.State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Gst.Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Track */
    /**
     * This signal will be emitted once the changes initiated by
     * ges_track_commit() have been executed in the backend. In particular,
     * this will be emitted whenever the underlying #nlecomposition has been
     * committed (see #nlecomposition::commited).
     */
    connect(sigName: "commited", callback: (($obj: Track) => void)): number
    connect_after(sigName: "commited", callback: (($obj: Track) => void)): number
    emit(sigName: "commited"): void
    /**
     * Will be emitted after a track element is added to the track.
     */
    connect(sigName: "track-element-added", callback: (($obj: Track, effect: TrackElement) => void)): number
    connect_after(sigName: "track-element-added", callback: (($obj: Track, effect: TrackElement) => void)): number
    emit(sigName: "track-element-added", effect: TrackElement): void
    /**
     * Will be emitted after a track element is removed from the track.
     */
    connect(sigName: "track-element-removed", callback: (($obj: Track, effect: TrackElement) => void)): number
    connect_after(sigName: "track-element-removed", callback: (($obj: Track, effect: TrackElement) => void)): number
    emit(sigName: "track-element-removed", effect: TrackElement): void
    /* Signals of Gst-1.0.Gst.Bin */
    /**
     * Will be emitted after the element was added to `sub_bin`.
     */
    connect(sigName: "deep-element-added", callback: (($obj: Track, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-added", callback: (($obj: Track, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-added", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from `sub_bin`.
     */
    connect(sigName: "deep-element-removed", callback: (($obj: Track, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-removed", callback: (($obj: Track, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-removed", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted when the bin needs to perform latency calculations. This
     * signal is only emitted for toplevel bins or when #GstBin:async-handling is
     * enabled.
     * 
     * Only one signal handler is invoked. If no signals are connected, the
     * default handler is invoked, which will query and distribute the lowest
     * possible latency to all sinks.
     * 
     * Connect to this signal if the default latency calculations are not
     * sufficient, like when you need different latencies for different sinks in
     * the same pipeline.
     */
    connect(sigName: "do-latency", callback: (($obj: Track) => boolean)): number
    connect_after(sigName: "do-latency", callback: (($obj: Track) => boolean)): number
    emit(sigName: "do-latency"): void
    /**
     * Will be emitted after the element was added to the bin.
     */
    connect(sigName: "element-added", callback: (($obj: Track, element: Gst.Element) => void)): number
    connect_after(sigName: "element-added", callback: (($obj: Track, element: Gst.Element) => void)): number
    emit(sigName: "element-added", element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from the bin.
     */
    connect(sigName: "element-removed", callback: (($obj: Track, element: Gst.Element) => void)): number
    connect_after(sigName: "element-removed", callback: (($obj: Track, element: Gst.Element) => void)): number
    emit(sigName: "element-removed", element: Gst.Element): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: Track) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: Track) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     */
    connect(sigName: "pad-added", callback: (($obj: Track, new_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: Track, new_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Gst.Pad): void
    /**
     * a #GstPad has been removed from the element
     */
    connect(sigName: "pad-removed", callback: (($obj: Track, old_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: Track, old_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Gst.Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     */
    connect(sigName: "deep-notify", callback: (($obj: Track, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Track, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Gst.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Track, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Track, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    /* Signals of Gst-1.0.Gst.ChildProxy */
    /**
     * Will be emitted after the `object` was added to the `child_proxy`.
     */
    connect(sigName: "child-added", callback: (($obj: Track, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: Track, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-added", object: GObject.Object, name: string): void
    /**
     * Will be emitted after the `object` was removed from the `child_proxy`.
     */
    connect(sigName: "child-removed", callback: (($obj: Track, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: Track, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-removed", object: GObject.Object, name: string): void
    connect(sigName: "notify::duration", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mixing", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mixing", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::restriction-caps", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::restriction-caps", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::async-handling", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::async-handling", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::message-forward", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-forward", callback: (($obj: Track, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Track_ConstructProps)
    _init (config?: Track_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(type: TrackType, caps: Gst.Caps): Track
    /* Function overloads */
    static new(name?: string | null): Track
    static $gtype: GObject.Type
}
interface TrackElement_ConstructProps extends TimelineElement_ConstructProps {
    /* Constructor properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active?: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources?: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source?: boolean
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type?: TrackType
}
class TrackElement {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESTimelineElement:parent of the element
     */
    readonly parent: TimelineElement
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: TrackElement, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: TrackElement, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: TrackElement, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: TrackElement, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TrackElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TrackElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TrackElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TrackElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TrackElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TrackElement, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TrackElement, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TrackElement, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TrackElement, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TrackElement_ConstructProps)
    _init (config?: TrackElement_ConstructProps): void
    static $gtype: GObject.Type
}
interface TrackElementAsset_ConstructProps extends Asset_ConstructProps {
    /* Constructor properties of GES-1.0.GES.TrackElementAsset */
    track_type?: TrackType
}
class TrackElementAsset {
    /* Properties of GES-1.0.GES.TrackElementAsset */
    track_type: TrackType
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GES-1.0.GES.Asset */
    readonly parent: GObject.Object
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElementAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Get the GESAssetTrackType the #GESTrackElement extracted from `self`
     * should get into
     */
    get_track_type(): TrackType
    /**
     * Set the #GESTrackType the #GESTrackElement extracted from `self`
     * should get into
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.TrackElementAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TrackElementAsset, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TrackElementAsset, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::track-type", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: TrackElementAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TrackElementAsset_ConstructProps)
    _init (config?: TrackElementAsset_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface Transition_ConstructProps extends Operation_ConstructProps {
}
class Transition {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.Transition */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Operation */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: Transition, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: Transition, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: Transition, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: Transition, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: Transition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: Transition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: Transition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: Transition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: Transition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Transition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: Transition, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: Transition, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: Transition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Transition_ConstructProps)
    _init (config?: Transition_ConstructProps): void
    static $gtype: GObject.Type
}
interface TransitionClip_ConstructProps extends BaseTransitionClip_ConstructProps {
    /* Constructor properties of GES-1.0.GES.TransitionClip */
    /**
     * a #GESVideoStandardTransitionType representing the wipe to use
     */
    vtype?: VideoStandardTransitionType
}
class TransitionClip {
    /* Properties of GES-1.0.GES.TransitionClip */
    /**
     * a #GESVideoStandardTransitionType representing the wipe to use
     */
    vtype: VideoStandardTransitionType
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /**
     * The #GESTrackType-s that the clip supports, which it can create
     * #GESTrackElement-s for. Note that this can be a combination of
     * #GESTrackType flags to indicate support for several
     * #GESTrackElement:track-type elements.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.Clip */
    readonly parent: Container
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.TransitionClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.BaseTransitionClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.OperationClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: TransitionClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: TransitionClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: TransitionClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: TransitionClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: TransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: TransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: TransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: TransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: TransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TransitionClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: TransitionClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: TransitionClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::vtype", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vtype", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::duration-limit", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: TransitionClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TransitionClip_ConstructProps)
    _init (config?: TransitionClip_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(vtype: VideoStandardTransitionType): TransitionClip
    static new_for_nick(nick: string): TransitionClip
    static $gtype: GObject.Type
}
interface UriClip_ConstructProps extends SourceClip_ConstructProps {
    /* Constructor properties of GES-1.0.GES.UriClip */
    /**
     * Whether this uri clip represents a still image or not. This must be set
     * before create_track_elements is called.
     */
    is_image?: boolean
    /**
     * Whether the sound will be played or not.
     */
    mute?: boolean
    supported_formats?: TrackType
    /**
     * The location of the file/resource to use.
     */
    uri?: string
}
class UriClip {
    /* Properties of GES-1.0.GES.UriClip */
    /**
     * Whether this uri clip represents a still image or not. This must be set
     * before create_track_elements is called.
     */
    is_image: boolean
    /**
     * Whether the sound will be played or not.
     */
    mute: boolean
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.Clip */
    /**
     * The maximum #GESTimelineElement:duration that can be *currently* set
     * for the clip, taking into account the #GESTimelineElement:in-point,
     * #GESTimelineElement:max-duration, #GESTrackElement:active, and
     * #GESTrackElement:track properties of its children, as well as any
     * time effects. If there is no limit, this will be set to
     * #GST_CLOCK_TIME_NONE.
     * 
     * Note that whilst a clip has no children in any tracks, the limit will
     * be unknown, and similarly set to #GST_CLOCK_TIME_NONE.
     * 
     * If the duration-limit would ever go below the current
     * #GESTimelineElement:duration of the clip due to a change in the above
     * variables, its #GESTimelineElement:duration will be set to the new
     * limit.
     */
    readonly duration_limit: number
    /**
     * The layer this clip lies in.
     * 
     * If you want to connect to this property's #GObject::notify signal,
     * you should connect to it with g_signal_connect_after() since the
     * signal emission may be stopped internally.
     */
    readonly layer: Layer
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.SourceClip */
    readonly parent: Clip
    /* Fields of GES-1.0.GES.Container */
    /**
     * The list of
     * #GESTimelineElement-s controlled by this Container
     */
    readonly children: TimelineElement[]
    /**
     * The #GESContainer:height of `obj`
     */
    readonly height: number
    readonly children_control_mode: ChildrenControlMode
    readonly initiated_move: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.UriClip */
    /**
     * Get the location of the resource.
     */
    get_uri(): string
    /**
     * Lets you know if the audio track of `self` is muted or not.
     */
    is_muted(): boolean
    /**
     * Sets whether the clip is a still image or not.
     */
    set_is_image(is_image: boolean): void
    /**
     * Sets whether the audio track of this clip is muted or not.
     */
    set_mute(mute: boolean): void
    /* Methods of GES-1.0.GES.Clip */
    /**
     * Extracts a #GESTrackElement from an asset and adds it to the clip.
     * This can be used to add effects that derive from the asset to the
     * clip, but this method is not intended to be used to create the core
     * elements of the clip.
     */
    add_asset(asset: Asset): TrackElement | null
    /**
     * Adds the track element child of the clip to a specific track.
     * 
     * If the given child is already in another track, this will create a copy
     * of the child, add it to the clip, and add this copy to the track.
     * 
     * You should only call this whilst a clip is part of a #GESTimeline, and
     * for tracks that are in the same timeline.
     * 
     * This method is an alternative to using the
     * #GESTimeline::select-tracks-for-object signal, but can be used to
     * complement it when, say, you wish to copy a clip's children from one
     * track into a new one.
     * 
     * When the child is a core child, it must be added to a track that does
     * not already contain another core child of the same clip. If it is not a
     * core child (an additional effect), then it must be added to a track
     * that already contains one of the core children of the same clip.
     * 
     * This method can also fail if the adding the track element to the track
     * would break a configuration rule of the corresponding #GESTimeline,
     * such as causing three sources to overlap at a single time, or causing
     * a source to completely overlap another in the same track.
     */
    add_child_to_track(child: TrackElement, track: Track): TrackElement
    /**
     * Add a top effect to a clip at the given index.
     * 
     * Unlike using ges_container_add(), this allows you to set the index
     * in advance. It will also check that no error occurred during the track
     * selection for the effect.
     * 
     * Note, only subclasses of #GESClipClass that have
     * #GES_CLIP_CLASS_CAN_ADD_EFFECTS set to %TRUE (such as #GESSourceClip
     * and #GESBaseEffectClip) can have additional top effects added.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is added.
     */
    add_top_effect(effect: BaseEffect, index: number): boolean
    /**
     * Finds an element controlled by the clip. If `track` is given,
     * then only the track elements in `track` are searched for. If `type` is
     * given, then this function searches for a track element of the given
     * `type`.
     * 
     * Note, if multiple track elements in the clip match the given criteria,
     * this will return the element amongst them with the highest
     * #GESTimelineElement:priority (numerically, the smallest). See
     * ges_clip_find_track_elements() if you wish to find all such elements.
     */
    find_track_element(track: Track | null, type: GObject.Type): TrackElement | null
    /**
     * Finds the #GESTrackElement-s controlled by the clip that match the
     * given criteria. If `track` is given as %NULL and `track_type` is given as
     * #GES_TRACK_TYPE_UNKNOWN, then the search will match all elements in any
     * track, including those with no track, and of any
     * #GESTrackElement:track-type. Otherwise, if `track` is not %NULL, but
     * `track_type` is #GES_TRACK_TYPE_UNKNOWN, then only the track elements in
     * `track` are searched for. Otherwise, if `track_type` is not
     * #GES_TRACK_TYPE_UNKNOWN, but `track` is %NULL, then only the track
     * elements whose #GESTrackElement:track-type matches `track_type` are
     * searched for. Otherwise, when both are given, the track elements that
     * match **either** criteria are searched for. Therefore, if you wish to
     * only find elements in a specific track, you should give the track as
     * `track,` but you should not give the track's #GESTrack:track-type as
     * `track_type` because this would also select elements from other tracks
     * of the same type.
     * 
     * You may also give `type` to _further_ restrict the search to track
     * elements of the given `type`.
     */
    find_track_elements(track: Track | null, track_type: TrackType, type: GObject.Type): TrackElement[]
    /**
     * Gets the #GESClip:duration-limit of the clip.
     */
    get_duration_limit(): Gst.ClockTime
    /**
     * Convert the timeline time to an internal source time of the child.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `timeline_time` is above the #GESTimelineElement:start of `clip,`
     * this will return the internal time at which the content that appears at
     * `timeline_time` in the output of the timeline is created in `child`. For
     * example, if `timeline_time` corresponds to the current seek position,
     * this would let you know which part of a media file is being read.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * internal time may be beyond the current out-point of the child, or even
     * its #GESTimelineElement:max-duration.
     * 
     * If, instead, `timeline_time` is below the current
     * #GESTimelineElement:start of `clip,` this will return what you would
     * need to set the #GESTimelineElement:in-point of `child` to if you set
     * the #GESTimelineElement:start of `clip` to `timeline_time` and wanted
     * to keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what #GESTimelineElement:in-point would result from a
     * #GES_EDIT_MODE_TRIM to `timeline_time`.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the internal time at which the content that
     * appears at `timeline_time` in the timeline can be found in `child` if it
     * had indefinite extent in both directions. However, with non-linear time
     * effects this second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use for the
     * #GESTimelineElement:in-point or #GESTimelineElement:max-duration of the
     * child.
     * 
     * See ges_clip_get_timeline_time_from_internal_time(), which performs the
     * reverse.
     */
    get_internal_time_from_timeline_time(child: TrackElement, timeline_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Gets the #GESClip:layer of the clip.
     */
    get_layer(): Layer | null
    /**
     * Gets the #GESClip:supported-formats of the clip.
     */
    get_supported_formats(): TrackType
    /**
     * Convert the internal source time from the child to a timeline time.
     * This will take any time effects placed on the clip into account (see
     * #GESBaseEffect for what time effects are supported, and how to
     * declare them in GES).
     * 
     * When `internal_time` is above the #GESTimelineElement:in-point of
     * `child,` this will return the timeline time at which the internal
     * content found at `internal_time` appears in the output of the timeline's
     * track. For example, this would let you know where in the timeline a
     * particular scene in a media file would appear.
     * 
     * This will be done assuming the clip has an indefinite end, so the
     * timeline time may be beyond the end of the clip, or even breaking its
     * #GESClip:duration-limit.
     * 
     * If, instead, `internal_time` is below the current
     * #GESTimelineElement:in-point of `child,` this will return what you would
     * need to set the #GESTimelineElement:start of `clip` to if you set the
     * #GESTimelineElement:in-point of `child` to `internal_time` and wanted to
     * keep the content of `child` currently found at the current
     * #GESTimelineElement:start of `clip` at the same timeline position. If
     * this would be negative, the conversion fails. This is useful for
     * determining what position to use in a #GES_EDIT_MODE_TRIM if you wish
     * to trim to a specific point in the internal content, such as a
     * particular scene in a media file.
     * 
     * Note that whilst a clip has no time effects, this second return is
     * equivalent to finding the timeline time at which the content of `child`
     * at `internal_time` would be found in the timeline if it had indefinite
     * extent in both directions. However, with non-linear time effects this
     * second return will be more distinct.
     * 
     * In either case, the returned time would be appropriate to use in
     * ges_timeline_element_edit() for #GES_EDIT_MODE_TRIM, and similar, if
     * you wish to use a particular internal point as a reference. For
     * example, you could choose to end a clip at a certain internal
     * 'out-point', similar to the #GESTimelineElement:in-point, by
     * translating the desired end time into the timeline coordinates, and
     * using this position to trim the end of a clip.
     * 
     * See ges_clip_get_internal_time_from_timeline_time(), which performs the
     * reverse, or ges_clip_get_timeline_time_from_source_frame() which does
     * the same conversion, but using frame numbers.
     */
    get_timeline_time_from_internal_time(child: TrackElement, internal_time: Gst.ClockTime): Gst.ClockTime
    /**
     * Convert the source frame number to a timeline time. This acts the same
     * as ges_clip_get_timeline_time_from_internal_time() using the core
     * children of the clip and using the frame number to specify the internal
     * position, rather than a timestamp.
     * 
     * The returned timeline time can be used to seek or edit to a specific
     * frame.
     * 
     * Note that you can get the frame timestamp of a particular clip asset
     * with ges_clip_asset_get_frame_time().
     */
    get_timeline_time_from_source_frame(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Gets the internal index of an effect in the clip. The index of effects
     * in a clip will run from 0 to n-1, where n is the total number of
     * effects. If two effects share the same #GESTrackElement:track, the
     * effect with the numerically lower index will be applied to the source
     * data **after** the other effect, i.e. output data will always flow from
     * a higher index effect to a lower index effect.
     */
    get_top_effect_index(effect: BaseEffect): number
    get_top_effect_position(effect: BaseEffect): number
    /**
     * Gets the #GESBaseEffect-s that have been added to the clip. The
     * returned list is ordered by their internal index in the clip. See
     * ges_clip_get_top_effect_index().
     */
    get_top_effects(): TrackElement[]
    /**
     * See ges_clip_move_to_layer_full(), which also gives an error.
     */
    move_to_layer(layer: Layer): boolean
    /**
     * Moves a clip to a new layer. If the clip already exists in a layer, it
     * is first removed from its current layer before being added to the new
     * layer.
     */
    move_to_layer_full(layer: Layer): boolean
    /**
     * Remove a top effect from the clip.
     * 
     * Note, if the effect is a time effect, this may be refused if the clip
     * would not be able to adapt itself once the effect is removed.
     */
    remove_top_effect(effect: BaseEffect): boolean
    /**
     * Sets the #GESClip:supported-formats of the clip. This should normally
     * only be called by subclasses, which should be responsible for updating
     * its value, rather than the user.
     */
    set_supported_formats(supportedformats: TrackType): void
    /**
     * See ges_clip_set_top_effect_index_full(), which also gives an error.
     */
    set_top_effect_index(effect: BaseEffect, newindex: number): boolean
    /**
     * Set the index of an effect within the clip. See
     * ges_clip_get_top_effect_index(). The new index must be an existing
     * index of the clip. The effect is moved to the new index, and the other
     * effects may be shifted in index accordingly to otherwise maintain the
     * ordering.
     */
    set_top_effect_index_full(effect: BaseEffect, newindex: number): boolean
    set_top_effect_priority(effect: BaseEffect, newpriority: number): boolean
    /**
     * See ges_clip_split_full(), which also gives an error.
     */
    split(position: number): Clip | null
    /**
     * Splits a clip at the given timeline position into two clips. The clip
     * must already have a #GESClip:layer.
     * 
     * The original clip's #GESTimelineElement:duration is reduced such that
     * its end point matches the split position. Then a new clip is created in
     * the same layer, whose #GESTimelineElement:start matches the split
     * position and #GESTimelineElement:duration will be set such that its end
     * point matches the old end point of the original clip. Thus, the two
     * clips together will occupy the same positions in the timeline as the
     * original clip did.
     * 
     * The children of the new clip will be new copies of the original clip's
     * children, so it will share the same sources and use the same
     * operations.
     * 
     * The new clip will also have its #GESTimelineElement:in-point set so
     * that any internal data will appear in the timeline at the same time.
     * Thus, when the timeline is played, the playback of data should
     * appear the same. This may be complicated by any additional
     * #GESEffect-s that have been placed on the original clip that depend on
     * the playback time or change the data consumption rate of sources. This
     * method will attempt to translate these effects such that the playback
     * appears the same. In such complex situations, you may get a better
     * result if you place the clip in a separate sub #GESProject, which only
     * contains this clip (and its effects), and in the original layer
     * create two neighbouring #GESUriClip-s that reference this sub-project,
     * but at a different #GESTimelineElement:in-point.
     */
    split_full(position: number): Clip | null
    /* Methods of GES-1.0.GES.Container */
    /**
     * Adds a timeline element to the container. The element will now be a
     * child of the container (and the container will be the
     * #GESTimelineElement:parent of the added element), which means that it
     * is now controlled by the container. This may change the properties of
     * the child or the container, depending on the subclass.
     * 
     * Additionally, the children properties of the newly added element will
     * be shared with the container, meaning they can also be read and set
     * using ges_timeline_element_get_child_property() and
     * ges_timeline_element_set_child_property() on the container.
     */
    add(child: TimelineElement): boolean
    /**
     * Edits the container within its timeline.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get the list of timeline elements contained in the container. If
     * `recursive` is %TRUE, and the container contains other containers as
     * children, then their children will be added to the list, in addition to
     * themselves, and so on.
     */
    get_children(recursive: boolean): TimelineElement[]
    /**
     * Removes a timeline element from the container. The element will no
     * longer be controlled by the container.
     */
    remove(child: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    ungroup(recursive: boolean): Container[]
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Get a list of children properties of the element, which is a list of
     * all the specifications passed to
     * ges_timeline_element_add_child_property().
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.UriClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.SourceClip */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Clip */
    vfunc_create_track_element(type: TrackType): TrackElement | null
    vfunc_create_track_elements(type: TrackType): TrackElement[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Container */
    vfunc_add_child(element: TimelineElement): boolean
    vfunc_child_added(element: TimelineElement): void
    vfunc_child_removed(element: TimelineElement): void
    /**
     * Edits the container within its timeline.
     */
    vfunc_edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    vfunc_remove_child(element: TimelineElement): boolean
    /**
     * Ungroups the container by splitting it into several containers
     * containing various children of the original. The rules for how the
     * container splits depends on the subclass. A #GESGroup will simply split
     * into its children. A #GESClip will split into one #GESClip per
     * #GESTrackType it overlaps with (so an audio-video clip will split into
     * an audio clip and a video clip), where each clip contains all the
     * #GESTrackElement-s from the original clip with a matching
     * #GESTrackElement:track-type.
     * 
     * If `recursive` is %TRUE, and the container contains other containers as
     * children, then they will also be ungrouped, and so on.
     */
    vfunc_ungroup(recursive: boolean): Container[]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Container */
    /**
     * Will be emitted after a child is added to the container. Usually,
     * you should connect with g_signal_connect_after() since the signal
     * may be stopped internally.
     */
    connect(sigName: "child-added", callback: (($obj: UriClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: UriClip, element: TimelineElement) => void)): number
    emit(sigName: "child-added", element: TimelineElement): void
    /**
     * Will be emitted after a child is removed from the container.
     */
    connect(sigName: "child-removed", callback: (($obj: UriClip, element: TimelineElement) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: UriClip, element: TimelineElement) => void)): number
    emit(sigName: "child-removed", element: TimelineElement): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: UriClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: UriClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: UriClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: UriClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: UriClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: UriClip, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: UriClip, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: UriClip, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::is-image", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-image", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mute", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mute", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::duration-limit", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration-limit", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::layer", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layer", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: UriClip, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: UriClip_ConstructProps)
    _init (config?: UriClip_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(uri: string): UriClip
    static $gtype: GObject.Type
}
interface UriClipAsset_ConstructProps extends SourceClipAsset_ConstructProps {
    /* Constructor properties of GES-1.0.GES.UriClipAsset */
    /**
     * The duration (in nanoseconds) of the media file
     */
    duration?: number
}
class UriClipAsset {
    /* Properties of GES-1.0.GES.UriClipAsset */
    /**
     * The duration (in nanoseconds) of the media file
     */
    duration: number
    /**
     * The duration (in nanoseconds) of the media file
     */
    readonly is_nested_timeline: boolean
    /* Properties of GES-1.0.GES.ClipAsset */
    /**
     * The formats supported by the asset.
     */
    supported_formats: TrackType
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GES-1.0.GES.SourceClipAsset */
    readonly parent_instance: ClipAsset
    /* Fields of GES-1.0.GES.ClipAsset */
    readonly parent: Asset
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.UriClipAsset */
    /**
     * Gets duration of the file represented by `self`
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets #GstDiscovererInfo about the file
     */
    get_info(): GstPbutils.DiscovererInfo
    /**
     * Gets maximum duration of the file represented by `self,`
     * it is usually the same as GESUriClipAsset::duration,
     * but in the case of nested timelines, for example, they
     * are different as those can be extended 'infinitely'.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Get the GESUriSourceAsset `self` containes
     */
    get_stream_assets(): UriSourceAsset[]
    /**
     * Gets Whether the file represented by `self` is an image or not
     */
    is_image(): boolean
    /* Methods of GES-1.0.GES.ClipAsset */
    /**
     * Converts the given frame number into a timestamp, using the "natural" frame
     * rate of the asset.
     * 
     * You can use this to reference a specific frame in a media file and use this
     * as, for example, the `in-point` or `max-duration` of a #GESClip.
     */
    get_frame_time(frame_number: FrameNumber): Gst.ClockTime
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets track types for which objects extracted from `self` can create #GESTrackElement
     */
    get_supported_formats(): TrackType
    /**
     * Sets track types for which objects extracted from `self` can create #GESTrackElement
     */
    set_supported_formats(supportedformats: TrackType): void
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.UriClipAsset */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.SourceClipAsset */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.ClipAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: UriClipAsset, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: UriClipAsset, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::duration", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::is-nested-timeline", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-nested-timeline", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::supported-formats", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-formats", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: UriClipAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: UriClipAsset_ConstructProps)
    _init (config?: UriClipAsset_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Finalize the request of an async #GESUriClipAsset
     */
    static finish(res: Gio.AsyncResult): UriClipAsset
    /**
     * Creates a #GESUriClipAsset for `uri` syncronously. You should avoid
     * to use it in application, and rather create #GESUriClipAsset asynchronously
     */
    static request_sync(uri: string): UriClipAsset
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    /**
     * Sets the timeout of #GESUriClipAsset loading
     */
    static set_timeout(klass: UriClipAsset | Function | GObject.Type, timeout: Gst.ClockTime): void
    static $gtype: GObject.Type
}
interface UriSourceAsset_ConstructProps extends TrackElementAsset_ConstructProps {
}
class UriSourceAsset {
    /* Properties of GES-1.0.GES.TrackElementAsset */
    track_type: TrackType
    /* Properties of GES-1.0.GES.Asset */
    /**
     * The default proxy for this asset, or %NULL if it has no proxy. A
     * proxy will act as a substitute for the original asset when the
     * original is requested (see ges_asset_request()).
     * 
     * Setting this property will not usually remove the existing proxy, but
     * will replace it as the default (see ges_asset_set_proxy()).
     */
    proxy: Asset
    /**
     * The asset that this asset is a proxy for, or %NULL if it is not a
     * proxy for another asset.
     * 
     * Note that even if this asset is acting as a proxy for another asset,
     * but this asset is not the default #GESAsset:proxy, then `proxy-target`
     * will *still* point to this other asset. So you should check the
     * #GESAsset:proxy property of `target-proxy` before assuming it is the
     * current default proxy for the target.
     * 
     * Note that the #GObject::notify for this property is emitted after
     * the #GESAsset:proxy #GObject::notify for the corresponding (if any)
     * asset it is now the proxy of/no longer the proxy of.
     */
    readonly proxy_target: Asset
    /* Fields of GES-1.0.GES.TrackElementAsset */
    readonly parent: Asset
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.UriSourceAsset */
    /**
     * Get the #GESUriClipAsset `self` is contained in
     */
    get_filesource_asset(): UriClipAsset
    /**
     * Get the #GstDiscovererStreamInfo user by `asset`
     */
    get_stream_info(): GstPbutils.DiscovererStreamInfo
    get_stream_uri(): string
    /**
     * Check if `asset` contains a single image
     */
    is_image(): boolean
    /* Methods of GES-1.0.GES.TrackElementAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Get the GESAssetTrackType the #GESTrackElement extracted from `self`
     * should get into
     */
    get_track_type(): TrackType
    /**
     * Set the #GESTrackType the #GESTrackElement extracted from `self`
     * should get into
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    extract(): Extractable
    /**
     * Retrieve the error that was set on the asset when it was loaded.
     */
    get_error(): GLib.Error | null
    /**
     * Gets the #GESAsset:extractable-type of the asset.
     */
    get_extractable_type(): GObject.Type
    /**
     * Gets the #GESAsset:id of the asset.
     */
    get_id(): string
    /**
     * Gets the default #GESAsset:proxy of the asset.
     */
    get_proxy(): Asset | null
    /**
     * Gets the #GESAsset:proxy-target of the asset.
     * 
     * Note that the proxy target may have loaded with an error, so you should
     * call ges_asset_get_error() on the returned target.
     */
    get_proxy_target(): Asset | null
    /**
     * Get all the proxies that the asset has. The first item of the list will
     * be the default #GESAsset:proxy. The second will be the proxy that is
     * 'next in line' to be default, and so on.
     */
    list_proxies(): Asset[]
    /**
     * Sets the #GESAsset:proxy for the asset.
     * 
     * If `proxy` is among the existing proxies of the asset (see
     * ges_asset_list_proxies()) it will be moved to become the default
     * proxy. Otherwise, if `proxy` is not %NULL, it will be added to the list
     * of proxies, as the new default. The previous default proxy will become
     * 'next in line' for if the new one is removed, and so on. As such, this
     * will **not** actually remove the previous default proxy (use
     * ges_asset_unproxy() for that).
     * 
     * Note that an asset can only act as a proxy for one other asset.
     * 
     * As a special case, if `proxy` is %NULL, then this method will actually
     * remove **all** proxies from the asset.
     */
    set_proxy(proxy?: Asset | null): boolean
    /**
     * Removes the proxy from the available list of proxies for the asset. If
     * the given proxy is the default proxy of the list, then the next proxy
     * in the available list (see ges_asset_list_proxies()) will become the
     * default. If there are no other proxies, then the asset will no longer
     * have a default #GESAsset:proxy.
     */
    unproxy(proxy: Asset): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.UriSourceAsset */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.TrackElementAsset */
    /**
     * Result: %TRUE if `self` has a natural framerate %FALSE otherwise
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GES-1.0.GES.Asset */
    /**
     * Extracts a new #GESAsset:extractable-type object from the asset. The
     * #GESAsset:id of the asset may determine the properties and state of the
     * newly created object.
     */
    vfunc_extract(): Extractable
    vfunc_inform_proxy(proxy_id: string): void
    vfunc_proxied(proxy: Asset): void
    vfunc_request_id_update(proposed_new_id: string, error: GLib.Error): boolean
    vfunc_start_loading(): AssetLoadingReturn
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: UriSourceAsset, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: UriSourceAsset, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::track-type", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy-target", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-target", callback: (($obj: UriSourceAsset, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: UriSourceAsset_ConstructProps)
    _init (config?: UriSourceAsset_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface VideoSource_ConstructProps extends Source_ConstructProps {
}
class VideoSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.VideoSource */
    /**
     * Retrieves the natural size of the video stream. The natural size, is
     * the size at which it will be displayed if no scaling is being applied.
     * 
     * NOTE: The sources take into account the potential video rotation applied
     * by the #videoflip element that is inside the source, effects applied on
     * the clip which potentially also rotate the element are not taken into
     * account.
     */
    get_natural_size(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.VideoSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: VideoSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: VideoSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: VideoSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: VideoSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: VideoSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: VideoSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: VideoSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: VideoSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: VideoSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: VideoSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: VideoSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: VideoSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: VideoSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VideoSource_ConstructProps)
    _init (config?: VideoSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface VideoTestSource_ConstructProps extends VideoSource_ConstructProps {
}
class VideoTestSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.VideoTestSource */
    /**
     * Get the video pattern used by the `source`.
     */
    get_pattern(): VideoTestPattern
    /**
     * Sets the source to use the given `pattern`.
     */
    set_pattern(pattern: VideoTestPattern): void
    /* Methods of GES-1.0.GES.VideoSource */
    /**
     * Retrieves the natural size of the video stream. The natural size, is
     * the size at which it will be displayed if no scaling is being applied.
     * 
     * NOTE: The sources take into account the potential video rotation applied
     * by the #videoflip element that is inside the source, effects applied on
     * the clip which potentially also rotate the element are not taken into
     * account.
     */
    get_natural_size(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.VideoTestSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.VideoSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: VideoTestSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: VideoTestSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: VideoTestSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: VideoTestSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: VideoTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: VideoTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: VideoTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: VideoTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: VideoTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: VideoTestSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: VideoTestSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: VideoTestSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: VideoTestSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VideoTestSource_ConstructProps)
    _init (config?: VideoTestSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface VideoTrack_ConstructProps extends Track_ConstructProps {
}
class VideoTrack {
    /* Properties of GES-1.0.GES.Track */
    /**
     * Current duration of the track
     * 
     * Default value: O
     */
    readonly duration: number
    /**
     * The #nlecomposition:id of the underlying #nlecomposition.
     */
    id: string
    /**
     * Whether the track should support the mixing of #GESLayer data, such
     * as composing the video data of each layer (when part of the video
     * data is transparent, the next layer will become visible) or adding
     * together the audio data. As such, for audio and video tracks, you'll
     * likely want to keep this set to %TRUE.
     */
    mixing: boolean
    /**
     * The capabilities that specifies the final output format of the
     * #GESTrack. For example, for a video track, it would specify the
     * height, width, framerate and other properties of the stream.
     * 
     * You may change this property after the track has been added to a
     * #GESTimeline, but it must remain compatible with the track's
     * #GESTrack:caps.
     * 
     * Default value: #GST_CAPS_ANY.
     */
    restriction_caps: Gst.Caps
    /* Properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward: boolean
    /* Fields of GES-1.0.GES.Track */
    readonly parent: Gst.Bin
    /**
     * The #GESTrack:track-type of the track
     */
    readonly type: TrackType
    /* Fields of Gst-1.0.Gst.Bin */
    readonly element: Gst.Element
    /**
     * the number of children in this bin
     */
    readonly numchildren: number
    /**
     * the list of children in this bin
     */
    readonly children: Gst.Element[]
    /**
     * updated whenever `children` changes
     */
    readonly children_cookie: number
    /**
     * internal bus for handling child messages
     */
    readonly child_bus: Gst.Bus
    /**
     * queued and cached messages
     */
    readonly messages: Gst.Message[]
    /**
     * the bin is currently calculating its state
     */
    readonly polling: boolean
    /**
     * the bin needs to recalculate its state (deprecated)
     */
    readonly state_dirty: boolean
    /**
     * the bin needs to select a new clock
     */
    readonly clock_dirty: boolean
    /**
     * the last clock selected
     */
    readonly provided_clock: Gst.Clock
    /**
     * the element that provided `provided_clock`
     */
    readonly clock_provider: Gst.Element
    /* Fields of Gst-1.0.Gst.Element */
    readonly object: Gst.Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    readonly state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    readonly state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    readonly state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    readonly target_state: Gst.State
    /**
     * the current state of an element
     */
    readonly current_state: Gst.State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    readonly next_state: Gst.State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    readonly pending_state: Gst.State
    /**
     * the last return value of an element state change
     */
    readonly last_return: Gst.StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    readonly bus: Gst.Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    readonly clock: Gst.Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    readonly base_time: Gst.ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    readonly start_time: Gst.ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    readonly numpads: number
    /**
     * list of pads
     */
    readonly pads: Gst.Pad[]
    /**
     * number of source pads of the element.
     */
    readonly numsrcpads: number
    /**
     * list of source pads
     */
    readonly srcpads: Gst.Pad[]
    /**
     * number of sink pads of the element.
     */
    readonly numsinkpads: number
    /**
     * list of sink pads
     */
    readonly sinkpads: Gst.Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    readonly pads_cookie: number
    /**
     * list of contexts
     */
    readonly contexts: Gst.Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    readonly lock: GLib.Mutex
    /**
     * The name of the object
     */
    readonly name: string
    /**
     * flags for this object
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Track */
    /**
     * See ges_track_add_element(), which also gives an error.
     */
    add_element(object: TrackElement): boolean
    /**
     * Adds the given track element to the track, which takes ownership of the
     * element.
     * 
     * Note that this can fail if it would break a configuration rule of the
     * track's #GESTimeline.
     * 
     * Note that a #GESTrackElement can only be added to one track.
     */
    add_element_full(object: TrackElement): boolean
    /**
     * Commits all the pending changes for the elements contained in the
     * track.
     * 
     * When changes are made to the timing or priority of elements within a
     * track, they are not directly executed for the underlying
     * #nlecomposition and its children. This method will finally execute
     * these changes so they are reflected in the data output of the track.
     * 
     * Any pending changes will be executed in the backend. The
     * #GESTimeline::commited signal will be emitted once this has completed.
     * 
     * Note that ges_timeline_commit() will call this method on all of its
     * tracks, so you are unlikely to need to use this directly.
     */
    commit(): boolean
    /**
     * Get the #GESTrack:caps of the track.
     */
    get_caps(): Gst.Caps
    /**
     * Gets the track elements contained in the track. The returned list is
     * sorted by the element's #GESTimelineElement:priority and
     * #GESTimelineElement:start.
     */
    get_elements(): TrackElement[]
    /**
     * Gets the #GESTrack:mixing of the track.
     */
    get_mixing(): boolean
    /**
     * Gets the #GESTrack:restriction-caps of the track.
     */
    get_restriction_caps(): Gst.Caps
    /**
     * Get the timeline this track belongs to.
     */
    get_timeline(): Timeline | null
    /**
     * See ges_track_remove_element_full(), which also returns an error.
     */
    remove_element(object: TrackElement): boolean
    /**
     * Removes the given track element from the track, which revokes
     * ownership of the element.
     */
    remove_element_full(object: TrackElement): boolean
    /**
     * Sets the #GESTrack:mixing for the track.
     */
    set_mixing(mixing: boolean): void
    /**
     * Sets the #GESTrack:restriction-caps for the track.
     * 
     * > **NOTE**: Restriction caps are **not** taken into account when
     * > using #GESPipeline:mode=#GES_PIPELINE_MODE_SMART_RENDER.
     */
    set_restriction_caps(caps: Gst.Caps): void
    /**
     * Informs the track that it belongs to the given timeline. Calling this
     * does not actually add the track to the timeline. For that, you should
     * use ges_timeline_add_track(), which will also take care of informing
     * the track that it belongs to the timeline. As such, there is no need
     * for you to call this method.
     */
    set_timeline(timeline: Timeline): void
    /**
     * Updates the #GESTrack:restriction-caps of the track using the fields
     * found in the given caps. Each of the #GstStructure-s in `caps` is
     * compared against the existing structure with the same index in the
     * current #GESTrack:restriction-caps. If there is no corresponding
     * existing structure at that index, then the new structure is simply
     * copied to that index. Otherwise, any fields in the new structure are
     * copied into the existing structure. This will replace existing values,
     * and may introduce new ones, but any fields 'missing' in the new
     * structure are left unchanged in the existing structure.
     * 
     * For example, if the existing #GESTrack:restriction-caps are
     * "video/x-raw, width=480, height=360", and the updating caps is
     * "video/x-raw, format=I420, width=500; video/x-bayer, width=400", then
     * the new #GESTrack:restriction-caps after calling this will be
     * "video/x-raw, width=500, height=360, format=I420; video/x-bayer,
     * width=400".
     */
    update_restriction_caps(caps: Gst.Caps): void
    /* Methods of Gst-1.0.Gst.Bin */
    /**
     * Adds the given element to the bin.  Sets the element's parent, and thus
     * takes ownership of the element. An element can only be added to one bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is added to the bin.
     * 
     * > When you add an element to an already-running pipeline, you will have to
     * > take care to set the state of the newly-added element to the desired
     * > state (usually PLAYING or PAUSED, same you set the pipeline to originally)
     * > with gst_element_set_state(), or use gst_element_sync_state_with_parent().
     * > The bin or pipeline will not take care of this for you.
     */
    add(element: Gst.Element): boolean
    /**
     * Recursively looks for elements with an unlinked pad of the given
     * direction within the specified bin and returns an unlinked pad
     * if one is found, or %NULL otherwise. If a pad is found, the caller
     * owns a reference to it and should use gst_object_unref() on the
     * pad when it is not needed any longer.
     */
    find_unlinked_pad(direction: Gst.PadDirection): Gst.Pad | null
    /**
     * Looks for an element inside the bin that implements the given
     * interface. If such an element is found, it returns the element.
     * You can cast this element to the given interface afterwards.  If you want
     * all elements that implement the interface, use
     * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
     */
    get_by_interface(iface: GObject.Type): Gst.Element | null
    /**
     * Gets the element with the given name from a bin. This
     * function recurses into child bins.
     */
    get_by_name(name: string): Gst.Element | null
    /**
     * Gets the element with the given name from this bin. If the
     * element is not found, a recursion is performed on the parent bin.
     */
    get_by_name_recurse_up(name: string): Gst.Element | null
    get_suppressed_flags(): Gst.ElementFlags
    /**
     * Looks for all elements inside the bin with the given element factory name.
     * The function recurses inside child bins. The iterator will yield a series of
     * #GstElement.
     */
    iterate_all_by_element_factory_name(factory_name: string): Gst.Iterator | null
    /**
     * Looks for all elements inside the bin that implements the given
     * interface. You can safely cast all returned elements to the given interface.
     * The function recurses inside child bins. The iterator will yield a series
     * of #GstElement.
     */
    iterate_all_by_interface(iface: GObject.Type): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     */
    iterate_elements(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     * This iterator recurses into GstBin children.
     */
    iterate_recurse(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SINK flag set.
     */
    iterate_sinks(): Gst.Iterator | null
    /**
     * Gets an iterator for the elements in this bin in topologically
     * sorted order. This means that the elements are returned from
     * the most downstream elements (sinks) to the sources.
     * 
     * This function is used internally to perform the state changes
     * of the bin elements and for clock selection.
     */
    iterate_sorted(): Gst.Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SOURCE flag set.
     */
    iterate_sources(): Gst.Iterator | null
    /**
     * Queries `bin` for the current latency and reconfigures this latency on all the
     * elements using a LATENCY event.
     * 
     * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
     * is posted on the bus.
     * 
     * This function simply emits the #GstBin::do-latency signal so any custom latency
     * calculations will be performed.
     */
    recalculate_latency(): boolean
    /**
     * Removes the element from the bin, unparenting it as well.
     * Unparenting the element means that the element will be dereferenced,
     * so if the bin holds the only reference to the element, the element
     * will be freed in the process of removing it from the bin.  If you
     * want the element to still exist after removing, you need to call
     * gst_object_ref() before removing it from the bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is removed from the bin.
     */
    remove(element: Gst.Element): boolean
    /**
     * Suppresses the given flags on the bin. #GstElementFlags of a
     * child element are propagated when it is added to the bin.
     * When suppressed flags are set, those specified flags will
     * not be propagated to the bin.
     */
    set_suppressed_flags(flags: Gst.ElementFlags): void
    /**
     * Synchronizes the state of every child of `bin` with the state
     * of `bin`. See also gst_element_sync_state_with_parent().
     */
    sync_children_states(): boolean
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     */
    add_pad(pad: Gst.Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     */
    call_async(func: Gst.ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     */
    continue_state(ret: Gst.StateChangeReturn): Gst.StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     */
    foreach_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_sink_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     */
    foreach_src_pad(func: Gst.ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): Gst.ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Gst.Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Gst.Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     */
    get_compatible_pad(pad: Gst.Pad, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     */
    get_compatible_pad_template(compattempl: Gst.PadTemplate): Gst.PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     */
    get_context(context_type: string): Gst.Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     */
    get_context_unlocked(context_type: string): Gst.Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Gst.Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): Gst.ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): Gst.ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): Gst.ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     */
    get_pad_template(name: string): Gst.PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): Gst.PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     */
    get_request_pad(name: string): Gst.Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): Gst.ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     */
    get_static_pad(name: string): Gst.Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Gst.Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Gst.Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link(dest: Gst.Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     */
    link_filtered(dest: Gst.Element, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     */
    link_pads(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     */
    link_pads_filtered(srcpadname: string | null, dest: Gst.Element, destpadname?: string | null, filter?: Gst.Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     */
    link_pads_full(srcpadname: string | null, dest: Gst.Element, destpadname: string | null, flags: Gst.PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     */
    message_full(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     */
    message_full_with_details(type: Gst.MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Gst.Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    query(query: Gst.Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     */
    query_convert(src_format: Gst.Format, src_val: number, dest_format: Gst.Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     */
    query_duration(format: Gst.Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     */
    query_position(format: Gst.Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     */
    release_request_pad(pad: Gst.Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     */
    remove_pad(pad: Gst.Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    request_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     */
    request_pad_simple(name: string): Gst.Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     */
    seek(rate: number, format: Gst.Format, flags: Gst.SeekFlags, start_type: Gst.SeekType, start: number, stop_type: Gst.SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     */
    seek_simple(format: Gst.Format, seek_flags: Gst.SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    send_event(event: Gst.Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     */
    set_base_time(time: Gst.ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    set_context(context: Gst.Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     */
    set_start_time(time: Gst.ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    set_state(state: Gst.State): Gst.StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     */
    unlink(dest: Gst.Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     */
    unlink_pads(srcpadname: string, dest: Gst.Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     */
    add_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): Gst.ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     */
    get_g_value_array(property_name: string, timestamp: Gst.ClockTime, interval: Gst.ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Gst.Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     */
    get_value(property_name: string, timestamp: Gst.ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     */
    has_as_ancestor(ancestor: Gst.Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     */
    has_as_parent(parent: Gst.Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Gst.Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     */
    remove_control_binding(binding: Gst.ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     */
    set_control_rate(control_rate: Gst.ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     */
    set_parent(parent: Gst.Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): Gst.ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     */
    sync_values(timestamp: Gst.ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Methods of Gst-1.0.Gst.ChildProxy */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    get_children_count(): number
    /**
     * Gets a single property using the GstChildProxy mechanism.
     * You are responsible for freeing it by calling g_value_unset()
     */
    get_property(name: string): /* value */ any
    /**
     * Looks up which object and #GParamSpec would be effected by the given `name`.
     */
    lookup(name: string): [ /* returnType */ boolean, /* target */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Sets a single property using the GstChildProxy mechanism.
     */
    set_property(name: string, value: any): void
    /* Virtual methods of GES-1.0.GES.VideoTrack */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /* Virtual methods of GES-1.0.GES.Track */
    /**
     * Emits the #GstChildProxy::child-added signal.
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /* Virtual methods of Gst-1.0.Gst.Bin */
    /**
     * Method to add an element to the bin.
     */
    vfunc_add_element(element: Gst.Element): boolean
    /**
     * Method called when an element was added somewhere in the bin hierarchy.
     */
    vfunc_deep_element_added(sub_bin: Gst.Bin, child: Gst.Element): void
    /**
     * Method called when an element was removed somewhere in the bin hierarchy.
     */
    vfunc_deep_element_removed(sub_bin: Gst.Bin, child: Gst.Element): void
    vfunc_do_latency(): boolean
    /**
     * Method called when an element was added to the bin.
     */
    vfunc_element_added(child: Gst.Element): void
    /**
     * Method called when an element was removed from the bin.
     */
    vfunc_element_removed(child: Gst.Element): void
    /**
     * Method to handle a message from the children.
     */
    vfunc_handle_message(message: Gst.Message): void
    /**
     * Method to remove an element from the bin.
     */
    vfunc_remove_element(element: Gst.Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     */
    vfunc_change_state(transition: Gst.StateChange): Gst.StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     */
    vfunc_get_state(timeout: Gst.ClockTime): [ /* returnType */ Gst.StateChangeReturn, /* state */ Gst.State | null, /* pending */ Gst.State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Gst.Pad): void
    vfunc_pad_removed(pad: Gst.Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     */
    vfunc_post_message(message: Gst.Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Gst.Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     */
    vfunc_query(query: Gst.Query): boolean
    vfunc_release_pad(pad: Gst.Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     */
    vfunc_request_new_pad(templ: Gst.PadTemplate, name?: string | null, caps?: Gst.Caps | null): Gst.Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     */
    vfunc_send_event(event: Gst.Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     */
    vfunc_set_bus(bus?: Gst.Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     */
    vfunc_set_clock(clock?: Gst.Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     */
    vfunc_set_context(context: Gst.Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     */
    vfunc_set_state(state: Gst.State): Gst.StateChangeReturn
    vfunc_state_changed(oldstate: Gst.State, newstate: Gst.State, pending: Gst.State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Gst.Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.Track */
    /**
     * This signal will be emitted once the changes initiated by
     * ges_track_commit() have been executed in the backend. In particular,
     * this will be emitted whenever the underlying #nlecomposition has been
     * committed (see #nlecomposition::commited).
     */
    connect(sigName: "commited", callback: (($obj: VideoTrack) => void)): number
    connect_after(sigName: "commited", callback: (($obj: VideoTrack) => void)): number
    emit(sigName: "commited"): void
    /**
     * Will be emitted after a track element is added to the track.
     */
    connect(sigName: "track-element-added", callback: (($obj: VideoTrack, effect: TrackElement) => void)): number
    connect_after(sigName: "track-element-added", callback: (($obj: VideoTrack, effect: TrackElement) => void)): number
    emit(sigName: "track-element-added", effect: TrackElement): void
    /**
     * Will be emitted after a track element is removed from the track.
     */
    connect(sigName: "track-element-removed", callback: (($obj: VideoTrack, effect: TrackElement) => void)): number
    connect_after(sigName: "track-element-removed", callback: (($obj: VideoTrack, effect: TrackElement) => void)): number
    emit(sigName: "track-element-removed", effect: TrackElement): void
    /* Signals of Gst-1.0.Gst.Bin */
    /**
     * Will be emitted after the element was added to `sub_bin`.
     */
    connect(sigName: "deep-element-added", callback: (($obj: VideoTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-added", callback: (($obj: VideoTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-added", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from `sub_bin`.
     */
    connect(sigName: "deep-element-removed", callback: (($obj: VideoTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    connect_after(sigName: "deep-element-removed", callback: (($obj: VideoTrack, sub_bin: Gst.Bin, element: Gst.Element) => void)): number
    emit(sigName: "deep-element-removed", sub_bin: Gst.Bin, element: Gst.Element): void
    /**
     * Will be emitted when the bin needs to perform latency calculations. This
     * signal is only emitted for toplevel bins or when #GstBin:async-handling is
     * enabled.
     * 
     * Only one signal handler is invoked. If no signals are connected, the
     * default handler is invoked, which will query and distribute the lowest
     * possible latency to all sinks.
     * 
     * Connect to this signal if the default latency calculations are not
     * sufficient, like when you need different latencies for different sinks in
     * the same pipeline.
     */
    connect(sigName: "do-latency", callback: (($obj: VideoTrack) => boolean)): number
    connect_after(sigName: "do-latency", callback: (($obj: VideoTrack) => boolean)): number
    emit(sigName: "do-latency"): void
    /**
     * Will be emitted after the element was added to the bin.
     */
    connect(sigName: "element-added", callback: (($obj: VideoTrack, element: Gst.Element) => void)): number
    connect_after(sigName: "element-added", callback: (($obj: VideoTrack, element: Gst.Element) => void)): number
    emit(sigName: "element-added", element: Gst.Element): void
    /**
     * Will be emitted after the element was removed from the bin.
     */
    connect(sigName: "element-removed", callback: (($obj: VideoTrack, element: Gst.Element) => void)): number
    connect_after(sigName: "element-removed", callback: (($obj: VideoTrack, element: Gst.Element) => void)): number
    emit(sigName: "element-removed", element: Gst.Element): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: VideoTrack) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: VideoTrack) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     */
    connect(sigName: "pad-added", callback: (($obj: VideoTrack, new_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: VideoTrack, new_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Gst.Pad): void
    /**
     * a #GstPad has been removed from the element
     */
    connect(sigName: "pad-removed", callback: (($obj: VideoTrack, old_pad: Gst.Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: VideoTrack, old_pad: Gst.Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Gst.Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     */
    connect(sigName: "deep-notify", callback: (($obj: VideoTrack, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: VideoTrack, prop_object: Gst.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Gst.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: VideoTrack, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: VideoTrack, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    /* Signals of Gst-1.0.Gst.ChildProxy */
    /**
     * Will be emitted after the `object` was added to the `child_proxy`.
     */
    connect(sigName: "child-added", callback: (($obj: VideoTrack, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: VideoTrack, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-added", object: GObject.Object, name: string): void
    /**
     * Will be emitted after the `object` was removed from the `child_proxy`.
     */
    connect(sigName: "child-removed", callback: (($obj: VideoTrack, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: VideoTrack, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-removed", object: GObject.Object, name: string): void
    connect(sigName: "notify::duration", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mixing", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mixing", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::restriction-caps", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::restriction-caps", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::async-handling", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::async-handling", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::message-forward", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-forward", callback: (($obj: VideoTrack, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VideoTrack_ConstructProps)
    _init (config?: VideoTrack_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): VideoTrack
    /* Function overloads */
    static new(type: TrackType, caps: Gst.Caps): VideoTrack
    static new(name?: string | null): VideoTrack
    static $gtype: GObject.Type
}
interface VideoTransition_ConstructProps extends Transition_ConstructProps {
    /* Constructor properties of GES-1.0.GES.VideoTransition */
    /**
     * This value represents the border width of the transition.
     */
    border?: number
    /**
     * This value represents the direction of the transition.
     */
    invert?: boolean
    transition_type?: VideoStandardTransitionType
}
class VideoTransition {
    /* Properties of GES-1.0.GES.VideoTransition */
    /**
     * This value represents the border width of the transition.
     */
    border: number
    /**
     * This value represents the direction of the transition.
     */
    invert: boolean
    transition_type: VideoStandardTransitionType
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.VideoTransition */
    /**
     * Get the border property of `self,` this value represents
     * the border width of the transition.
     */
    get_border(): number
    /**
     * Get the transition type used by `trans`.
     */
    get_transition_type(): VideoStandardTransitionType
    /**
     * Get the invert property of `self,` this value represents
     * the direction of the transition.
     */
    is_inverted(): boolean
    /**
     * Set the border property of `self,` this value represents
     * the border width of the transition. In case this value does
     * not make sense for the current transition type, it is cached
     * for later use.
     */
    set_border(value: number): void
    /**
     * Set the invert property of `self,` this value represents
     * the direction of the transition. In case this value does
     * not make sense for the current transition type, it is cached
     * for later use.
     */
    set_inverted(inverted: boolean): void
    /**
     * Sets the transition being used to `type`.
     */
    set_transition_type(type: VideoStandardTransitionType): boolean
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.VideoTransition */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Transition */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Operation */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: VideoTransition, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: VideoTransition, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: VideoTransition, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: VideoTransition, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: VideoTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: VideoTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: VideoTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: VideoTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: VideoTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: VideoTransition, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: VideoTransition, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: VideoTransition, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::border", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::border", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::invert", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::invert", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::transition-type", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transition-type", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: VideoTransition, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VideoTransition_ConstructProps)
    _init (config?: VideoTransition_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): VideoTransition
    static $gtype: GObject.Type
}
interface VideoUriSource_ConstructProps extends VideoSource_ConstructProps {
    /* Constructor properties of GES-1.0.GES.VideoUriSource */
    /**
     * The location of the file/resource to use.
     */
    uri?: string
}
class VideoUriSource {
    /* Properties of GES-1.0.GES.TrackElement */
    /**
     * Whether the effect of the element should be applied in its
     * #GESTrackElement:track. If set to %FALSE, it will not be used in
     * the output of the track.
     */
    active: boolean
    /**
     * Whether the control sources on the element (see
     * ges_track_element_set_control_source()) will be automatically
     * updated whenever the #GESTimelineElement:in-point or out-point of the
     * element change in value.
     * 
     * See ges_track_element_clamp_control_source() for how this is done
     * per control source.
     * 
     * Default value: %TRUE
     */
    auto_clamp_control_sources: boolean
    /**
     * This property is used to determine whether the 'internal time'
     * properties of the element have any meaning. In particular, unless
     * this is set to %TRUE, the #GESTimelineElement:in-point and
     * #GESTimelineElement:max-duration can not be set to any value other
     * than the default 0 and #GST_CLOCK_TIME_NONE, respectively.
     * 
     * If an element has some *internal* *timed* source #GstElement that it
     * reads stream data from as part of its function in a #GESTrack, then
     * you'll likely want to set this to %TRUE to allow the
     * #GESTimelineElement:in-point and #GESTimelineElement:max-duration to
     * be set.
     * 
     * The default value is determined by the #GESTrackElementClass
     * `default_has_internal_source` class property. For most
     * #GESSourceClass-es, this will be %TRUE, with the exception of those
     * that have a potentially *static* source, such as #GESImageSourceClass
     * and #GESTitleSourceClass. Otherwise, this will usually be %FALSE.
     * 
     * For most #GESOperation-s you will likely want to leave this set to
     * %FALSE. The exception may be for an operation that reads some stream
     * data from some private internal source as part of manipulating the
     * input data from the usual linked upstream #GESTrackElement.
     * 
     * For example, you may want to set this to %TRUE for a
     * #GES_TRACK_TYPE_VIDEO operation that wraps a #textoverlay that reads
     * from a subtitle file and places its text on top of the received video
     * data. The #GESTimelineElement:in-point of the element would be used
     * to shift the initial seek time on the #textoverlay away from 0, and
     * the #GESTimelineElement:max-duration could be set to reflect the
     * time at which the subtitle file runs out of data.
     * 
     * Note that GES can not support track elements that have both internal
     * content and manipulate the timing of their data streams (time
     * effects).
     */
    has_internal_source: boolean
    /**
     * The track that this element belongs to, or %NULL if it does not
     * belong to a track.
     */
    readonly track: Track
    /**
     * The track type of the element, which determines the type of track the
     * element can be added to (see #GESTrack:track-type). This should
     * correspond to the type of data that the element can produce or
     * process.
     */
    track_type: TrackType
    /* Properties of GES-1.0.GES.TimelineElement */
    /**
     * The initial offset to use internally when outputting content (in
     * nanoseconds, but in the time coordinates of the internal content).
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, the "internal content" is the media file data, and the
     * in-point would correspond to some timestamp in the media file.
     * When playing the timeline, and when the element is first reached at
     * timeline-time #GESTimelineElement:start, it will begin outputting the
     * data from the timestamp in-point **onwards**, until it reaches the
     * end of its #GESTimelineElement:duration in the timeline.
     * 
     * For elements that have no internal content, this should be kept
     * as 0.
     */
    in_point: number
    /**
     * The full duration of internal content that is available (a time
     * difference in nanoseconds using the time coordinates of the internal
     * content).
     * 
     * This will act as a cap on the #GESTimelineElement:in-point of the
     * element (which is in the same time coordinates), and will sometimes
     * be used to limit the #GESTimelineElement:duration of the element in
     * the timeline.
     * 
     * For example, for a #GESVideoUriSource that references some media
     * file, this would be the length of the media file.
     * 
     * For elements that have no internal content, or whose content is
     * indefinite, this should be kept as #GST_CLOCK_TIME_NONE.
     */
    max_duration: number
    /**
     * Whether the element should be serialized.
     */
    serialize: boolean
    /* Fields of GES-1.0.GES.TrackElement */
    readonly parent: TimelineElement
    /* Fields of GES-1.0.GES.TimelineElement */
    readonly parent_instance: GObject.InitiallyUnowned
    /**
     * The #GESAsset from which the object has been extracted
     */
    readonly asset: Asset
    /**
     * The #GESTimelineElement:start of the element
     */
    readonly start: Gst.ClockTime
    /**
     * The #GESTimelineElement:in-point of the element
     */
    readonly inpoint: Gst.ClockTime
    /**
     * The #GESTimelineElement:duration of the element
     */
    readonly duration: Gst.ClockTime
    /**
     * The #GESTimelineElement:max-duration of the element
     */
    readonly maxduration: Gst.ClockTime
    /**
     * The #GESTimelineElement:priority of the element
     */
    readonly priority: number
    /**
     * The #GESTimelineElement:timeline of the element
     */
    readonly timeline: Timeline
    /**
     * The #GESTimelineElement:name of the element
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.VideoSource */
    /**
     * Retrieves the natural size of the video stream. The natural size, is
     * the size at which it will be displayed if no scaling is being applied.
     * 
     * NOTE: The sources take into account the potential video rotation applied
     * by the #videoflip element that is inside the source, effects applied on
     * the clip which potentially also rotate the element are not taken into
     * account.
     */
    get_natural_size(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /* Methods of GES-1.0.GES.TrackElement */
    /**
     * Adds all the properties of a #GstElement that match the criteria as
     * children properties of the track element. If the name of `element'`s
     * #GstElementFactory is not in `blacklist,` and the factory's
     * #GST_ELEMENT_METADATA_KLASS contains at least one member of
     * `wanted_categories` (e.g. #GST_ELEMENT_FACTORY_KLASS_DECODER), then
     * all the properties of `element` that are also in `whitelist` are added as
     * child properties of `self` using
     * ges_timeline_element_add_child_property().
     * 
     * This is intended to be used by subclasses when constructing.
     */
    add_children_props(element: Gst.Element, wanted_categories?: string[] | null, blacklist?: string[] | null, whitelist?: string[] | null): void
    /**
     * Clamp the #GstTimedValueControlSource for the specified child property
     * to lie between the #GESTimelineElement:in-point and out-point of the
     * element. The out-point is the #GES_TIMELINE_ELEMENT_END of the element
     * translated from the timeline coordinates to the internal source
     * coordinates of the element.
     * 
     * If the property does not have a #GstTimedValueControlSource set by
     * ges_track_element_set_control_source(), nothing happens. Otherwise, if
     * a timed value for the control source lies before the in-point of the
     * element, or after its out-point, then it will be removed. At the
     * in-point and out-point times, a new interpolated value will be placed.
     */
    clamp_control_source(property_name: string): void
    /**
     * Edits the element within its track.
     */
    edit(layers: Layer[] | null, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Get all the control bindings that have been created for the children
     * properties of the track element using
     * ges_track_element_set_control_source(). The keys used in the returned
     * hash table are the child property names that were passed to
     * ges_track_element_set_control_source(), and their values are the
     * corresponding created #GstControlBinding.
     */
    get_all_control_bindings(): GLib.HashTable
    /**
     * Gets #GESTrackElement:auto-clamp-control-sources.
     */
    get_auto_clamp_control_sources(): boolean
    /**
     * Gets the control binding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    get_control_binding(property_name: string): Gst.ControlBinding | null
    /**
     * Get the #GstElement that the track element's underlying nleobject
     * controls.
     */
    get_element(): Gst.Element
    /**
     * Get the GNonLin object this object is controlling.
     */
    get_gnlobject(): Gst.Element
    /**
     * Get the nleobject that this element wraps.
     */
    get_nleobject(): Gst.Element
    /**
     * Get the #GESTrackElement:track for the element.
     */
    get_track(): Track | null
    /**
     * Gets the #GESTrackElement:track-type for the element.
     */
    get_track_type(): TrackType
    /**
     * Gets #GESTrackElement:active for the element.
     */
    is_active(): boolean
    /**
     * Get whether the given track element is a core track element. That is,
     * it was created by the `create_track_elements` #GESClipClass method for
     * some #GESClip.
     * 
     * Note that such a track element can only be added to a clip that shares
     * the same #GESAsset as the clip that created it. For example, you are
     * allowed to move core children between clips that resulted from
     * ges_container_ungroup(), but you could not move the core child from a
     * #GESUriClip to a #GESTitleClip or another #GESUriClip with a different
     * #GESUriClip:uri.
     * 
     * Moreover, if a core track element is added to a clip, it will always be
     * added as a core child. Therefore, if this returns %TRUE, then `element`
     * will be a core child of its parent clip.
     */
    is_core(): boolean
    /**
     * Gets an array of #GParamSpec* for all configurable properties of the
     * children of `object`.
     */
    list_children_properties(): GObject.ParamSpec[]
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Removes the #GstControlBinding that was created for the specified child
     * property of the track element using
     * ges_track_element_set_control_source(). The given `property_name` must
     * be the same name of the child property that was passed to
     * ges_track_element_set_control_source().
     */
    remove_control_binding(property_name: string): boolean
    /**
     * Sets #GESTrackElement:active for the element.
     */
    set_active(active: boolean): boolean
    /**
     * Sets #GESTrackElement:auto-clamp-control-sources. If set to %TRUE, this
     * will immediately clamp all the control sources.
     */
    set_auto_clamp_control_sources(auto_clamp: boolean): void
    /**
     * Creates a #GstControlBinding for the specified child property of the
     * track element using the given control source. The given `property_name`
     * should refer to an existing child property of the track element, as
     * used in ges_timeline_element_lookup_child().
     * 
     * If `binding_type` is "direct", then the control binding is created with
     * gst_direct_control_binding_new() using the given control source. If
     * `binding_type` is "direct-absolute", it is created with
     * gst_direct_control_binding_new_absolute() instead.
     */
    set_control_source(source: Gst.ControlSource, property_name: string, binding_type: string): boolean
    /**
     * Sets #GESTrackElement:has-internal-source for the element. If this is
     * set to %FALSE, this method will also set the
     * #GESTimelineElement:in-point of the element to 0 and its
     * #GESTimelineElement:max-duration to #GST_CLOCK_TIME_NONE.
     */
    set_has_internal_source(has_internal_source: boolean): boolean
    /**
     * Sets the #GESTrackElement:track-type for the element.
     */
    set_track_type(type: TrackType): void
    /* Methods of GES-1.0.GES.TimelineElement */
    /**
     * Register a property of a child of the element to allow it to be
     * written with ges_timeline_element_set_child_property() and read with
     * ges_timeline_element_get_child_property(). A change in the property
     * will also appear in the #GESTimelineElement::deep-notify signal.
     * 
     * `pspec` should be unique from other children properties that have been
     * registered on `self`.
     */
    add_child_property(pspec: GObject.ParamSpec, child: GObject.Object): boolean
    /**
     * Create a copy of `self`. All the properties of `self` are copied into
     * a new element, with the exception of #GESTimelineElement:parent,
     * #GESTimelineElement:timeline and #GESTimelineElement:name. Other data,
     * such the list of a #GESContainer's children, is **not** copied.
     * 
     * If `deep` is %TRUE, then the new element is prepared so that it can be
     * used in ges_timeline_element_paste() or ges_timeline_paste_element().
     * In the case of copying a #GESContainer, this ensures that the children
     * of `self` will also be pasted. The new element should not be used for
     * anything else and can only be used **once** in a pasting operation. In
     * particular, the new element itself is not an actual 'deep' copy of
     * `self,` but should be thought of as an intermediate object used for a
     * single paste operation.
     */
    copy(deep: boolean): TimelineElement
    /**
     * See ges_timeline_element_edit_full(), which also gives an error.
     * 
     * Note that the `layers` argument is currently ignored, so you should
     * just pass %NULL.
     */
    edit(layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Edits the element within its timeline by adjusting its
     * #GESTimelineElement:start, #GESTimelineElement:duration or
     * #GESTimelineElement:in-point, and potentially doing the same for
     * other elements in the timeline. See #GESEditMode for details about each
     * edit mode. An edit may fail if it would place one of these properties
     * out of bounds, or if it would place the timeline in an unsupported
     * configuration.
     * 
     * Note that if you act on a #GESTrackElement, this will edit its parent
     * #GESClip instead. Moreover, for any #GESTimelineElement, if you select
     * #GES_EDGE_NONE for #GES_EDIT_MODE_NORMAL or #GES_EDIT_MODE_RIPPLE, this
     * will edit the toplevel instead, but still in such a way as to make the
     * #GESTimelineElement:start of `self` reach the edit `position`.
     * 
     * Note that if the element's timeline has a
     * #GESTimeline:snapping-distance set, then the edit position may be
     * snapped to the edge of some element under the edited element.
     * 
     * `new_layer_priority` can be used to switch `self,` and other elements
     * moved by the edit, to a new layer. New layers may be be created if the
     * the corresponding layer priority/index does not yet exist for the
     * timeline.
     */
    edit_full(new_layer_priority: number, mode: EditMode, edge: Edge, position: number): boolean
    /**
     * Gets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to get (as used in g_object_get()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property copied into `value`.
     * 
     * Note that ges_timeline_element_get_child_properties() may be more
     * convenient for C programming.
     */
    get_child_property(property_name: string): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Gets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is copied into `value`.
     */
    get_child_property_by_pspec(pspec: GObject.ParamSpec): /* value */ any
    /**
     * Gets the #GESTimelineElement:duration for the element.
     */
    get_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:in-point for the element.
     */
    get_inpoint(): Gst.ClockTime
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    get_layer_priority(): number
    /**
     * Gets the #GESTimelineElement:max-duration for the element.
     */
    get_max_duration(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:name for the element.
     */
    get_name(): string
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the #GESTimelineElement:parent for the element.
     */
    get_parent(): TimelineElement | null
    /**
     * Gets the #GESTimelineElement:priority for the element.
     */
    get_priority(): number
    /**
     * Gets the #GESTimelineElement:start for the element.
     */
    get_start(): Gst.ClockTime
    /**
     * Gets the #GESTimelineElement:timeline for the element.
     */
    get_timeline(): Timeline | null
    /**
     * Gets the toplevel #GESTimelineElement:parent of the element.
     */
    get_toplevel_parent(): TimelineElement
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Paste an element inside the same timeline and layer as `self`. `self`
     * **must** be the return of ges_timeline_element_copy() with `deep=TRUE`,
     * and it should not be changed before pasting.
     * `self` is not placed in the timeline, instead a new element is created,
     * alike to the originally copied element. Note that the originally
     * copied element must stay within the same timeline and layer, at both
     * the point of copying and pasting.
     * 
     * Pasting may fail if it would place the timeline in an unsupported
     * configuration.
     * 
     * After calling this function `element` should not be used. In particular,
     * `element` can **not** be pasted again. Instead, you can copy the
     * returned element and paste that copy (although, this is only possible
     * if the paste was successful).
     * 
     * See also ges_timeline_paste_element().
     */
    paste(paste_position: Gst.ClockTime): TimelineElement | null
    /**
     * Remove a child property from the element. `pspec` should be a
     * specification that was passed to
     * ges_timeline_element_add_child_property(). The corresponding property
     * will no longer be registered as a child property for the element.
     */
    remove_child_property(pspec: GObject.ParamSpec): boolean
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    ripple(start: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    ripple_end(end: Gst.ClockTime): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    roll_end(end: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    roll_start(start: Gst.ClockTime): boolean
    /**
     * See ges_timeline_element_set_child_property_full(), which also gives an
     * error.
     * 
     * Note that ges_timeline_element_set_child_properties() may be more
     * convenient for C programming.
     */
    set_child_property(property_name: string, value: any): boolean
    /**
     * Sets the property of a child of the element. Specifically, the property
     * corresponding to the `pspec` used in
     * ges_timeline_element_add_child_property() is set to `value`.
     */
    set_child_property_by_pspec(pspec: GObject.ParamSpec, value: any): void
    /**
     * Sets the property of a child of the element.
     * 
     * `property_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to set (as used in g_object_set()), and "TypeName" is the type name of
     * the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will have the corresponding
     * property set to `value`. Other children that may have also matched the
     * property name (and type name) are left unchanged!
     */
    set_child_property_full(property_name: string, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:name for the element. If %NULL is given
     * for `name,` then the library will instead generate a new name based on
     * the type name of the element, such as the name "uriclip3" for a
     * #GESUriClip, and will set that name instead.
     * 
     * If `self` already has a #GESTimelineElement:timeline, you should not
     * call this function with `name` set to %NULL.
     * 
     * You should ensure that, within each #GESTimeline, every element has a
     * unique name. If you call this function with `name` as %NULL, then
     * the library should ensure that the set generated name is unique from
     * previously **generated** names. However, if you choose a `name` that
     * interferes with the naming conventions of the library, the library will
     * attempt to ensure that the generated names will not conflict with the
     * chosen name, which may lead to a different name being set instead, but
     * the uniqueness between generated and user-chosen names is not
     * guaranteed.
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    set_start(start: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:timeline of the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESClip will have its #GESTimelineElement:timeline set through its
     * #GESLayer. A #GESTrack will similarly take care of setting the
     * #GESTimelineElement:timeline of its #GESTrackElement-s. A #GESGroup
     * will adopt the same #GESTimelineElement:timeline as its children.
     * 
     * If `timeline` is %NULL, this will stop its current
     * #GESTimelineElement:timeline from tracking it, otherwise `timeline` will
     * start tracking `self`. Note, in the latter case, `self` must not already
     * have a timeline set. Therefore, if you wish to switch timelines, you
     * will need to call this function twice: first to set the timeline to
     * %NULL, and then to the new timeline.
     */
    set_timeline(timeline: Timeline): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    trim(start: Gst.ClockTime): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Methods of GES-1.0.GES.MetaContainer */
    /**
     * Deserializes the given string, and adds and sets the found fields and
     * their values on the container. The string should be the return of
     * ges_meta_container_metas_to_string().
     */
    add_metas_from_string(str: string): boolean
    /**
     * Checks whether the specified field has been registered as static, and
     * gets the registered type and flags of the field, as used in
     * ges_meta_container_register_meta() and
     * ges_meta_container_register_static_meta().
     */
    check_meta_registered(meta_item: string): [ /* returnType */ boolean, /* flags */ MetaFlag | null, /* type */ GObject.Type | null ]
    /**
     * Calls the given function on each of the meta container's set metadata
     * fields.
     */
    foreach(func: MetaForeachFunc): void
    /**
     * Gets the current boolean value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_boolean(meta_item: string): [ /* returnType */ boolean, /* dest */ boolean ]
    /**
     * Gets the current date value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date(meta_item: string): [ /* returnType */ boolean, /* dest */ GLib.Date ]
    /**
     * Gets the current date time value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_date_time(meta_item: string): [ /* returnType */ boolean, /* dest */ Gst.DateTime ]
    /**
     * Gets the current double value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_double(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current float value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_float(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current int64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_int64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current marker list value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_marker_list(key: string): MarkerList
    /**
     * Gets the current value of the specified field of the meta container.
     */
    get_meta(key: string): any
    /**
     * Gets the current string value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_string(meta_item: string): string
    /**
     * Gets the current uint value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Gets the current uint64 value of the specified field of the meta
     * container. If the field does not have a set value, or it is of the
     * wrong type, the method will fail.
     */
    get_uint64(meta_item: string): [ /* returnType */ boolean, /* dest */ number ]
    /**
     * Serializes the set metadata fields of the meta container to a string.
     */
    metas_to_string(): string
    /**
     * Sets the value of the specified field of the meta container to the
     * given value, and registers the field to only hold a value of the
     * same type. After calling this, only values of the same type as `value`
     * can be set for this field. The given flags can be set to make this
     * field only readable after calling this method.
     */
    register_meta(flags: MetaFlag, meta_item: string, value: any): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value, and registers the field to only hold a boolean
     * typed value. After calling this, only boolean values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_boolean(flags: MetaFlag, meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value, and registers the field to only hold a date
     * typed value. After calling this, only date values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date(flags: MetaFlag, meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value, and registers the field to only hold a date time
     * typed value. After calling this, only date time values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_date_time(flags: MetaFlag, meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value, and registers the field to only hold a double
     * typed value. After calling this, only double values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_double(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value, and registers the field to only hold a float
     * typed value. After calling this, only float values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_float(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value, and registers the field to only hold an int
     * typed value. After calling this, only int values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value, and registers the field to only hold an int64
     * typed value. After calling this, only int64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_int64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value, and registers the field to only hold a string
     * typed value. After calling this, only string values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_string(flags: MetaFlag, meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value, and registers the field to only hold a uint
     * typed value. After calling this, only uint values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value, and registers the field to only hold a uint64
     * typed value. After calling this, only uint64 values can be set for
     * this field. The given flags can be set to make this field only
     * readable after calling this method.
     */
    register_meta_uint64(flags: MetaFlag, meta_item: string, value: number): boolean
    /**
     * Registers a static metadata field on the container to only hold the
     * specified type. After calling this, setting a value under this field
     * can only succeed if its type matches the registered type of the field.
     * 
     * Unlike ges_meta_container_register_meta(), no (initial) value is set
     * for this field, which means you can use this method to reserve the
     * space to be _optionally_ set later.
     * 
     * Note that if a value has already been set for the field being
     * registered, then its type must match the registering type, and its
     * value will be left in place. If the field has no set value, then
     * you will likely want to include #GES_META_WRITABLE in `flags` to allow
     * the value to be set later.
     */
    register_static_meta(flags: MetaFlag, meta_item: string, type: GObject.Type): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given boolean value.
     */
    set_boolean(meta_item: string, value: boolean): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date value.
     */
    set_date(meta_item: string, value: GLib.Date): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given date time value.
     */
    set_date_time(meta_item: string, value: Gst.DateTime): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given double value.
     */
    set_double(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given float value.
     */
    set_float(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int value.
     */
    set_int(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given int64 value.
     */
    set_int64(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given marker list value.
     */
    set_marker_list(meta_item: string, list: MarkerList): boolean
    /**
     * Sets the value of the specified field of the meta container to a
     * copy of the given value. If the given `value` is %NULL, the field
     * given by `meta_item` is removed and %TRUE is returned.
     */
    set_meta(meta_item: string, value?: any | null): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given string value.
     */
    set_string(meta_item: string, value: string): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint value.
     */
    set_uint(meta_item: string, value: number): boolean
    /**
     * Sets the value of the specified field of the meta container to the
     * given uint64 value.
     */
    set_uint64(meta_item: string, value: number): boolean
    /* Virtual methods of GES-1.0.GES.VideoUriSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.VideoSource */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.Source */
    /**
     * Creates the GstElement to put in the source topbin. Other elements will be
     * queued, like a volume. In the case of a AudioUriSource, for example, the
     * subclass will return a decodebin, and we will append a volume.
     */
    vfunc_create_source(): Gst.Element
    /**
     * Check whether `pad` should be exposed/used.
     */
    vfunc_select_pad(pad: Gst.Pad): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /* Virtual methods of GES-1.0.GES.TrackElement */
    /**
     * Notify when the #GESTrackElement:active property changes
     */
    vfunc_active_changed(active: boolean): void
    vfunc_changed(): void
    vfunc_create_element(): Gst.Element
    vfunc_create_gnl_object(): Gst.Element
    /**
     * Looks up which `element` and `pspec` would be effected by the given `name`. If various
     * contained elements have this property name you will get the first one, unless you
     * specify the class name in `name`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    /* Function overloads */
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.TimelineElement */
    vfunc_deep_copy(copy: TimelineElement): void
    /**
     * Gets the priority of the layer the element is in. A #GESGroup may span
     * several layers, so this would return the highest priority (numerically,
     * the smallest) amongst them.
     */
    vfunc_get_layer_priority(): number
    /**
     * Get the "natural" framerate of `self`. This is to say, for example
     * for a #GESVideoUriSource the framerate of the source.
     * 
     * Note that a #GESAudioSource may also have a natural framerate if it derives
     * from the same #GESSourceClip asset as a #GESVideoSource, and its value will
     * be that of the video source. For example, if the uri of a #GESUriClip points
     * to a file that contains both a video and audio stream, then the corresponding
     * #GESAudioUriSource will share the natural framerate of the corresponding
     * #GESVideoUriSource.
     */
    vfunc_get_natural_framerate(): [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    /**
     * Gets the track types that the element can interact with, i.e. the type
     * of #GESTrack it can exist in, or will create #GESTrackElement-s for.
     */
    vfunc_get_track_types(): TrackType
    /**
     * Looks up a child property of the element.
     * 
     * `prop_name` can either be in the format "prop-name" or
     * "TypeName::prop-name", where "prop-name" is the name of the property
     * to look up (as used in g_object_get()), and "TypeName" is the type name
     * of the child (as returned by G_OBJECT_TYPE_NAME()). The latter format is
     * useful when two children of different types share the same property
     * name.
     * 
     * The first child found with the given "prop-name" property that was
     * registered with ges_timeline_element_add_child_property() (and of the
     * type "TypeName", if it was given) will be passed to `child,` and the
     * registered specification of this property will be passed to `pspec`.
     */
    vfunc_lookup_child(prop_name: string): [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Edits the start time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_NONE.
     */
    vfunc_ripple(start: number): boolean
    /**
     * Edits the end time of an element within its timeline in ripple mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_RIPPLE and
     * #GES_EDGE_END.
     */
    vfunc_ripple_end(end: number): boolean
    /**
     * Edits the end time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_END.
     */
    vfunc_roll_end(end: number): boolean
    /**
     * Edits the start time of an element within its timeline in roll mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_ROLL and
     * #GES_EDGE_START.
     */
    vfunc_roll_start(start: number): boolean
    /**
     * Method for setting the child property given by
     * `pspec` on `child` to `value`. Default implementation will use
     * g_object_set_property().
     */
    vfunc_set_child_property(child: GObject.Object, pspec: GObject.ParamSpec, value: any): void
    /**
     * Similar to `set_child_property,` except setting can fail, with the `error`
     * being optionally set. Default implementation will call `set_child_property`
     * and return %TRUE.
     */
    vfunc_set_child_property_full(child: GObject.Object, pspec: GObject.ParamSpec, value: any): boolean
    /**
     * Sets #GESTimelineElement:duration for the element.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_TRIM with #GES_EDGE_END. In particular, the
     * #GESTimelineElement:duration of the element may be snapped to a
     * different timeline time difference from the one given. In addition,
     * setting may fail if it would place the timeline in an unsupported
     * configuration, or the element does not have enough internal content to
     * last the desired duration.
     */
    vfunc_set_duration(duration: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:in-point for the element. If the new in-point
     * is above the current #GESTimelineElement:max-duration of the element,
     * this method will fail.
     */
    vfunc_set_inpoint(inpoint: Gst.ClockTime): boolean
    /**
     * Sets #GESTimelineElement:max-duration for the element. If the new
     * maximum duration is below the current #GESTimelineElement:in-point of
     * the element, this method will fail.
     */
    vfunc_set_max_duration(maxduration: Gst.ClockTime): boolean
    /**
     * Sets the #GESTimelineElement:parent for the element.
     * 
     * This is used internally and you should normally not call this. A
     * #GESContainer will set the #GESTimelineElement:parent of its children
     * in ges_container_add() and ges_container_remove().
     * 
     * Note, if `parent` is not %NULL, `self` must not already have a parent
     * set. Therefore, if you wish to switch parents, you will need to call
     * this function twice: first to set the parent to %NULL, and then to the
     * new parent.
     * 
     * If `parent` is not %NULL, you must ensure it already has a
     * (non-floating) reference to `self` before calling this.
     */
    vfunc_set_parent(parent: TimelineElement): boolean
    /**
     * Sets the priority of the element within the containing layer.
     */
    vfunc_set_priority(priority: number): boolean
    /**
     * Sets #GESTimelineElement:start for the element. If the element has a
     * parent, this will also move its siblings with the same shift.
     * 
     * Whilst the element is part of a #GESTimeline, this is the same as
     * editing the element with ges_timeline_element_edit() under
     * #GES_EDIT_MODE_NORMAL with #GES_EDGE_NONE. In particular, the
     * #GESTimelineElement:start of the element may be snapped to a different
     * timeline time from the one given. In addition, setting may fail if it
     * would place the timeline in an unsupported configuration.
     */
    vfunc_set_start(start: Gst.ClockTime): boolean
    /**
     * Edits the start time of an element within its timeline in trim mode.
     * See ges_timeline_element_edit() with #GES_EDIT_MODE_TRIM and
     * #GES_EDGE_START.
     */
    vfunc_trim(start: number): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.TrackElement */
    /**
     * This is emitted when a control binding is added to a child property
     * of the track element.
     */
    connect(sigName: "control-binding-added", callback: (($obj: VideoUriSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-added", callback: (($obj: VideoUriSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-added", control_binding: Gst.ControlBinding): void
    /**
     * This is emitted when a control binding is removed from a child
     * property of the track element.
     */
    connect(sigName: "control-binding-removed", callback: (($obj: VideoUriSource, control_binding: Gst.ControlBinding) => void)): number
    connect_after(sigName: "control-binding-removed", callback: (($obj: VideoUriSource, control_binding: Gst.ControlBinding) => void)): number
    emit(sigName: "control-binding-removed", control_binding: Gst.ControlBinding): void
    /* Signals of GES-1.0.GES.TimelineElement */
    /**
     * Emitted when the element has a new child property registered. See
     * ges_timeline_element_add_child_property().
     * 
     * Note that some GES elements will be automatically created with
     * pre-registered children properties. You can use
     * ges_timeline_element_list_children_properties() to list these.
     */
    connect(sigName: "child-property-added", callback: (($obj: VideoUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-added", callback: (($obj: VideoUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-added", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when the element has a child property unregistered. See
     * ges_timeline_element_remove_child_property().
     */
    connect(sigName: "child-property-removed", callback: (($obj: VideoUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "child-property-removed", callback: (($obj: VideoUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "child-property-removed", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /**
     * Emitted when a child of the element has one of its registered
     * properties set. See ges_timeline_element_add_child_property().
     * Note that unlike #GObject::notify, a child property name can not be
     * used as a signal detail.
     */
    connect(sigName: "deep-notify", callback: (($obj: VideoUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: VideoUriSource, prop_object: GObject.Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: GObject.Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of GES-1.0.GES.MetaContainer */
    /**
     * This is emitted for a meta container whenever the metadata under one
     * of its fields changes, is set for the first time, or is removed. In
     * the latter case, `value` will be %NULL.
     */
    connect(sigName: "notify-meta", callback: (($obj: VideoUriSource, key: string, value?: any | null) => void)): number
    connect_after(sigName: "notify-meta", callback: (($obj: VideoUriSource, key: string, value?: any | null) => void)): number
    emit(sigName: "notify-meta", key: string, value?: any | null): void
    connect(sigName: "notify::active", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-clamp-control-sources", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::has-internal-source", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-internal-source", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::track-type", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::track-type", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::in-point", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::in-point", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-duration", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-duration", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serialize", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serialize", callback: (($obj: VideoUriSource, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VideoUriSource_ConstructProps)
    _init (config?: VideoUriSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface XmlFormatter_ConstructProps extends BaseXmlFormatter_ConstructProps {
}
class XmlFormatter {
    /* Fields of GES-1.0.GES.BaseXmlFormatter */
    readonly parent: Formatter
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GES-1.0.GES.Formatter */
    /**
     * Load data from the given URI into timeline.
     */
    load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of GES-1.0.GES.Extractable */
    /**
     * Get the asset that has been set on the extractable object.
     */
    get_asset(): Asset | null
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    get_id(): string
    /**
     * Sets the asset for this extractable object.
     * 
     * When an object is extracted from an asset using ges_asset_extract() its
     * asset will be automatically set. Note that many classes that implement
     * #GESExtractable will automatically create their objects using assets
     * when you call their `new` methods. However, you can use this method to
     * associate an object with a compatible asset if it was created by other
     * means and does not yet have an asset. Or, for some implementations of
     * #GESExtractable, you can use this to change the asset of the given
     * extractable object, which will lead to a change in its state to
     * match the new asset #GESAsset:id.
     */
    set_asset(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.XmlFormatter */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.BaseXmlFormatter */
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GES-1.0.GES.Formatter */
    vfunc_can_load_uri(uri: string): boolean
    /**
     * Load data from the given URI into timeline.
     */
    vfunc_load_from_uri(timeline: Timeline, uri: string): boolean
    /**
     * Save data from timeline to the given URI.
     */
    vfunc_save_to_uri(timeline: Timeline, uri: string, overwrite: boolean): boolean
    /**
     * Gets the #GESAsset:id of some associated asset. It may be the case
     * that the object has no set asset, or even that such an asset does not
     * yet exist in the GES cache. Instead, this will return the asset
     * #GESAsset:id that is _compatible_ with the current state of the object,
     * as determined by the #GESExtractable implementer. If it was indeed
     * extracted from an asset, this should return the same as its
     * corresponding asset #GESAsset:id.
     */
    vfunc_get_id(): string
    vfunc_set_asset(asset: Asset): void
    vfunc_set_asset_full(asset: Asset): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: XmlFormatter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: XmlFormatter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: XmlFormatter_ConstructProps)
    _init (config?: XmlFormatter_ConstructProps): void
    static $gtype: GObject.Type
}
abstract class AssetClass {
    /* Fields of GES-1.0.GES.AssetClass */
    readonly parent: GObject.ObjectClass
    readonly start_loading: (self: Asset) => AssetLoadingReturn
    readonly extract: (self: Asset) => Extractable
    readonly inform_proxy: (self: Asset, proxy_id: string) => void
    readonly proxied: (self: Asset, proxy: Asset) => void
    readonly request_id_update: (self: Asset, proposed_new_id: string, error: GLib.Error) => boolean
    readonly _ges_reserved: object[]
    static name: string
}
class AssetPrivate {
    static name: string
}
abstract class AudioSourceClass {
    static name: string
}
class AudioSourcePrivate {
    static name: string
}
abstract class AudioTestSourceClass {
    static name: string
}
class AudioTestSourcePrivate {
    static name: string
}
abstract class AudioTrackClass {
    /* Fields of GES-1.0.GES.AudioTrackClass */
    readonly parent_class: TrackClass
    readonly _ges_reserved: object[]
    static name: string
}
class AudioTrackPrivate {
    static name: string
}
abstract class AudioTransitionClass {
    /* Fields of GES-1.0.GES.AudioTransitionClass */
    readonly parent_class: TransitionClass
    readonly _ges_reserved: object[]
    static name: string
}
class AudioTransitionPrivate {
    static name: string
}
abstract class AudioUriSourceClass {
    static name: string
}
class AudioUriSourcePrivate {
    static name: string
}
abstract class BaseEffectClass {
    static name: string
}
abstract class BaseEffectClipClass {
    static name: string
}
class BaseEffectClipPrivate {
    static name: string
}
class BaseEffectPrivate {
    static name: string
}
abstract class BaseTransitionClipClass {
    static name: string
}
class BaseTransitionClipPrivate {
    static name: string
}
abstract class BaseXmlFormatterClass {
    /* Fields of GES-1.0.GES.BaseXmlFormatterClass */
    readonly parent: FormatterClass
    readonly content_parser: GLib.MarkupParser
    readonly save: (formatter: Formatter, timeline: Timeline) => GLib.String
    readonly _ges_reserved: object[]
    static name: string
}
class BaseXmlFormatterPrivate {
    static name: string
}
abstract class ClipAssetClass {
    /* Fields of GES-1.0.GES.ClipAssetClass */
    readonly parent: AssetClass
    readonly get_natural_framerate: (self: ClipAsset) => [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    readonly _ges_reserved: object[]
    static name: string
}
class ClipAssetPrivate {
    static name: string
}
abstract class ClipClass {
    /* Fields of GES-1.0.GES.ClipClass */
    /**
     * Method to create the core #GESTrackElement of a clip
     * of this class. If a clip of this class may create several track elements per
     * track type, this should be left as %NULL, and
     * GESClipClass::create_track_elements should be used instead. Otherwise, you
     * should implement this class method and leave
     * GESClipClass::create_track_elements as the default implementation
     */
    readonly create_track_element: CreateTrackElementFunc
    /**
     * Method to create the (multiple) core
     * #GESTrackElement-s of a clip of this class. If
     * GESClipClass::create_track_element is implemented, this should be kept as the
     * default implementation
     */
    readonly create_track_elements: CreateTrackElementsFunc
    static name: string
}
class ClipPrivate {
    static name: string
}
abstract class CommandLineFormatterClass {
    /* Fields of GES-1.0.GES.CommandLineFormatterClass */
    readonly parent_class: FormatterClass
    static name: string
}
class CommandLineFormatterPrivate {
    static name: string
}
abstract class ContainerClass {
    /* Fields of GES-1.0.GES.ContainerClass */
    readonly child_added: (container: Container, element: TimelineElement) => void
    readonly child_removed: (container: Container, element: TimelineElement) => void
    readonly add_child: (container: Container, element: TimelineElement) => boolean
    readonly remove_child: (container: Container, element: TimelineElement) => boolean
    readonly ungroup: (container: Container, recursive: boolean) => Container[]
    readonly edit: (container: Container, layers: Layer[] | null, new_layer_priority: number, mode: EditMode, edge: Edge, position: number) => boolean
    static name: string
}
class ContainerPrivate {
    static name: string
}
abstract class EffectAssetClass {
    /* Fields of GES-1.0.GES.EffectAssetClass */
    readonly parent_class: TrackElementAssetClass
    readonly _ges_reserved: object[]
    static name: string
}
class EffectAssetPrivate {
    static name: string
}
abstract class EffectClass {
    /* Methods of GES-1.0.GES.EffectClass */
    /**
     * Register an element that can change the rate at which media is playing.
     * The property type must be float or double, and must be a factor of the
     * rate, i.e. a value of 2.0 must mean that the media plays twice as fast.
     * Several properties may be registered for a single element type,
     * provided they all contribute to the rate as independent factors. For
     * example, this is true for the "GstPitch::rate" and "GstPitch::tempo"
     * properties. These are already registered by default in GES, along with
     * #videorate:rate for #videorate and #scaletempo:rate for #scaletempo.
     * 
     * If such a rate property becomes a child property of a #GESEffect upon
     * its creation (the element is part of its #GESEffect:bin-description),
     * it will be automatically registered as a time property (see
     * ges_base_effect_register_time_property()) and will have its time
     * translation functions set (see
     * ges_base_effect_set_time_translation_funcs()) to use the overall rate
     * of the rate properties. Note that if an effect contains a rate
     * property as well as a non-rate time property, you should ensure to set
     * the time translation functions to some other methods using
     * ges_base_effect_set_time_translation_funcs().
     * 
     * Note, you can obtain a reference to the GESEffectClass using
     * 
     * ```
     *   GES_EFFECT_CLASS (g_type_class_ref (GES_TYPE_EFFECT));
     * ```
     */
    static register_rate_property(klass: Effect | Function | GObject.Type, element_name: string, property_name: string): boolean
    static name: string
}
abstract class EffectClipClass {
    static name: string
}
class EffectClipPrivate {
    static name: string
}
class EffectPrivate {
    static name: string
}
abstract class ExtractableInterface {
    /* Fields of GES-1.0.GES.ExtractableInterface */
    readonly parent: GObject.TypeInterface
    /**
     * The subclass type of #GESAsset that should be created when
     * an asset with the corresponding #GESAsset:extractable-type is
     * requested.
     */
    readonly asset_type: GObject.Type
    /**
     * The method to call to check whether a given ID is valid as
     * an asset #GESAsset:id for the given #GESAsset:extractable-type. The
     * returned ID is the actual #GESAsset:id that is set on the asset. The
     * default implementation will simply always return the type name of the
     * #GESAsset:extractable-type, even if the received ID is %NULL. As such,
     * any given ID is considered valid (or is ignored), but only one is
     * actually ever set on an asset, which means the given
     * #GESAsset:extractable-type can only have one associated asset.
     */
    readonly check_id: ExtractableCheckId
    /**
     * Whether an object of this class can have its
     * #GESAsset change over its lifetime. This should be set to %TRUE if one
     * of the object's parameters that is associated with its ID can change
     * after construction, which would require an asset with a new ID. Note
     * that the subclass is required to handle the requesting and setting of
     * the new asset on the object.
     */
    readonly can_update_asset: boolean
    readonly set_asset: (self: Extractable, asset: Asset) => void
    readonly set_asset_full: (self: Extractable, asset: Asset) => boolean
    readonly get_id: (self: Extractable) => string
    readonly get_real_extractable_type: (wanted_type: GObject.Type, id: string) => GObject.Type
    readonly register_metas: (self: ExtractableInterface, klass: GObject.ObjectClass, asset: Asset) => boolean
    readonly _ges_reserved: object[]
    static name: string
}
abstract class FormatterClass {
    /* Fields of GES-1.0.GES.FormatterClass */
    /**
     * the parent class structure
     */
    readonly parent_class: GObject.InitiallyUnownedClass
    /**
     * Whether the URI can be loaded
     */
    readonly can_load_uri: FormatterCanLoadURIMethod
    /**
     * class method to deserialize data from a URI
     */
    readonly load_from_uri: FormatterLoadFromURIMethod
    /**
     * class method to serialize data to a URI
     */
    readonly save_to_uri: FormatterSaveToURIMethod
    /* Methods of GES-1.0.GES.FormatterClass */
    static register_metas(klass: Formatter | Function | GObject.Type, name: string, description: string, extensions: string, caps: string, version: number, rank: Gst.Rank): void
    static name: string
}
class FormatterPrivate {
    static name: string
}
abstract class GroupClass {
    /* Fields of GES-1.0.GES.GroupClass */
    readonly parent_class: ContainerClass
    readonly _ges_reserved: object[]
    static name: string
}
class GroupPrivate {
    static name: string
}
abstract class ImageSourceClass {
    /* Fields of GES-1.0.GES.ImageSourceClass */
    readonly parent_class: VideoSourceClass
    readonly _ges_reserved: object[]
    static name: string
}
class ImageSourcePrivate {
    static name: string
}
abstract class LayerClass {
    /* Fields of GES-1.0.GES.LayerClass */
    readonly object_added: (layer: Layer, object: Clip) => void
    readonly object_removed: (layer: Layer, object: Clip) => void
    static name: string
}
class LayerPrivate {
    static name: string
}
abstract class MarkerClass {
    /* Fields of GES-1.0.GES.MarkerClass */
    readonly parent_class: GObject.ObjectClass
    static name: string
}
abstract class MarkerListClass {
    /* Fields of GES-1.0.GES.MarkerListClass */
    readonly parent_class: GObject.ObjectClass
    static name: string
}
abstract class MetaContainerInterface {
    /* Fields of GES-1.0.GES.MetaContainerInterface */
    readonly parent_iface: GObject.TypeInterface
    readonly _ges_reserved: object[]
    static name: string
}
abstract class MultiFileSourceClass {
    /* Fields of GES-1.0.GES.MultiFileSourceClass */
    readonly parent_class: VideoSourceClass
    readonly _ges_reserved: object[]
    static name: string
}
class MultiFileSourcePrivate {
    static name: string
}
abstract class OperationClass {
    static name: string
}
abstract class OperationClipClass {
    static name: string
}
class OperationClipPrivate {
    static name: string
}
class OperationPrivate {
    static name: string
}
abstract class OverlayClipClass {
    /* Fields of GES-1.0.GES.OverlayClipClass */
    /**
     * parent class
     */
    readonly parent_class: OperationClipClass
    static name: string
}
class OverlayClipPrivate {
    static name: string
}
abstract class PipelineClass {
    static name: string
}
class PipelinePrivate {
    static name: string
}
abstract class PitiviFormatterClass {
    static name: string
}
class PitiviFormatterPrivate {
    static name: string
}
abstract class ProjectClass {
    /* Fields of GES-1.0.GES.ProjectClass */
    readonly parent_class: AssetClass
    readonly asset_added: (self: Project, asset: Asset) => void
    readonly asset_loading: (self: Project, asset: Asset) => void
    readonly asset_removed: (self: Project, asset: Asset) => void
    readonly missing_uri: (self: Project, error: GLib.Error, wrong_asset: Asset) => string
    readonly loading_error: (self: Project, error: GLib.Error, id: string, extractable_type: GObject.Type) => boolean
    readonly loaded: (self: Project, timeline: Timeline) => boolean
    readonly loading: (self: Project, timeline: Timeline) => void
    readonly _ges_reserved: object[]
    static name: string
}
class ProjectPrivate {
    static name: string
}
abstract class SourceClass {
    /* Fields of GES-1.0.GES.SourceClass */
    readonly select_pad: (source: Source, pad: Gst.Pad) => boolean
    readonly create_source: (source: Source) => Gst.Element
    static name: string
}
abstract class SourceClipAssetClass {
    /* Fields of GES-1.0.GES.SourceClipAssetClass */
    readonly parent_class: ClipAssetClass
    static name: string
}
abstract class SourceClipClass {
    static name: string
}
class SourceClipPrivate {
    static name: string
}
class SourcePrivate {
    static name: string
}
abstract class TestClipClass {
    static name: string
}
class TestClipPrivate {
    static name: string
}
abstract class TextOverlayClass {
    /* Fields of GES-1.0.GES.TextOverlayClass */
    readonly parent_class: OperationClass
    static name: string
}
abstract class TextOverlayClipClass {
    static name: string
}
class TextOverlayClipPrivate {
    static name: string
}
class TextOverlayPrivate {
    static name: string
}
abstract class TimelineClass {
    /* Fields of GES-1.0.GES.TimelineClass */
    /**
     * parent class
     */
    readonly parent_class: Gst.BinClass
    readonly track_added: (timeline: Timeline, track: Track) => void
    readonly track_removed: (timeline: Timeline, track: Track) => void
    readonly layer_added: (timeline: Timeline, layer: Layer) => void
    readonly layer_removed: (timeline: Timeline, layer: Layer) => void
    readonly group_added: (timeline: Timeline, group: Group) => void
    static name: string
}
abstract class TimelineElementClass {
    /* Fields of GES-1.0.GES.TimelineElementClass */
    readonly parent_class: GObject.InitiallyUnownedClass
    readonly set_parent: (self: TimelineElement, parent: TimelineElement) => boolean
    readonly set_start: (self: TimelineElement, start: Gst.ClockTime) => boolean
    readonly set_inpoint: (self: TimelineElement, inpoint: Gst.ClockTime) => boolean
    readonly set_duration: (self: TimelineElement, duration: Gst.ClockTime) => boolean
    readonly set_max_duration: (self: TimelineElement, maxduration: Gst.ClockTime) => boolean
    readonly set_priority: (self: TimelineElement, priority: number) => boolean
    readonly ripple: (self: TimelineElement, start: number) => boolean
    readonly ripple_end: (self: TimelineElement, end: number) => boolean
    readonly roll_start: (self: TimelineElement, start: number) => boolean
    readonly roll_end: (self: TimelineElement, end: number) => boolean
    readonly trim: (self: TimelineElement, start: number) => boolean
    readonly deep_copy: (self: TimelineElement, copy: TimelineElement) => void
    readonly lookup_child: (self: TimelineElement, prop_name: string) => [ /* returnType */ boolean, /* child */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    readonly get_track_types: (self: TimelineElement) => TrackType
    readonly set_child_property: (self: TimelineElement, child: GObject.Object, pspec: GObject.ParamSpec, value: any) => void
    readonly get_layer_priority: (self: TimelineElement) => number
    readonly get_natural_framerate: (self: TimelineElement) => [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    readonly set_child_property_full: (self: TimelineElement, child: GObject.Object, pspec: GObject.ParamSpec, value: any) => boolean
    readonly _ges_reserved: object[]
    static name: string
}
class TimelineElementPrivate {
    static name: string
}
class TimelinePrivate {
    static name: string
}
abstract class TitleClipClass {
    static name: string
}
class TitleClipPrivate {
    static name: string
}
abstract class TitleSourceClass {
    /* Fields of GES-1.0.GES.TitleSourceClass */
    /**
     * parent class
     */
    readonly parent_class: VideoSourceClass
    static name: string
}
class TitleSourcePrivate {
    static name: string
}
abstract class TrackClass {
    static name: string
}
abstract class TrackElementAssetClass {
    /* Fields of GES-1.0.GES.TrackElementAssetClass */
    readonly parent_class: AssetClass
    readonly get_natural_framerate: (self: TrackElementAsset) => [ /* returnType */ boolean, /* framerate_n */ number, /* framerate_d */ number ]
    readonly _ges_reserved: object[]
    static name: string
}
class TrackElementAssetPrivate {
    static name: string
}
abstract class TrackElementClass {
    /* Fields of GES-1.0.GES.TrackElementClass */
    readonly nleobject_factorytype: string
    readonly create_gnl_object: (object: TrackElement) => Gst.Element
    readonly create_element: (object: TrackElement) => Gst.Element
    readonly active_changed: (object: TrackElement, active: boolean) => void
    readonly changed: (object: TrackElement) => void
    readonly lookup_child: (object: TrackElement, prop_name: string) => [ /* returnType */ boolean, /* element */ Gst.Element | null, /* pspec */ GObject.ParamSpec | null ]
    static name: string
}
class TrackElementPrivate {
    static name: string
}
class TrackPrivate {
    static name: string
}
abstract class TransitionClass {
    static name: string
}
abstract class TransitionClipClass {
    static name: string
}
class TransitionClipPrivate {
    static name: string
}
class TransitionPrivate {
    static name: string
}
abstract class UriClipAssetClass {
    /* Fields of GES-1.0.GES.UriClipAssetClass */
    readonly parent_class: SourceClipAssetClass
    readonly discovered: (discoverer: GstPbutils.Discoverer, info: GstPbutils.DiscovererInfo, err: GLib.Error) => void
    /* Methods of GES-1.0.GES.UriClipAssetClass */
    /**
     * Sets the timeout of #GESUriClipAsset loading
     */
    static set_timeout(klass: UriClipAsset | Function | GObject.Type, timeout: Gst.ClockTime): void
    static name: string
}
class UriClipAssetPrivate {
    static name: string
}
abstract class UriClipClass {
    static name: string
}
class UriClipPrivate {
    static name: string
}
class UriSource {
    static name: string
}
abstract class UriSourceAssetClass {
    /* Fields of GES-1.0.GES.UriSourceAssetClass */
    readonly parent_class: TrackElementAssetClass
    readonly _ges_reserved: object[]
    static name: string
}
class UriSourceAssetPrivate {
    static name: string
}
abstract class VideoSourceClass {
    static name: string
}
class VideoSourcePrivate {
    static name: string
}
abstract class VideoTestSourceClass {
    /* Fields of GES-1.0.GES.VideoTestSourceClass */
    readonly parent_class: VideoSourceClass
    readonly _ges_reserved: object[]
    static name: string
}
class VideoTestSourcePrivate {
    static name: string
}
abstract class VideoTrackClass {
    /* Fields of GES-1.0.GES.VideoTrackClass */
    readonly parent_class: TrackClass
    readonly _ges_reserved: object[]
    static name: string
}
class VideoTrackPrivate {
    static name: string
}
abstract class VideoTransitionClass {
    /* Fields of GES-1.0.GES.VideoTransitionClass */
    /**
     * parent class
     */
    readonly parent_class: TransitionClass
    static name: string
}
class VideoTransitionPrivate {
    static name: string
}
abstract class VideoUriSourceClass {
    static name: string
}
class VideoUriSourcePrivate {
    static name: string
}
abstract class XmlFormatterClass {
    /* Fields of GES-1.0.GES.XmlFormatterClass */
    readonly parent: BaseXmlFormatterClass
    readonly _ges_reserved: object[]
    static name: string
}
class XmlFormatterPrivate {
    static name: string
}
    type FrameNumber = number
}
export default GES;