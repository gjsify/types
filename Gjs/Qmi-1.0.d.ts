/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * Qmi-1.0
 */

import type * as Gjs from './Gjs';
import type Gio from './Gio-2.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';

export namespace Qmi {

/**
 * Common errors that may be reported by libqmi-glib.
 */
enum CoreError {
    /**
     * Operation failed.
     */
    FAILED,
    /**
     * Operation cannot be executed in the current state.
     */
    WRONGSTATE,
    /**
     * Operation timed out.
     */
    TIMEOUT,
    /**
     * Invalid arguments given.
     */
    INVALIDARGS,
    /**
     * QMI message is invalid.
     */
    INVALIDMESSAGE,
    /**
     * TLV not found.
     */
    TLVNOTFOUND,
    /**
     * TLV is too long.
     */
    TLVTOOLONG,
    /**
     * Not supported.
     */
    UNSUPPORTED,
    /**
     * TLV has no value. Empty TLVs are not a real error, so this error type is never generated. Since: 1.12. Deprecated: 1.22.
     */
    TLVEMPTY,
    /**
     * QMI message is unexpected. Since: 1.16.
     */
    UNEXPECTEDMESSAGE,
    /**
     * Invalid data found in the message. Since: 1.24.6.
     */
    INVALIDDATA,
}
/**
 * Controls whether the network port data format includes a QoS header or not.
 * Should normally be set to ABSENT.
 */
enum CtlDataFormat {
    /**
     * QoS header absent
     */
    ABSENT,
    /**
     * QoS header present
     */
    PRESENT,
}
/**
 * Determines the network port data format.
 */
enum CtlDataLinkProtocol {
    UNKNOWN,
    /**
     * data frames formatted as 802.3 Ethernet
     */
    TODO_802_3,
    /**
     * data frames are raw IP packets
     */
    RAW_IP,
}
/**
 * Data Endpoint Type.
 */
enum DataEndpointType {
    /**
     * Unknown. Since 1.30.
     */
    UNKNOWN,
    /**
     * High-speed inter-chip interface. Since 1.30.
     */
    HSIC,
    /**
     * High-speed USB.
     */
    HSUSB,
    /**
     * PCIe. Since: 1.28.
     */
    PCIE,
    /**
     * Embedded. Since 1.28.
     */
    EMBEDDED,
    /**
     * BAM/DMUX. Since 1.30.
     */
    BAM_DMUX,
    /**
     * Undefined.
     */
    UNDEFINED,
}
/**
 * Data format expected by the kernel.
 * 
 * <note><para>
 * This type is only applicable when using the qmi_wwan kernel driver.
 * </para></note>
 */
enum DeviceExpectedDataFormat {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * 802.3.
     */
    TODO_802_3,
    /**
     * Raw IP.
     */
    RAW_IP,
    /**
     * QMAP pass-through. Since 1.28.
     */
    QMAP_PASS_THROUGH,
}
/**
 * State of the service activation.
 */
enum DmsActivationState {
    /**
     * Service not activated.
     */
    NOT_ACTIVATED,
    /**
     * Service is activated.
     */
    ACTIVATED,
    /**
     * Connection in progress for automatic activation.
     */
    CONNECTING,
    /**
     * Connection connected for automatic activation.
     */
    CONNECTED,
    /**
     * OTASP security authenticated.
     */
    OTASP_AUTHENTICATED,
    /**
     * OTASP NAM downloaded.
     */
    OTASP_NAM,
    /**
     * OTASP MDN downloaded.
     */
    OTASP_MDN,
    /**
     * OTASP IMSI downloaded.
     */
    OTASP_IMSI,
    /**
     * OTASP PRL downloaded.
     */
    OTASP_PRL,
    /**
     * OTASP SPC downloaded.
     */
    OTASP_SPC,
    /**
     * OTASP settings committed.
     */
    OTASP_COMMITED,
}
/**
 * Specifies the mode for the next boot.
 */
enum DmsBootImageDownloadMode {
    /**
     * Normal operation.
     */
    NORMAL,
    /**
     * Boot and recovery image download mode.
     */
    BOOT_AND_RECOVERY,
}
/**
 * Data service capability.
 */
enum DmsDataServiceCapability {
    /**
     * No data services supported.
     */
    NONE,
    /**
     * Only CS supported.
     */
    CS,
    /**
     * Only PS supported.
     */
    PS,
    /**
     * Simultaneous CS and PS supported.
     */
    SIMULTANEOUS_CS_PS,
    /**
     * Non simultaneous CS and PS supported.
     */
    NON_SIMULTANEOUS_CS_PS,
}
/**
 * Type of firmware image.
 */
enum DmsFirmwareImageType {
    /**
     * Modem image.
     */
    MODEM,
    /**
     * PRI image.
     */
    PRI,
}
/**
 * Foxconn specific device modes.
 */
enum DmsFoxconnDeviceMode {
    /**
     * Unknown mode.
     */
    UNKNOWN,
    /**
     * Fastboot download mode for full partition files.
     */
    FASTBOOT_ONLINE,
    /**
     * Fastboot download mode for OTA files.
     */
    FASTBOOT_OTA,
}
/**
 * Foxconn specific firmware version types.
 */
enum DmsFoxconnFirmwareVersionType {
    /**
     * E.g. T77W968.F0.0.0.2.3.GC.004.
     */
    FIRMWARE_MCFG,
    /**
     * E.g. T77W968.F0.0.0.2.3.GC.004.011.
     */
    FIRMWARE_MCFG_APPS,
    /**
     * E.g. 011.
     */
    APPS,
}
/**
 * HP specific device modes.
 */
enum DmsHpDeviceMode {
    /**
     * Fastboot download mode.
     */
    FASTBOOT,
}
/**
 * Specifies the device from which the MAC address should be queried.
 */
enum DmsMacType {
    /**
     * WLAN MAC address.
     */
    WLAN,
    /**
     * Bluetooth MAC address.
     */
    BT,
}
/**
 * Operating mode of the device.
 */
enum DmsOperatingMode {
    /**
     * Device can acquire a system and make calls.
     */
    ONLINE,
    /**
     * Device has temporarily disabled RF.
     */
    LOW_POWER,
    /**
     * Special mode for manufacturer tests.
     */
    FACTORY_TEST,
    /**
     * Device has deactivated RF and is partially shutdown.
     */
    OFFLINE,
    /**
     * Device is in the process of power cycling.
     */
    RESET,
    /**
     * Device is in the process of shutting down.
     */
    SHUTTING_DOWN,
    /**
     * Device has disabled RF and state persists even after a reset.
     */
    PERSISTENT_LOW_POWER,
    /**
     * Mode-only Low Power.
     */
    MODE_ONLY_LOW_POWER,
    /**
     * Unknown.
     */
    UNKNOWN,
}
/**
 * Radio interface type.
 */
enum DmsRadioInterface {
    /**
     * CDMA2000 1x.
     */
    CDMA20001X,
    /**
     * CDMA2000 HRPD (1xEV-DO)
     */
    EVDO,
    /**
     * GSM.
     */
    GSM,
    /**
     * UMTS.
     */
    UMTS,
    /**
     * LTE.
     */
    LTE,
    /**
     * TDS. Since 1.32.
     */
    TDS,
    /**
     * 5G NR. Since 1.26.
     */
    TODO_5GNR,
}
/**
 * SIM capability.
 */
enum DmsSimCapability {
    /**
     * SIM not supported.
     */
    NOT_SUPPORTED,
    /**
     * SIM is supported.
     */
    SUPPORTED,
}
/**
 * Sierra Wireless USB composition modes.
 */
enum DmsSwiUsbComposition {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * HIP, DM, NMEA, AT, MDM1, MDM2, MDM3, MS.
     */
    TODO_0,
    /**
     * HIP, DM, NMEA, AT, MDM1, MS.
     */
    TODO_1,
    /**
     * HIP, DM, NMEA, AT, NIC1, MS.
     */
    TODO_2,
    /**
     * HIP, DM, NMEA, AT, MDM1, NIC1, MS.
     */
    TODO_3,
    /**
     * HIP, DM, NMEA, AT, NIC1, NIC2, NIC3, MS.
     */
    TODO_4,
    /**
     * HIP, DM, NMEA, AT, ECM1, MS.
     */
    TODO_5,
    /**
     * DM, NMEA, AT, QMI.
     */
    TODO_6,
    /**
     * DM, NMEA, AT, RMNET1, RMNET2, RMNET3.
     */
    TODO_7,
    /**
     * DM, NMEA, AT, MBIM.
     */
    TODO_8,
    /**
     * MBIM.
     */
    TODO_9,
    /**
     * NMEA, MBIM.
     */
    TODO_10,
    /**
     * DM, MBIM.
     */
    TODO_11,
    /**
     * DM, NMEA, MBIM.
     */
    TODO_12,
    /**
     * Dual configuration: USB composition 6 and USB composition 8.
     */
    TODO_13,
    /**
     * Dual configuration: USB composition 6 and USB composition 9.
     */
    TODO_14,
    /**
     * Dual configuration: USB composition 6 and USB composition 10.
     */
    TODO_15,
    /**
     * Dual configuration: USB composition 6 and USB composition 11.
     */
    TODO_16,
    /**
     * Dual configuration: USB composition 6 and USB composition 12.
     */
    TODO_17,
    /**
     * Dual configuration: USB composition 7 and USB composition 8.
     */
    TODO_18,
    /**
     * Dual configuration: USB composition 7 and USB composition 9.
     */
    TODO_19,
    /**
     * Dual configuration: USB composition 7 and USB composition 10.
     */
    TODO_20,
    /**
     * Dual configuration: USB composition 7 and USB composition 11.
     */
    TODO_21,
    /**
     * Dual configuration: USB composition 7 and USB composition 12.
     */
    TODO_22,
}
/**
 * Time reference type.
 */
enum DmsTimeReferenceType {
    /**
     * User time.
     */
    USER,
}
/**
 * Source of the timestamp.
 */
enum DmsTimeSource {
    /**
     * 32 kHz device clock.
     */
    DEVICE,
    /**
     * CDMA network.
     */
    CDMA_NETWORK,
    /**
     * HDR network.
     */
    HDR_NETWORK,
}
/**
 * UIM personalization facilities.
 */
enum DmsUimFacility {
    /**
     * Network personalization facility.
     */
    PN,
    /**
     * Network subset personalization facility.
     */
    PU,
    /**
     * Service provider facility.
     */
    PP,
    /**
     * Corporate personalization facility.
     */
    PC,
    /**
     * UIM personalization facility.
     */
    PF,
}
/**
 * State of the UIM facility.
 */
enum DmsUimFacilityState {
    /**
     * Facility is deactivated.
     */
    DEACTIVATED,
    /**
     * Facility is activated.
     */
    ACTIVATED,
    /**
     * Facility is blocked.
     */
    BLOCKED,
}
/**
 * The PIN identifier.
 */
enum DmsUimPinId {
    /**
     * PIN.
     */
    PIN,
    /**
     * PIN2.
     */
    PIN2,
}
/**
 * The PIN status.
 */
enum DmsUimPinStatus {
    /**
     * Not initialized.
     */
    NOT_INITIALIZED,
    /**
     * Enabled, not verified.
     */
    ENABLED_NOT_VERIFIED,
    /**
     * Enabled, verified.
     */
    ENABLED_VERIFIED,
    /**
     * Disabled.
     */
    DISABLED,
    /**
     * Blocked.
     */
    BLOCKED,
    /**
     * Permanently Blocked.
     */
    PERMANENTLY_BLOCKED,
    /**
     * Unblocked.
     */
    UNBLOCKED,
    /**
     * Changed.
     */
    CHANGED,
}
/**
 * State of the UIM.
 */
enum DmsUimState {
    /**
     * UIM initialization completed.
     */
    INITIALIZATION_COMPLETED,
    /**
     * UIM is locked or failed.
     */
    LOCKED_OR_FAILED,
    /**
     * No UIM in the device.
     */
    NOT_PRESENT,
    /**
     * Reserved, unknown.
     */
    RESERVED,
    /**
     * UIM state currently unavailable.
     */
    UNKNOWN,
}
/**
 * APN type.
 */
enum DsdApnType {
    /**
     * Default/Internet traffic.
     */
    DEFAULT,
    /**
     * IMS.
     */
    IMS,
    /**
     * Multimedia Messaging Service.
     */
    MMS,
    /**
     * Dial Up Network.
     */
    DUN,
    /**
     * Secure User Plane Location.
     */
    SUPL,
    /**
     * High Priority Mobile Data.
     */
    HIPRI,
    /**
     * over the air administration.
     */
    FOTA,
    /**
     * Carrier Branded Services.
     */
    CBS,
    /**
     * Initial Attach.
     */
    IA,
    /**
     * Emergency.
     */
    EMERGENCY,
}
/**
 * Type of endianness.
 */
enum Endian {
    /**
     * Little endian.
     */
    LITTLE,
    /**
     * Big endian.
     */
    BIG,
}
/**
 * Foxconn specific firmware version types.
 */
enum FoxFirmwareVersionType {
    /**
     * E.g. T99W265.F0.0.0.0.1.GC.004.
     */
    FIRMWARE_MCFG,
    /**
     * E.g. T99W265.F0.0.0.0.1.GC.004.001.
     */
    FIRMWARE_MCFG_APPS,
    /**
     * E.g. 001.
     */
    APPS,
}
/**
 * Mode when retrieving a list of stored firmwares.
 */
enum GasFirmwareListingMode {
    /**
     * List only the active firmware.
     */
    ACTIVE_FIRMWARE,
    /**
     * List all stored firmwares.
     */
    ALL_FIRMWARE,
    /**
     * List only specific firmware with condition.
     */
    SPECIFIC_FIRMWARE,
}
/**
 * Peripheral endpoint type.
 */
enum GasUsbCompositionEndpointType {
    /**
     * High-speed USB.
     */
    HSUSB,
    /**
     * High-speed inter-chip interface.
     */
    HSIC,
}
/**
 * State of the engine.
 * 
 * Since 1.22
 */
enum LocEngineState {
    /**
     * On.
     */
    ON,
    /**
     * Off.
     */
    OFF,
}
/**
 * Whether to request a single or periodic fixes.
 * 
 * Since 1.22
 */
enum LocFixRecurrenceType {
    /**
     * Periodic fixes.
     */
    PERIODIC_FIXES,
    /**
     * Single fix.
     */
    SINGLE_FIX,
}
/**
 * Whether a satellite is healthy or unhealthy.
 * 
 * Since 1.22
 */
enum LocHealthStatus {
    /**
     * Unhealthy.
     */
    UNHEALTHY,
    /**
     * Healthy.
     */
    HEALTHY,
}
/**
 * General result of a received indication.
 * 
 * Since 1.22
 */
enum LocIndicationStatus {
    /**
     * Success.
     */
    SUCCESS,
    /**
     * General Failure.
     */
    GENERAL_FAILURE,
    /**
     * Unsupported.
     */
    UNSUPPORTED,
    /**
     * Invalid Parameter.
     */
    INVALID_PARAMETER,
    /**
     * Engine is busy.
     */
    ENGINE_BUSY,
    /**
     * Phone is offline.
     */
    PHONE_OFFLINE,
    /**
     * Timeout.
     */
    TIMEOUT,
}
/**
 * Whether to enable or disable intermediate state reporting.
 */
enum LocIntermediateReportState {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Enable intermediate state reporting.
     */
    ENABLE,
    /**
     * Disable intermediate state reporting.
     */
    DISABLE,
}
/**
 * Location engine lock type.
 */
enum LocLockType {
    /**
     * Do not lock any position sessions.
     */
    NONE,
    /**
     * Lock mobile-initiated position sessions.
     */
    MI,
    /**
     * Lock mobile-terminated position sessions.
     */
    MT,
    /**
     * Lock all position sessions.
     */
    ALL,
}
/**
 * Whether the ephemeris or almanac exist for a satellite.
 * 
 * Since 1.22
 */
enum LocNavigationData {
    /**
     * Has ephemeris.
     */
    EPHEMERIS,
    /**
     * Has almanac.
     */
    ALMANAC,
}
/**
 * Which operation mode to use.
 * 
 * Since 1.22
 */
enum LocOperationMode {
    /**
     * Default.
     */
    DEFAULT,
    /**
     * Mobile Station Based (MSB) A-GPS.
     */
    MSB,
    /**
     * Mobile Station Assisted (MSA) A-GPS.
     */
    MSA,
    /**
     * Standalone.
     */
    STANDALONE,
    /**
     * Cell ID.
     */
    CELLID,
    /**
     * WWAN.
     */
    WWAN,
}
/**
 * Type of predicted orbits data.
 */
enum LocPredictedOrbitsDataFormat {
    /**
     * Qualcomm XTRA database.
     */
    XTRA,
}
/**
 * Reliability of the provided information.
 * 
 * Since 1.22
 */
enum LocReliability {
    /**
     * Not set.
     */
    NOT_SET,
    /**
     * Very low.
     */
    VERY_LOW,
    /**
     * Low.
     */
    LOW,
    /**
     * Medium.
     */
    MEDIUM,
    /**
     * High.
     */
    HIGH,
}
/**
 * Whether the engine searches or tracks a satellite.
 * 
 * Since 1.22
 */
enum LocSatelliteStatus {
    /**
     * Idle.
     */
    IDLE,
    /**
     * Searching.
     */
    SEARCHING,
    /**
     * Tracking.
     */
    TRACKING,
}
/**
 * Server type for Assisted-GPS.
 */
enum LocServerType {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * CDMA Position Determining System.
     */
    CDMA_PDE,
    /**
     * CDMA Mobile Positioning Center.
     */
    CDMA_MPC,
    /**
     * SUPL Location Platform.
     */
    UMTS_SLP,
    /**
     * Custom position determining system.
     */
    CUSTOM_PDE,
}
/**
 * Status of a received session indication.
 * 
 * Since 1.22
 */
enum LocSessionStatus {
    /**
     * Success
     */
    SUCCESS,
    /**
     * Operation in Progress.
     */
    IN_PROGRESS,
    /**
     * General Failure.
     */
    GENERAL_FAILURE,
    /**
     * Timeout.
     */
    TIMEOUT,
    /**
     * User ended.
     */
    USER_ENDED,
    /**
     * Bad Parameter.
     */
    BAD_PARAMETER,
    /**
     * Phone is offline.
     */
    PHONE_OFFLINE,
    /**
     * Engine is locked.
     */
    ENGINE_LOCKED,
}
/**
 * Which location system a satellite is part of.
 * 
 * Since 1.22
 */
enum LocSystem {
    /**
     * GPS.
     */
    GPS,
    /**
     * Galileo.
     */
    GALILEO,
    /**
     * SBAS.
     */
    SBAS,
    /**
     * COMPASS (BeiDou).
     */
    COMPASS,
    /**
     * GLONASS.
     */
    GLONASS,
}
/**
 * Source of the used time.
 * 
 * Since 1.22
 */
enum LocTimeSource {
    /**
     * Invalid.
     */
    INVALID,
    /**
     * Time is set by the 1X system.
     */
    NETWORK_TIME_TRANSFER,
    /**
     * Time is set by WCDMA/GSM time tagging.
     */
    NETWORK_TIME_TAGGING,
    /**
     * Time set by external injection.
     */
    EXTERNAL_INPUT,
    /**
     * Time is set after decoding over-the-air GPS navigation data from one GPS satellite.
     */
    TOW_DECODE,
    /**
     * Time is set after decoding over-the-air GPS navigation data from multiple satellites.
     */
    TOW_CONFIRMED,
    /**
     * Both time of the week and GPS week number are known.
     */
    TOW_AND_WEEK_CONFIRMED,
    /**
     * Time is set by the position engine after the fix is obtained.
     */
    NAVIGATION_SOLUTION,
    /**
     * Time is set by the position engine after performing SFT.
     */
    SOLVE_FOR_TIME,
    /**
     * Time is set after decoding QZSS satellites.
     */
    GLO_TOW_DECODE,
    /**
     * Time is set after transforming the GPS to GLO time.
     */
    TIME_TRANSFORM,
    /**
     * Time is set by the sleep time tag provided by the WCDMA network.
     */
    WCDMA_SLEEP_TIME_TAG,
    /**
     * Time is set by the sleep time tag provided by the GSM network.
     */
    GSM_SLEEP_TIME_TAG,
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Time is derived from the system clock.
     */
    SYSTEM_TIMETICK,
    /**
     * Time set after decoding QZSS satellites.
     */
    QZSS_TOW_DECODE,
    /**
     * Time set after decoding BDS satellites.
     */
    BDS_TOW_DECODE,
}
/**
 * Band classes.
 */
enum NasActiveBand {
    /**
     * Band class 0.
     */
    BC_0,
    /**
     * Band class 1.
     */
    BC_1,
    /**
     * Band class 2.
     */
    BC_2,
    /**
     * Band class 3.
     */
    BC_3,
    /**
     * Band class 4.
     */
    BC_4,
    /**
     * Band class 5.
     */
    BC_5,
    /**
     * Band class 6.
     */
    BC_6,
    /**
     * Band class 7.
     */
    BC_7,
    /**
     * Band class 8.
     */
    BC_8,
    /**
     * Band class 9.
     */
    BC_9,
    /**
     * Band class 10.
     */
    BC_10,
    /**
     * Band class 11.
     */
    BC_11,
    /**
     * Band class 12.
     */
    BC_12,
    /**
     * Band class 13.
     */
    BC_13,
    /**
     * Band class 14.
     */
    BC_14,
    /**
     * Band class 15.
     */
    BC_15,
    /**
     * Band class 16.
     */
    BC_16,
    /**
     * Band class 17.
     */
    BC_17,
    /**
     * Band class 18.
     */
    BC_18,
    /**
     * Band class 19.
     */
    BC_19,
    /**
     * GSM 450.
     */
    GSM_450,
    /**
     * GSM 480.
     */
    GSM_480,
    /**
     * GSM 750.
     */
    GSM_750,
    /**
     * GSM 850.
     */
    GSM_850,
    /**
     * GSM 900 (Extended).
     */
    GSM_900_EXTENDED,
    /**
     * GSM 900 (Primary).
     */
    GSM_900_PRIMARY,
    /**
     * GSM 900 (Railways).
     */
    GSM_900_RAILWAYS,
    /**
     * GSM 1800.
     */
    GSM_DCS_1800,
    /**
     * GSM 1900.
     */
    GSM_PCS_1900,
    /**
     * WCDMA 2100.
     */
    WCDMA_2100,
    /**
     * WCDMA PCS 1900.
     */
    WCDMA_PCS_1900,
    /**
     * WCDMA DCS 1800.
     */
    WCDMA_DCS_1800,
    /**
     * WCDMA 1700 (U.S.).
     */
    WCDMA_1700_US,
    /**
     * WCDMA 850.
     */
    WCDMA_850,
    /**
     * WCDMA 800.
     */
    WCDMA_800,
    /**
     * WCDMA 2600.
     */
    WCDMA_2600,
    /**
     * WCDMA 900.
     */
    WCDMA_900,
    /**
     * WCDMA 1700 (Japan).
     */
    WCDMA_1700_JAPAN,
    /**
     * WCDMA 1500 (Japan).
     */
    WCDMA_1500_JAPAN,
    /**
     * WCDMA 850 (Japan).
     */
    WCDMA_850_JAPAN,
    /**
     * EUTRAN band 1.
     */
    EUTRAN_1,
    /**
     * EUTRAN band 2.
     */
    EUTRAN_2,
    /**
     * EUTRAN band 3.
     */
    EUTRAN_3,
    /**
     * EUTRAN band 4.
     */
    EUTRAN_4,
    /**
     * EUTRAN band 5.
     */
    EUTRAN_5,
    /**
     * EUTRAN band 6.
     */
    EUTRAN_6,
    /**
     * EUTRAN band 7.
     */
    EUTRAN_7,
    /**
     * EUTRAN band 8.
     */
    EUTRAN_8,
    /**
     * EUTRAN band 9.
     */
    EUTRAN_9,
    /**
     * EUTRAN band 10.
     */
    EUTRAN_10,
    /**
     * EUTRAN band 11.
     */
    EUTRAN_11,
    /**
     * EUTRAN band 12.
     */
    EUTRAN_12,
    /**
     * EUTRAN band 13.
     */
    EUTRAN_13,
    /**
     * EUTRAN band 14.
     */
    EUTRAN_14,
    /**
     * EUTRAN band 17.
     */
    EUTRAN_17,
    /**
     * EUTRAN band 18.
     */
    EUTRAN_18,
    /**
     * EUTRAN band 19.
     */
    EUTRAN_19,
    /**
     * EUTRAN band 20.
     */
    EUTRAN_20,
    /**
     * EUTRAN band 21.
     */
    EUTRAN_21,
    /**
     * EUTRAN band 23.
     */
    EUTRAN_23,
    /**
     * EUTRAN band 24.
     */
    EUTRAN_24,
    /**
     * EUTRAN band 25.
     */
    EUTRAN_25,
    /**
     * EUTRAN band 26.
     */
    EUTRAN_26,
    /**
     * EUTRAN band 27.
     */
    EUTRAN_27,
    /**
     * EUTRAN band 28.
     */
    EUTRAN_28,
    /**
     * EUTRAN band 29.
     */
    EUTRAN_29,
    /**
     * EUTRAN band 30.
     */
    EUTRAN_30,
    /**
     * EUTRAN band 31.
     */
    EUTRAN_31,
    /**
     * EUTRAN band 32.
     */
    EUTRAN_32,
    /**
     * EUTRAN band 33.
     */
    EUTRAN_33,
    /**
     * EUTRAN band 34.
     */
    EUTRAN_34,
    /**
     * EUTRAN band 35.
     */
    EUTRAN_35,
    /**
     * EUTRAN band 36.
     */
    EUTRAN_36,
    /**
     * EUTRAN band 37.
     */
    EUTRAN_37,
    /**
     * EUTRAN band 38.
     */
    EUTRAN_38,
    /**
     * EUTRAN band 39.
     */
    EUTRAN_39,
    /**
     * EUTRAN band 40.
     */
    EUTRAN_40,
    /**
     * EUTRAN band 41.
     */
    EUTRAN_41,
    /**
     * EUTRAN band 42.
     */
    EUTRAN_42,
    /**
     * EUTRAN band 43.
     */
    EUTRAN_43,
    /**
     * EUTRAN band 46.
     */
    EUTRAN_46,
    /**
     * EUTRAN band 47.
     */
    EUTRAN_47,
    /**
     * EUTRAN band 48.
     */
    EUTRAN_48,
    /**
     * EUTRAN band 66.
     */
    EUTRAN_66,
    /**
     * EUTRAN band 71.
     */
    EUTRAN_71,
    /**
     * EUTRAN band 125.
     */
    EUTRAN_125,
    /**
     * EUTRAN band 126.
     */
    EUTRAN_126,
    /**
     * EUTRAN band 127.
     */
    EUTRAN_127,
    /**
     * EUTRAN band 250.
     */
    EUTRAN_250,
    /**
     * TD-SCDMA Band A.
     */
    TDSCDMA_A,
    /**
     * TD-SCDMA Band B.
     */
    TDSCDMA_B,
    /**
     * TD-SCDMA Band C.
     */
    TDSCDMA_C,
    /**
     * TD-SCDMA Band D.
     */
    TDSCDMA_D,
    /**
     * TD-SCDMA Band E.
     */
    TDSCDMA_E,
    /**
     * TD-SCDMA Band F.
     */
    TDSCDMA_F,
}
/**
 * Domain attach state.
 */
enum NasAttachState {
    /**
     * Unknown attach state.
     */
    UNKNOWN,
    /**
     * Attached.
     */
    ATTACHED,
    /**
     * Detached.
     */
    DETACHED,
}
/**
 * Boolean flag with validity info.
 */
enum NasBoolean {
    /**
     * Status FALSE.
     */
    FALSE,
    /**
     * Status TRUE.
     */
    TRUE,
    /**
     * Status Unknown.
     */
    UNKNOWN,
}
/**
 * Status of the call barring functionality.
 */
enum NasCallBarringStatus {
    /**
     * Normal calls only.
     */
    NORMAL_ONLY,
    /**
     * Emergency calls only.
     */
    EMERGENCY_ONLY,
    /**
     * No calls allowed.
     */
    NO_CALLS,
    /**
     * All calls allowed.
     */
    ALL_CALLS,
    /**
     * Unknown.
     */
    UNKNOWN,
}
/**
 * The pilot set the pilot belongs to.
 */
enum NasCdmaPilotType {
    /**
     * the pilot is part of the active set.
     */
    ACTIVE,
    /**
     * the pilot is part of the neighbor set.
     */
    NEIGHBOR,
}
/**
 * Flags specifying the preference when using CDMA Band Class 0.
 */
enum NasCdmaPrlPreference {
    /**
     * System A only.
     */
    A_SIDE_ONLY,
    /**
     * System B only.
     */
    B_SIDE_ONLY,
    /**
     * Any system.
     */
    ANY,
}
/**
 * Cell broadcast support.
 */
enum NasCellBroadcastCapability {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Cell broadcast not supported.
     */
    OFF,
    /**
     * Cell broadcast supported.
     */
    ON,
}
/**
 * Duration of the change setting.
 */
enum NasChangeDuration {
    /**
     * Until the next power cycle.
     */
    POWER_CYCLE,
    /**
     * Permanent.
     */
    PERMANENT,
}
/**
 * DL Bandwidth.
 */
enum NasDLBandwidth {
    /**
     * 1.4 MHz
     */
    TODO_1_4,
    /**
     * 3 MHz
     */
    TODO_3,
    /**
     * 5 MHz
     */
    TODO_5,
    /**
     * 10 MHz
     */
    TODO_10,
    /**
     * 15 MHz
     */
    TODO_15,
    /**
     * 20 MHz
     */
    TODO_20,
    /**
     * Invalid
     */
    INVALID,
    /**
     * Unknown
     */
    UNKNOWN,
}
/**
 * Data capability of the network.
 */
enum NasDataCapability {
    /**
     * None or unknown.
     */
    NONE,
    /**
     * GPRS.
     */
    GPRS,
    /**
     * EDGE.
     */
    EDGE,
    /**
     * HSDPA.
     */
    HSDPA,
    /**
     * HSUPA.
     */
    HSUPA,
    /**
     * WCDMA.
     */
    WCDMA,
    /**
     * CDMA.
     */
    CDMA,
    /**
     * EV-DO revision 0.
     */
    EVDO_REV_0,
    /**
     * EV-DO revision A.
     */
    EVDO_REV_A,
    /**
     * GSM.
     */
    GSM,
    /**
     * EV-DO revision B.
     */
    EVDO_REV_B,
    /**
     * LTE.
     */
    LTE,
    /**
     * HSDPA+.
     */
    HSDPA_PLUS,
    /**
     * DC-HSDPA+.
     */
    DC_HSDPA_PLUS,
}
/**
 * The day of the week.
 */
enum NasDayOfWeek {
    /**
     * Monday
     */
    MONDAY,
    /**
     * Tuesday
     */
    TUESDAY,
    /**
     * Wednesday
     */
    WEDNESDAY,
    /**
     * Thursday
     */
    THURSDAY,
    /**
     * Friday
     */
    FRIDAY,
    /**
     * Saturday
     */
    SATURDAY,
    /**
     * Sunday
     */
    SUNDAY,
}
/**
 * The number of hours a time is adjusted for daylight savings.
 */
enum NasDaylightSavingsAdjustment {
    /**
     * no adjustment
     */
    NONE,
    /**
     * one hour adjustment
     */
    ONE_HOUR,
    /**
     * two hours adjustment
     */
    TWO_HOURS,
}
/**
 * DRX setting of the device.
 */
enum NasDrx {
    /**
     * Unknown or not specified.
     */
    UNKNOWN,
    /**
     * CN=6, T=32.
     */
    CN6_T32,
    /**
     * CN=7, T=64.
     */
    CN7_T64,
    /**
     * CN=8, T=128.
     */
    CN8_T128,
    /**
     * CN=9, T=256.
     */
    CN9_T256,
}
/**
 * EV-DO SINR level.
 */
enum NasEvdoSinrLevel {
    /**
     * -9 dB.
     */
    TODO_0,
    /**
     * -6 dB.
     */
    TODO_1,
    /**
     * -4.5 dB.
     */
    TODO_2,
    /**
     * -3 dB.
     */
    TODO_3,
    /**
     * -2 dB.
     */
    TODO_4,
    /**
     * +1 dB.
     */
    TODO_5,
    /**
     * +3 dB.
     */
    TODO_6,
    /**
     * +6 dB.
     */
    TODO_7,
    /**
     * +9 dB.
     */
    TODO_8,
}
/**
 * GSM/WCDMA acquisition order preference.
 */
enum NasGsmWcdmaAcquisitionOrderPreference {
    /**
     * Automatic.
     */
    AUTOMATIC,
    /**
     * GSM first, then WCDMA.
     */
    GSM,
    /**
     * WCDMA first, then GSM.
     */
    WCDMA,
}
/**
 * HDR personality type.
 */
enum NasHdrPersonality {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * HRPD.
     */
    HRPD,
    /**
     * eHRPD.
     */
    EHRPD,
}
/**
 * HDR protocol revision.
 */
enum NasHdrProtocolRevision {
    /**
     * None.
     */
    NONE,
    /**
     * HDR Rel 0.
     */
    REL_0,
    /**
     * HDR Rel A.
     */
    REL_A,
    /**
     * HDR Rel B.
     */
    REL_B,
}
/**
 * Cell access status for LTE calls.
 */
enum NasLteCellAccessStatus {
    /**
     * Access is allowed for normal calls only.
     */
    NORMAL_ONLY,
    /**
     * Access is allowed for emergency calls only.
     */
    EMERGENCY_ONLY,
    /**
     * Access is not allowed for any call type.
     */
    NO_CALLS,
    /**
     * Access is allowed for all call types.
     */
    ALL_CALLS,
    /**
     * Unknown.
     */
    UNKNOWN,
}
/**
 * LTE registration domain.
 */
enum NasLteRegistrationDomain {
    /**
     * Not applicable since the UE is not in "Camp Only" mode.
     */
    NOT_APPLICABLE,
    /**
     * UE is in "Camp Only" mode and the PLMN can provide CS service only.
     */
    CS_ONLY,
    /**
     * UE is in "Camp Only" mode and the PLMN can provide PS service only.
     */
    PS_ONLY,
    /**
     * UE is in "Camp Only" mode and the PLMN can provide CS and PS service.
     */
    CS_PS,
    /**
     * UE is in "Camp Only" mode but the PLMN cannot provide any service.
     */
    LIMITED_SERVICE,
}
/**
 * LTE voice domain.
 */
enum NasLteVoiceDomain {
    /**
     * No voice.
     */
    NONE,
    /**
     * Voice is supported over IMS network.
     */
    IMS,
    /**
     * Voice is supported over the 1X network.
     */
    TODO_1X,
    /**
     * Voice is supported over the 3GPP network.
     */
    TODO_3GPP,
}
/**
 * Setup to define whether the network description should be displayed.
 */
enum NasNetworkDescriptionDisplay {
    /**
     * Don't display.
     */
    NO,
    /**
     * Display.
     */
    YES,
    /**
     * Unknown.
     */
    UNKNOWN,
}
/**
 * Type of encoding used in the network description.
 */
enum NasNetworkDescriptionEncoding {
    /**
     * Unspecified.
     */
    UNSPECIFIED,
    /**
     * ASCII-7.
     */
    ASCII7,
    /**
     * Unicode.
     */
    UNICODE,
    /**
     * GSM 7-bit.
     */
    GSM,
}
/**
 * Network name source.
 */
enum NasNetworkNameSource {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Operator PLMN list and PLMN network name.
     */
    OPERATOR_PLMN_LIST_AND_PLMN_NETWORK_NAME,
    /**
     * Common PCN handset specification and operator name string.
     */
    COMMON_PCN_HANDSET_SPECIFICATION_AND_OPERATOR_NAME_STRING,
    /**
     * Network identity and time zone.
     */
    NITZ,
    /**
     * GSMA SE13 table.
     */
    SE13,
    /**
     * MCC and MNC.
     */
    MCC_MNC,
    /**
     * Service provider name.
     */
    SERVICE_PROVIDER_NAME,
}
/**
 * Type of network registration.
 */
enum NasNetworkRegisterType {
    /**
     * Automatic network registration.
     */
    AUTOMATIC,
    /**
     * Manual network registration.
     */
    MANUAL,
}
/**
 * Network scan result.
 */
enum NasNetworkScanResult {
    /**
     * Success.
     */
    SUCCESS,
    /**
     * Abort.
     */
    ABORT,
    /**
     * Radio link failure.
     */
    RADIO_LINK_FAILURE,
}
/**
 * Network selection preference.
 */
enum NasNetworkSelectionPreference {
    /**
     * Automatic.
     */
    AUTOMATIC,
    /**
     * Manual.
     */
    MANUAL,
}
/**
 * Registration restriction.
 */
enum NasNetworkSelectionRegistrationRestriction {
    /**
     * Device follows the normal registration process.
     */
    UNRESTRICTED,
    /**
     * Device camps on the network according to its provisioning, but does not register.
     */
    CAMPED_ONLY,
    /**
     * Device selects the network for limited service.
     */
    LIMITED,
}
/**
 * Network Service Domain.
 */
enum NasNetworkServiceDomain {
    /**
     * No service.
     */
    NONE,
    /**
     * Circuit switched.
     */
    CS,
    /**
     * Packet switched.
     */
    PS,
    /**
     * Circuit and packet switched.
     */
    CS_PS,
    /**
     * Unknown service.
     */
    UNKNOWN,
}
/**
 * Type of network.
 */
enum NasNetworkType {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * 3GPP2 network.
     */
    TODO_3GPP2,
    /**
     * 3GPP network.
     */
    TODO_3GPP,
}
/**
 * PLMN name encoding schemes.  See 3GPP TS 24.008 section "Network Name
 * information element".
 */
enum NasPlmnEncodingScheme {
    /**
     * GSM default alphabet packed encoding (ETSI GSM 03.38)
     */
    GSM,
    /**
     * UCS-2 little-endian
     */
    UCS2LE,
}
/**
 * Language ID used when encoding the PLMN.
 */
enum NasPlmnLanguageId {
    /**
     * Language Unknown.
     */
    UNKNOWN,
    /**
     * Traditional Chinese.
     */
    ZH_TRAD,
    /**
     * Simplified Chinese.
     */
    ZH_SIMP,
}
/**
 * PLMN name country initials options. See 3GPP TS 24.008
 * section "Network Name information element".
 */
enum NasPlmnNameCountryInitials {
    /**
     * don't add country initials
     */
    INITIALS_DO_NOT_ADD,
    /**
     * add country initials
     */
    INIITALS_ADD,
    /**
     * unspecified
     */
    INIITALS_UNSPECIFIED,
}
/**
 * PLMN name spare bits in last octet of a network name.  See 3GPP TS 24.008
 * section "Network Name information element".
 */
enum NasPlmnNameSpareBits {
    /**
     * unknown
     */
    UNKNOWN,
    /**
     * bit 8 is spare
     */
    BIT_8,
    /**
     * bits 7 - 8 are spare
     */
    BITS_78,
    /**
     * bits 6 - 8 are spare
     */
    BITS_68,
    /**
     * bits 5 - 8 are spare
     */
    BITS_58,
    /**
     * bits 4 - 8 are spare
     */
    BITS_48,
    /**
     * bits 3 - 8 are spare
     */
    BITS_38,
    /**
     * bits 2 - 8 are spare
     */
    BITS_28,
}
/**
 * Duration of the preference setting.
 */
enum NasPreferenceDuration {
    /**
     * Permanent.
     */
    PERMANENT,
    /**
     * Until the next power cycle.
     */
    POWER_CYCLE,
    /**
     * Until end of call.
     */
    ONE_CALL,
    /**
     * Until end of call or a specified time.
     */
    ONE_CALL_OR_TIME,
    /**
     * Internal reason 1, one call.
     */
    INTERNAL_ONE_CALL_1,
    /**
     * Internal reason 2, one call.
     */
    INTERNAL_ONE_CALL_2,
    /**
     * Internal reason 3, one call.
     */
    INTERNAL_ONE_CALL_3,
}
/**
 * Packet Switched domain attach/detach action.
 */
enum NasPsAttachAction {
    /**
     * Attach the PS domain.
     */
    ATTACH,
    /**
     * Detach the PS domain.
     */
    DETACH,
}
/**
 * Radio interface technology.
 */
enum NasRadioInterface {
    /**
     * Not known or not needed.
     */
    UNKNOWN,
    /**
     * None, no service.
     */
    NONE,
    /**
     * CDMA2000 1X.
     */
    CDMA_1X,
    /**
     * CDMA2000 HRPD (1xEV-DO).
     */
    CDMA_1XEVDO,
    /**
     * AMPS.
     */
    AMPS,
    /**
     * GSM.
     */
    GSM,
    /**
     * UMTS.
     */
    UMTS,
    /**
     * LTE.
     */
    LTE,
    /**
     * TD-SCDMA.
     */
    TD_SCDMA,
    /**
     * 5G NR. Since 1.26.
     */
    TODO_5GNR,
}
/**
 * Status of the network registration.
 */
enum NasRegistrationState {
    /**
     * Not registered.
     */
    NOT_REGISTERED,
    /**
     * Registered.
     */
    REGISTERED,
    /**
     * Searching.
     */
    NOT_REGISTERED_SEARCHING,
    /**
     * Registration denied.
     */
    REGISTRATION_DENIED,
    /**
     * Unknown.
     */
    UNKNOWN,
}
/**
 * Reason why a request from the mobile station is rejected by the network.
 * 
 * Defined in 3GPP TS 24.008 in sections 10.5.3.6 and 10.5.5.14 (detailed in
 * annex G) and in 3GPP TS 24.301 in section 9.9.3.9.
 */
enum NasRejectCause {
    /**
     * None.
     */
    NONE,
    /**
     * IMSI unknown in HLR/HSS.
     */
    IMSI_UNKNOWN_IN_HLR,
    /**
     * Illegal MS/UE.
     */
    ILLEGAL_UE,
    /**
     * IMSI unknown in VLR.
     */
    IMSI_UNKNOWN_IN_VLR,
    /**
     * IMEI not accepted.
     */
    IMEI_NOT_ACCEPTED,
    /**
     * Illegal ME.
     */
    ILLEGAL_ME,
    /**
     * GPRS/EPS services not allowed.
     */
    PS_SERVICES_NOT_ALLOWED,
    /**
     * GPRS/EPS and non-GPRS/EPS services not allowed.
     */
    PS_AND_NON_PS_SERVICES_NOT_ALLOWED,
    /**
     * MS/UE identity not derived by network.
     */
    UE_IDENTITY_NOT_DERIVED_BY_NETWORK,
    /**
     * Implicitly detached.
     */
    IMPLICITLY_DETACHED,
    /**
     * PLMN not allowed.
     */
    PLMN_NOT_ALLOWED,
    /**
     * Location/tracking area not allowed.
     */
    LOCATION_AREA_NOT_ALLOWED,
    /**
     * Roaming in location/tracking area not allowed.
     */
    ROAMING_IN_LOCATION_AREA_NOT_ALLOWED,
    /**
     * GPRS/EPS services in location/tracking area not allowed.
     */
    PS_SERVICES_IN_LOCATION_AREA_NOT_ALLOWED,
    /**
     * No suitable cells in location/tracking area.
     */
    NO_SUITABLE_CELLS_IN_LOCATION_AREA,
    /**
     * MSC temporarily not reachable.
     */
    MSC_TEMPORARILY_NOT_REACHABLE,
    /**
     * Network failure.
     */
    NETWORK_FAILURE,
    /**
     * CS domain not available.
     */
    CS_DOMAIN_NOT_AVAILABLE,
    /**
     * ESM failure.
     */
    ESM_FAILURE,
    /**
     * MAC failure.
     */
    MAC_FAILURE,
    /**
     * Synch failure.
     */
    SYNCH_FAILURE,
    /**
     * Congestion.
     */
    CONGESTION,
    /**
     * GSM authentication unacceptable, UE security capabilities mismatch.
     */
    UE_SECURITY_CAPABILITIES_MISMATCH,
    /**
     * Security mode rejected or unspecified.
     */
    SECURITY_MODE_REJECTED_UNSPECIFIED,
    /**
     * CSG not authorized.
     */
    CSG_NOT_AUTHORIZED,
    /**
     * Non-EPS authentication unacceptable.
     */
    NON_EPS_AUTHENTICATION_UNACCEPTABLE,
    /**
     * SMS provided by GPRS in routing area.
     */
    SMS_PROVIDED_BY_GPRS_IN_ROUTING_AREA,
    /**
     * Redirection to 5GCN required.
     */
    REDIRECTION_TO_5GCN_REQUIRED,
    /**
     * Service option not supported.
     */
    SERVICE_OPTION_NOT_SUPPORTED,
    /**
     * Requested service option not subscribed.
     */
    REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED,
    /**
     * Service option temporarily out of order.
     */
    SERVICE_OPTION_TEMPORARILY_OUT_OF_ORDER,
    /**
     * Requested service option not authorized.
     */
    REQUESTED_SERVICE_OPTION_NOT_AUTHORIZED,
    /**
     * Call cannot be identified.
     */
    CALL_CANNOT_BE_IDENTIFIED,
    /**
     * CS service temporarily not available.
     */
    CS_SERVICE_TEMPORARILY_NOT_AVAILABLE,
    /**
     * No EPS bearer context activated.
     */
    NO_EPS_BEARER_CONTEXT_ACTIVATED,
    /**
     * Severe network failure.
     */
    SEVERE_NETWORK_FAILURE,
    /**
     * Retry upon entry 0.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_0,
    /**
     * Retry upon entry 1.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_1,
    /**
     * Retry upon entry 2.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_2,
    /**
     * Retry upon entry 3.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_3,
    /**
     * Retry upon entry 4.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_4,
    /**
     * Retry upon entry 5.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_5,
    /**
     * Retry upon entry 6.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_6,
    /**
     * Retry upon entry 7.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_7,
    /**
     * Retry upon entry 8.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_8,
    /**
     * Retry upon entry 9.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_9,
    /**
     * Retry upon entry 10.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_10,
    /**
     * Retry upon entry 11.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_11,
    /**
     * Retry upon entry 12.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_12,
    /**
     * Retry upon entry 13.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_13,
    /**
     * Retry upon entry 14.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_14,
    /**
     * Retry upon entry 15.
     */
    RETRY_UPON_ENTRY_INTO_NEW_CELL_15,
    /**
     * Semantically incorrect message.
     */
    SEMANTICALLY_INCORRECT_MESSAGE,
    /**
     * Invalid mandatory information.
     */
    INVALID_MANDATORY_INFORMATION,
    /**
     * Message type non existent.
     */
    MESSAGE_TYPE_NON_EXISTENT,
    /**
     * Message type not compatible.
     */
    MESSAGE_TYPE_NOT_COMPATIBLE,
    /**
     * Information element non existent.
     */
    INFORMATION_ELEMENT_NON_EXISTENT,
    /**
     * Conditional information element error.
     */
    CONDITIONAL_INFORMATION_ELEMENT_ERROR,
    /**
     * Message not compatible.
     */
    MESSAGE_NOT_COMPATIBLE,
    /**
     * Unspecified protocol error.
     */
    UNSPECIFIED_PROTOCOL_ERROR,
}
/**
 * Status of the roaming indication.
 */
enum NasRoamingIndicatorStatus {
    /**
     * Roaming.
     */
    ON,
    /**
     * Home.
     */
    OFF,
}
/**
 * Roaming preference.
 */
enum NasRoamingPreference {
    /**
     * Only non-roaming networks.
     */
    OFF,
    /**
     * Only roaming networks.
     */
    NOT_OFF,
    /**
     * Only non-roaming networks or not flashing.
     */
    NOT_FLASHING,
    /**
     * Don't filter by roaming when acquiring networks.
     */
    ANY,
}
/**
 * Roaming status.
 */
enum NasRoamingStatus {
    /**
     * Off.
     */
    OFF,
    /**
     * On.
     */
    ON,
    /**
     * Blinking.
     */
    BLINK,
    /**
     * Out of neighborhood.
     */
    OUT_OF_NEIGHBORHOOD,
    /**
     * Out of building.
     */
    OUT_OF_BUILDING,
    /**
     * Preferred system.
     */
    PREFERRED_SYSTEM,
    /**
     * Available system.
     */
    AVAILABLE_SYSTEM,
    /**
     * Alliance partner.
     */
    ALLIANCE_PARTNER,
    /**
     * Premium partner.
     */
    PREMIUM_PARTNER,
    /**
     * Full service.
     */
    FULL_SERVICE,
    /**
     * Partial service.
     */
    PARTIAL_SERVICE,
    /**
     * Banner on.
     */
    BANNER_ON,
    /**
     * Banner off.
     */
    BANNER_OFF,
}
/**
 * SCell State.
 */
enum NasScellState {
    /**
     * Deconfigured
     */
    DECONFIGURED,
    /**
     * Deactivated
     */
    DEACTIVATED,
    /**
     * Activated
     */
    ACTIVATED,
}
/**
 * Service domain preference.
 */
enum NasServiceDomainPreference {
    /**
     * Circuit-switched only.
     */
    CS_ONLY,
    /**
     * Packet-switched only.
     */
    PS_ONLY,
    /**
     * Circuit-switched and packet-switched.
     */
    CS_PS,
    /**
     * Packet-switched attach.
     */
    PS_ATTACH,
    /**
     * Packet-switched dettach.
     */
    PS_DETACH,
}
/**
 * Status of the service.
 */
enum NasServiceStatus {
    /**
     * No service.
     */
    NONE,
    /**
     * Limited service.
     */
    LIMITED,
    /**
     * Service available.
     */
    AVAILABLE,
    /**
     * Limited regional service.
     */
    LIMITED_REGIONAL,
    /**
     * Device in power save mode.
     */
    POWER_SAVE,
}
/**
 * Reject information of the SIM.
 */
enum NasSimRejectState {
    /**
     * SIM not available.
     */
    UNAVAILABLE,
    /**
     * SIM available.
     */
    AVAILABLE,
    /**
     * SIM invalid for circuit-switched connections.
     */
    CS_INVALID,
    /**
     * SIM invalid for packet-switched connections.
     */
    PS_INVALID,
    /**
     * SIM invalid for circuit-switched and packet-switched connections.
     */
    CS_PS_INVALID,
}
/**
 * EMM connection state state. (Sierra Wireless specific).
 */
enum NasSwiEmmConnectionState {
    /**
     * RRC idle
     */
    RRC_IDLE,
    /**
     * Waiting RRC Cfm
     */
    WAITING_RRC_CFM,
    /**
     * RRC connecting
     */
    RRC_CONNECTING,
    /**
     * RRC releasing
     */
    RRC_RELEASING,
    /**
     * Unknown
     */
    UNKNOWN,
}
/**
 * EMM registration state. (Sierra Wireless specific).
 */
enum NasSwiEmmState {
    /**
     * Deregistered
     */
    DEREGISTERED,
    /**
     * Registration initiated
     */
    REG_INITIATED,
    /**
     * Registered
     */
    REGISTERED,
    /**
     * TAU initiated
     */
    TAU_INITIATED,
    /**
     * SR initiated
     */
    SR_INITIATED,
    /**
     * Deregistration initiated
     */
    DEREG_INITIATED,
    /**
     * Invalid
     */
    INVALID,
    /**
     * Unknown
     */
    UNKNOWN,
}
/**
 * IMS registration state. (Sierra Wireless specific).
 */
enum NasSwiImsRegState {
    /**
     * No service
     */
    NO_SRV,
    /**
     * In prog
     */
    IN_PROG,
    /**
     * Failed
     */
    FAILED,
    /**
     * Limited
     */
    LIMITED,
    /**
     * Full service
     */
    FULL_SRV,
    /**
     * Unknown
     */
    _UNKNOWN,
}
/**
 * Modem mode (Sierra Wireless specific).
 */
enum NasSwiModemMode {
    /**
     * Powering off
     */
    POWERING_OFF,
    /**
     * Factory test
     */
    FACTORY_TEST,
    /**
     * Offline
     */
    OFFLINE,
    /**
     * Offline AMPS
     */
    OFFLINE_AMPS,
    /**
     * Offline CDMA
     */
    OFFLINE_CDMA,
    /**
     * Online
     */
    ONLINE,
    /**
     * Low power
     */
    LOW_POWER,
    /**
     * Resetting
     */
    RESETTING,
    /**
     * Network test
     */
    NETWORK_TEST,
    /**
     * Offline request
     */
    OFFLINE_REQUEST,
    /**
     * Pseudo online
     */
    PSEUDO_ONLINE,
    /**
     * Resetting modem
     */
    RESETTING_MODEM,
    /**
     * Unknown
     */
    UNKNOWN,
}
/**
 * PS registration state. (Sierra Wireless specific).
 */
enum NasSwiPsState {
    /**
     * Attached
     */
    ATTACHED,
    /**
     * Detached
     */
    DETACHED,
    /**
     * Unknown
     */
    UNKNOWN,
}
/**
 * System mode (Sierra Wireless specific).
 */
enum NasSwiSystemMode {
    /**
     * No service
     */
    NO_SERVICE,
    /**
     * AMPS
     */
    AMPS,
    /**
     * CDMA
     */
    CDMA,
    /**
     * GSM
     */
    GSM,
    /**
     * HDR
     */
    HDR,
    /**
     * WCDMA
     */
    WCDMA,
    /**
     * GPS
     */
    GPS,
    /**
     * WLAN
     */
    WLAN,
    /**
     * LTE
     */
    LTE,
    /**
     * Unknown
     */
    UNKNOWN,
}
/**
 * Modem usage preference.
 */
enum NasUsagePreference {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Voice centric.
     */
    VOICE_CENTRIC,
    /**
     * Data centric.
     */
    DATA_CENTRIC,
}
/**
 * Voice domain preference.
 */
enum NasVoiceDomainPreference {
    /**
     * Circuit-switched voice only
     */
    CS_ONLY,
    /**
     * Packet-switched voice only.
     */
    PS_ONLY,
    /**
     * Circuit-switched voice is preferred.
     */
    CS_PREFERRED,
    /**
     * Packet-switched voice is preferred.
     */
    PS_PREFERRED,
}
/**
 * Call status on high speed.
 */
enum NasWcdmaHsService {
    /**
     * HSDPA and HSUPA not supported.
     */
    HSDPA_HSUPA_UNSUPPORTED,
    /**
     * HSDPA supported.
     */
    HSDPA_SUPPORTED,
    /**
     * HSUPA supported.
     */
    HSUPA_SUPPORTED,
    /**
     * HSDPA and HSUPA supported.
     */
    HSDPA_HSUPA_SUPPORTED,
    /**
     * HSDPA+ supported.
     */
    HSDPA_PLUS_SUPPORTED,
    /**
     * HSDPA+ and HSUPA supported.
     */
    HSDPA_PLUS_HSUPA_SUPPORTED,
    /**
     * DC-HSDPA+ supported.
     */
    DC_HSDPA_PLUS_SUPPORTED,
    /**
     * DC-HSDPA+ and HSUPA supported.
     */
    DC_HSDPA_PLUS_HSUPA_SUPPORTED,
}
/**
 * RRC state.
 */
enum NasWcdmaRrcState {
    /**
     * Disconnected.
     */
    DISCONNECTED,
    /**
     * WCDMA RRC state is CELL_PCH.
     */
    CELL_PCH,
    /**
     * WCDMA RRC state is URA_PCH.
     */
    URA_PCH,
    /**
     * WCDMA RRC state is CELL_FACH.
     */
    CELL_FACH,
    /**
     * WCDMA RRC state is CELL_DCH.
     */
    CELL_DCH,
}
/**
 * HFA feature done state.
 */
enum OmaHfaFeatureDoneState {
    /**
     * None.
     */
    NONE,
    /**
     * Succeeded.
     */
    SUCCEEDED,
    /**
     * Failed.
     */
    FAILED,
}
/**
 * Session failure reason.
 */
enum OmaSessionFailedReason {
    /**
     * Unknown reason.
     */
    UNKNOWN,
    /**
     * Network unavailable.
     */
    NETWORK_UNAVAILABLE,
    /**
     * Server unavailable.
     */
    SERVER_UNAVAILABLE,
    /**
     * Authentication failed.
     */
    AUTHENTICATION_FAILED,
    /**
     * Maximum retries exceeded.
     */
    MAX_RETRY_EXCEEDED,
    /**
     * Session cancelled.
     */
    SESSION_CANCELLED,
}
/**
 * State of the OMA-DM session.
 */
enum OmaSessionState {
    /**
     * Session complete and information updated.
     */
    COMPLETE_INFORMATION_UPDATED,
    /**
     * Session complete but updated information not available.
     */
    COMPLETE_UPDATED_INFORMATION_UNAVAILABLE,
    /**
     * Session failed.
     */
    FAILED,
    /**
     * Session retrying.
     */
    RETRYING,
    /**
     * Session connecting.
     */
    CONNECTING,
    /**
     * Session connected.
     */
    CONNECTED,
    /**
     * Session authenticated.
     */
    AUTHENTICATED,
    /**
     * MDN downloaded.
     */
    MDN_DOWNLOADED,
    /**
     * MSID downloaded.
     */
    MSID_DOWNLOADED,
    /**
     * PRL downloaded.
     */
    PRL_DOWNLOADED,
    /**
     * MIP profile downloaded.
     */
    MIP_PROFILE_DOWNLOADED,
}
/**
 * Type of OMA-DM session.
 */
enum OmaSessionType {
    /**
     * Client-initiated device configure.
     */
    CLIENT_INITIATED_DEVICE_CONFIGURE,
    /**
     * Client-initiated PRL update.
     */
    CLIENT_INITIATED_PRL_UPDATE,
    /**
     * Client-initiated hands free activation.
     */
    CLIENT_INITIATED_HANDS_FREE_ACTIVATION,
    /**
     * Device-initiated hands free activation.
     */
    DEVICE_INITIATED_HANDS_FREE_ACTIVATION,
    /**
     * Network-initiated PRL update.
     */
    NETWORK_INITIATED_PRL_UPDATE,
    /**
     * Network-initiated device configure.
     */
    NETWORK_INITIATED_DEVICE_CONFIGURE,
    /**
     * Device-initiated PRL update.
     */
    DEVICE_INITIATED_PRL_UPDATE,
}
/**
 * Type of phonebook management session.
 */
enum PbmSessionType {
    /**
     * Access phonebooks under GSM DF (ICC) or USIM application (UICC).
     */
    GW_PRIMARY,
    /**
     * Access phonebooks under CDMA DF (ICC) or CSIM application (UICC).
     */
    TODO_1X_PRIMARY,
    /**
     * Access phonebooks under GSM DF (ICC) or USIM application (UICC). Dual standby.
     */
    GW_SECONDARY,
    /**
     * Access phonebooks under CDMA DF (ICC) or CSIM application (UICC). Dual standby.
     */
    TODO_1X_SECONDARY,
    /**
     * Access phonebooks under a nonprovisioning application in slot 1.
     */
    NONPROVISIONING_SLOT_1,
    /**
     * Access phonebooks under a nonprovisioning application in slot 2.
     */
    NONPROVISIONING_SLOT_2,
    /**
     * Access phonebooks that are not in any application of the card in slot 1.
     */
    GLOBAL_PHONEBOOK_SLOT_1,
    /**
     * Access phonebooks that are not in any application of the card in slot 2.
     */
    GLOBAL_PHONEBOOK_SLOT_2,
}
/**
 * Configuration type for change/load configuration.
 */
enum PdcConfigurationType {
    /**
     * Platform
     */
    PLATFORM,
    /**
     * Software
     */
    SOFTWARE,
}
/**
 * Refresh event type.
 */
enum PdcRefreshEventType {
    /**
     * Refresh start event
     */
    START,
    /**
     * Refresh complete event
     */
    COMPLETE,
    /**
     * Client refresh event
     */
    CLIENT_REFRESH,
}
/**
 * Network mode used during the A-GPS setup.
 */
enum PdsNetworkMode {
    /**
     * UMTS.
     */
    UMTS,
    /**
     * CDMA.
     */
    CDMA,
}
/**
 * GPS operating mode.
 */
enum PdsOperatingMode {
    /**
     * Standalone (GPS only).
     */
    STANDALONE,
    /**
     * Mobile Station Based (MSB) A-GPS
     */
    MS_BASED,
    /**
     * Mobile Station Assisted (MSA) A-GPS.
     */
    MS_ASSISTED,
}
/**
 * Operation mode used to compute the position.
 */
enum PdsOperationMode {
    /**
     * Unknown (position not fixed yet).
     */
    UNKNOWN,
    /**
     * Standalone.
     */
    STANDALONE,
    /**
     * Mobile Station Based (MSB) A-GPS.
     */
    MS_BASED,
    /**
     * Mobile Station Assisted (MSA) A-GPS.
     */
    MS_ASSISTED,
}
/**
 * Status of the positioning session.
 */
enum PdsPositionSessionStatus {
    /**
     * Success.
     */
    SUCCESS,
    /**
     * In progress.
     */
    IN_PROGRESS,
    /**
     * General failure.
     */
    GENERAL_FAILURE,
    /**
     * Timeout.
     */
    TIMEOUT,
    /**
     * User ended session.
     */
    USER_ENDED_SESSION,
    /**
     * Bad parameter.
     */
    BAD_PARAMETER,
    /**
     * Phone is offline.
     */
    PHONE_OFFLINE,
    /**
     * Engine locked.
     */
    ENGINE_LOCKED,
    /**
     * Emergency call in progress.
     */
    E911_SESSION_IN_PROGRESS,
}
/**
 * State of the tracking session.
 */
enum PdsTrackingSessionState {
    /**
     * Unknown state.
     */
    UNKNOWN,
    /**
     * Session inactive.
     */
    INACTIVE,
    /**
     * Session active.
     */
    ACTIVE,
}
/**
 * QMI protocol errors.
 */
enum ProtocolError {
    /**
     * No error.
     */
    NONE,
    /**
     * Malformed message.
     */
    MALFORMEDMESSAGE,
    /**
     * No memory.
     */
    NOMEMORY,
    /**
     * Internal.
     */
    INTERNAL,
    /**
     * Aborted.
     */
    ABORTED,
    /**
     * Client IDs exhausted.
     */
    CLIENTIDSEXHAUSTED,
    /**
     * Unabortable transaction.
     */
    UNABORTABLETRANSACTION,
    /**
     * Invalid client ID.
     */
    INVALIDCLIENTID,
    /**
     * No thresholds provided.
     */
    NOTHRESHOLDSPROVIDED,
    /**
     * Invalid handle.
     */
    INVALIDHANDLE,
    /**
     * Invalid profile.
     */
    INVALIDPROFILE,
    /**
     * Invalid PIN ID.
     */
    INVALIDPINID,
    /**
     * Incorrect PIN.
     */
    INCORRECTPIN,
    /**
     * No network found.
     */
    NONETWORKFOUND,
    /**
     * Call failed.
     */
    CALLFAILED,
    /**
     * Out of call.
     */
    OUTOFCALL,
    /**
     * Not provisioned.
     */
    NOTPROVISIONED,
    /**
     * Missing argument.
     */
    MISSINGARGUMENT,
    /**
     * Argument too long.
     */
    ARGUMENTTOOLONG,
    /**
     * Invalid transaction ID.
     */
    INVALIDTRANSACTIONID,
    /**
     * Device in use.
     */
    DEVICEINUSE,
    /**
     * Network unsupported.
     */
    NETWORKUNSUPPORTED,
    /**
     * Device unsupported.
     */
    DEVICEUNSUPPORTED,
    /**
     * No effect.
     */
    NOEFFECT,
    /**
     * No free profile.
     */
    NOFREEPROFILE,
    /**
     * Invalid PDP type.
     */
    INVALIDPDPTYPE,
    /**
     * Invalid technology preference.
     */
    INVALIDTECHNOLOGYPREFERENCE,
    /**
     * Invalid profile type.
     */
    INVALIDPROFILETYPE,
    /**
     * Invalid service type.
     */
    INVALIDSERVICETYPE,
    /**
     * Invalid register action.
     */
    INVALIDREGISTERACTION,
    /**
     * Invalid PS attach action.
     */
    INVALIDPSATTACHACTION,
    /**
     * Authentication failed.
     */
    AUTHENTICATIONFAILED,
    /**
     * PIN blocked.
     */
    PINBLOCKED,
    /**
     * PIN always blocked.
     */
    PINALWAYSBLOCKED,
    /**
     * UIM uninitialized.
     */
    UIMUNINITIALIZED,
    /**
     * Maximum QoS requests in use.
     */
    MAXIMUMQOSREQUESTSINUSE,
    /**
     * Incorrect flow filter.
     */
    INCORRECTFLOWFILTER,
    /**
     * Network QoS unaware.
     */
    NETWORKQOSUNAWARE,
    /**
     * Invalid QoS ID.
     */
    INVALIDQOSID,
    /**
     * Requested number unsupported. Since: 1.22.
     */
    REQUESTEDNUMBERUNSUPPORTED,
    /**
     * Interface not found. Since: 1.22.
     */
    INTERFACENOTFOUND,
    /**
     * Flow suspended.
     */
    FLOWSUSPENDED,
    /**
     * Invalid data format. Since: 1.22.
     */
    INVALIDDATAFORMAT,
    /**
     * General error.
     */
    GENERALERROR,
    /**
     * Unknown error.
     */
    UNKNOWNERROR,
    /**
     * Invalid argument.
     */
    INVALIDARGUMENT,
    /**
     * Invalid index.
     */
    INVALIDINDEX,
    /**
     * No entry.
     */
    NOENTRY,
    /**
     * Device storage full.
     */
    DEVICESTORAGEFULL,
    /**
     * Device not ready.
     */
    DEVICENOTREADY,
    /**
     * Network not ready.
     */
    NETWORKNOTREADY,
    /**
     * WMS cause code.
     */
    WMSCAUSECODE,
    /**
     * WMS message not sent.
     */
    WMSMESSAGENOTSENT,
    /**
     * WMS message delivery failure.
     */
    WMSMESSAGEDELIVERYFAILURE,
    /**
     * WMS invalid message ID.
     */
    WMSINVALIDMESSAGEID,
    /**
     * WMS encoding.
     */
    WMSENCODING,
    /**
     * Authentication lock.
     */
    AUTHENTICATIONLOCK,
    /**
     * Invalid transition.
     */
    INVALIDTRANSITION,
    /**
     * Not a multicast interface. Since: 1.22.
     */
    NOTMCASTINTERFACE,
    /**
     * Maximum multicast requests in use. Since: 1.22.
     */
    MAXIMUMMCASTREQUESTSINUSE,
    /**
     * Invalid mulitcast handle. Since: 1.22.
     */
    INVALIDMCASTHANDLE,
    /**
     * Invalid IP family preference. Since: 1.22.
     */
    INVALIDIPFAMILYPREFERENCE,
    /**
     * Session inactive.
     */
    SESSIONINACTIVE,
    /**
     * Session invalid.
     */
    SESSIONINVALID,
    /**
     * Session ownership.
     */
    SESSIONOWNERSHIP,
    /**
     * Insufficient resources.
     */
    INSUFFICIENTRESOURCES,
    /**
     * Disabled.
     */
    DISABLED,
    /**
     * Invalid operation.
     */
    INVALIDOPERATION,
    /**
     * Invalid QMI command.
     */
    INVALIDQMICOMMAND,
    /**
     * WMS T-PDU type.
     */
    WMSTPDUTYPE,
    /**
     * WMS SMSC address.
     */
    WMSSMSCADDRESS,
    /**
     * Information unavailable.
     */
    INFORMATIONUNAVAILABLE,
    /**
     * Segment too long.
     */
    SEGMENTTOOLONG,
    /**
     * Segment order.
     */
    SEGMENTORDER,
    /**
     * Bundling not supported.
     */
    BUNDLINGNOTSUPPORTED,
    /**
     * Operation partial failure. Since: 1.22.
     */
    OPERATIONPARTIALFAILURE,
    /**
     * Policy mismatch. Since: 1.6.
     */
    POLICYMISMATCH,
    /**
     * SIM file not found.
     */
    SIMFILENOTFOUND,
    /**
     * Extended internal error. Since: 1.6.
     */
    EXTENDEDINTERNAL,
    /**
     * Access denied.
     */
    ACCESSDENIED,
    /**
     * Hardware restricted.
     */
    HARDWARERESTRICTED,
    /**
     * ACK not sent. Since: 1.6.
     */
    ACKNOTSENT,
    /**
     * Inject timeout. Since: 1.6.
     */
    INJECTTIMEOUT,
    /**
     * Incompatible state. Since: 1.6.
     */
    INCOMPATIBLESTATE,
    /**
     * FDN restrict. Since: 1.6.
     */
    FDNRESTRICT,
    /**
     * SUPS failure case. Since: 1.6.
     */
    SUPSFAILURECASE,
    /**
     * No radio. Since: 1.6.
     */
    NORADIO,
    /**
     * Not supported. Since: 1.6.
     */
    NOTSUPPORTED,
    /**
     * No subscription. Since: 1.6.
     */
    NOSUBSCRIPTION,
    /**
     * Card call control failed. Since: 1.6.
     */
    CARDCALLCONTROLFAILED,
    /**
     * Network aborted. Since: 1.6.
     */
    NETWORKABORTED,
    /**
     * Message blocked. Since: 1.6.
     */
    MSGBLOCKED,
    /**
     * Invalid session type. Since: 1.6.
     */
    INVALIDSESSIONTYPE,
    /**
     * Invalid PB type. Since: 1.6.
     */
    INVALIDPBTYPE,
    /**
     * No SIM. Since: 1.6.
     */
    NOSIM,
    /**
     * PB not ready. Since: 1.6.
     */
    PBNOTREADY,
    /**
     * PIN restriction. Since: 1.6.
     */
    PINRESTRICTION,
    /**
     * PIN2 restriction. Since: 1.6.
     */
    PIN1RESTRICTION,
    /**
     * PUK restriction. Since: 1.6.
     */
    PUKRESTRICTION,
    /**
     * PUK2 restriction. Since: 1.6.
     */
    PUK2RESTRICTION,
    /**
     * PB access restricted. Since: 1.6.
     */
    PBACCESSRESTRICTED,
    /**
     * PB delete in progress. Since: 1.22.
     */
    PBDELETEINPROGRESS,
    /**
     * PB text too long. Since: 1.6.
     */
    PBTEXTTOOLONG,
    /**
     * PB number too long. Since: 1.6.
     */
    PBNUMBERTOOLONG,
    /**
     * PB hidden key restriction. Since: 1.6.
     */
    PBHIDDENKEYRESTRICTION,
    /**
     * PB not available. Since: 1.22.
     */
    PBNOTAVAILABLE,
    /**
     * Device memory error. Since: 1.22.
     */
    DEVICEMEMORYERROR,
    /**
     * No permission. Since: 1.22.
     */
    NOPERMISSION,
    /**
     * Too soon. Since: 1.22.
     */
    TOOSOON,
    /**
     * Time not acquired. Since: 1.22.
     */
    TIMENOTACQUIRED,
    /**
     * Operation in progress. Since: 1.22.
     */
    OPERATIONINPROGRESS,
    /**
     * Firmware write failed. Since: 1.22.
     */
    FWWRITEFAILED,
    /**
     * Firmware info read failed. Since: 1.22.
     */
    FWINFOREADFAILED,
    /**
     * Firmware file not found. Since: 1.22.
     */
    FWFILENOTFOUND,
    /**
     * Firmware dir not found. Since: 1.22.
     */
    FWDIRNOTFOUND,
    /**
     * Firmware already activated. Since: 1.22.
     */
    FWALREADYACTIVATED,
    /**
     * Firmware cannot generic image. Since: 1.22.
     */
    FWCANNOTGENERICIMAGE,
    /**
     * Firmware file open failed. Since: 1.22.
     */
    FWFILEOPENFAILED,
    /**
     * Firmware update discontinuous frame. Since: 1.22.
     */
    FWUPDATEDISCONTINUOUSFRAME,
    /**
     * Firmware update failed. Since: 1.22.
     */
    FWUPDATEFAILED,
    /**
     * Event registration failed.
     */
    CATEVENTREGISTRATIONFAILED,
    /**
     * Invalid terminal response.
     */
    CATINVALIDTERMINALRESPONSE,
    /**
     * Invalid envelope command.
     */
    CATINVALIDENVELOPECOMMAND,
    /**
     * Envelope command busy.
     */
    CATENVELOPECOMMANDBUSY,
    /**
     * Envelope command failed.
     */
    CATENVELOPECOMMANDFAILED,
}
/**
 * QoS event.
 */
enum QosEvent {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Activated.
     */
    ACTIVATED,
    /**
     * Suspended.
     */
    SUSPENDED,
    /**
     * Gone.
     */
    GONE,
    /**
     * Modify accepted.
     */
    MODIFY_ACCEPTED,
    /**
     * Modify rejected.
     */
    MODIFY_REJECTED,
    /**
     * Information code updated.
     */
    INFO_CODE_UPDATED,
}
/**
 * QoS flow status.
 */
enum QosStatus {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Activated.
     */
    ACTIVATED,
    /**
     * Suspended.
     */
    SUSPENDED,
    /**
     * Gone.
     */
    GONE,
}
/**
 * SAR RF state. Each RF state corresponds to a TX power, and the mapping between TX power and RF state is dictated by NV items.
 */
enum SarRfState {
    /**
     * RF State 0
     */
    TODO_0,
    /**
     * RF State 1
     */
    TODO_1,
    /**
     * RF State 2
     */
    TODO_2,
    /**
     * RF State 3
     */
    TODO_3,
    /**
     * RF State 4
     */
    TODO_4,
    /**
     * RF State 5
     */
    TODO_5,
    /**
     * RF State 6
     */
    TODO_6,
    /**
     * RF State 7
     */
    TODO_7,
    /**
     * RF State 8
     */
    TODO_8,
    /**
     * RF State 9
     */
    TODO_9,
    /**
     * RF State 10
     */
    TODO_10,
    /**
     * RF State 11
     */
    TODO_11,
    /**
     * RF State 12
     */
    TODO_12,
    /**
     * RF State 13
     */
    TODO_13,
    /**
     * RF State 14
     */
    TODO_14,
    /**
     * RF State 15
     */
    TODO_15,
    /**
     * RF State 16
     */
    TODO_16,
    /**
     * RF State 17
     */
    TODO_17,
    /**
     * RF State 18
     */
    TODO_18,
    /**
     * RF State 19
     */
    TODO_19,
    /**
     * RF State 20
     */
    TODO_20,
}
/**
 * QMI services.
 */
enum Service {
    /**
     * Unknown service.
     */
    UNKNOWN,
    /**
     * Control service.
     */
    CTL,
    /**
     * Wireless Data Service.
     */
    WDS,
    /**
     * Device Management Service.
     */
    DMS,
    /**
     * Network Access Service.
     */
    NAS,
    /**
     * Quality Of Service service.
     */
    QOS,
    /**
     * Wireless Messaging Service.
     */
    WMS,
    /**
     * Position Determination Service.
     */
    PDS,
    /**
     * Authentication service.
     */
    AUTH,
    /**
     * AT service.
     */
    AT,
    /**
     * Voice service.
     */
    VOICE,
    /**
     * Card Application Toolkit service (v2).
     */
    CAT2,
    /**
     * User Identity Module service.
     */
    UIM,
    /**
     * Phonebook Management service.
     */
    PBM,
    /**
     * QCHAT service. Since: 1.8.
     */
    QCHAT,
    /**
     * Remote file system service.
     */
    RMTFS,
    /**
     * Test service. Since: 1.8.
     */
    TEST,
    /**
     * Location service (~ PDS v2).
     */
    LOC,
    /**
     * Service access proxy service.
     */
    SAR,
    /**
     * IMS settings service. Since: 1.8.
     */
    IMS,
    /**
     * Analog to digital converter driver service. Since: 1.8.
     */
    ADC,
    /**
     * Core sound driver service. Since: 1.8.
     */
    CSD,
    /**
     * Modem embedded file system service. Since: 1.8.
     */
    MFS,
    /**
     * Time service. Since: 1.8.
     */
    TIME,
    /**
     * Thermal sensors service. Since: 1.8.
     */
    TS,
    /**
     * Thermal mitigation device service. Since: 1.8.
     */
    TMD,
    /**
     * Service access proxy service. Since: 1.8.
     */
    SAP,
    /**
     * Wireless data administrative service. Since: 1.8.
     */
    WDA,
    /**
     * TSYNC control service. Since: 1.8.
     */
    TSYNC,
    /**
     * Remote file system access service. Since: 1.8.
     */
    RFSA,
    /**
     * Circuit switched videotelephony service. Since: 1.8.
     */
    CSVT,
    /**
     * Qualcomm mobile access point service. Since: 1.8.
     */
    QCMAP,
    /**
     * IMS presence service. Since: 1.8.
     */
    IMSP,
    /**
     * IMS videotelephony service. Since: 1.8.
     */
    IMSVT,
    /**
     * IMS application service. Since: 1.8.
     */
    IMSA,
    /**
     * Coexistence service. Since: 1.8.
     */
    COEX,
    /**
     * Persistent device configuration service. Since: 1.8.
     */
    PDC,
    /**
     * Simultaneous transmit service. Since: 1.8.
     */
    STX,
    /**
     * Bearer independent transport service. Since: 1.8.
     */
    BIT,
    /**
     * IMS RTP service. Since: 1.8.
     */
    IMSRTP,
    /**
     * RF radiated performance enhancement service. Since: 1.8.
     */
    RFRPE,
    /**
     * Data system determination service. Since: 1.8.
     */
    DSD,
    /**
     * Subsystem control service. Since: 1.8.
     */
    SSCTL,
    /**
     * Data Port Mapper service. Since: 1.30.
     */
    DPM,
    /**
     * Card Application Toolkit service (v1).
     */
    CAT,
    /**
     * Remote Management Service.
     */
    RMS,
    /**
     * Open Mobile Alliance device management service.
     */
    OMA,
    /**
     * Foxconn General Modem Service. Since: 1.32.
     */
    FOX,
    /**
     * Firmware Over The Air service. Since: 1.24.
     */
    FOTA,
    /**
     * Telit General Modem Service. Since: 1.24.
     */
    GMS,
    /**
     * Telit General Application Service. Since: 1.24.
     */
    GAS,
}
/**
 * SIO (serial I/O) port numbers. All ports available in the modem have a SIO
 * port number. This enum is incomplete, only few port numbers are publicly
 * known.
 */
enum SioPort {
    /**
     * Invalid port number.
     */
    NONE,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet0.
     */
    A2_MUX_RMNET0,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet1.
     */
    A2_MUX_RMNET1,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet2.
     */
    A2_MUX_RMNET2,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet3.
     */
    A2_MUX_RMNET3,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet4.
     */
    A2_MUX_RMNET4,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet5.
     */
    A2_MUX_RMNET5,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet6.
     */
    A2_MUX_RMNET6,
    /**
     * A2 MUX (BAM-DMUX) port for rmnet7.
     */
    A2_MUX_RMNET7,
}
/**
 * Card application personalization feature, when a code is required.
 */
enum UimCardApplicationPersonalizationFeature {
    /**
     * GW network.
     */
    GW_NETWORK,
    /**
     * GW network subset.
     */
    GW_NETWORK_SUBSET,
    /**
     * GW service provider.
     */
    GW_SERVICE_PROVIDER,
    /**
     * GW corporate.
     */
    GW_CORPORATE,
    /**
     * UIM.
     */
    GW_UIM,
    /**
     * 1X network type 1.
     */
    TODO_1X_NETWORK_TYPE_1,
    /**
     * 1X network type 2.
     */
    TODO_1X_NETWORK_TYPE_2,
    /**
     * 1X HRPD.
     */
    TODO_1X_HRPD,
    /**
     * 1X service provider.
     */
    TODO_1X_SERVICE_PROVIDER,
    /**
     * 1X corporate.
     */
    TODO_1X_CORPORATE,
    /**
     * 1X R-UIM.
     */
    TODO_1X_RUIM,
    /**
     * Unknown.
     */
    UNKNOWN,
}
/**
 * Card application personalization state.
 */
enum UimCardApplicationPersonalizationState {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Operation in progress.
     */
    IN_PROGRESS,
    /**
     * Ready.
     */
    READY,
    /**
     * Code required.
     */
    CODE_REQUIRED,
    /**
     * PUK code required.
     */
    PUK_CODE_REQUIRED,
    /**
     * Permanently blocked-
     */
    PERMANENTLY_BLOCKED,
}
/**
 * Card application state.
 */
enum UimCardApplicationState {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Detected.
     */
    DETECTED,
    /**
     * PIN1 or UPIN PIN required.
     */
    PIN1_OR_UPIN_PIN_REQUIRED,
    /**
     * PUK1 or UPIN PUK required.
     */
    PUK1_OR_UPIN_PUK_REQUIRED,
    /**
     * Personalization state must be checked.
     */
    CHECK_PERSONALIZATION_STATE,
    /**
     * PIN1 blocked.
     */
    PIN1_BLOCKED,
    /**
     * Illegal.
     */
    ILLEGAL,
    /**
     * Ready
     */
    READY,
}
/**
 * Card application type.
 */
enum UimCardApplicationType {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * SIM.
     */
    SIM,
    /**
     * USIM.
     */
    USIM,
    /**
     * RUIM.
     */
    RUIM,
    /**
     * CSIM.
     */
    CSIM,
    /**
     * ISIM.
     */
    ISIM,
}
/**
 * Card error.
 */
enum UimCardError {
    /**
     * Unknown error.
     */
    UNKNOWN,
    /**
     * Power down.
     */
    POWER_DOWN,
    /**
     * Poll error.
     */
    POLL,
    /**
     * No ATR received.
     */
    NO_ATR_RECEIVED,
    /**
     * Voltage mismatch.
     */
    VOLTAGE_MISMATCH,
    /**
     * Parity error.
     */
    PARITY,
    /**
     * Unknown error, possibly removed.
     */
    POSSIBLY_REMOVED,
    /**
     * Technical problem.
     */
    TECHNICAL,
}
/**
 * Protocol for the card.
 */
enum UimCardProtocol {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * ICC protocol.
     */
    ICC,
    /**
     * UICC protocol.
     */
    UICC,
}
/**
 * State of the card.
 */
enum UimCardState {
    /**
     * Absent.
     */
    ABSENT,
    /**
     * Present.
     */
    PRESENT,
    /**
     * Error.
     */
    ERROR,
}
/**
 * Depersonalization operation to perform.
 */
enum UimDepersonalizationOperation {
    /**
     * Deactivate personalization
     */
    DEACTIVATE,
    /**
     * Unblock personalization
     */
    UNBLOCK,
}
/**
 * Type of UIM file.
 */
enum UimFileType {
    /**
     * Transparent.
     */
    TRANSPARENT,
    /**
     * Cyclic.
     */
    CYCLIC,
    /**
     * Linear fixed.
     */
    LINEAR_FIXED,
    /**
     * Dedicated file.
     */
    DEDICATED_FILE,
    /**
     * Master file.
     */
    MASTER_FILE,
}
/**
 * State of the physical card.
 */
enum UimPhysicalCardState {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Absent.
     */
    ABSENT,
    /**
     * Present.
     */
    PRESENT,
}
/**
 * PIN ID.
 */
enum UimPinId {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * PIN1.
     */
    PIN1,
    /**
     * PIN2.
     */
    PIN2,
    /**
     * UPIN.
     */
    UPIN,
    /**
     * Hidden key.
     */
    HIDDEN_KEY,
}
/**
 * The PIN state.
 */
enum UimPinState {
    /**
     * Not initialized.
     */
    NOT_INITIALIZED,
    /**
     * Enabled, not verified.
     */
    ENABLED_NOT_VERIFIED,
    /**
     * Enabled, verified.
     */
    ENABLED_VERIFIED,
    /**
     * Disabled.
     */
    DISABLED,
    /**
     * Blocked.
     */
    BLOCKED,
    /**
     * Permanently Blocked.
     */
    PERMANENTLY_BLOCKED,
}
/**
 * Refresh mode
 */
enum UimRefreshMode {
    /**
     * Reset.
     */
    RESET,
    /**
     * Init.
     */
    INIT,
    /**
     * Init & FCN.
     */
    INIT_FCN,
    /**
     * FCN.
     */
    FCN,
    /**
     * Init & full FCN.
     */
    INIT_FULL_FCN,
    /**
     * Application reset.
     */
    APP_RESET,
    /**
     * 3G session reset.
     */
    TODO_3G_RESET,
}
/**
 * Current stage of the refresh procedure.
 */
enum UimRefreshStage {
    /**
     * Waiting for REFRESH OK message.
     */
    WAIT_FOR_OK,
    /**
     * Refresh started.
     */
    START,
    /**
     * Refresh completed successfully.
     */
    END_WITH_SUCCESS,
    /**
     * Refresh has failed.
     */
    END_WITH_FAILURE,
}
/**
 * Logic applicable to security attributes.
 */
enum UimSecurityAttributeLogic {
    /**
     * Always.
     */
    ALWAYS,
    /**
     * Never.
     */
    NEVER,
    /**
     * And.
     */
    AND,
    /**
     * Or.
     */
    OR,
    /**
     * Single.
     */
    SINGLE,
}
/**
 * Type of UIM session.
 */
enum UimSessionType {
    /**
     * Primary GSM/WCDMA provisioning.
     */
    PRIMARY_GW_PROVISIONING,
    /**
     * Primary CDMA1x provisioning.
     */
    PRIMARY_1X_PROVISIONING,
    /**
     * Secondary GSM/WCDMA provisioning.
     */
    SECONDARY_GW_PROVISIONING,
    /**
     * Secondary CDMA1x provisioning.
     */
    SECONDARY_1X_PROVISIONING,
    /**
     * Nonprovisioning on slot 1.
     */
    NONPROVISIONING_SLOT_1,
    /**
     * Nonprovisioning on slot 2.
     */
    NONPROVISIONING_SLOT_2,
    /**
     * Card on slot 1.
     */
    CARD_SLOT_1,
    /**
     * Card on slot 2.
     */
    CARD_SLOT_2,
    /**
     * Logical channel on slot 1.
     */
    LOGICAL_CHANNEL_SLOT_1,
    /**
     * Logical channel on slot 2.
     */
    LOGICAL_CHANNEL_SLOT_2,
    /**
     * Tertiary GSM/WCDMA provisioning. Since 1.28.
     */
    TERTIARY_GW_PROVISIONING,
    /**
     * Tertiary CDMA1x provisioning. Since 1.28.
     */
    TERTIARY_1X_PROVISIONING,
    /**
     * Quaternary GSM/WCDMA provisioning. Since 1.28.
     */
    QUATERNARY_GW_PROVISIONING,
    /**
     * Quaternary CDMA1x provisioning. Since 1.28.
     */
    QUATERNARY_1X_PROVISIONING,
    /**
     * Quinary GSM/WCDMA provisioning. Since 1.28.
     */
    QUINARY_GW_PROVISIONING,
    /**
     * Quinary CDMA1x provisioning. Since 1.28.
     */
    QUINARY_1X_PROVISIONING,
    /**
     * Nonprovisioning on slot 3. Since 1.28.
     */
    NONPROVISIONING_SLOT_3,
    /**
     * Nonprovisioning on slot 4. Since 1.28.
     */
    NONPROVISIONING_SLOT_4,
    /**
     * Nonprovisioning on slot 5. Since 1.28.
     */
    NONPROVISIONING_SLOT_5,
    /**
     * Card on slot 3. Since 1.28.
     */
    CARD_SLOT_3,
    /**
     * Card on slot 4. Since 1.28.
     */
    CARD_SLOT_4,
    /**
     * Card on slot 5. Since 1.28.
     */
    CARD_SLOT_5,
    /**
     * Logical channel on slot 3. Since 1.28.
     */
    LOGICAL_CHANNEL_SLOT_3,
    /**
     * Logical channel on slot 4. Since 1.28.
     */
    LOGICAL_CHANNEL_SLOT_4,
    /**
     * Logical channel on slot 5. Since 1.28.
     */
    LOGICAL_CHANNEL_SLOT_5,
}
/**
 * State of the slot.
 */
enum UimSlotState {
    /**
     * Inactive.
     */
    INACTIVE,
    /**
     * Active.
     */
    ACTIVE,
}
/**
 * Alpha Coding Scheme.
 */
enum VoiceAlphaDataCodingScheme {
    /**
     * SMS default 7-bit coded alphabet.
     */
    GSM,
    /**
     * UCS2.
     */
    UCS2,
}
/**
 * ALS line indicator.
 */
enum VoiceAls {
    /**
     * Line 1, default.
     */
    TODO_1,
    /**
     * Line 2.
     */
    TODO_2,
}
/**
 * Call control result type.
 */
enum VoiceCallControlResultType {
    /**
     * Voice.
     */
    VOICE,
    /**
     * Supplementary service.
     */
    SUPS,
    /**
     * Unstructured supplementary service.
     */
    USSD,
}
/**
 * Call control supplementary service type.
 */
enum VoiceCallControlSupplementaryServiceType {
    /**
     * Activate.
     */
    ACTIVATE,
    /**
     * Deactivate.
     */
    DEACTIVATE,
    /**
     * Register.
     */
    REGISTER,
    /**
     * Erase.
     */
    ERASE,
    /**
     * Interrogate.
     */
    INTERROGATE,
    /**
     * Register password.
     */
    REGISTER_PASSWORD,
    /**
     * USSD.
     */
    USSD,
}
/**
 * Call direction.
 */
enum VoiceCallDirection {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * Mobile-originated.
     */
    MO,
    /**
     * Mobile-terminated.
     */
    MT,
}
/**
 * Possible call end reasons resulting from a voice call or supplementary
 * service connection being terminated.
 */
enum VoiceCallEndReason {
    /**
     * Device is offline.
     */
    OFFLINE,
    /**
     * CDMA specific. Phone is CDMA locked.
     */
    CDMA_LOCK,
    /**
     * Device has no service.
     */
    NO_SERVICE,
    /**
     * Fade.
     */
    FADE,
    /**
     * CDMA specific. Received intercept from the BS.
     */
    INTERCEPT,
    /**
     * CDMA specific. Received reorder from the BS.
     */
    REORDER,
    /**
     * Received release from the BS.
     */
    RELEASE_NORMAL,
    /**
     * CDMA specific. Received release from the BS.
     */
    RELEASE_SO_REJECT,
    /**
     * CDMA specific. Received incoming call from the BS.
     */
    INCOMING_CALL,
    /**
     * CDMA specific. Received alert stop from the BS.
     */
    ALERT_STOP,
    /**
     * Client ended the call.
     */
    CLIENT_END,
    /**
     * CDMA specific. Received end activation.
     */
    ACTIVATION,
    /**
     * CDMA specific. MC aborted the origination/conversation.
     */
    MC_ABORT,
    /**
     * CDMA specific. Maximum access probes transmitted.
     */
    MAX_ACCESS_PROBE,
    /**
     * CDMA specific. Persistence test failure.
     */
    PSIST_N,
    /**
     * R-UIM not present.
     */
    UIM_NOT_PRESENT,
    /**
     * Access attempt in progress.
     */
    ACCESS_ATTEMPT_IN_PROGRESS,
    /**
     * Access failure.
     */
    ACCESS_FAILURE,
    /**
     * CDMA specific. Retry order.
     */
    ACCESS_RETRY_ORDER,
    /**
     * CDMA specific. Concurrent service not supported by the BS.
     */
    CCS_NOT_SUPPORTED_BY_BS,
    /**
     * CDMA specific. No response received from the BS.
     */
    NO_RESPONSE_FROM_BS,
    /**
     * CDMA specific. Rejected by the BS.
     */
    REJECTED_BY_BS,
    /**
     * CDMA specific. Concurrent services requested are incompatible.
     */
    INCOMPATIBLE,
    /**
     * CDMA specific. Access blocked by the BS.
     */
    ACCESS_BLOCK,
    /**
     * Already in TC.
     */
    ALREADY_IN_TC,
    /**
     * CDMA specific. Emergency call is flashed over this call.
     */
    EMERGENCY_FLASHED,
    /**
     * Call originated during GPS.
     */
    USER_CALL_ORIGINATED_DURING_GPS,
    /**
     * Call originated during SMS.
     */
    USER_CALL_ORIGINATED_DURING_SMS,
    /**
     * Call originated during data.
     */
    USER_CALL_ORIGINATED_DURING_DATA,
    /**
     * Redirection or handoff.
     */
    REDIRECTION_OR_HANDOFF,
    /**
     * Access blocked by BS for all.
     */
    ACCESS_BLOCK_ALL,
    /**
     * OTASP SPC error indication.
     */
    OTASP_SPC_ERR,
    /**
     * Maximum access probes for IS-707B call.
     */
    IS707B_MAX_ACCESS_PROBES,
    /**
     * Base station reject order.
     */
    ACCESS_FAILURE_REJECT_ORDER,
    /**
     * Base station retry order.
     */
    ACCESS_FAILURE_RETRY_ORDER,
    /**
     * Timer T42 expired.
     */
    TIMEOUT_T42,
    /**
     * Timer T40 expired.
     */
    TIMEOUT_T40,
    /**
     * Service initialization failure.
     */
    SERVICE_INIT_FAILURE,
    /**
     * Timer T50 expired.
     */
    TIMEOUT_T50,
    /**
     * Timer T51 expired.
     */
    TIMEOUT_T51,
    /**
     * Acknowledgement timeout due to 12 retransmissions.
     */
    RL_ACK_TIMEOUT,
    /**
     * Bad forward link or timer T5M expired.
     */
    BAD_FORWARD_LINK,
    /**
     * Transceiver Resource Manager request failed.
     */
    TRM_REQUEST_FAILED,
    /**
     * Timer T41 expired.
     */
    TIMEOUT_T41,
    /**
     * GSM/WCDMA specific. Client rejected incoming call.
     */
    INCOMING_REJECTED,
    /**
     * GSM/WCDMA specific. Client rejected a setup indication.
     */
    SETUP_REJECTED,
    /**
     * GSM/WCDMA specific. Network ended the call.
     */
    NETWORK_END,
    /**
     * GSM/WCDMA specific. No funds.
     */
    NO_FUNDS,
    /**
     * GSM/WCDMA specific. Device has no service.
     */
    NO_GW_SERVICE,
    /**
     * CDMA specific. Device has no service.
     */
    NO_CDMA_SERVICE,
    /**
     * Full service is unavailable.
     */
    NO_FULL_SERVICE,
    /**
     * No resources available to handle a new MO/MT PS call.
     */
    MAX_PS_CALLS,
    /**
     * Unknown subscriber.
     */
    UNKNOWN_SUBSCRIBER,
    /**
     * Illegal subscriber.
     */
    ILLEGAL_SUBSCRIBER,
    /**
     * Bearer service not provisioned.
     */
    BEARER_SERVICE_NOT_PROVISIONED,
    /**
     * Tele service not provisioned.
     */
    TELE_SERVICE_NOT_PROVISIONED,
    /**
     * Illegal equipment.
     */
    ILLEGAL_EQUIPMENT,
    /**
     * Call barred.
     */
    CALL_BARRED,
    /**
     * Illegal SS operation.
     */
    ILLEGAL_SS_OPERATION,
    /**
     * Supplementary service error status.
     */
    SS_ERROR_STATUS,
    /**
     * Supplementary service not available.
     */
    SS_NOT_AVAILABLE,
    /**
     * Supplementary service subscription violation.
     */
    SS_SUBSCRIPTION_VIOLATION,
    /**
     * Supplementary service incompatibility.
     */
    SS_INCOMPATIBILITY,
    /**
     * Facility not supported.
     */
    FACILITY_NOT_SUPPORTED,
    /**
     * Absent subscriber.
     */
    ABSENT_SUBSCRIBER,
    /**
     * Short term denial.
     */
    SHORT_TERM_DENIAL,
    /**
     * Long term denial.
     */
    LONG_TERM_DENIAL,
    /**
     * System failure.
     */
    SYSTEM_FAILURE,
    /**
     * Data missing.
     */
    DATA_MISSING,
    /**
     * Unexpected data value.
     */
    UNEXPECTED_DATA_VALUE,
    /**
     * Password registration failure.
     */
    PASSWORD_REGISTRATION_FAILURE,
    /**
     * Negative password check.
     */
    NEGATIVE_PASSWORD_CHECK,
    /**
     * Number of password attempts violation.
     */
    NUM_OF_PASSWORD_ATTEMPTS_VIOLATION,
    /**
     * Position method failure.
     */
    POSITION_METHOD_FAILURE,
    /**
     * Unknown alphabet.
     */
    UNKNOWN_ALPHABET,
    /**
     * USSD busy.
     */
    USSD_BUSY,
    /**
     * Rejected by user.
     */
    REJECTED_BY_USER,
    /**
     * Rejected by network.
     */
    REJECTED_BY_NETWORK,
    /**
     * Deflection to served subscriber.
     */
    DEFLECTION_TO_SERVED_SUBSCRIBER,
    /**
     * Special service codde.
     */
    SPECIAL_SERVICE_CODE,
    /**
     * Invalid deflected to number.
     */
    INVALID_DEFLECTED_TO_NUMBER,
    /**
     * Multiparty participants exceeded.
     */
    MULTIPARTY_PARTICIPANTS_EXCEEDED,
    /**
     * Resources not available.
     */
    RESOURCES_NOT_AVAILABLE,
    /**
     * Unassigned number.
     */
    UNASSIGNED_NUMBER,
    /**
     * No route to destination.
     */
    NO_ROUTE_TO_DESTINATION,
    /**
     * Channel unacceptable.
     */
    CHANNEL_UNACCEPTABLE,
    /**
     * Operator determined barring.
     */
    OPERATOR_DETERMINED_BARRING,
    /**
     * Normal call clearing.
     */
    NORMAL_CALL_CLEARING,
    /**
     * User busy.
     */
    USER_BUSY,
    /**
     * No user responding.
     */
    NO_USER_RESPONDING,
    /**
     * User alerting no answer.
     */
    USER_ALERTING_NO_ANSWER,
    /**
     * Call rejected.
     */
    CALL_REJECTED,
    /**
     * Number changed.
     */
    NUMBER_CHANGED,
    /**
     * Preemption.
     */
    PREEMPTION,
    /**
     * Destination out of order.
     */
    DESTINATION_OUT_OF_ORDER,
    /**
     * Invalid number format.
     */
    INVALID_NUMBER_FORMAT,
    /**
     * Facility rejected.
     */
    FACILITY_REJECTED,
    /**
     * Response to status enquiry.
     */
    RESPONSE_TO_STATUS_ENQUIRY,
    /**
     * Normal unspecified.
     */
    NORMAL_UNSPECIFIED,
    /**
     * No circuit or channel available.
     */
    NO_CIRCUIT_OR_CHANNEL_AVAILABLE,
    /**
     * Network out of order.
     */
    NETWORK_OUT_OF_ORDER,
    /**
     * Temporary failure.
     */
    TEMPORARY_FAILURE,
    /**
     * Switching equipment congestion.
     */
    SWITCHING_EQUIPMENT_CONGESTION,
    /**
     * Access information discarded.
     */
    ACCESS_INFORMATION_DISCARDED,
    /**
     * Requested circuit or channel not available.
     */
    REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE,
    /**
     * Resources unavailable or unspecified.
     */
    RESOURCES_UNAVAILABLE_OR_UNSPECIFIED,
    /**
     * QoS unavailable.
     */
    QOS_UNAVAILABLE,
    /**
     * Requested facility not subscribed.
     */
    REQUESTED_FACILITY_NOT_SUBSCRIBED,
    /**
     * Incoming calls barred withing closed user group.
     */
    INCOMING_CALLS_BARRED_WITHIN_CUG,
    /**
     * Bearer capability not auth.
     */
    BEARER_CAPABILITY_NOT_AUTH,
    /**
     * Bearer capability unavailable.
     */
    BEARER_CAPABILITY_UNAVAILABLE,
    /**
     * Service option not available.
     */
    SERVICE_OPTION_NOT_AVAILABLE,
    /**
     * ACM limit exceeded.
     */
    ACM_LIMIT_EXCEEDED,
    /**
     * Bearer service not implemented.
     */
    BEARER_SERVICE_NOT_IMPLEMENTED,
    /**
     * Requested facility not implemented.
     */
    REQUESTED_FACILITY_NOT_IMPLEMENTED,
    /**
     * Only digital information bearer available.
     */
    ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE,
    /**
     * Service or option not implemented.
     */
    SERVICE_OR_OPTION_NOT_IMPLEMENTED,
    /**
     * Invalid transaction identifier.
     */
    INVALID_TRANSACTION_IDENTIFIER,
    /**
     * User not member of closed user group.
     */
    USER_NOT_MEMBER_OF_CUG,
    /**
     * Incompatible destination.
     */
    INCOMPATIBLE_DESTINATION,
    /**
     * Invalid transit network selection.
     */
    INVALID_TRANSIT_NETWORK_SELECTION,
    /**
     * Semantically incorrect message.
     */
    SEMANTICALLY_INCORRECT_MESSAGE,
    /**
     * Invalid mandatory information.
     */
    INVALID_MANDATORY_INFORMATION,
    /**
     * Message type not implemented.
     */
    MESSAGE_TYPE_NOT_IMPLEMENTED,
    /**
     * Message type not compatible with protocol state.
     */
    MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE,
    /**
     * Information element non existent.
     */
    INFORMATION_ELEMENT_NON_EXISTENT,
    /**
     * IE error.
     */
    CONDITIONAL_IE_ERROR,
    /**
     * Message not compatible with protocol state.
     */
    MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE,
    /**
     * Recovery on timer expired.
     */
    RECOVERY_ON_TIMER_EXPIRED,
    /**
     * Protocol error unspecified.
     */
    PROTOCOL_ERROR_UNSPECIFIED,
    /**
     * Interworking unspecified.
     */
    INTERWORKING_UNSPECIFIED,
    /**
     * Outgoing calls barred within closed user group.
     */
    OUTGOING_CALLS_BARRED_WITHIN_CUG,
    /**
     * No closed user group selection.
     */
    NO_CUG_SELECTION,
    /**
     * Unknown closed user group index.
     */
    UNKNOWN_CUG_INDEX,
    /**
     * Closed user group index incompatible.
     */
    CUG_INDEX_INCOMPATIBLE,
    /**
     * Closed user group call failure unspecified.
     */
    CUG_CALL_FAILURE_UNSPECIFIED,
    /**
     * Calling line identification restriction not subscribed.
     */
    CLIR_NOT_SUBSCRIBED,
    /**
     * Completion of communications to busy subscriber possible.
     */
    CCBS_POSSIBLE,
    /**
     * Completion of communications to busy subscriber not possible.
     */
    CCBS_NOT_POSSIBLE,
    /**
     * IMSI unknown in HLR.
     */
    IMSI_UNKNOWN_IN_HLR,
    /**
     * Illegal MS.
     */
    ILLEGAL_MS,
    /**
     * IMSI unknown in VLR.
     */
    IMSI_UNKNOWN_IN_VLR,
    /**
     * IMEI not accepted.
     */
    IMEI_NOT_ACCEPTED,
    /**
     * Illegal ME.
     */
    ILLEGAL_ME,
    /**
     * PLMN not allowed.
     */
    PLMN_NOT_ALLOWED,
    /**
     * Location area not allowed.
     */
    LOCATION_AREA_NOT_ALLOWED,
    /**
     * Roaming not allowed in this location area.
     */
    ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA,
    /**
     * No suitable cells in location area.
     */
    NO_SUITABLE_CELLS_IN_LOCATION_AREA,
    /**
     * Network failure.
     */
    NETWORK_FAILURE,
    /**
     * MAC failure.
     */
    MAC_FAILURE,
    /**
     * Synch failure.
     */
    SYNCH_FAILURE,
    /**
     * Network contestion.
     */
    NETWORK_CONGESTION,
    /**
     * GSM authentication unacceptable.
     */
    GSM_AUTHENTICATION_UNACCEPTABLE,
    /**
     * Service not subscribed.
     */
    SERVICE_NOT_SUBSCRIBED,
    /**
     * Service temporarily out of order.
     */
    SERVICE_TEMPORARILY_OUT_OF_ORDER,
    /**
     * Call cannot be identified.
     */
    CALL_CANNOT_BE_IDENTIFIED,
    /**
     * Incorrect semantics in message.
     */
    INCORRECT_SEMANTICS_IN_MESSAGE,
    /**
     * Mandatory information invalid.
     */
    MANDATORY_INFORMATION_INVALID,
    /**
     * Access stratum failure.
     */
    ACCESS_STRATUM_FAILURE,
    /**
     * Invalid SIM.
     */
    INVALID_SIM,
    /**
     * Wrong state.
     */
    WRONG_STATE,
    /**
     * Access class blocked.
     */
    ACCESS_CLASS_BLOCKED,
    /**
     * No resources.
     */
    NO_RESOURCES,
    /**
     * Invalid user data.
     */
    INVALID_USER_DATA,
    /**
     * Timer T3230 expired.
     */
    TIMER_T3230_EXPIRED,
    /**
     * No cell available.
     */
    NO_CELL_AVAILABLE,
    /**
     * Abort message received.
     */
    ABORT_MESSAGE_RECEIVED,
    /**
     * Radio link lost.
     */
    RADIO_LINK_LOST,
    /**
     * Timer T303 expired.
     */
    TIMER_T303_EXPIRED,
    /**
     * CNM MM release pending.
     */
    CNM_MM_RELEASE_PENDING,
    /**
     * Access stratum reject, RR release indication.
     */
    ACCESS_STRATUM_REJECT_RR_RELEASE_INDICATION,
    /**
     * Access stratum reject, RR random access failure.
     */
    ACCESS_STRATUM_REJECT_RR_RANDOM_ACCESS_FAILURE,
    /**
     * Access stratum reject, RRC release indication.
     */
    ACCESS_STRATUM_REJECT_RRC_RELEASE_INDICATION,
    /**
     * Access stratum reject, RRC close session indication.
     */
    ACCESS_STRATUM_REJECT_RRC_CLOSE_SESSION_INDICATION,
    /**
     * Access stratum reject, RRC open session failure.
     */
    ACCESS_STRATUM_REJECT_RRC_OPEN_SESSION_FAILURE,
    /**
     * Access stratum reject, low level failure.
     */
    ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE,
    /**
     * Access stratum reject, low level failure redial not allowed.
     */
    ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE_REDIAL_NOT_ALLOWED,
    /**
     * Access stratum reject, low level immediate retry.
     */
    ACCESS_STRATUM_REJECT_LOW_LEVEL_IMMEDIATE_RETRY,
    /**
     * Access stratum reject, abort radio unavailable.
     */
    ACCESS_STRATUM_REJECT_ABORT_RADIO_UNAVAILABLE,
    /**
     * Service option not supported.
     */
    SERVICE_OPTION_NOT_SUPPORTED,
    /**
     * Bad request wait invite.
     */
    BAD_REQUEST_WAIT_INVITE,
    /**
     * Bad request wait reinvite.
     */
    BAD_REQUEST_WAIT_REINVITE,
    /**
     * Invalid remote URI.
     */
    INVALID_REMOTE_URI,
    /**
     * Remote unsupported media type.
     */
    REMOTE_UNSUPPORTED_MEDIA_TYPE,
    /**
     * Peer not reachable.
     */
    PEER_NOT_REACHABLE,
    /**
     * Network no response, timeout.
     */
    NETWORK_NO_RESPONSE_TIMEOUT,
    /**
     * Network no response, hold failure.
     */
    NETWORK_NO_RESPONSE_HOLD_FAILURE,
    /**
     * Data connection lost.
     */
    DATA_CONNECTION_LOST,
    /**
     * Upgrade/downgrade rejected.
     */
    UPGRADE_DOWNGRADE_REJECTED,
    /**
     * SIP 403 forbidden.
     */
    SIP_403_FORBIDDEN,
    /**
     * No network response.
     */
    NO_NETWORK_RESPONSE,
    /**
     * Upgrade/downgrade failed.
     */
    UPGRADE_DOWNGRADE_FAILED,
    /**
     * Upgrade/downgrade cancelled.
     */
    UPGRADE_DOWNGRADE_CANCELLED,
    /**
     * Service specific access control reject.
     */
    SSAC_REJECT,
    /**
     * Thermal emergency.
     */
    THERMAL_EMERGENCY,
    /**
     * 1xCSFG soft failure.
     */
    TODO_1XCSFB_SOFT_FAILURE,
    /**
     * 1xCSFG hard failure.
     */
    TODO_1XCSFB_HARD_FAILURE,
}
/**
 * Call mode.
 */
enum VoiceCallMode {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * CDMA.
     */
    CDMA,
    /**
     * GSM.
     */
    GSM,
    /**
     * UMTS.
     */
    UMTS,
    /**
     * LTE.
     */
    LTE,
}
/**
 * State of a call.
 */
enum VoiceCallState {
    /**
     * Unknown state.
     */
    UNKNOWN,
    /**
     * Call is being originated.
     */
    ORIGINATION,
    /**
     * Incoming call.
     */
    INCOMING,
    /**
     * Call is in progress.
     */
    CONVERSATION,
    /**
     * Call is originating but waiting for call control to complete.
     */
    CC_IN_PROGRESS,
    /**
     * Alerting.
     */
    ALERTING,
    /**
     * On hold.
     */
    HOLD,
    /**
     * Waiting.
     */
    WAITING,
    /**
     * Disconnecting.
     */
    DISCONNECTING,
    /**
     * Call is finished.
     */
    END,
    /**
     * 3GPP specific. MT call is in setup state.
     */
    SETUP,
}
/**
 * Type of a voice call.
 */
enum VoiceCallType {
    /**
     * Voice call.
     */
    VOICE,
    /**
     * VoIP call.
     */
    VOICE_IP,
    /**
     * OTAPA.
     */
    OTAPA,
    /**
     * Non-standard OTASP.
     */
    NON_STD_OTASP,
    /**
     * Emergency call.
     */
    EMERGENCY,
    /**
     * Supplementary service.
     */
    SUPS,
}
/**
 * Voice domain preference.
 */
enum VoiceDomain {
    /**
     * CS-only.
     */
    CS_ONLY,
    /**
     * PS-only.
     */
    PS_ONLY,
    /**
     * CS preferred, PS secondary.
     */
    CS_PREFERRED,
    /**
     * PS preferred, CS secondary.
     */
    PS_PREFERRED,
}
/**
 * Remote party number presentation indicator.
 */
enum VoicePresentation {
    /**
     * Allowed presentation.
     */
    ALLOWED,
    /**
     * Restricted presentation.
     */
    RESTRICTED,
    /**
     * Unavailable presentation.
     */
    UNAVAILABLE,
    /**
     * 3GPP specific. Payphone presentation.
     */
    PAYPHONE,
}
/**
 * Voice privacy.
 */
enum VoicePrivacy {
    /**
     * Standard.
     */
    STANDARD,
    /**
     * Enhanced.
     */
    ENHANCED,
}
/**
 * Service option.
 */
enum VoiceServiceOption {
    /**
     * Any service option.
     */
    WILD,
    /**
     * IS-96A.
     */
    IS_96A,
    /**
     * EVRC.
     */
    EVRC,
    /**
     * IS733.
     */
    TODO_13K_IS733,
    /**
     * Selectable mode vocoder.
     */
    SELECTABLE_MODE_VOCODER,
    /**
     * 4GV narrowband.
     */
    TODO_4GV_NARROW_BAND,
    /**
     * 4GV wideband.
     */
    TODO_4GV_WIDE_BAND,
    /**
     * 13K.
     */
    TODO_13K,
    /**
     * IS-96.
     */
    IS_96,
    /**
     * WVRC.
     */
    WVRC,
}
/**
 * Supplementary service action.
 */
enum VoiceSupplementaryServiceAction {
    /**
     * Activate supplementary service.
     */
    ACTIVATE,
    /**
     * De-activate supplementary service.
     */
    DEACTIVATE,
    /**
     * Register supplementary service.
     */
    REGISTER,
    /**
     * Erase/Un-register supplementary service.
     */
    ERASE,
}
/**
 * Supplementary service notification type.
 */
enum VoiceSupplementaryServiceNotificationType {
    /**
     * Outgoing call is forward.
     */
    OUTGOING_CALL_IS_FORWARDED,
    /**
     * Outgoing call is waiting.
     */
    OUTGOING_CALL_IS_WAITING,
    /**
     * Outgoing CUG call.
     */
    OUTGOING_CUG_CALL,
    /**
     * All outgoing calls are barred.
     */
    OUTGOING_CALLS_BARRED,
    /**
     * Outgoing call is deflected.
     */
    OUTGOING_CALL_IS_DEFLECTED,
    /**
     * Incoming CUG call.
     */
    INCOMING_CUG_CALL,
    /**
     * All incoming calls are barred.
     */
    INCOMING_CALLS_BARRED,
    /**
     * Incoming forwarded call.
     */
    INCOMING_FORWARDED_CALL,
    /**
     * Incoming deflected call.
     */
    INCOMING_DEFLECTED_CALL,
    /**
     * Incoming call is forwarded.
     */
    INCOMING_CALL_IS_FORWARDED,
    /**
     * Unconditional call forward is active.
     */
    UNCONDITIONAL_CALL_FORWARD_ACTIVE,
    /**
     * Conditional call forward is active.
     */
    CONDITIONAL_CALL_FORWARD_ACTIVE,
    /**
     * CLIR suppression is rejected.
     */
    CLIR_SUPPRESSION_REJECTED,
    /**
     * Call is on hold.
     */
    CALL_IS_ON_HOLD,
    /**
     * Call is retrieved.
     */
    CALL_IS_RETRIEVED,
    /**
     * Call is in multiparty.
     */
    CALL_IS_IN_MULTIPARTY,
    /**
     * Incoming call is ECT.
     */
    INCOMING_CALL_IS_ECT,
}
/**
 * Supplementary service reason.
 */
enum VoiceSupplementaryServiceReason {
    /**
     * Unconditional call forward.
     */
    FORWARD_UNCONDITIONAL,
    /**
     * Forward when mobile is busy.
     */
    FORWARD_MOBILE_BUSY,
    /**
     * Forward when no reply.
     */
    FORWARD_NO_REPLY,
    /**
     * Forward when call is unreachable.
     */
    FORWARD_UNREACHABLE,
    /**
     * Forward all calls.
     */
    FORWARD_ALL,
    /**
     * Forward all calls conditionally.
     */
    FORWARD_ALL_CONDITIONAL,
    /**
     * All outgoing.
     */
    ALL_OUTGOING,
    /**
     * Outgoing Internal.
     */
    OUTGOING_INTERNAL,
    /**
     * Outgoing internal/external to home.
     */
    OUTGOING_INTERNAL_EXTERNAL_TO_HOME,
    /**
     * All incoming.
     */
    ALL_INCOMING,
    /**
     * Roaming incoming.
     */
    INCOMING_ROAMING,
    /**
     * All calls are barred.
     */
    BAR_ALL,
    /**
     * All outgoing calls are barred.
     */
    BAR_ALL_OUTGOING,
    /**
     * All incoming calls are barred.
     */
    BAR_ALL_INCOMING,
    /**
     * Call waiting.
     */
    CALL_WAITING,
}
/**
 * Supplementary service type during call.
 */
enum VoiceSupplementaryServiceType {
    /**
     * Release held or waiting call.
     */
    RELEASE_HELD_OR_WAITING,
    /**
     * Release active call and accept held or waiting call.
     */
    RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING,
    /**
     * Hold active call and accept held or waiting call.
     */
    HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD,
    /**
     * Hold all calls except specified call.
     */
    HOLD_ALL_EXCEPT_SPECIFIED_CALL,
    /**
     * Create conference call.
     */
    MAKE_CONFERENCE_CALL,
    /**
     * Explicit call transfer.
     */
    EXPLICIT_CALL_TRANSFER,
    /**
     * Activate completion of calls to busy subscriber.
     */
    CCBS_ACTIVATION,
    /**
     * End all calls.
     */
    END_ALL_CALLS,
    /**
     * Release a specified call.
     */
    RELEASE_SPECIFIED_CALL,
    /**
     * Put all active calls to hold.
     */
    LOCAL_HOLD,
    /**
     * Unhold all held calls.
     */
    LOCAL_UNHOLD,
}
/**
 * TTY mode.
 */
enum VoiceTtyMode {
    /**
     * Full.
     */
    FULL,
    /**
     * Voice carry over.
     */
    VCO,
    /**
     * Hearing carry over.
     */
    HCO,
    /**
     * Off.
     */
    OFF,
}
/**
 * User action type.
 */
enum VoiceUserAction {
    /**
     * Unknown user action.
     */
    UNKNOWN,
    /**
     * User is not required to respond to the USSD code.
     */
    NOT_REQUIRED,
    /**
     * User is required to respond to the USSD code.
     */
    REQUIRED,
}
/**
 * Data Coding Scheme used in USSD operations.
 */
enum VoiceUssDataCodingScheme {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * ASCII coding scheme.
     */
    ASCII,
    /**
     * 8-bit coding scheme.
     */
    TODO_8BIT,
    /**
     * UCS2.
     */
    UCS2,
}
/**
 * Data aggregation protocol in uplink or downlink.
 */
enum WdaDataAggregationProtocol {
    /**
     * Disabled.
     */
    DISABLED,
    /**
     * TLP enabled.
     */
    TLP,
    /**
     * QC NCM enabled.
     */
    QC_NCM,
    /**
     * MBIM enabled.
     */
    MBIM,
    /**
     * RNDIS enabled.
     */
    RNDIS,
    /**
     * QMAP enabled.
     */
    QMAP,
    /**
     * QMAPV2 enabled. Since: 1.30.
     */
    QMAPV2,
    /**
     * QMAPV3 enabled. Since: 1.30.
     */
    QMAPV3,
    /**
     * QMAPV4 enabled. Since: 1.30.
     */
    QMAPV4,
    /**
     * QMAPV5 enabled. Since: 1.28.
     */
    QMAPV5,
}
/**
 * Link layer protocol.
 */
enum WdaLinkLayerProtocol {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * 802.3 ethernet mode.
     */
    TODO_802_3,
    /**
     * Raw IP mode.
     */
    RAW_IP,
}
/**
 * Action when setting the attach PDN list.
 */
enum WdsAttachPdnListAction {
    /**
     * No action (default)
     */
    NONE,
    /**
     * PS detach or PDN disconnect based on the modem configuration
     */
    DETACH_OR_PDN_DISCONNECT,
}
/**
 * Status of the autoconnect setting.
 */
enum WdsAutoconnectSetting {
    /**
     * Disabled.
     */
    DISABLED,
    /**
     * Enabled.
     */
    ENABLED,
    /**
     * Paused, resume on power cycle.
     */
    PAUSED,
}
/**
 * Status of the autoconnect setting while roaming.
 */
enum WdsAutoconnectSettingRoaming {
    /**
     * Autoconnect always allowed, even when roaming.
     */
    ALLOWED,
    /**
     * Autoconnect allowed only in home network.
     */
    HOME_ONLY,
}
/**
 * Reason for ending the call.
 */
enum WdsCallEndReason {
    /**
     * Unspecified reason.
     */
    GENERIC_UNSPECIFIED,
    /**
     * Client end.
     */
    GENERIC_CLIENT_END,
    /**
     * No service.
     */
    GENERIC_NO_SERVICE,
    /**
     * Fade.
     */
    GENERIC_FADE,
    /**
     * Release normal.
     */
    GENERIC_RELEASE_NORMAL,
    /**
     * Access attempt in progress.
     */
    GENERIC_ACCESS_ATTEMPT_IN_PROGRESS,
    /**
     * Access Failure.
     */
    GENERIC_ACCESS_FAILURE,
    /**
     * Redirection or handoff.
     */
    GENERIC_REDIRECTION_OR_HANDOFF,
    /**
     * Close in progress.
     */
    GENERIC_CLOSE_IN_PROGRESS,
    /**
     * Authentication failed.
     */
    GENERIC_AUTHENTICATION_FAILED,
    /**
     * Internal error.
     */
    GENERIC_INTERNAL_ERROR,
    /**
     * CDMA specific. Phone is CDMA-locked.
     */
    CDMA_LOCK,
    /**
     * CDMA specific. Received intercept from the BS.
     */
    CDMA_INTERCEPT,
    /**
     * CDMA specific. Received reorder from the BS.
     */
    CDMA_REORDER,
    /**
     * CDMA specific. Received release from the BS, SO reject.
     */
    CDMA_RELEASE_SO_REJECT,
    /**
     * CDMA specific. Received incoming call from the BS.
     */
    CDMA_INCOMING_CALL,
    /**
     * CDMA specific. Received alert stop from the BS.
     */
    CDMA_ALERT_STOP,
    /**
     * CDMA specific. Received end activation.
     */
    CDMA_ACTIVATION,
    /**
     * CDMA specific. Maximum access probes transmitted.
     */
    CDMA_MAX_ACCESS_PROBES,
    /**
     * CDMA specific. Concurrent service not supported by the BS.
     */
    CDMA_CCS_NOT_SUPPORTED_BY_BS,
    /**
     * CDMA specific. No response received from the BS.
     */
    CDMA_NO_RESPONSE_FROM_BS,
    /**
     * CDMA specific. Rejected by the BS.
     */
    CDMA_REJECTED_BY_BS,
    /**
     * CDMA specific. Concurrent services requested are incompatible.
     */
    CDMA_INCOMPATIBLE,
    /**
     * CDMA specific. Already in TC.
     */
    CDMA_ALREADY_IN_TC,
    /**
     * CDMA specific. Call originated during GPS.
     */
    CDMA_USER_CALL_ORIGINATED_DURING_GPS,
    /**
     * CDMA specific. Call originated during SMS.
     */
    CDMA_USER_CALL_ORIGINATED_DURING_SMS,
    /**
     * CDMA specific. No service.
     */
    CDMA_NO_SERVICE,
    /**
     * GSM/WCDMA specific. Call origination request failed.
     */
    GSM_WCDMA_CONFERENCE_FAILED,
    /**
     * GSM/WCDMA specific. Client rejected incoming call.
     */
    GSM_WCDMA_INCOMING_REJECTED,
    /**
     * GSM/WCDMA specific. No service.
     */
    GSM_WCDMA_NO_SERVICE,
    /**
     * GSM/WCDMA specific. Network ended the call.
     */
    GSM_WCDMA_NETWORK_END,
    /**
     * GSM/WCDMA specific. LLC or SNDCP failure.
     */
    GSM_WCDMA_LLC_SNDCP_FAILURE,
    /**
     * GSM/WCDMA specific. Insufficient resources.
     */
    GSM_WCDMA_INSUFFICIENT_RESOURCES,
    /**
     * GSM/WCDMA specific. Service option temporarily out of order.
     */
    GSM_WCDMA_OPTION_TEMPORARILY_OUT_OF_ORDER,
    /**
     * GSM/WCDMA specific. NSAPI already used.
     */
    GSM_WCDMA_NSAPI_ALREADY_USED,
    /**
     * GSM/WCDMA specific. Regular PDP context deactivation.
     */
    GSM_WCDMA_REGULAR_DEACTIVATION,
    /**
     * GSM/WCDMA specific. Network failure.
     */
    GSM_WCDMA_NETWORK_FAILURE,
    /**
     * GSM/WCDMA specific. Reattach required.
     */
    GSM_WCDMA_REATTACH_REQUIRED,
    /**
     * GSM/WCDMA specific. Protocol error.
     */
    GSM_WCDMA_PROTOCOL_ERROR,
    /**
     * GSM/WCDMA specific. Operator-determined barring.
     */
    GSM_WCDMA_OPERATOR_DETERMINED_BARRING,
    /**
     * GSM/WCDMA specific. Unknown or missing APN.
     */
    GSM_WCDMA_UNKNOWN_APN,
    /**
     * GSM/WCDMA specific. Unknown PDP address or type.
     */
    GSM_WCDMA_UNKNOWN_PDP,
    /**
     * GSM/WCDMA specific. Activation rejected by GGSN.
     */
    GSM_WCDMA_GGSN_REJECT,
    /**
     * GSM/WCDMA specific. Activation rejected.
     */
    GSM_WCDMA_ACTIVATION_REJECT,
    /**
     * GSM/WCDMA specific. Service option not supported.
     */
    GSM_WCDMA_OPTION_NOT_SUPPORTED,
    /**
     * GSM/WCDMA specific. Service option not subscribed.
     */
    GSM_WCDMA_OPTION_UNSUBSCRIBED,
    /**
     * GSM/WCDMA specific. QoS not accepted.
     */
    GSM_WCDMA_QOS_NOT_ACCEPTED,
    /**
     * GSM/WCDMA specific. Semantic error in TFT operation.
     */
    GSM_WCDMA_TFT_SEMANTIC_ERROR,
    /**
     * GSM/WCDMA specific. Syntax error in TFT operation.
     */
    GSM_WCDMA_TFT_SYNTAX_ERROR,
    /**
     * GSM/WCDMA specific. Unknown PDP context.
     */
    GSM_WCDMA_UNKNOWN_PDP_CONTEXT,
    /**
     * GSM/WCDMA specific. Semantic error in packet filters.
     */
    GSM_WCDMA_FILTER_SEMANTIC_ERROR,
    /**
     * GSM/WCDMA specific. Syntax error in packet filters.
     */
    GSM_WCDMA_FILTER_SYNTAX_ERROR,
    /**
     * GSM/WCDMA specific. PDP context without TFT activated.
     */
    GSM_WCDMA_PDP_WITHOUT_ACTIVE_TFT,
    /**
     * GSM/WCDMA specific. Invalid transaction ID.
     */
    GSM_WCDMA_INVALID_TRANSACTION_ID,
    /**
     * GSM/WCDMA specific. Message incorrect semantically.
     */
    GSM_WCDMA_MESSAGE_INCORRECT_SEMANTIC,
    /**
     * GSM/WCDMA specific. Invalid mandatory information.
     */
    GSM_WCDMA_INVALID_MANDATORY_INFO,
    /**
     * GSM/WCDMA specific. Message type not implemented.
     */
    GSM_WCDMA_MESSAGE_TYPE_UNSUPPORTED,
    /**
     * GSM/WCDMA specific. Message not compatible with state.
     */
    GSM_WCDMA_MESSAGE_TYPE_NONCOMPATIBLE_STATE,
    /**
     * GSM/WCDMA specific. Information element unknown.
     */
    GSM_WCDMA_UNKNOWN_INFO_ELEMENT,
    /**
     * GSM/WCDMA specific. Conditional IE error.
     */
    GSM_WCDMA_CONDITIONAL_IE_ERROR,
    /**
     * GSM/WCDMA specific. Message and protocol state uncompatible.
     */
    GSM_WCDMA_MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE,
    /**
     * GSM/WCDMA specific. APN type conflict.
     */
    GSM_WCDMA_APN_TYPE_CONFLICT,
    /**
     * GSM/WCDMA specific. No GPRS context.
     */
    GSM_WCDMA_NO_GPRS_CONTEXT,
    /**
     * GSM/WCDMA specific. Feature not supported.
     */
    GSM_WCDMA_FEATURE_NOT_SUPPORTED,
    /**
     * CDMA/EVDO specific. Received Connection Deny: General or Network busy.
     */
    EVDO_CONNECTION_DENY_GENERAL_OR_BUSY,
    /**
     * CDMA/EVDO specific. Received Connection Deny: Billing or Authentication failure.
     */
    EVDO_CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE,
    /**
     * CDMA/EVDO specific. Change HDR.
     */
    EVDO_HDR_CHANGE,
    /**
     * CDMA/EVDO specific. Exit HDR.
     */
    EVDO_HDR_EXIT,
    /**
     * CDMA/EVDO specific. No HDR session.
     */
    EVDO_HDR_NO_SESSION,
    /**
     * CDMA/EVDO specific. HDR call ended in favor of a GPS fix.
     */
    EVDO_HDR_ORIGINATION_DURING_GPS_FIX,
    /**
     * CDMA/EVDO specific. Connection setup timeout.
     */
    EVDO_HDR_CONNECTION_SETUP_TIMEOUT,
    /**
     * CDMA/EVDO specific. Released HDR call by call manager.
     */
    EVDO_HDR_RELEASED_BY_CM,
}
/**
 * Type of call to originate.
 */
enum WdsCallType {
    /**
     * Laptop call.
     */
    LAPTOP,
    /**
     * Embedded call.
     */
    EMBEDDED,
}
/**
 * Client Type
 */
enum WdsClientType {
    /**
     * client type tethered
     */
    TETHERED,
    /**
     * no client type defined
     */
    UNDEFINED,
}
/**
 * Status of the network connection.
 */
enum WdsConnectionStatus {
    /**
     * Unknown status.
     */
    UNKNOWN,
    /**
     * Network is disconnected
     */
    DISCONNECTED,
    /**
     * Network is connected.
     */
    CONNECTED,
    /**
     * Network connection is suspended.
     */
    SUSPENDED,
    /**
     * Network authentication is ongoing.
     */
    AUTHENTICATING,
}
/**
 * Data bearer technology.
 */
enum WdsDataBearerTechnology {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * CDMA2000 1x.
     */
    CDMA20001X,
    /**
     * CDMA2000 HRPD 1xEVDO.
     */
    TODO_1XEVDO,
    /**
     * GSM.
     */
    GSM,
    /**
     * UMTS.
     */
    UMTS,
    /**
     * CDMA2000 HRPD 1xEVDO RevA.
     */
    TODO_1XEVDO_REVA,
    /**
     * EDGE.
     */
    EDGE,
    /**
     * HSDPA and WCDMA.
     */
    HSDPA,
    /**
     * WCDMA and HSUPA.
     */
    HSUPA,
    /**
     * HSDPA and HSUPA.
     */
    HSDPA_HSUPDA,
    /**
     * LTE.
     */
    LTE,
    /**
     * CDMA2000 eHRPD.
     */
    EHRPD,
    /**
     * HSDPA+ and WCDMA.
     */
    HSDPAPLUS,
    /**
     * HSDPA+ and HSUPA.
     */
    HSDPAPLUS_HSUPA,
    /**
     * DC-HSDPA+ and WCDMA.
     */
    DCHSDPAPLUS,
    /**
     * DC-HSDPA+ and HSUPA.
     */
    DCHSDPAPLUS_HSUPA,
    /**
     * HSDPA+ with 64QAM. Since: 1.18.
     */
    HSDPAPLUS_PLUS_64QAM,
    /**
     * HSDPA+ with 64QAM and HSUPA. Since: 1.18.
     */
    HSDPAPLUS_PLUS_64QAM_HSUPA,
    /**
     * TD-SCDMA. Since: 1.18.
     */
    TDSCDMA,
    /**
     * TD-SCDMA and HSDPA. Since: 1.18.
     */
    TDSCDMA_HSDPA,
    /**
     * TD-SCDMA and HSUPA. Since: 1.18.
     */
    TDSCDMA_HSUPA,
}
/**
 * Data call status.
 */
enum WdsDataCallStatus {
    /**
     * data call status unknown.
     */
    UNKNOWN,
    /**
     * data call status activated.
     */
    ACTIVATED,
    /**
     * data call status terminated.
     */
    TERMINATED,
}
/**
 * Data call type.
 */
enum WdsDataCallType {
    /**
     * data call type unknown.
     */
    UNKNOWN,
    /**
     * embedded data call.
     */
    EMBEDDED,
    /**
     * tethered data call.
     */
    TETHERED,
    /**
     * modem embedded data call.
     */
    MODEM_EMBEDDED,
}
/**
 * Data system type.
 */
enum WdsDataSystem {
    /**
     * unknown
     */
    UNKNOWN,
    /**
     * CDMA 1x
     */
    CDMA1X,
    /**
     * CDMA 1x EVDO
     */
    CDMA1X_EVDO,
    /**
     * GPRS
     */
    GPRS,
    /**
     * WCDMA
     */
    WCDMA,
    /**
     * LTE
     */
    LTE,
    /**
     * TD-SCDMA.
     */
    TDSCDMA,
}
/**
 * Network type of the data system.
 */
enum WdsDataSystemNetworkType {
    /**
     * 3GPP network type.
     */
    TODO_3GPP,
    /**
     * 3GPP2 network type.
     */
    TODO_3GPP2,
}
/**
 * QoS delivery order.
 */
enum WdsDeliveryOrder {
    /**
     * Subscribe.
     */
    SUBSCRIBE,
    /**
     * On.
     */
    ON,
    /**
     * Off.
     */
    OFF,
}
/**
 * Dormancy status.
 */
enum WdsDormancyStatus {
    /**
     * dormancy status unknown.
     */
    UNKNOWN,
    /**
     * traffic channel is dormant.
     */
    TRAFFIC_CHANNEL_DORMANT,
    /**
     * traffic channel is active.
     */
    TRAFFIC_CHANNEL_ACTIVE,
}
/**
 * Extended DS profile errors.
 */
enum WdsDsProfileError {
    /**
     * Unknown DS profile error.
     */
    UNKNOWN,
    /**
     * General failure.
     */
    FAIL,
    /**
     * Invalid handle.
     */
    INVALID_HANDLE,
    /**
     * Invalid operation.
     */
    INVALID_OPERATION,
    /**
     * Invalid profile type.
     */
    INVALID_PROFILE_TYPE,
    /**
     * Invalid profile number.
     */
    INVALID_PROFILE_NUMBER,
    /**
     * Invalid profile identifier.
     */
    INVALID_PROFILE_ID,
    /**
     * Invalid argument.
     */
    INVALID_ARGUMENT,
    /**
     * Registry not initialized.
     */
    REGISTRY_NOT_INITIALIZED,
    /**
     * Invalid parameter length.
     */
    INVALID_PARAMETER_LENGTH,
    /**
     * List end, profile not found.
     */
    LIST_END,
    /**
     * Invalid subscription identifier.
     */
    INVALID_SUBSCRIPTION_ID,
    /**
     * Invalid profile family.
     */
    INVALID_PROFILE_FAMILY,
    /**
     * Invalid 3GPP profile family.
     */
    TODO_3GPP_INVALID_PROFILE_FAMILY,
    /**
     * Error accessing 3GPP profiles.
     */
    TODO_3GPP_ACCESS_ERROR,
    /**
     * 3GPP profile doesn't have a valid context.
     */
    TODO_3GPP_CONTEXT_NOT_DEFINED,
    /**
     * 3GPP profile doesn't have valid flag set.
     */
    TODO_3GPP_VALID_FLAG_NOT_SET,
    /**
     * 3GPP profile has read-only flag set.
     */
    TODO_3GPP_READ_ONLY_FLAG_SET,
    /**
     * Out of 3GPP profiles.
     */
    TODO_3GPP_OUT_OF_PROFILES,
    /**
     * Invalid 3GPP2 profile identifier.
     */
    TODO_3GPP2_INVALID_PROFILE_ID,
}
/**
 * Type of network allowed when trying to connect.
 */
enum WdsExtendedTechnologyPreference {
    /**
     * Use CDMA.
     */
    CDMA,
    /**
     * Use UMTS.
     */
    UMTS,
    /**
     * Use EPC, LTE.
     */
    EPC,
    /**
     * Use eMBMS.
     */
    EMBMS,
    /**
     * Use modem link-local.
     */
    MODEM_LINK_LOCAL,
}
/**
 * Type of IP family.
 */
enum WdsIpFamily {
    /**
     * unknown. Since: 1.18.
     */
    UNKNOWN,
    /**
     * IPv4.
     */
    IPV4,
    /**
     * IPv6.
     */
    IPV6,
    /**
     * None specified.
     */
    UNSPECIFIED,
}
/**
 * IP support type.
 */
enum WdsIpSupportType {
    /**
     * IPv4 type.
     */
    IPV4,
    /**
     * IPv6 type.
     */
    IPV6,
    /**
     * IPv4v6 type.
     */
    IPV4V6,
}
/**
 * Network type of the data bearer.
 */
enum WdsNetworkType {
    /**
     * Unknown.
     */
    UNKNOWN,
    /**
     * 3GPP2 network type.
     */
    TODO_3GPP2,
    /**
     * 3GPP network type.
     */
    TODO_3GPP,
}
/**
 * PDP data compression types.
 */
enum WdsPdpDataCompressionType {
    /**
     * no data compression
     */
    OFF,
    /**
     * manufacturer preferred
     */
    MANUFACTURER_PREFERRED,
    /**
     * V42bis
     */
    V42BIS,
    /**
     * V44
     */
    V44,
}
/**
 * PDP header compression types.
 */
enum WdsPdpHeaderCompressionType {
    /**
     * no header compression
     */
    OFF,
    /**
     * manufacturer preferred
     */
    MANUFACTURER_PREFERRED,
    /**
     * RFC1144
     */
    RFC1144,
    /**
     * RFC2507
     */
    RFC2507,
    /**
     * RFC3095
     */
    RFC3095,
}
/**
 * PDP context type.
 */
enum WdsPdpType {
    /**
     * IPv4
     */
    IPV4,
    /**
     * PPP
     */
    PPP,
    /**
     * IPv6
     */
    IPV6,
    /**
     * IPv4 and IPv6 combined context
     */
    IPV4_OR_IPV6,
}
/**
 * Profile family.
 */
enum WdsProfileFamily {
    /**
     * Embedded profile family.
     */
    EMBEDDED,
    /**
     * Tethered profile family.
     */
    TETHERED,
}
/**
 * Profile network type family.
 */
enum WdsProfileType {
    /**
     * 3GPP profile type.
     */
    TODO_3GPP,
    /**
     * 3GPP2 profile type.
     */
    TODO_3GPP2,
}
/**
 * QoS Class Identifier.
 */
enum WdsQosClassIdentifier {
    /**
     * network assigned
     */
    NETWORK_ASSIGN,
    /**
     * guaranteed bitrate 1
     */
    GUARANTEED_BITRATE1,
    /**
     * guaranteed bitrate 2
     */
    GUARANTEED_BITRATE2,
    /**
     * guaranteed bitrate 3
     */
    GUARANTEED_BITRATE3,
    /**
     * guaranteed bitrate 4
     */
    GUARANTEED_BITRATE4,
    /**
     * non-guaranteed bitrate 5
     */
    NON_GUARANTEED_BITRATE5,
    /**
     * non-guaranteed bitrate 6
     */
    NON_GUARANTEED_BITRATE6,
    /**
     * non-guaranteed bitrate 7
     */
    NON_GUARANTEED_BITRATE7,
    /**
     * non-guaranteed bitrate 8
     */
    NON_GUARANTEED_BITRATE8,
}
/**
 * Radio access technology.
 */
enum WdsRadioAccessTechnology {
    /**
     * null bearer
     */
    NULL_BEARER,
    /**
     * WCDMA.
     */
    TODO_3GPP_WCDMA,
    /**
     * GERAN.
     */
    TODO_3GPP_GERAN,
    /**
     * LTE.
     */
    TODO_3GPP_LTE,
    /**
     * TD-SDCMA.
     */
    TODO_3GPP_TDSCDMA,
    /**
     * 3GPP WLAN.
     */
    TODO_3GPP_WLAN,
    /**
     * 3GPP maximum.
     */
    TODO_3GPP_MAXIMUM,
    /**
     * CDMA 1x.
     */
    TODO_3GPP2_1X,
    /**
     * CDMA EVDO, HRPD.
     */
    TODO_3GPP2_HRPD,
    /**
     * CDMA EVDO with eHRPD.
     */
    TODO_3GPP2_EHRPD,
    /**
     * 3GPP2 WLAN.
     */
    TODO_3GPP2_WLAN,
    /**
     * 3GPP2 maximum.
     */
    TODO_3GPP2_MAXIMUM,
}
/**
 * Whether SDUs detected as erroneous are delivered or not.
 */
enum WdsSduErroneousDelivery {
    /**
     * Subscribe.
     */
    SUBSCRIBE,
    /**
     * No detection.
     */
    NO_DETECTION,
    /**
     * Erroneous SDUs are delivered.
     */
    ENABLED,
    /**
     * Erroneous SDUs are delivered.
     */
    DISABLED,
}
/**
 * Target value for the fraction of SDUs lost or detected as erroneous.
 */
enum WdsSduErrorRatio {
    /**
     * Subscribe.
     */
    SUBSCRIBE,
    /**
     * 1x10^2.
     */
    TODO_1E2,
    /**
     * 7x10^3.
     */
    TODO_7E3,
    /**
     * 1x10^3.
     */
    TODO_1E3,
    /**
     * 1x10^4.
     */
    TODO_1E4,
    /**
     * 1x10^5.
     */
    TODO_1E5,
    /**
     * 1x10^6.
     */
    TODO_1E6,
    /**
     * 1x10^7.
     */
    TODO_1E1,
}
/**
 * Target value for the undetected bit error ratio in the delivered SDUs.
 */
enum WdsSduResidualBitErrorRatio {
    /**
     * Subscribe.
     */
    SUBSCRIBE,
    /**
     * 5x10^2.
     */
    TODO_5E2,
    /**
     * 1x10^2.
     */
    TODO_1E2,
    /**
     * 5x10^3.
     */
    TODO_5E3,
    /**
     * 4x10^3.
     */
    TODO_4E3,
    /**
     * 1x10^3.
     */
    TODO_1E3,
    /**
     * 1x10^4.
     */
    TODO_1E4,
    /**
     * 1x10^5.
     */
    TODO_1E5,
    /**
     * 1x10^6.
     */
    TODO_1E6,
    /**
     * 6x10^8.
     */
    TODO_6E8,
}
/**
 * Tethered call type.
 */
enum WdsTetheredCallType {
    /**
     * non-tethered.
     */
    NON_TETHERED,
    /**
     * RmNet.
     */
    RMNET,
    /**
     * DUN.
     */
    DUN,
}
/**
 * QoS Traffic Classes.
 */
enum WdsTrafficClass {
    /**
     * default class, best-effort
     */
    SUBSCRIBED,
    /**
     * two-way video/voice, most delay sensitive
     */
    CONVERSATIONAL,
    /**
     * one-way video/audio, delay sensitive
     */
    STREAMING,
    /**
     * delay-sensitive, e.g. browsing, SSH.
     */
    INTERACTIVE,
    /**
     * delay-insensitive, e.g. downloads, email.
     */
    BACKGROUND,
}
/**
 * 3GPP-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_3GPP.
 */
enum WdsVerboseCallEndReason3gpp {
    /**
     * Operator-determined barring.
     */
    OPERATOR_DETERMINED_BARRING,
    /**
     * LLC or SNDCP failure.
     */
    LLC_SNDCP_FAILURE,
    /**
     * Insufficient resources.
     */
    INSUFFICIENT_RESOURCES,
    /**
     * Unknown or missing APN.
     */
    UNKNOWN_APN,
    /**
     * Unknown PDP address or type.
     */
    UNKNOWN_PDP,
    /**
     * Authentication failed.
     */
    AUTHENTICATION_FAILED,
    /**
     * Activation rejected by GGSN.
     */
    GGSN_REJECT,
    /**
     * Activation rejected.
     */
    ACTIVATION_REJECT,
    /**
     * Service option not supported.
     */
    OPTION_NOT_SUPPORTED,
    /**
     * Service option not subscribed.
     */
    OPTION_UNSUBSCRIBED,
    /**
     * Service option temporarily out of order.
     */
    OPTION_TEMPORARILY_OUT_OF_ORDER,
    /**
     * NSAPI already used.
     */
    NSAPI_ALREADY_USED,
    /**
     * Regular PDP context deactivation.
     */
    REGULAR_DEACTIVATION,
    /**
     * QoS not accepted.
     */
    QOS_NOT_ACCEPTED,
    /**
     * Network failure.
     */
    NETWORK_FAILURE,
    /**
     * Reattach required.
     */
    REATTACH_REQUIRED,
    /**
     * Feature not supported.
     */
    FEATURE_NOT_SUPPORTED,
    /**
     * Semantic error in TFT operation.
     */
    TFT_SEMANTIC_ERROR,
    /**
     * Syntax error in TFT operation.
     */
    TFT_SYNTAX_ERROR,
    /**
     * Unknown PDP context.
     */
    UNKNOWN_PDP_CONTEXT,
    /**
     * Semantic error in packet filters.
     */
    FILTER_SEMANTIC_ERROR,
    /**
     * Syntax error in packet filters.
     */
    FILTER_SYNTAX_ERROR,
    /**
     * PDP context without TFT activated.
     */
    PDP_WITHOUT_ACTIVE_TFT,
    /**
     * IPv4 only allowed.
     */
    IPV4_ONLY_ALLOWED,
    /**
     * IPv6 only allowed.
     */
    IPV6_ONLY_ALLOWED,
    /**
     * Single address bearer only.
     */
    SINGLE_ADDRESS_BEARER_ONLY,
    /**
     * ESM information not received.
     */
    ESM_INFO_NOT_RECEIVED,
    /**
     * PDN connection does not exist.
     */
    PDN_CONNECTION_DOES_NOT_EXIST,
    /**
     * Multiple connection to same PDN not allowed.
     */
    MULTIPLE_CONNECTION_TO_SAME_PDN_NOT_ALLOWED,
    /**
     * Invalid transaction ID.
     */
    INVALID_TRANSACTION_ID,
    /**
     * Message incorrect semantically.
     */
    MESSAGE_INCORRECT_SEMANTIC,
    /**
     * Invalid mandatory information.
     */
    INVALID_MANDATORY_INFO,
    /**
     * Message type not implemented.
     */
    MESSAGE_TYPE_UNSUPPORTED,
    /**
     * Message not compatible with state.
     */
    MESSAGE_TYPE_NONCOMPATIBLE_STATE,
    /**
     * Information element unknown.
     */
    UNKNOWN_INFO_ELEMENT,
    /**
     * Conditional IE error.
     */
    CONDITIONAL_IE_ERROR,
    /**
     * Message and protocol state uncompatible.
     */
    MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE,
    /**
     * Protocol error.
     */
    PROTOCOL_ERROR,
    /**
     * APN type conflict.
     */
    APN_TYPE_CONFLICT,
    /**
     * Invalid proxy call session control function address. Since 1.24.10.
     */
    INVALID_PROXY_CALL_SESSION_CONTROL_FUNCTION_ADDRESS,
}
/**
 * Call manager specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_CM.
 */
enum WdsVerboseCallEndReasonCm {
    /**
     * CDMA specific. Phone is CDMA-locked.
     */
    CDMA_LOCK,
    /**
     * CDMA specific. Received intercept from the BS.
     */
    INTERCEPT,
    /**
     * CDMA specific. Received reorder from the BS.
     */
    REORDER,
    /**
     * CDMA specific. Received release from the BS, SO reject.
     */
    RELEASE_SO_REJECT,
    /**
     * CDMA specific. Received incoming call from the BS.
     */
    INCOMING_CALL,
    /**
     * CDMA specific. Received alert stop from the BS.
     */
    ALERT_STOP,
    /**
     * CDMA specific. Received end activation.
     */
    ACTIVATION,
    /**
     * CDMA specific. Maximum access probes transmitted.
     */
    MAX_ACCESS_PROBES,
    /**
     * CDMA specific. Concurrent service not supported by the BS.
     */
    CCS_NOT_SUPPORTED_BY_BS,
    /**
     * CDMA specific. No response received from the BS.
     */
    NO_RESPONSE_FROM_BS,
    /**
     * CDMA specific. Rejected by the BS.
     */
    REJECTED_BY_BS,
    /**
     * CDMA specific. Concurrent services requested are incompatible.
     */
    INCOMPATIBLE,
    /**
     * CDMA specific. Already in TC.
     */
    ALREADY_IN_TC,
    /**
     * CDMA specific. Call originated during GPS.
     */
    USER_CALL_ORIGINATED_DURING_GPS,
    /**
     * CDMA specific. Call originated during SMS.
     */
    USER_CALL_ORIGINATED_DURING_SMS,
    /**
     * CDMA specific. No service.
     */
    NO_CDMA_SERVICE,
    /**
     * MC abort. Since 1.24.10.
     */
    MC_ABORT,
    /**
     * Persistence test failure. Since 1.24.10.
     */
    PSIST_NG,
    /**
     * UIM not present. Since 1.24.10.
     */
    UIM_NOT_PRESENT,
    /**
     * Retry order.
     */
    RETRY_ORDER,
    /**
     * Access blocked. Since 1.24.10.
     */
    ACCESS_BLOCK,
    /**
     * Access blocked for all. Since 1.24.10.
     */
    ACCESS_BLOCK_ALL,
    /**
     * Maximum access probes for IS-707B call. Since 1.24.10.
     */
    IS707B_MAX_ACCESS_PROBES,
    /**
     * Thermal emergency. Since 1.24.10.
     */
    THERMAL_EMERGENCY,
    /**
     * Call origination throttled. Since 1.24.10.
     */
    CALL_ORIGINATION_THROTTLED,
    /**
     * Voice call originated and concurrent voice/data not supported. Since 1.24.10.
     */
    USER_CALL_ORIGINATED,
    /**
     * Conference failed. Since 1.24.10.
     */
    CONFERENCE_FAILED,
    /**
     * Incoming rejected.
     */
    INCOMING_REJECTED,
    /**
     * No gateway service.
     */
    NO_GATEWAY_SERVICE,
    /**
     * No GPRS context.
     */
    NO_GPRS_CONTEXT,
    /**
     * Illegal MS.
     */
    ILLEGAL_MS,
    /**
     * Illegal ME.
     */
    ILLEGAL_ME,
    /**
     * GPRS and non GPRS services not allowed.
     */
    GPRS_AND_NON_GPRS_SERVICES_NOT_ALLOWED,
    /**
     * GPRS services not allowed.
     */
    GPRS_SERVICES_NOT_ALLOWED,
    /**
     * MS identity not derived by the network.
     */
    MS_IDENTITY_NOT_DERIVED_BY_THE_NETWORK,
    /**
     * Implicitly detached.
     */
    IMPLICITLY_DETACHED,
    /**
     * PLMN not allowed.
     */
    PLMN_NOT_ALLOWED,
    /**
     * LA not allowed.
     */
    LA_NOT_ALLOWED,
    /**
     * GPRS services not allowed in PLMN.
     */
    GPRS_SERVICES_NOT_ALLOWED_IN_PLMN,
    /**
     * PDP duplicate.
     */
    PDP_DUPLICATE,
    /**
     * UE radio access technology change.
     */
    UE_RAT_CHANGE,
    /**
     * Congestion.
     */
    CONGESTION,
    /**
     * No PDP context activated.
     */
    NO_PDP_CONTEXT_ACTIVATED,
    /**
     * Access class DSAC rejection.
     */
    ACCESS_CLASS_DSAC_REJECTION,
    /**
     * Maximum retries failed to activate PDP context. Since 1.24.10.
     */
    PDP_ACTIVATE_MAX_RETRY_FAILED,
    /**
     * RAB failure. Since 1.24.10.
     */
    RAB_FAILURE,
    /**
     * EPS service not allowed. Since 1.24.10.
     */
    EPS_SERVICE_NOT_ALLOWED,
    /**
     * Tracking area not allowed. Since 1.24.10.
     */
    TRACKING_AREA_NOT_ALLOWED,
    /**
     * Roaming not allowed in tracking area. Since 1.24.10.
     */
    ROAMING_NOT_ALLOWED_IN_TRACKING_AREA,
    /**
     * No suitable cells in tracking area. Since 1.24.10.
     */
    NO_SUITABLE_CELLS_IN_TRACKING_AREA,
    /**
     * Not authorized in closed subscriber group. Since 1.24.10.
     */
    NOT_AUTHORIZED_CLOSED_SUBSCRIBER_GROUP,
    /**
     * EPS Session Management, unknown EPS bearer context. Since 1.24.10.
     */
    ESM_UNKNOWN_EPS_BEARER_CONTEXT,
    /**
     * DRB released at RRC. Since 1.24.10.
     */
    DRB_RELEASED_AT_RRC,
    /**
     * NAS signal connection released. Since 1.24.10.
     */
    NAS_SIGNAL_CONNECTION_RELEASED,
    /**
     * EPS Mobility Management, detached. Since 1.24.10.
     */
    EMM_DETACHED,
    /**
     * EPS Mobility Management, attach failed. Since 1.24.10.
     */
    EMM_ATTACH_FAILED,
    /**
     * EPS Mobility Management, attach started. Since 1.24.10.
     */
    EMM_ATTACH_STARTED,
    /**
     * LTE NAS service request failed. Since 1.24.10.
     */
    LTE_NAS_SERVICE_REQUEST_FAILED,
    /**
     * EPS Session Management, active dedicated bearer reactivated by network. Since 1.24.10.
     */
    ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW,
    /**
     * EPS Session Management, lower layer failure. Since 1.24.10.
     */
    ESM_LOWER_LAYER_FAILURE,
    /**
     * EPS Session Management, sync up with network. Since 1.24.10.
     */
    ESM_SYNC_UP_WITH_NW,
    /**
     * EPS Session Management, network activated dedicated bearer with id of default bearer. Since 1.24.10.
     */
    ESM_NW_ACTIVATED_DEDICATED_BEARER_WITH_ID_OF_DEFAULT_BEARER,
    /**
     * EPS Session Management, bad OTA message. Since 1.24.10.
     */
    ESM_BAD_OTA_MESSAGE,
    /**
     * EPS Session Management, DS rejected call. Since 1.24.10.
     */
    ESM_DS_REJECTED_CALL,
    /**
     * EPS Session Management, context transferred due to IRAT. Since 1.24.10.
     */
    ESM_CONTEXT_TRANSFERRED_DUE_TO_IRAT,
    /**
     * DS explicit deactivation. Since 1.24.10.
     */
    DS_EXPLICIT_DEACT,
    /**
     * EPS Session Management, local cause none. Since 1.24.10.
     */
    ESM_LOCAL_CAUSE_NONE,
    /**
     * LTE NAS service request failed, no throttle. Since 1.24.10.
     */
    LTE_NAS_SERVICE_REQUEST_FAILED_NO_THROTTLE,
    /**
     * ACL failure. Since 1.24.10.
     */
    ACL_FAILURE,
    /**
     * LTE NAS service request failed, DS disallow. Since 1.24.10.
     */
    LTE_NAS_SERVICE_REQUEST_FAILED_DS_DISALLOW,
    /**
     * EPS Mobility Management, T3417 expired. Since 1.24.10.
     */
    EMM_T3417_EXPIRED,
    /**
     * EPS Mobility Management, T3417 ext expired. Since 1.24.10.
     */
    EMM_T3417_EXT_EXPIRED,
    /**
     * LTE Radio Resource Control, UL data confirmation failure, txn. Since 1.24.10.
     */
    LRRC_UL_DATA_CONFIRMATION_FAILURE_TXN,
    /**
     * LTE Radio Resource Control, UL data confirmation failure, handover. Since 1.24.10.
     */
    LRRC_UL_DATA_CONFIRMATION_FAILURE_HANDOVER,
    /**
     * LTE Radio Resource Control, UL data confirmation failure, connection release. Since 1.24.10.
     */
    LRRC_UL_DATA_CONFIRMATION_FAILURE_CONN_REL,
    /**
     * LTE Radio Resource Control, UL data confirmation failure, radio link failure. Since 1.24.10.
     */
    LRRC_UL_DATA_CONFIRMATION_FAILURE_RLF,
    /**
     * LTE Radio Resource Control, UL data confirmation failure, ctrl not conn. Since 1.24.10.
     */
    LRRC_UL_DATA_CONFIRMATION_FAILURE_CTRL_NOT_CONN,
    /**
     * LTE Radio Resource Control, connection establishment failure. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE,
    /**
     * LTE Radio Resource Control, connection establishment failure, aborted. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ABORTED,
    /**
     * LTE Radio Resource Control, connection establishment failure, access barred. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ACCESS_BARRED,
    /**
     * LTE Radio Resource Control, connection establishment failure, cell reselection. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CELL_RESELECTION,
    /**
     * LTE Radio Resource Control, connection establishment failure, config failure. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CONFIG_FAILURE,
    /**
     * LTE Radio Resource Control, connection establishment failure, timer expired. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_TIMER_EXPIRED,
    /**
     * LTE Radio Resource Control, connection establishment failure, link failure. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_LINK_FAILURE,
    /**
     * LTE Radio Resource Control, connection establishment failure, not camped. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_NOT_CAMPED,
    /**
     * LTE Radio Resource Control, connection establishment failure, SI failure. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_SI_FAILURE,
    /**
     * LTE Radio Resource Control, connection establishment failure, rejected. Since 1.24.10.
     */
    LRRC_CONNECTION_ESTABLISHMENT_FAILURE_REJECTED,
    /**
     * LTE Radio Resource Control, connection release, normal. Since 1.24.10.
     */
    LRRC_CONNECTION_RELEASE_NORMAL,
    /**
     * LTE Radio Resource Control, connection release, radio link failure. Since 1.24.10.
     */
    LRRC_CONNECTION_RELEASE_RLF,
    /**
     * LTE Radio Resource Control, connection release, cre failure. Since 1.24.10.
     */
    LRRC_CONNECTION_RELEASE_CRE_FAILURE,
    /**
     * LTE Radio Resource Control, connection release, oos during cre. Since 1.24.10.
     */
    LRRC_CONNECTION_RELEASE_OOS_DURING_CRE,
    /**
     * LTE Radio Resource Control, connection release, aborted. Since 1.24.10.
     */
    LRRC_CONNECTION_RELEASE_ABORTED,
    /**
     * LTE Radio Resource Control, connection release, SIB read error. Since 1.24.10.
     */
    LRRC_CONNECTION_RELEASE_SIB_READ_ERROR,
    /**
     * Detach with reattach LTE network detach. Since 1.24.10.
     */
    DETACH_WITH_REATTACH_LTE_NW_DETACH,
    /**
     * Detach without reattach LTE network detach. Since 1.24.10.
     */
    DETACH_WITHOUT_REATTACH_LTE_NW_DETACH,
    /**
     * EPS Session Management, proc timeout. Since 1.24.10.
     */
    ESM_PROC_TIMEOUT,
    /**
     * Message exceed max L2 limit. Since 1.24.10.
     */
    MESSAGE_EXCEED_MAX_L2_LIMIT,
    /**
     * CDMA/EVDO specific. Received Connection Deny. General or Network busy.
     */
    CONNECTION_DENY_GENERAL_OR_BUSY,
    /**
     * CDMA/EVDO specific. Received Connection Deny. Billing or Authentication failure.
     */
    CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE,
    /**
     * CDMA/EVDO specific. Change HDR.
     */
    HDR_CHANGE,
    /**
     * CDMA/EVDO specific. Exit HDR.
     */
    HDR_EXIT,
    /**
     * CDMA/EVDO specific. No HDR session.
     */
    HDR_NO_SESSION,
    /**
     * CDMA/EVDO specific. HDR call ended in favor of a GPS fix.
     */
    HDR_ORIGINATION_DURING_GPS_FIX,
    /**
     * CDMA/EVDO specific. Connection setup timeout.
     */
    HDR_CONNECTION_SETUP_TIMEOUT,
    /**
     * CDMA/EVDO specific. Released HDR call by call manager.
     */
    HDR_RELEASED_BY_CM,
    /**
     * Failed to acquire co-located HDR for origination. Since 1.24.10.
     */
    HDR_COLLOCATED_ACQUISITION_FAILED,
    /**
     * CDMA/EVDO specific. OTASP commit in progress. Since 1.24.10.
     */
    OTASP_COMMIT_IN_PROGRESS,
    /**
     * CDMA/EVDO specific. No hybrid HDR service.
     */
    HDR_NO_HYBRID_SERVICE,
    /**
     * CDMA/EVDO specific. No lock granted. Since 1.24.10.
     */
    HDR_NO_LOCK_GRANTED,
    /**
     * CDMA/EVDO specific. hold other in progress. Since 1.24.10.
     */
    HOLD_OTHER_IN_PROGRESS,
    /**
     * CDMA/EVDO specific. Fade. Since 1.24.10.
     */
    HDR_FADE,
    /**
     * CDMA/EVDO specific. Access failure. Since 1.24.10.
     */
    HDR_ACCESS_FAILURE,
    /**
     * Client end.
     */
    CLIENT_END,
    /**
     * No service.
     */
    NO_SERVICE,
    /**
     * Fade.
     */
    FADE,
    /**
     * Release normal.
     */
    RELEASE_NORMAL,
    /**
     * Access attempt in progress.
     */
    ACCESS_ATTEMPT_IN_PROGRESS,
    /**
     * Access Failure.
     */
    ACCESS_FAILURE,
    /**
     * Redirection or handoff.
     */
    REDIRECTION_OR_HANDOFF,
    /**
     * Offline. Since 1.24.10.
     */
    OFFLINE,
    /**
     * Emergency mode. Since 1.24.10.
     */
    EMERGENCY_MODE,
    /**
     * Phone in use. Since 1.24.10.
     */
    PHONE_IN_USE,
    /**
     * Invalid mode. Since 1.24.10.
     */
    INVALID_MODE,
    /**
     * Invalid SIM state. Since 1.24.10.
     */
    INVALID_SIM_STATE,
    /**
     * No collocated HDR. Since 1.24.10.
     */
    NO_COLLOCATED_HDR,
    /**
     * Call control rejected. Since 1.24.10.
     */
    CALL_CONTROL_REJECTED,
}
/**
 * eHRPD-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_EHRPD.
 */
enum WdsVerboseCallEndReasonEhrpd {
    /**
     * Subscription limited to IPv4.
     */
    SUBSCRIPTION_LIMITED_TO_IPV4,
    /**
     * Subscription limited to IPv6.
     */
    SUBSCRIPTION_LIMITED_TO_IPV6,
    /**
     * VSNCP specific. timeout.
     */
    VSNCP_TIMEOUT,
    /**
     * VSNCP specific. failure.
     */
    VSNCP_FAILURE,
    /**
     * VSNCP specific. 3GPP2 general error.
     */
    VSNCP_3GPP2_GENERAL_ERROR,
    /**
     * VSNCP specific. 3GPP2 unauthenticated APN.
     */
    VSNCP_3GPP2_UNAUTHENTICATED_APN,
    /**
     * VSNCP specific. 3GPP2 PDN limit exceeded.
     */
    VSNCP_3GPP2_PDN_LIMIT_EXCEEDED,
    /**
     * VSNCP specific. 3GPP2 no PDN gateway.
     */
    VSNCP_3GPP2_NO_PDN_GATEWAY,
    /**
     * VSNCP specific. 3GPP2 PDN gateway unreachable.
     */
    VSNCP_3GPP2_PDN_GATEWAY_UNREACHABLE,
    /**
     * VSNCP specific. 3GPP2 PDN gateway rejected.
     */
    VSNCP_3GPP2_PDN_GATEWAY_REJECTED,
    /**
     * VSNCP specific. 3GPP2 insufficient parameters.
     */
    VSNCP_3GPP2_INSUFFICIENT_PARAMETERS,
    /**
     * VSNCP specific. 3GPP2 resource unavailable.
     */
    VSNCP_3GPP2_RESOURCE_UNAVAILABLE,
    /**
     * VSNCP specific. 3GPP2 administratively prohibited.
     */
    VSNCP_3GPP2_ADMINISTRATIVELY_PROHIBITED,
    /**
     * VSNCP specific. 3GPP2 PDN ID in use.
     */
    VSNCP_3GPP2_PDN_ID_IN_USE,
    /**
     * VSNCP specific. 3GPP2 subscription limitation.
     */
    VSNCP_3GPP2_SUBSCRIPTION_LIMITATION,
    /**
     * VSNCP specific. 3GPP2 PDN exists for this APN.
     */
    VSNCP_3GPP2_PDN_EXISTS_FOR_THIS_APN,
}
/**
 * Internal call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_INTERNAL.
 */
enum WdsVerboseCallEndReasonInternal {
    /**
     * Internal error.
     */
    ERROR,
    /**
     * Call ended.
     */
    CALL_ENDED,
    /**
     * Unknown internal cause.
     */
    UNKNOWN_INTERNAL_CAUSE,
    /**
     * Unknown cause.
     */
    UNKNOWN_CAUSE,
    /**
     * Close in progress.
     */
    CLOSE_IN_PROGRESS,
    /**
     * Network initiated termination.
     */
    NETWORK_INITIATED_TERMINATION,
    /**
     * App preempted.
     */
    APP_PREEMPTED,
    /**
     * PDN IPv4 call disallowed. Since: 1.14.
     */
    PDN_IPV4_CALL_DISALLOWED,
    /**
     * PDN IPv4 call throttled. Since: 1.14.
     */
    PDN_IPV4_CALL_THROTTLED,
    /**
     * PDN IPv6 call disallowed. Since: 1.14.
     */
    PDN_IPV6_CALL_DISALLOWED,
    /**
     * PDN IPv6 call throttled. Since: 1.14.
     */
    PDN_IPV6_CALL_THROTTLED,
    /**
     * Modem restart. Since: 1.14.
     */
    MODEM_RESTART,
    /**
     * PDP PPP not supported. Since: 1.14.
     */
    PDP_PPP_NOT_SUPPORTED,
    /**
     * Unpreferred RAT. Since: 1.14.
     */
    UNPREFERRED_RAT,
    /**
     * Physical link close in progress. Since: 1.14.
     */
    PHYSICAL_LINK_CLOSE_IN_PROGRESS,
    /**
     * APN pending handover. Since: 1.14.
     */
    APN_PENDING_HANDOVER,
    /**
     * Profile bearer incompatible. Since: 1.14.
     */
    PROFILE_BEARER_INCOMPATIBLE,
    /**
     * MMGDSI Card event. Since: 1.14.
     */
    MMGDSI_CARD_EVENT,
    /**
     * LPM or power down. Since: 1.14.
     */
    LPM_OR_POWER_DOWN,
    /**
     * APN disabled. Since: 1.14.
     */
    APN_DISABLED,
    /**
     * MPIT expired. Since: 1.14.
     */
    MPIT_EXPIRED,
    /**
     * IPv6 address transfer failed. Since: 1.14.
     */
    IPV6_ADDRESS_TRANSFER_FAILED,
    /**
     * TRAT swap failed. Since: 1.14.
     */
    TRAT_SWAP_FAILED,
    /**
     * eHRPD to HRPD fallback. Since 1.24.10.
     */
    EHRPD_TO_HRPD_FALLBACK,
    /**
     * Mandatory APN disabled. Since 1.24.10.
     */
    MANDATORY_APN_DISABLED,
    /**
     * MIP config failure. Since 1.24.10.
     */
    MIP_CONFIG_FAILURE,
    /**
     * PDN inactivity timeout expired. Since 1.24.10.
     */
    PDN_INACTIVITY_TIMER_EXPIRED,
    /**
     * Max IPv4 connections. Since 1.24.10.
     */
    MAX_V4_CONNECTIONS,
    /**
     * Max IPv6 connections. Since 1.24.10.
     */
    MAX_V6_CONNECTIONS,
    /**
     * APN mismatch. Since 1.24.10.
     */
    APN_MISMATCH,
    /**
     * IP version mismatch. Since 1.24.10.
     */
    IP_VERSION_MISMATCH,
    /**
     * DUN call disallowed. Since 1.24.10.
     */
    DUN_CALL_DISALLOWED,
    /**
     * Invalid profile. Since 1.24.10.
     */
    INVALID_PROFILE,
    /**
     * EPC to non-EPC transition. Since 1.24.10.
     */
    EPC_NONEPC_TRANSITION,
    /**
     * Invalid profile ID. Since 1.24.10.
     */
    INVALID_PROFILE_ID,
    /**
     * Call already present. Since 1.24.10.
     */
    CALL_ALREADY_PRESENT,
    /**
     * Interface in use. Since 1.24.10.
     */
    INTERFACE_IN_USE,
    /**
     * IP PDP mismatch. Since 1.24.10.
     */
    IP_PDP_MISMATCH,
    /**
     * APN disallowed on roaming. Since 1.24.10.
     */
    APN_DISALLOWED_ON_ROAMING,
    /**
     * APN parameter change. Since 1.24.10.
     */
    APN_PARAMETER_CHANGE,
    /**
     * Interface in use config match. Since 1.24.10.
     */
    INTERFACE_IN_USE_CONFIG_MATCH,
    /**
     * NULL APN disallowed. Since 1.24.10.
     */
    NULL_APN_DISALLOWED,
    /**
     * Thermal mitigation. Since 1.24.10.
     */
    THERMAL_MITIGATION,
    /**
     * Subs ID mismatch Since 1.24.10.
     */
    SUBS_ID_MISMATCH,
    /**
     * Data settings disabled. Since 1.24.10.
     */
    DATA_SETTINGS_DISABLED,
    /**
     * Data roaming settings disabled. Since 1.24.10.
     */
    DATA_ROAMING_SETTINGS_DISABLED,
    /**
     * APN format invalid. Since 1.24.10.
     */
    APN_FORMAT_INVALID,
    /**
     * DDS call abort. Since 1.24.10.
     */
    DDS_CALL_ABORT,
    /**
     * Validation failure. Since 1.24.10.
     */
    VALIDATION_FAILURE,
}
/**
 * IPv6-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IPV6.
 */
enum WdsVerboseCallEndReasonIpv6 {
    /**
     * Prefix unavailable.
     */
    PREFIX_UNAVAILABLE,
    /**
     * HRDP IPv6 disabled.
     */
    HRPD_IPV6_DISABLED,
    /**
     * IPv6 disabled. Since 1.24.10.
     */
    DISABLED,
}
/**
 * Mobile IP specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP.
 */
enum WdsVerboseCallEndReasonMip {
    /**
     * Unknown reason.
     */
    ERROR_REASON_UNKNOWN,
    /**
     * FA error. Reason unspecified.
     */
    FA_ERROR_REASON_UNSPECIFIED,
    /**
     * FA error. Administratively prohibited.
     */
    FA_ERROR_ADMINISTRATIVELY_PROHIBITED,
    /**
     * FA error. Insufficient resources.
     */
    FA_ERROR_INSUFFICIENT_RESOURCES,
    /**
     * FA error. Mobile node authenticatin failure.
     */
    FA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE,
    /**
     * FA error. HA authentication failure.
     */
    FA_ERROR_HA_AUTHENTICATION_FAILURE,
    /**
     * FA error. Requested lifetime too long.
     */
    FA_ERROR_REQUESTED_LIFETIME_TOO_LONG,
    /**
     * FA error. Malformed request.
     */
    FA_ERROR_MALFORMED_REQUEST,
    /**
     * FA error. Malformed reply.
     */
    FA_ERROR_MALFORMED_REPLY,
    /**
     * FA error. Encapsulation unavailable.
     */
    FA_ERROR_ENCAPSULATION_UNAVAILABLE,
    /**
     * FA error. VJHC unavailable.
     */
    FA_ERROR_VJHC_UNAVAILABLE,
    /**
     * FA error. Reverse tunnel unavailable.
     */
    FA_ERROR_REVERSE_TUNNEL_UNAVAILABLE,
    /**
     * FA error. Reverse tunnel mandatory and T bit not set.
     */
    FA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET,
    /**
     * FA error. Delivery style not supported.
     */
    FA_ERROR_DELIVERY_STYLE_NOT_SUPPORTED,
    /**
     * FA error. Missing NAI.
     */
    FA_ERROR_MISSING_NAI,
    /**
     * FA error. Missing HA.
     */
    FA_ERROR_MISSING_HA,
    /**
     * FA error. Missing home address.
     */
    FA_ERROR_MISSING_HOME_ADDRESS,
    /**
     * FA error. Unknown challenge.
     */
    FA_ERROR_UNKNOWN_CHALLENGE,
    /**
     * FA error. Missing challenge.
     */
    FA_ERROR_MISSING_CHALLENGE,
    /**
     * FA error. Stale challenge.
     */
    FA_ERROR_STALE_CHALLENGE,
    /**
     * HA error. Reason unspecified.
     */
    HA_ERROR_REASON_UNSPECIFIED,
    /**
     * HA error. Administratively prohibited.
     */
    HA_ERROR_ADMINISTRATIVELY_PROHIBITED,
    /**
     * HA error. Insufficient resources.
     */
    HA_ERROR_INSUFFICIENT_RESOURCES,
    /**
     * HA error. Mobile node authentication failure.
     */
    HA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE,
    /**
     * HA error. FA authentication failure.
     */
    HA_ERROR_FA_AUTHENTICATION_FAILURE,
    /**
     * HA error. Registration ID mismatch.
     */
    HA_ERROR_REGISTRATION_ID_MISMATCH,
    /**
     * HA error. Malformed request.
     */
    HA_ERROR_MALFORMED_REQUEST,
    /**
     * HA error. Unknown HA address.
     */
    HA_ERROR_UNKNOWN_HA_ADDRESS,
    /**
     * HA error. Reverse tunnel unavailable.
     */
    HA_ERROR_REVERSE_TUNNEL_UNAVAILABLE,
    /**
     * HA error. Reverse tunnel mandatory and T bit not set.
     */
    HA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET,
    /**
     * HA error. Encapsulation unavailable.
     */
    HA_ERROR_ENCAPSULATION_UNAVAILABLE,
}
/**
 * PPP-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_PPP.
 */
enum WdsVerboseCallEndReasonPpp {
    /**
     * Unknown error.
     */
    UNKNOWN,
    /**
     * Timeout.
     */
    TIMEOUT,
    /**
     * Authentication failure.
     */
    AUTHENTICATION_FAILURE,
    /**
     * Option mismatch.
     */
    OPTION_MISMATCH,
    /**
     * PAP failure.
     */
    PAP_FAILURE,
    /**
     * CHAP failure.
     */
    CHAP_FAILURE,
    /**
     * Close in progress. Since 1.24.10.
     */
    CLOSE_IN_PROGRESS,
}
/**
 * Type of verbose call end reason.
 */
enum WdsVerboseCallEndReasonType {
    /**
     * Mobile IP.
     */
    MIP,
    /**
     * Internal.
     */
    INTERNAL,
    /**
     * Call manager.
     */
    CM,
    /**
     * 3GPP.
     */
    TODO_3GPP,
    /**
     * PPP.
     */
    PPP,
    /**
     * eHRPD.
     */
    EHRPD,
    /**
     * IPv6.
     */
    IPV6,
}
/**
 * Ack failure cause.
 */
enum WmsAckFailureCause {
    /**
     * No network response.
     */
    NO_NETWORK_RESPONSE,
    /**
     * Network released link.
     */
    NETWORK_RELEASED_LINK,
    /**
     * Not sent.
     */
    NOT_SENT,
}
/**
 * Indication of whether ACK needs to be sent or not.
 */
enum WmsAckIndicator {
    /**
     * ACK needs to be sent.
     */
    SEND,
    /**
     * ACK doesn't need to be sent.
     */
    DO_NOT_SEND,
}
/**
 * Cause codes when failed to send an SMS in CDMA.
 */
enum WmsCdmaCauseCode {
    /**
     * Address is valid but not yet allocated. Since 1.18.
     */
    NETWORK_ADDRESS_VACANT,
    /**
     * Address is invalid. Since 1.18.
     */
    NETWORK_ADDRESS_TRANSLATION_FAILURE,
    /**
     * Network resource shortage. Since 1.18.
     */
    NETWORK_RESOURCE_SHORTAGE,
    /**
     * Network failed. Since 1.18.
     */
    NETWORK_FAILURE,
    /**
     * SMS teleservice ID is invalid. Since 1.18.
     */
    NETWORK_INVALID_TELESERVICE_ID,
    /**
     * Other network error. Since 1.18.
     */
    NETWORK_OTHER,
    /**
     * No page response from destination. Since 1.18.
     */
    DESTINATION_NO_PAGE_RESPONSE,
    /**
     * Destination is busy. Since 1.18.
     */
    DESTINATION_BUSY,
    /**
     * No acknowledge from destination. Since 1.18.
     */
    DESTINATION_NO_ACK,
    /**
     * Destination resource shortage. Since 1.18.
     */
    DESTINATION_RESOURCE_SHORTAGE,
    /**
     * SMS delivery postponed. Since 1.18.
     */
    DESTINATION_SMS_DELIVERY_POSTPONED,
    /**
     * Destination out of service. Since 1.18.
     */
    DESTINATION_OUT_OF_SERVICE,
    /**
     * Destination not at address. Since 1.18.
     */
    DESTINATION_NOT_AT_ADDRESS,
    /**
     * Other destination error. Since 1.18.
     */
    DESTINATION_OTHER,
    /**
     * Radio interface resource shortage. Since 1.18.
     */
    RADIO_INTERFACE_RESOURCE_SHORTAGE,
    /**
     * Radio interface incompatibility. Since 1.18.
     */
    RADIO_INTERFACE_INCOMPATIBILITY,
    /**
     * Other radio interface error. Since 1.18.
     */
    RADIO_INTERFACE_OTHER,
    /**
     * Encoding error. Since 1.18.
     */
    GENERAL_ENCODING,
    /**
     * SMS origin denied. Since 1.18.
     */
    GENERAL_SMS_ORIGIN_DENIED,
    /**
     * SMS destination denied. Since 1.18.
     */
    GENERAL_SMS_DESTINATION_DENIED,
    /**
     * Supplementary service not supported. Since 1.18.
     */
    GENERAL_SUPPLEMENTARY_SERVICE_NOT_SUPPORTED,
    /**
     * SMS not supported. Since 1.18.
     */
    GENERAL_SMS_NOT_SUPPORTED,
    /**
     * Missing optional expected parameter. Since 1.18.
     */
    GENERAL_MISSING_EXPECTED_PARAMETER,
    /**
     * Missing mandatory parameter. Since 1.18.
     */
    GENERAL_MISSING_MANDATORY_PARAMETER,
    /**
     * Unrecognized parameter value. Since 1.18.
     */
    GENERAL_UNRECOGNIZED_PARAMETER_VALUE,
    /**
     * Unexpected parameter value. Since 1.18.
     */
    GENERAL_UNEXPECTED_PARAMETER_VALUE,
    /**
     * User data size error. Since 1.18.
     */
    GENERAL_USER_DATA_SIZE_ERROR,
    /**
     * Other general error. Since 1.18.
     */
    GENERAL_OTHER,
}
/**
 * Error class reported from the network when failed to send an SMS in CDMA,
 * or reported by the device when failed to process a transfer-only CDMA message.
 */
enum WmsCdmaErrorClass {
    /**
     * Temporary error reported by network.
     */
    TEMPORARY,
    /**
     * Permanent error reported by network.
     */
    PERMANENT,
    /**
     * Temporary error reported by device. Since 1.28.
     */
    TEMPORARY_DEVICE,
    /**
     * Permanent error reported by device. Since 1.28.
     */
    PERMANENT_DEVICE,
}
/**
 * CDMA service option selection.
 */
enum WmsCdmaServiceOption {
    /**
     * Automatic selection of service option.
     */
    AUTO,
    /**
     * Use service option 6.
     */
    TODO_6,
    /**
     * Use service option 14.
     */
    TODO_14,
}
/**
 * RP cause codes when failed to send an SMS in GSM/WCDMA.
 */
enum WmsGsmUmtsRpCause {
    /**
     * Unassigned number.
     */
    UNASSIGNED_NUMBER,
    /**
     * Operator determined barring.
     */
    OPERATOR_DETERMINED_BARRING,
    /**
     * Call barred.
     */
    CALL_BARRED,
    /**
     * Reserved.
     */
    RESERVED,
    /**
     * SMS transfer rejected.
     */
    SMS_TRANSFER_REJECTED,
    /**
     * Memory capacity exceeded.
     */
    MEMORY_CAPACITY_EXCEEDED,
    /**
     * Destination out of order.
     */
    DESTINATION_OUT_OF_ORDER,
    /**
     * Unidentified subscriber.
     */
    UNIDENTIFIED_SUBSCRIBER,
    /**
     * Facility rejected.
     */
    FACILITY_REJECTED,
    /**
     * Unknown subscriber.
     */
    UNKNOWN_SUBSCRIBER,
    /**
     * Network out of order.
     */
    NETWORK_OUF_OF_ORDER,
    /**
     * Temporary failure.
     */
    TEMPORARY_FAILURE,
    /**
     * Congestion.
     */
    CONGESTION,
    /**
     * Resources unavailable.
     */
    RESOURCES_UNAVAILABLE,
    /**
     * Facility not subscribed.
     */
    FACILITY_NOT_SUBSCRIBED,
    /**
     * Facility not implemented.
     */
    FACILITY_NOT_IMPLEMENTED,
    /**
     * Invalid SMS transfer reference value.
     */
    INVALID_SMS_TRANSFER_REFERENCE_VALUE,
    /**
     * Semantically incorrect message.
     */
    SEMANTICALLY_INCORRECT_MESSAGE,
    /**
     * Invalid mandatory info.
     */
    INVALID_MANDATORY_INFO,
    /**
     * Message type not implemented.
     */
    MESSAGE_TYPE_NOT_IMPLEMENTED,
    /**
     * Message not compatible with SMS.
     */
    MESSAGE_NOT_COMPATIBLE_WITH_SMS,
    /**
     * Information element not implemented.
     */
    INFORMATION_ELEMENT_NOT_IMPLEMENTED,
    /**
     * Protocol error.
     */
    PROTOCOL_ERROR,
    /**
     * Interworking error.
     */
    INTERWORKING,
}
/**
 * RT cause codes when failed to send an SMS in GSM/WCDMA.
 */
enum WmsGsmUmtsTpCause {
    /**
     * Tele interworking not supported.
     */
    TELE_INTERWORKING_NOT_SUPPORTED,
    /**
     * Short message type 0 not supported.
     */
    SHORT_MESSAGE_TYPE_0_NOT_SUPPORTED,
    /**
     * Short message cannot be replaced.
     */
    SHORT_MESSAGE_CANNOT_BE_REPLACED,
    /**
     * Unspecified TP-PID error.
     */
    UNSPECIFIED_PID_ERROR,
    /**
     * Data coding scheme not supported.
     */
    DCS_NOT_SUPPORTED,
    /**
     * Message class not supported.
     */
    MESSAGE_CLASS_NOT_SUPPORTED,
    /**
     * Unspecified data coding scheme error.
     */
    UNSPECIFIED_DCS_ERROR,
    /**
     * Command cannot be actioned.
     */
    COMMAND_CANNOT_BE_ACTIONED,
    /**
     * Command unsupported.
     */
    COMMAND_UNSUPPORTED,
    /**
     * Unspecified command error.
     */
    UNSPECIFIED_COMMAND_ERROR,
    /**
     * TPDU not supported.
     */
    TPDU_NOT_SUPPORTED,
    /**
     * SC busy.
     */
    SC_BUSY,
    /**
     * No SC subscription.
     */
    NO_SC_SUBSCRIPTION,
    /**
     * SC system failure.
     */
    SC_SYSTEM_FAILURE,
    /**
     * Invalid SME address.
     */
    INVALID_SME_ADDRESS,
    /**
     * Destination SME barred.
     */
    DESTINATION_SME_BARRED,
    /**
     * SM rejected or duplicate.
     */
    SM_REJECTED_OR_DUPLICATE,
    /**
     * TP-VPF not supported.
     */
    VPF_NOT_SUPPORTED,
    /**
     * TP-VP not supported.
     */
    VP_NOT_SUPPORTED,
    /**
     * SIM SMS storage full.
     */
    SIM_SMS_STORAGE_FULL,
    /**
     * No SMS storage capability in SIM.
     */
    NO_SMS_STORAGE_CAPABILITY_IN_SIM,
    /**
     * MS error.
     */
    MS_ERROR,
    /**
     * Memory capacity exceeded.
     */
    MEMORY_CAPACITY_EXCEEDED,
    /**
     * SIM application toolkit busy.
     */
    SIM_APPLICATION_TOOLKIT_BUSY,
    /**
     * SIM data download error.
     */
    SIM_DATA_DOWNLOAD_ERROR,
    /**
     * Unspecified error.
     */
    UNSPECIFIED_ERROR,
}
/**
 * Message class.
 */
enum WmsMessageClass {
    /**
     * Class 0.
     */
    TODO_0,
    /**
     * Class 1.
     */
    TODO_1,
    /**
     * Class 2.
     */
    TODO_2,
    /**
     * Class 3.
     */
    TODO_3,
    /**
     * Class none.
     */
    NONE,
    /**
     * Class CDMA.
     */
    CDMA,
}
/**
 * Type of message delivery failure.
 */
enum WmsMessageDeliveryFailureType {
    /**
     * Temporary failure.
     */
    TEMPORARY,
    /**
     * Permanent failure.
     */
    PERMANENT,
}
/**
 * Type of message.
 */
enum WmsMessageFormat {
    /**
     * CDMA message.
     */
    CDMA,
    /**
     * Point-to-point 3GPP message.
     */
    GSM_WCDMA_POINT_TO_POINT,
    /**
     * Broadcast 3GPP message.
     */
    GSM_WCDMA_BROADCAST,
    /**
     * Message Waiting Indicator.
     */
    MWI,
}
/**
 * Message mode.
 */
enum WmsMessageMode {
    /**
     * Message sent using 3GPP2 technologies.
     */
    CDMA,
    /**
     * Message sent using 3GPP technologies.
     */
    GSM_WCDMA,
}
/**
 * Type of message protocol.
 */
enum WmsMessageProtocol {
    /**
     * CDMA.
     */
    CDMA,
    /**
     * WCDMA.
     */
    WCDMA,
}
/**
 * Type of message tag.
 */
enum WmsMessageTagType {
    /**
     * Received SMS, already read.
     */
    MT_READ,
    /**
     * Received SMS, not read.
     */
    MT_NOT_READ,
    /**
     * Sent SMS.
     */
    MO_SENT,
    /**
     * Not yet sent SMS.
     */
    MO_NOT_SENT,
}
/**
 * Type of message.
 */
enum WmsMessageType {
    /**
     * Point to point message.
     */
    POINT,
}
/**
 * Type of notification.
 */
enum WmsNotificationType {
    /**
     * Primary.
     */
    PRIMARY,
    /**
     * Secondary GSM.
     */
    SECONDARY_GSM,
    /**
     * Secondary UMTS.
     */
    SECONDARY_UMTS,
}
/**
 * Action to perform when a message is received.
 */
enum WmsReceiptAction {
    /**
     * Discard message.
     */
    DISCARD,
    /**
     * Store and notify to client.
     */
    STORE_AND_NOTIFY,
    /**
     * Notify to client, which should send back ACK.
     */
    TRANSFER_ONLY,
    /**
     * Notify to client and send back ACK.
     */
    TRANSFER_AND_ACK,
    /**
     * Unknown action.
     */
    UNKNOWN,
}
/**
 * Type of messaging storage.
 */
enum WmsStorageType {
    /**
     * Message stored in UIM.
     */
    UIM,
    /**
     * Message stored in non-volatile memory.
     */
    NV,
    /**
     * None.
     */
    NONE,
}
/**
 * Transfer indication actions.
 */
enum WmsTransferIndication {
    /**
     * Status reports transferred to the client.
     */
    CLIENT,
}
/**
 * QMI flags in messages of the %QMI_SERVICE_CTL service.
 */
enum CtlFlag {
    /**
     * None.
     */
    NONE,
    /**
     * Message is a response.
     */
    RESPONSE,
    /**
     * Message is an indication.
     */
    INDICATION,
}
/**
 * Flags specifying the behavior of the new link.
 */
enum DeviceAddLinkFlags {
    /**
     * none.
     */
    NONE,
    /**
     * checksum offload (v4) is enabled in ingress path.
     */
    INGRESS_MAP_CKSUMV4,
    /**
     * checksum offload (v4) is enabled in egress path.
     */
    EGRESS_MAP_CKSUMV4,
    /**
     * checksum offload (v5) is enabled in ingress path. Since 1.32.
     */
    INGRESS_MAP_CKSUMV5,
    /**
     * checksum offload (v5) is enabled in egress path. Since 1.32.
     */
    EGRESS_MAP_CKSUMV5,
}
/**
 * Flags to specify which actions to be performed when the device is open.
 */
enum DeviceOpenFlags {
    /**
     * No flags.
     */
    NONE,
    /**
     * Run version info check when opening. Since 1.24.4 this flag no longer prevents requests from being sent to the modem if they're assumed not supported based on the version info of each message.
     */
    VERSION_INFO,
    /**
     * Synchronize with endpoint once the device is open. Will release any previously allocated client ID.
     */
    SYNC,
    /**
     * set network port to "802.3" mode; mutually exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_RAW_IP`
     */
    NET_802_3,
    /**
     * set network port to "raw IP" mode; mutally exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_8`02_3
     */
    NET_RAW_IP,
    /**
     * set network port to transmit/receive QoS headers; mutually exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_NO_QOS_HEADER`
     */
    NET_QOS_HEADER,
    /**
     * set network port to not transmit/receive QoS headers; mutually exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_QOS_HEADER`
     */
    NET_NO_QOS_HEADER,
    /**
     * Try to open the port through the 'qmi-proxy'. Since: 1.8.
     */
    PROXY,
    /**
     * open an MBIM port with QMUX tunneling service. Since: 1.16.
     */
    MBIM,
    /**
     * open a port either in QMI or MBIM mode, depending on device driver. Since: 1.18.
     */
    AUTO,
    /**
     * Explicitly state that indications are wanted (implicit in QMI mode, optional when in MBIM mode).
     */
    EXPECT_INDICATIONS,
}
/**
 * Flags to specify which actions to be performed when releasing the client.
 */
enum DeviceReleaseClientFlags {
    /**
     * No flags.
     */
    NONE,
    /**
     * Release the CID when releasing the client.
     */
    RELEASE_CID,
}
/**
 * Frequency band capabilities.
 * 
 * This type is bit to bit compatible with #QmiNasBandPreference.
 */
enum DmsBandCapability {
    /**
     * Band class 0, A-system.
     */
    BC_0_A_SYSTEM,
    /**
     * Band class 0, B-system.
     */
    BC_0_B_SYSTEM,
    /**
     * Band class 1, all blocks.
     */
    BC_1_ALL_BLOCKS,
    /**
     * Band class 2.
     */
    BC_2,
    /**
     * Band class 3, A-system.
     */
    BC_3_A_SYSTEM,
    /**
     * Band class 4, all blocks.
     */
    BC_4_ALL_BLOCKS,
    /**
     * Band class 5, all blocks.
     */
    BC_5_ALL_BLOCKS,
    /**
     * GSM DCS band.
     */
    GSM_DCS_1800,
    /**
     * GSM Extended GSM band (900).
     */
    GSM_900_EXTENDED,
    /**
     * GSM Primary GSM band (900).
     */
    GSM_900_PRIMARY,
    /**
     * Band class 6.
     */
    BC_6,
    /**
     * Band class 7.
     */
    BC_7,
    /**
     * Band class 8.
     */
    BC_8,
    /**
     * Band class 9.
     */
    BC_9,
    /**
     * Band class 10.
     */
    BC_10,
    /**
     * Band class 11.
     */
    BC_11,
    /**
     * GSM 450 band.
     */
    GSM_450,
    /**
     * GSM 480 band.
     */
    GSM_480,
    /**
     * GSM 750 band.
     */
    GSM_750,
    /**
     * GSM 850 band.
     */
    GSM_850,
    /**
     * GSM railways band (900).
     */
    GSM_900_RAILWAYS,
    /**
     * GSM PCS band (1900).
     */
    GSM_PCS_1900,
    /**
     * WCDMA 2100 band (Europe, Japan, China).
     */
    WCDMA_2100,
    /**
     * WCDMA PCS 1900 band (US).
     */
    WCDMA_PCS_1900,
    /**
     * WCDMA DCS 1800 band (Europe, China).
     */
    WCDMA_DCS_1800,
    /**
     * WCDMA 1700 band (US).
     */
    WCDMA_1700_US,
    /**
     * WCDMA 850 band (US).
     */
    WCDMA_850_US,
    /**
     * QWCDMA 850 band (Japan).
     */
    WCDMA_800,
    /**
     * Band class 12.
     */
    BC_12,
    /**
     * Band class 14.
     */
    BC_14,
    /**
     * Band class 15.
     */
    BC_15,
    /**
     * WCDMA 2600 band (Europe).
     */
    WCDMA_2600,
    /**
     * WCDMA 900 band (Europe, Japan).
     */
    WCDMA_900,
    /**
     * WCDMA 1700 band (Japan).
     */
    WCDMA_1700_JAPAN,
    /**
     * Band class 16.
     */
    BC_16,
    /**
     * Band class 17.
     */
    BC_17,
    /**
     * Band class 18.
     */
    BC_18,
    /**
     * Band class 19.
     */
    BC_19,
    /**
     * WCDMA 850 band (Japan)
     */
    WCDMA_850_JAPAN,
    /**
     * WCDMA 1500 band.
     */
    WCDMA_1500,
}
/**
 * LTE-specific Frequency bands.
 */
enum DmsLteBandCapability {
    /**
     * LTE EUTRAN Band 1
     */
    TODO_1,
    /**
     * LTE EUTRAN Band 2.
     */
    TODO_2,
    /**
     * LTE EUTRAN Band 3.
     */
    TODO_3,
    /**
     * LTE EUTRAN Band 4.
     */
    TODO_4,
    /**
     * LTE EUTRAN Band 5.
     */
    TODO_5,
    /**
     * LTE EUTRAN Band 6.
     */
    TODO_6,
    /**
     * LTE EUTRAN Band 7.
     */
    TODO_7,
    /**
     * LTE EUTRAN Band 8.
     */
    TODO_8,
    /**
     * LTE EUTRAN Band 9.
     */
    TODO_9,
    /**
     * LTE EUTRAN Band 10.
     */
    TODO_10,
    /**
     * LTE EUTRAN Band 11.
     */
    TODO_11,
    /**
     * LTE EUTRAN Band 12.
     */
    TODO_12,
    /**
     * LTE EUTRAN Band 13.
     */
    TODO_13,
    /**
     * LTE EUTRAN Band 14.
     */
    TODO_14,
    /**
     * LTE EUTRAN Band 17.
     */
    TODO_17,
    /**
     * LTE EUTRAN Band 18.
     */
    TODO_18,
    /**
     * LTE EUTRAN Band 19.
     */
    TODO_19,
    /**
     * LTE EUTRAN Band 20.
     */
    TODO_20,
    /**
     * LTE EUTRAN Band 21.
     */
    TODO_21,
    /**
     * LTE EUTRAN Band 24.
     */
    TODO_24,
    /**
     * LTE EUTRAN Band 25.
     */
    TODO_25,
    /**
     * LTE EUTRAN Band 26.
     */
    TODO_26,
    /**
     * LTE EUTRAN Band 27.
     */
    TODO_27,
    /**
     * LTE EUTRAN Band 28.
     */
    TODO_28,
    /**
     * LTE EUTRAN Band 29.
     */
    TODO_29,
    /**
     * LTE EUTRAN Band 30.
     */
    TODO_30,
    /**
     * LTE EUTRAN Band 31.
     */
    TODO_31,
    /**
     * LTE EUTRAN Band 32.
     */
    TODO_32,
    /**
     * LTE EUTRAN Band 33.
     */
    TODO_33,
    /**
     * LTE EUTRAN Band 34.
     */
    TODO_34,
    /**
     * LTE EUTRAN Band 35.
     */
    TODO_35,
    /**
     * LTE EUTRAN Band 36.
     */
    TODO_36,
    /**
     * LTE EUTRAN Band 37.
     */
    TODO_37,
    /**
     * LTE EUTRAN Band 38.
     */
    TODO_38,
    /**
     * LTE EUTRAN Band 39.
     */
    TODO_39,
    /**
     * LTE EUTRAN Band 40.
     */
    TODO_40,
    /**
     * LTE EUTRAN Band 41.
     */
    TODO_41,
    /**
     * LTE EUTRAN Band 42.
     */
    TODO_42,
    /**
     * LTE EUTRAN Band 43.
     */
    TODO_43,
}
/**
 * Reasons for being in Offline (`QMI_DMS_OPERATING_MODE_OFFLINE)` state.
 */
enum DmsOfflineReason {
    /**
     * Host image misconfiguration.
     */
    HOST_IMAGE_MISCONFIGURATION,
    /**
     * PRI image misconfiguration.
     */
    PRI_IMAGE_MISCONFIGURATION,
    /**
     * PRI version incompatible.
     */
    PRI_VERSION_INCOMPATIBLE,
    /**
     * Memory full, cannot copy PRI information.
     */
    DEVICE_MEMORY_FULL,
}
/**
 * Flags specifying the current power state.
 * 
 * If `QMI_DMS_POWER_STATE_EXTERNAL_SOURCE` is set, the device is powerered by an
 * external source; otherwise it is powered by a battery.
 * 
 * If `QMI_DMS_POWER_STATE_BATTERY_CONNECTED` is set, the battery is connected;
 * otherwise the battery is not connected.
 * 
 * If `QMI_DMS_POWER_STATE_BATTERY_CHARGING` is set, the battery is being charged;
 * otherwise the battery is not being charged.
 * 
 * If `QMI_DMS_POWER_STATE_FAULT` is set, a power fault has been detected.
 */
enum DmsPowerState {
    /**
     * Powered by an external source.
     */
    EXTERNAL_SOURCE,
    /**
     * Battery is connected.
     */
    BATTERY_CONNECTED,
    /**
     * Battery is currently being charged.
     */
    BATTERY_CHARGING,
    /**
     * Recognized power fault.
     */
    FAULT,
}
/**
 * APN type preference as a bitmask.
 */
enum DsdApnTypePreference {
    /**
     * Default/Internet traffic.
     */
    DEFAULT,
    /**
     * IMS.
     */
    IMS,
    /**
     * Multimedia Messaging Service.
     */
    MMS,
    /**
     * Dial Up Network.
     */
    DUN,
    /**
     * Secure User Plane Location.
     */
    SUPL,
    /**
     * High Priority Mobile Data.
     */
    HIPRI,
    /**
     * over the air administration.
     */
    FOTA,
    /**
     * Carrier Branded Services.
     */
    CBS,
    /**
     * Initial Attach.
     */
    IA,
    /**
     * Emergency.
     */
    EMERGENCY,
}
/**
 * Type of data to delete from the cell database.
 */
enum LocDeleteCellDatabase {
    /**
     * Position.
     */
    POS,
    /**
     * Latest GPS position.
     */
    LATEST_GPS_POS,
    /**
     * OTA position.
     */
    OTA_POS,
    /**
     * External reference position.
     */
    EXT_REF_POS,
    /**
     * Timetag.
     */
    TIMETAG,
    /**
     * Cell ID.
     */
    CELLID,
    /**
     * Cached cell ID.
     */
    CACHED_CELLID,
    /**
     * Last serving cell.
     */
    LAST_SRV_CELL,
    /**
     * Current servince cell.
     */
    CUR_SRV_CELL,
    /**
     * Neighboring cell info.
     */
    NEIGHBOR_INFO,
}
/**
 * Type of data to delete from the clock information.
 */
enum LocDeleteClockInfo {
    /**
     * Time estimation.
     */
    TIME_EST,
    /**
     * Frequency estimation.
     */
    FREQ_EST,
    /**
     * Week number.
     */
    WEEK_NUMBER,
    /**
     * RTC time.
     */
    RTC_TIME,
    /**
     * Time transfer.
     */
    TIME_TRANSFER,
    /**
     * GPS time estimation.
     */
    GPS_TIME_EST,
    /**
     * GLONASS time estimation.
     */
    GLO_TIME_EST,
    /**
     * GLONASS day number.
     */
    GLO_DAY_NUMBER,
    /**
     * GLONASS year number.
     */
    GLO_YEAR_NUMBER,
    /**
     * GLONASS RF group delay.
     */
    GLO_RF_GRP_DELAY,
    /**
     * Disable TT.
     */
    DISABLE_TT,
}
/**
 * Flags to use when deleting GNSS assistance data.
 * 
 * Since 1.22
 */
enum LocDeleteGnssData {
    /**
     * GPS SV dir.
     */
    GPS_SVDIR,
    /**
     * GPS SV steer.
     */
    GPS_SVSTEER,
    /**
     * GPS time.
     */
    GPS_TIME,
    /**
     * GPS alm corr.
     */
    GPS_ALM_CORR,
    /**
     * GLONASS SV dir.
     */
    GLO_SVDIR,
    /**
     * GLONASS SV steer.
     */
    GLO_SVSTEER,
    /**
     * GLONASS time.
     */
    GLO_TIME,
    /**
     * GLONASS alm corr.
     */
    GLO_ALM_CORR,
    /**
     * SBAS SV dir.
     */
    SBAS_SVDIR,
    /**
     * SBAS SV steer.
     */
    SBAS_SVSTEER,
    /**
     * Position.
     */
    POSITION,
    /**
     * Time.
     */
    TIME,
    /**
     * Ionospheric data.
     */
    IONO,
    /**
     * UTC time.
     */
    UTC,
    /**
     * Health information.
     */
    HEALTH,
    /**
     * SA data.
     */
    SADATA,
    /**
     * RTI.
     */
    RTI,
    /**
     * SV no exist.
     */
    SV_NO_EXIST,
    /**
     * Frequency bias estimation.
     */
    FREQ_BIAS_EST,
}
/**
 * Type of data to delete for a given satellite.
 */
enum LocDeleteSvInfo {
    /**
     * Ephemeris.
     */
    EPHEMERIS,
    /**
     * Almanac.
     */
    ALMANAC,
}
/**
 * For which events to register the subscription.
 * 
 * Since 1.22
 */
enum LocEventRegistrationFlag {
    /**
     * Position report.
     */
    POSITION_REPORT,
    /**
     * GNSS satellite info.
     */
    GNSS_SATELLITE_INFO,
    /**
     * NMEA.
     */
    NMEA,
    /**
     * NI Notify verify request.
     */
    NI_NOTIFY_VERIFY_REQUEST,
    /**
     * Inject time request.
     */
    INJECT_TIME_REQUEST,
    /**
     * Inject predicted orbits request.
     */
    INJECT_PREDICTED_ORBITS_REQUEST,
    /**
     * Inject position request.
     */
    INJECT_POSITION_REQUEST,
    /**
     * Engine state.
     */
    ENGINE_STATE,
    /**
     * Fix session state.
     */
    FIX_SESSION_STATE,
    /**
     * WIFI request.
     */
    WIFI_REQUEST,
    /**
     * Sensor streaming ready status.
     */
    SENSOR_STREAMING_READY_STATUS,
    /**
     * Time sync request.
     */
    TIME_SYNC_REQUEST,
    /**
     * Set SPI streaming report.
     */
    SET_SPI_STREAMING_REPORT,
    /**
     * Location server connection request.
     */
    LOCATION_SERVER_CONNECTION_REQUEST,
    /**
     * NI geofence notification.
     */
    NI_GEOFENCE_NOTIFICATION,
    /**
     * Geofence general alert.
     */
    GEOFENCE_GENERAL_ALERT,
    /**
     * Geofence breach notification.
     */
    GEOFENCE_BREACH_NOTIFICATION,
    /**
     * Pedometer control.
     */
    PEDOMETER_CONTROL,
    /**
     * Motion data control.
     */
    MOTION_DATA_CONTROL,
}
/**
 * NMEA trace types that may be enabled in the GNSS engine.
 */
enum LocNmeaType {
    /**
     * Enable GGA traces.
     */
    GGA,
    /**
     * Enable RMC traces.
     */
    RMC,
    /**
     * Enable GSV traces.
     */
    GSV,
    /**
     * Enable GSA traces.
     */
    GSA,
    /**
     * Enable VTG traces.
     */
    VTG,
    /**
     * Enable PQXFI traces.
     */
    PQXFI,
    /**
     * Enable PSTIS traces.
     */
    PSTIS,
    /**
     * Enable all supported trace types.
     */
    ALL,
}
/**
 * Which information about the satellite is valid.
 * 
 * Since 1.22
 */
enum LocSatelliteValidInformation {
    /**
     * System,
     */
    SYSTEM,
    /**
     * GNSS Satellite ID.
     */
    GNSS_SATELLITE_ID,
    /**
     * Health status.
     */
    HEALTH_STATUS,
    /**
     * Process status.
     */
    PROCESS_STATUS,
    /**
     * Satellite info mask.
     */
    SATELLITE_INFO_MASK,
    /**
     * Elevation.
     */
    ELEVATION,
    /**
     * Azimuth.
     */
    AZIMUTH,
    /**
     * Signal to noise ratio.
     */
    SIGNAL_TO_NOISE_RATIO,
}
/**
 * Which sensors where used and for which measurements.
 * 
 * Since 1.22
 */
enum LocSensorDataUsage {
    /**
     * Accelerometer used.
     */
    ACCELEROMETER_USED,
    /**
     * Gyro used.
     */
    GYRO_USED,
    /**
     * Aided heading.
     */
    AIDED_HEADING,
    /**
     * Aided speed.
     */
    AIDED_SPEED,
    /**
     * Aided position.
     */
    AIDED_POSITION,
    /**
     * Aided velocity.
     */
    AIDED_VELOCITY,
}
/**
 * Type of server address for Assisted-GPS.
 */
enum LocServerAddressType {
    /**
     * None.
     */
    NONE,
    /**
     * IPv4 server address.
     */
    IPV4,
    /**
     * IPv6 server address.
     */
    IPV6,
    /**
     * URL server address.
     */
    URL,
}
/**
 * Which technology has been used.
 * 
 * Since 1.22
 */
enum LocTechnologyUsed {
    /**
     * Satellite.
     */
    SATELLITE,
    /**
     * Cellular.
     */
    CELLULAR,
    /**
     * Wifi.
     */
    WIFI,
    /**
     * Sensors.
     */
    SENSORS,
    /**
     * Reference Location.
     */
    REFERENCE_LOCATION,
    /**
     * Injected Position.
     */
    INJECTED_POSITION,
    /**
     * AFLT (Advanced Forward Link Trilateration).
     */
    AFLT,
    /**
     * Hybrid.
     */
    HYBRID,
}
/**
 * Flags to specify frequency band preferences.
 * 
 * This type is bit to bit compatible with #QmiDmsBandCapability.
 */
enum NasBandPreference {
    /**
     * Band class 0, A system.
     */
    BC_0_A_SYSTEM,
    /**
     * Band class 0, B system.
     */
    BC_0_B_SYSTEM,
    /**
     * Band class 1.
     */
    BC_1_ALL_BLOCKS,
    /**
     * Band class 2.
     */
    BC_2,
    /**
     * Band class 3, A system.
     */
    BC_3_A_SYSTEM,
    /**
     * Band class 4, all blocks.
     */
    BC_4_ALL_BLOCKS,
    /**
     * Band class 5, all blocks.
     */
    BC_5_ALL_BLOCKS,
    /**
     * GSM DCS 1800 band.
     */
    GSM_DCS_1800,
    /**
     * Extended GSM 900 band.
     */
    GSM_900_EXTENDED,
    /**
     * Primary GSM 900 band.
     */
    GSM_900_PRIMARY,
    /**
     * Band class 6.
     */
    BC_6,
    /**
     * Band class 7.
     */
    BC_7,
    /**
     * Band class 8.
     */
    BC_8,
    /**
     * Band class 9.
     */
    BC_9,
    /**
     * Band class 10.
     */
    BC_10,
    /**
     * Band class 11.
     */
    BC_11,
    /**
     * GSM 450.
     */
    GSM_450,
    /**
     * GSM 480.
     */
    GSM_480,
    /**
     * GSM 750.
     */
    GSM_750,
    /**
     * GSM 850.
     */
    GSM_850,
    /**
     * GSM 900 (Railways).
     */
    GSM_900_RAILWAYS,
    /**
     * GSM 1900.
     */
    GSM_PCS_1900,
    /**
     * WCDMA 2100.
     */
    WCDMA_2100,
    /**
     * WCDMA PCS 1900.
     */
    WCDMA_PCS_1900,
    /**
     * WCDMA DCS 1800.
     */
    WCDMA_DCS_1800,
    /**
     * WCDMA 1700 (U.S.).
     */
    WCDMA_1700_US,
    /**
     * WCDMA 850.
     */
    WCDMA_850_US,
    /**
     * WCDMA 800.
     */
    WCDMA_800,
    /**
     * Band class 12.
     */
    BC_12,
    /**
     * Band class 14.
     */
    BC_14,
    /**
     * Band class 15.
     */
    BC_15,
    /**
     * WCDMA 2600.
     */
    WCDMA_2600,
    /**
     * WCDMA 900.
     */
    WCDMA_900,
    /**
     * WCDMA 1700 (Japan).
     */
    WCDMA_1700_JAPAN,
    /**
     * Band class 16.
     */
    BC_16,
    /**
     * Band class 17.
     */
    BC_17,
    /**
     * Band class 18.
     */
    BC_18,
    /**
     * Band class 19.
     */
    BC_19,
    /**
     * WCDMA 850 (Japan). Since: 1.22.
     */
    WCDMA_850_JAPAN,
    /**
     * WCDMA 1500. Since: 1.22.
     */
    WCDMA_1500,
}
/**
 * Flags to specify LTE-specific frequency band preferences.
 */
enum NasLteBandPreference {
    /**
     * LTE EUTRAN Band 1
     */
    TODO_1,
    /**
     * LTE EUTRAN Band 2.
     */
    TODO_2,
    /**
     * LTE EUTRAN Band 3.
     */
    TODO_3,
    /**
     * LTE EUTRAN Band 4.
     */
    TODO_4,
    /**
     * LTE EUTRAN Band 5.
     */
    TODO_5,
    /**
     * LTE EUTRAN Band 6.
     */
    TODO_6,
    /**
     * LTE EUTRAN Band 7.
     */
    TODO_7,
    /**
     * LTE EUTRAN Band 8.
     */
    TODO_8,
    /**
     * LTE EUTRAN Band 9.
     */
    TODO_9,
    /**
     * LTE EUTRAN Band 10.
     */
    TODO_10,
    /**
     * LTE EUTRAN Band 11.
     */
    TODO_11,
    /**
     * LTE EUTRAN Band 12.
     */
    TODO_12,
    /**
     * LTE EUTRAN Band 13.
     */
    TODO_13,
    /**
     * LTE EUTRAN Band 14.
     */
    TODO_14,
    /**
     * LTE EUTRAN Band 17.
     */
    TODO_17,
    /**
     * LTE EUTRAN Band 18.
     */
    TODO_18,
    /**
     * LTE EUTRAN Band 19.
     */
    TODO_19,
    /**
     * LTE EUTRAN Band 20.
     */
    TODO_20,
    /**
     * LTE EUTRAN Band 21.
     */
    TODO_21,
    /**
     * LTE EUTRAN Band 24.
     */
    TODO_24,
    /**
     * LTE EUTRAN Band 25.
     */
    TODO_25,
    /**
     * LTE EUTRAN Band 26.
     */
    TODO_26,
    /**
     * LTE EUTRAN Band 27.
     */
    TODO_27,
    /**
     * LTE EUTRAN Band 28.
     */
    TODO_28,
    /**
     * LTE EUTRAN Band 29.
     */
    TODO_29,
    /**
     * LTE EUTRAN Band 30.
     */
    TODO_30,
    /**
     * LTE EUTRAN Band 31.
     */
    TODO_31,
    /**
     * LTE EUTRAN Band 32.
     */
    TODO_32,
    /**
     * LTE EUTRAN Band 33.
     */
    TODO_33,
    /**
     * LTE EUTRAN Band 34.
     */
    TODO_34,
    /**
     * LTE EUTRAN Band 35.
     */
    TODO_35,
    /**
     * LTE EUTRAN Band 36.
     */
    TODO_36,
    /**
     * LTE EUTRAN Band 37.
     */
    TODO_37,
    /**
     * LTE EUTRAN Band 38.
     */
    TODO_38,
    /**
     * LTE EUTRAN Band 39.
     */
    TODO_39,
    /**
     * LTE EUTRAN Band 40.
     */
    TODO_40,
    /**
     * LTE EUTRAN Band 41.
     */
    TODO_41,
    /**
     * LTE EUTRAN Band 42.
     */
    TODO_42,
    /**
     * LTE EUTRAN Band 43.
     */
    TODO_43,
}
/**
 * Flags used to control display of the PLMN name and Service Provider Name. See
 * 3GPP TS 51.011 descripton of the EFspn SIM file for more details.
 */
enum NasNetworkNameDisplayCondition {
    /**
     * if
     * set, display of the registered PLMN is required when the registered PLMN is either
     * the HPLMN or a PLMN in the Service Provider PLMN List (see EFspdi). Otherwise
     * display of the registered PLMN is not required in this case.
     */
    REGISTERED_PLMN_IF_KNOWN_NETWORK,
    /**
     * if
     * set, display of the Service Provider Name is not required when registered PLMN is
     * neither HPLMN nor a PLMN in the service provider PLMN list (see EFspdi). If not set,
     * SPN display is required in this case.
     */
    SPN_NOT_REQUIRED_IF_UNKNOWN_NETWORK,
}
/**
 * Flags to use when specifying which networks to scan.
 */
enum NasNetworkScanType {
    /**
     * GSM network.
     */
    GSM,
    /**
     * UMTS network.
     */
    UMTS,
    /**
     * LTE network.
     */
    LTE,
    /**
     * TD-SCDMA network.
     */
    TD_SCDMA,
}
/**
 * Flags to specify the status of a given network.
 */
enum NasNetworkStatus {
    /**
     * Network is in use, current serving.
     */
    CURRENT_SERVING,
    /**
     * Network is vailable.
     */
    AVAILABLE,
    /**
     * Network is home network.
     */
    HOME,
    /**
     * Network is a roaming network.
     */
    ROAMING,
    /**
     * Network is forbidden.
     */
    FORBIDDEN,
    /**
     * Network is not forbidden.
     */
    NOT_FORBIDDEN,
    /**
     * Network is preferred.
     */
    PREFERRED,
    /**
     * Network is not preferred.
     */
    NOT_PREFERRED,
}
/**
 * Preferred networks access technology identifier as specified in
 * ETSI TS 131 102, chapter 4.2.5.
 */
enum NasPlmnAccessTechnologyIdentifier {
    /**
     * Unspecified.
     */
    UNSPECIFIED,
    /**
     * GSM Compact.
     */
    GSM_COMPACT,
    /**
     * GSM.
     */
    GSM,
    /**
     * NG-RAN.
     */
    NGRAN,
    /**
     * E-UTRAN.
     */
    EUTRAN,
    /**
     * UTRAN.
     */
    UTRAN,
    /**
     * All technologies.
     */
    ALL,
}
/**
 * Flags to specify the radio technology preference.
 */
enum NasRadioTechnologyPreference {
    /**
     * Automatic selection.
     */
    AUTO,
    /**
     * 3GPP2 technology.
     */
    TODO_3GPP2,
    /**
     * 3GPP technology.
     */
    TODO_3GPP,
    /**
     * AMPS if 3GPP2, GSM if 3GPP.
     */
    AMPS_OR_GSM,
    /**
     * CDMA if 3GPP2, WCDMA if 3GPP.
     */
    CDMA_OR_WCDMA,
    /**
     * CDMA EV-DO.
     */
    HDR,
    /**
     * LTE.
     */
    LTE,
}
/**
 * Flags specifying radio access technology mode preference.
 */
enum NasRatModePreference {
    /**
     * CDMA2000 1X.
     */
    CDMA_1X,
    /**
     * CDMA2000 HRPD (1xEV-DO).
     */
    CDMA_1XEVDO,
    /**
     * GSM.
     */
    GSM,
    /**
     * UMTS.
     */
    UMTS,
    /**
     * LTE.
     */
    LTE,
    /**
     * TD-SCDMA.
     */
    TD_SCDMA,
    /**
     * 5GNR. Since 1.26.
     */
    TODO_5GNR,
}
/**
 * Extra information to request when gathering Signal Strength.
 */
enum NasSignalStrengthRequest {
    /**
     * None.
     */
    NONE,
    /**
     * Request RSSI information.
     */
    RSSI,
    /**
     * Request ECIO information.
     */
    ECIO,
    /**
     * Request IO information.
     */
    IO,
    /**
     * Request SINR information.
     */
    SINR,
    /**
     * Request error rate information.
     */
    ERROR_RATE,
    /**
     * Request RSRQ information.
     */
    RSRQ,
    /**
     * Request LTE SNR information.
     */
    LTE_SNR,
    /**
     * Request LTE RSRP information.
     */
    LTE_RSRP,
}
/**
 * Flags to specify TD-SCDMA-specific frequency band preferences.
 */
enum NasTdScdmaBandPreference {
    /**
     * Band A.
     */
    A,
    /**
     * Band B.
     */
    B,
    /**
     * Band C.
     */
    C,
    /**
     * Band D.
     */
    D,
    /**
     * Band E.
     */
    E,
    /**
     * Band F.
     */
    F,
}
/**
 * Flags to use to register to phonebook indications.
 */
enum PbmEventRegistrationFlag {
    /**
     * Request indications when records are added/edited/deleted.
     */
    RECORD_UPDATE,
    /**
     * Request indications when phonebooks are ready.
     */
    PHONEBOOK_READY,
    /**
     * Request indications when emergency numbers are changed.
     */
    EMERGENCY_NUMBER_LIST,
    /**
     * Request indications when hidden record status is changed.
     */
    HIDDEN_RECORD_STATUS,
    /**
     * Request indications when Additional number Alpha String records are added/edited/deleted.
     */
    AAS_UPDATE,
    /**
     * Request indications when Grouping information Alpha String records are added/edited/deleted.
     */
    GAS_UPDATE,
}
/**
 * Phonebook type.
 */
enum PbmPhonebookType {
    /**
     * Abbreviated Dialing Number.
     */
    ADN,
    /**
     * Fixed Dialing Number.
     */
    FDN,
    /**
     * Mobile Subscriber Integrated Services Digital Network.
     */
    MSISDN,
    /**
     * Mail Box Dialing Number.
     */
    MBDN,
    /**
     * Service Dialing Number.
     */
    SDN,
    /**
     * Barred Dialing Number.
     */
    BDN,
    /**
     * Last Number Dialed.
     */
    LND,
    /**
     * Mail Box Number.
     */
    MBN,
}
/**
 * Flags to indicate which position data parameters are valid.
 */
enum PdsDataValid {
    /**
     * Timestamp calendar (GPS time).
     */
    TIMESTAMP_CALENDAR,
    /**
     * Timestamp (UTC).
     */
    TIMESTAMP_UTC,
    /**
     * Leap seconds.
     */
    LEAP_SECONDS,
    /**
     * Time uncertainty.
     */
    TIME_UNCERTAINTY,
    /**
     * Latitude.
     */
    LATITUDE,
    /**
     * Longitude.
     */
    LONGITUDE,
    /**
     * Ellipsoid altitude.
     */
    ELLIPSOID_ALTITUDE,
    /**
     * Mean sea level altitude.
     */
    MEAN_SEA_LEVEL_ALTITUDE,
    /**
     * Horizontal speed.
     */
    HORIZONTAL_SPEED,
    /**
     * Vertical speed.
     */
    VERTICAL_SPEED,
    /**
     * Heading.
     */
    HEADING,
    /**
     * Horizontal uncertainty circular.
     */
    HORIZONTAL_UNCERTAINTY_CIRCULAR,
    /**
     * Horizontal uncertainty ellipse semi-major.
     */
    HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MAJOR,
    /**
     * Horizontal uncertainty ellipse semi-minor.
     */
    HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MINOR,
    /**
     * Horizontal uncertainty ellipse orient azimuth.
     */
    HORIZONTAL_UNCERTAINTY_ELLIPSE_ORIENT_AZIMUTH,
    /**
     * Vertical uncertainty.
     */
    VERTICAL_UNCERTAINTY,
    /**
     * Horizontal velocity uncertainty.
     */
    HORIZONTAL_VELOCITY_UNCERTAINTY,
    /**
     * Vertical velocity uncertainty.
     */
    VERTICAL_VELOCITY_UNCERTAINTY,
    /**
     * Horizontal confidence.
     */
    HORIZONTAL_CONFIDENCE,
    /**
     * Position dillution of precision.
     */
    POSITION_DOP,
    /**
     * Horizontal dillution of precision.
     */
    HORIZONTAL_DOP,
    /**
     * Vertical dillution of precision.
     */
    VERTICAL_DOP,
    /**
     * Operating mode.
     */
    OPERATING_MODE,
}
/**
 * QMI flags in messages which are not of the %QMI_SERVICE_CTL service.
 */
enum ServiceFlag {
    /**
     * None.
     */
    NONE,
    /**
     * Message is compound.
     */
    COMPOUND,
    /**
     * Message is a response.
     */
    RESPONSE,
    /**
     * Message is an indication.
     */
    INDICATION,
}
/**
 * Requested configurations. If none explicitly requested, all configuration
 * items are returned.
 */
enum UimConfiguration {
    /**
     * Automatic selection.
     */
    AUTOMATIC_SELECTION,
    /**
     * Personalization status.
     */
    PERSONALIZATION_STATUS,
    /**
     * Halt publication of subscription.
     */
    HALT_SUBSCRIPTION,
}
/**
 * Flags to use to register to UIM indications.
 */
enum UimEventRegistrationFlag {
    /**
     * Card status.
     */
    CARD_STATUS,
    /**
     * SAP connection.
     */
    SAP_CONNECTION,
    /**
     * Extended card status.
     */
    EXTENDED_CARD_STATUS,
    /**
     * Physical slot status. Since 1.26.
     */
    PHYSICAL_SLOT_STATUS,
}
/**
 * Security Attributes.
 */
enum UimSecurityAttribute {
    /**
     * PIN1.
     */
    PIN1,
    /**
     * PIN2.
     */
    PIN2,
    /**
     * UPIN.
     */
    UPIN,
    /**
     * ADM.
     */
    ADM,
}
/**
 * WCDMA AMR status.
 */
enum VoiceWcdmaAmrStatus {
    /**
     * Not supported.
     */
    NOT_SUPPORTED,
    /**
     * WCDMA AMR wideband.
     */
    WCDMA_AMR_WB,
    /**
     * GSM half-rate AMR.
     */
    GSM_HR_AMR,
    /**
     * GSM AMR wideband.
     */
    GSM_AMR_WB,
    /**
     * GSM AMR narrowband.
     */
    GSM_AMR_NB,
}
/**
 * APN type as a bitmask.
 */
enum WdsApnTypeMask {
    /**
     * Default/Internet traffic.
     */
    DEFAULT,
    /**
     * IP Multimedia Subsystem.
     */
    IMS,
    /**
     * Multimedia Messaging Service.
     */
    MMS,
    /**
     * over the air administration.
     */
    FOTA,
    /**
     * Initial Attach.
     */
    IA,
    /**
     * Emergency.
     */
    EMERGENCY,
}
/**
 * PDP context authentication protocols.
 */
enum WdsAuthentication {
    /**
     * no authentication
     */
    NONE,
    /**
     * PAP authentication
     */
    PAP,
    /**
     * CHAP authentication
     */
    CHAP,
}
/**
 * 3GPP extended data bearer technologies.
 */
enum WdsExtendedDataBearerTechnology3gpp {
    /**
     * unknown.
     */
    UNKNOWN,
    /**
     * WCDMA.
     */
    WCDMA,
    /**
     * HSDPA.
     */
    HSDPA,
    /**
     * HSUPA.
     */
    HSUPA,
    /**
     * HSDPA+.
     */
    HSDPA_PLUS,
    /**
     * Dual-cell HSDPA+.
     */
    DC_HSDPA_PLUS,
    /**
     * 64-QAM.
     */
    TODO_64QAM,
    /**
     * HSPA.
     */
    HSPA,
    /**
     * GPRS.
     */
    GPRS,
    /**
     * EDGE.
     */
    EDGE,
    /**
     * GSM.
     */
    GSM,
    /**
     * S2B.
     */
    S2B,
    /**
     * LTE limited service.
     */
    LTE_LIMITED_SERVICE,
    /**
     * LTE FDD.
     */
    LTE_FDD,
    /**
     * LTE TDD.
     */
    LTE_TDD,
}
/**
 * 3GPP2 extended data bearer technologies.
 */
enum WdsExtendedDataBearerTechnology3gpp2 {
    /**
     * unknown.
     */
    UNKNOWN,
    /**
     * reserved.
     */
    RESERVED,
    /**
     * CDMA1x IS-95.
     */
    CDMA1X_IS95,
    /**
     * CDMA1x IS-2000.
     */
    CDMA1X_IS2000,
    /**
     * CDMA1x IS-2000 Release A.
     */
    CDMA1X_IS2000_REL_A,
    /**
     * HDR EVDO Rev 0 DPA.
     */
    HDR_REV_0_DPA,
    /**
     * HDR EVDO Rev A DPA.
     */
    HDR_REV_A_DPA,
    /**
     * HDR EVDO Rev B DPA.
     */
    HDR_REV_B_DPA,
    /**
     * HDR EVDO Rev A MPA.
     */
    HDR_REV_A_MPA,
    /**
     * HDR EVDO Rev B MPA.
     */
    HDR_REV_B_MPA,
    /**
     * HDR EVDO Rev A EMPA.
     */
    HDR_REV_A_EMPA,
    /**
     * HDR EVDO Rev B EMPA.
     */
    HDR_REV_B_EMPA,
    /**
     * HDR EVDO Rev B MMPA.
     */
    HDR_REV_B_MMPA,
    /**
     * HDR EVDO FMC.
     */
    HDR_EVDO_FMC,
}
/**
 * Flags specifying which specific settings to return when requesting the
 * current WDS bearer settings.
 */
enum WdsGetCurrentSettingsRequestedSettings {
    /**
     * no settings requested
     */
    NONE,
    /**
     * request profile ID
     */
    PROFILE_ID,
    /**
     * request profile name
     */
    PROFILE_NAME,
    /**
     * request PDP context type
     */
    PDP_TYPE,
    /**
     * request APN name
     */
    APN_NAME,
    /**
     * request DNS server addresses
     */
    DNS_ADDRESS,
    /**
     * request granted QoS
     */
    GRANTED_QOS,
    /**
     * request username
     */
    USERNAME,
    /**
     * request authentication protocol, ie PAP/CHAP/none.
     */
    AUTH_PROTOCOL,
    /**
     * request IP address
     */
    IP_ADDRESS,
    /**
     * request gateway address
     */
    GATEWAY_INFO,
    /**
     * request PCSCF address
     */
    PCSCF_ADDRESS,
    /**
     * request PCSCF server address list
     */
    PCSCF_SERVER_ADDRESS_LIST,
    /**
     * request PCSCF domain name list
     */
    PCSCF_DOMAIN_NAME_LIST,
    /**
     * request MTU
     */
    MTU,
    /**
     * request domain name list
     */
    DOMAIN_NAME_LIST,
    /**
     * request IP family, ie IPv4 or IPv6.
     */
    IP_FAMILY,
    /**
     * request IMCN flag
     */
    IMCN_FLAG,
    /**
     * request extended technology info
     */
    EXTENDED_TECHNOLOGY,
}
/**
 * Mask to use when requesting packet statistics.
 */
enum WdsPacketStatisticsMaskFlag {
    /**
     * Request count of correctly sent packets.
     */
    TX_PACKETS_OK,
    /**
     * Request count of correctly received packets.
     */
    RX_PACKETS_OK,
    /**
     * Request count of sent packets with error.
     */
    TX_PACKETS_ERROR,
    /**
     * Request count of received packets with error.
     */
    RX_PACKETS_ERROR,
    /**
     * Request count of transmitter overflows.
     */
    TX_OVERFLOWS,
    /**
     * Request count of receiver overflows.
     */
    RX_OVERFLOWS,
    /**
     * Request count of correctly sent bytes.
     */
    TX_BYTES_OK,
    /**
     * Request count of correctly received bytes.
     */
    RX_BYTES_OK,
    /**
     * Request count of dropped packets in transmission.
     */
    TX_PACKETS_DROPPED,
    /**
     * Request count of dropped packets in reception.
     */
    RX_PACKETS_DROPPED,
}
/**
 * Flags specifying the 3GPP-specific Radio Access Technology, when the data
 * bearer network type is `QMI_WDS_NETWORK_TYPE_3`GPP.
 */
enum WdsRat3gpp {
    /**
     * Unknown, to be ignored.
     */
    NONE,
    /**
     * WCDMA.
     */
    WCDMA,
    /**
     * GPRS.
     */
    GPRS,
    /**
     * HSDPA.
     */
    HSDPA,
    /**
     * HSUPA.
     */
    HSUPA,
    /**
     * EDGE.
     */
    EDGE,
    /**
     * LTE.
     */
    LTE,
    /**
     * HSDPA+.
     */
    HSDPAPLUS,
    /**
     * DC-HSDPA+.
     */
    DCHSDPAPLUS,
    /**
     * 64QAM. Since: 1.18.
     */
    TODO_64QAM,
    /**
     * TD-SCDMA. Since: 1.18.
     */
    TDSCDMA,
    /**
     * No bearer.
     */
    NULL_BEARER,
}
/**
 * Flags specifying the 3GPP2-specific Radio Access Technology, when the data
 * bearer network type is `QMI_WDS_NETWORK_TYPE_3`GPP2.
 */
enum WdsRat3gpp2 {
    /**
     * Unknown, to be ignored.
     */
    NONE,
    /**
     * CDMA 1x.
     */
    CDMA1X,
    /**
     * EVDO Rev0.
     */
    EVDO_REV0,
    /**
     * EVDO RevA.
     */
    EVDO_REVA,
    /**
     * EVDO RevB.
     */
    EVDO_REVB,
    /**
     * eHRPD. Since: 1.18.
     */
    EHRPD,
    /**
     * FMC. Since: 1.18.
     */
    FMC,
    /**
     * No bearer.
     */
    NULL_BEARER,
}
/**
 * Flags indicating which WDS Set Event Report Transfer Statistics indicators
 * should be emitted.
 */
enum WdsSetEventReportTransferStatistics {
    /**
     * report TX packet successes.
     */
    TX_PACKETS_OK,
    /**
     * report RX packet successes.
     */
    RX_PACKETS_OK,
    /**
     * report TX packet errors.
     */
    TX_PACKETS_ERROR,
    /**
     * report RX packet errors.
     */
    RX_PACKETS_ERROR,
    /**
     * report TX overflows.
     */
    TX_OVERFLOWS,
    /**
     * report RX overflows.
     */
    RX_OVERFLOWS,
    /**
     * report TX byte total.
     */
    TX_BYTES_OK,
    /**
     * report RX byte total.
     */
    RX_BYTES_OK,
    /**
     * report TX packets dropped.
     */
    TX_PACKETS_DROPPED,
    /**
     * report RX packets dropped.
     */
    RX_PACKETS_DROPPED,
}
/**
 * Flags specifying the Service Option when the bearer network type is
 * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
 * contains `QMI_WDS_RAT_3`GPP2_CDMA1X.
 */
enum WdsSoCdma1x {
    /**
     * Unknown, to be ignored.
     */
    NONE,
    /**
     * IS95.
     */
    IS95,
    /**
     * IS2000.
     */
    IS2000,
    /**
     * IS2000 RelA.
     */
    IS2000_REL_A,
}
/**
 * Flags specifying the Service Option when the bearer network type is
 * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
 * contains `QMI_WDS_RAT_3`GPP2_EVDO_REV0.
 */
enum WdsSoEvdoRev0 {
    /**
     * Unknown, to be ignored.
     */
    NONE,
    /**
     * DPA.
     */
    DPA,
}
/**
 * Flags specifying the Service Option when the bearer network type is
 * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
 * contains `QMI_WDS_RAT_3`GPP2_EVDO_REVA.
 */
enum WdsSoEvdoRevA {
    /**
     * Unknown, to be ignored.
     */
    NONE,
    /**
     * DPA.
     */
    DPA,
    /**
     * MFPA.
     */
    MFPA,
    /**
     * EMPA.
     */
    EMPA,
    /**
     * EMPA eHRPD.
     */
    EMPA_EHRPD,
}
/**
 * Flags specifying the Service Option when the bearer network type is
 * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
 * contains `QMI_WDS_RAT_3`GPP2_EVDO_REVB.
 */
enum WdsSoEvdoRevB {
    /**
     * Unknown, to be ignored.
     */
    NONE,
    /**
     * DPA.
     */
    DPA,
    /**
     * MFPA.
     */
    MFPA,
    /**
     * EMPA.
     */
    EMPA,
    /**
     * EMPA eHRPD.
     */
    EMPA_EHRPD,
    /**
     * MMPA.
     */
    MMPA,
    /**
     * MMPA eHRPD.
     */
    MMPA_EHRPD,
}
/**
 * Type of network allowed when trying to connect.
 */
enum WdsTechnologyPreference {
    /**
     * 3GPP allowed.
     */
    TODO_3GPP,
    /**
     * 3GPP2 allowed.
     */
    TODO_3GPP2,
}
/**
 * A symbol specifying the broadcast CID.
 */
const CID_BROADCAST: number
/**
 * A symbol specifying a special CID value that references no CID.
 */
const CID_NONE: number
/**
 * Symbol defining the #QmiClient:client-cid property.
 */
const CLIENT_CID: string
/**
 * Symbol defining the #QmiClient:client-device property.
 */
const CLIENT_DEVICE: string
/**
 * Symbol defining the #QmiClient:client-service property.
 */
const CLIENT_SERVICE: string
/**
 * Symbol defining the #QmiClient:client-valid property.
 */
const CLIENT_VALID: string
/**
 * Symbol defining the #QmiClient:client-version-major property.
 */
const CLIENT_VERSION_MAJOR: string
/**
 * Symbol defining the #QmiClient:client-version-minor property.
 */
const CLIENT_VERSION_MINOR: string
/**
 * Symbol defining the common string prefix used for all libqmi errors in DBus.
 */
const DBUS_ERROR_PREFIX: string
/**
 * Symbol defining the #QmiDevice:device-file property.
 */
const DEVICE_FILE: string
/**
 * Symbol defining the maximum supported mux id.
 */
const DEVICE_MUX_ID_MAX: number
/**
 * Symbol defining the minimum supported mux id.
 */
const DEVICE_MUX_ID_MIN: number
/**
 * Symbol defining the mux id for an unbound interface. This value is also used
 * to indicate an invalid mux id.
 */
const DEVICE_MUX_ID_UNBOUND: number
const DEVICE_NODE: string
/**
 * Symbol defining the #QmiDevice:device-no-file-check property.
 */
const DEVICE_NO_FILE_CHECK: string
/**
 * Symbol defining the #QmiDevice:device-proxy-path property.
 */
const DEVICE_PROXY_PATH: string
/**
 * Symbol defining the #QmiDevice::indication signal.
 */
const DEVICE_SIGNAL_INDICATION: string
/**
 * Symbol defining the #QmiDevice::device-removed signal.
 */
const DEVICE_SIGNAL_REMOVED: string
/**
 * Symbol defining the #QmiDevice:device-wwan-iface property.
 */
const DEVICE_WWAN_IFACE: string
/**
 * First byte of every QMI message.
 */
const MESSAGE_QMUX_MARKER: number
/**
 * Generic vendor id (0x0000).
 */
const MESSAGE_VENDOR_GENERIC: number
/**
 * Symbol defining the #QmiProxy:qmi-proxy-n-clients property.
 */
const PROXY_N_CLIENTS: string
/**
 * Symbol defining the default abstract socket name where the #QmiProxy will listen.
 */
const PROXY_SOCKET_PATH: string
/**
 * The TX/RX rate information is unavailable or cannot be measured.
 */
const WDS_RATE_UNAVAILABLE: number
function core_error_get_string(val: CoreError): string
function core_error_quark(): GLib.Quark
function data_endpoint_type_get_string(val: DataEndpointType): string
function device_add_link_flags_build_string_from_mask(mask: DeviceAddLinkFlags): string
function device_expected_data_format_get_string(val: DeviceExpectedDataFormat): string
function device_open_flags_build_string_from_mask(mask: DeviceOpenFlags): string
function device_release_client_flags_build_string_from_mask(mask: DeviceReleaseClientFlags): string
function dms_activation_state_get_string(val: DmsActivationState): string
function dms_band_capability_build_string_from_mask(mask: DmsBandCapability): string
function dms_boot_image_download_mode_get_string(val: DmsBootImageDownloadMode): string
function dms_data_service_capability_get_string(val: DmsDataServiceCapability): string
function dms_firmware_image_type_get_string(val: DmsFirmwareImageType): string
function dms_foxconn_device_mode_get_string(val: DmsFoxconnDeviceMode): string
function dms_foxconn_firmware_version_type_get_string(val: DmsFoxconnFirmwareVersionType): string
function dms_hp_device_mode_get_string(val: DmsHpDeviceMode): string
function dms_lte_band_capability_build_string_from_mask(mask: DmsLteBandCapability): string
function dms_mac_type_get_string(val: DmsMacType): string
function dms_offline_reason_build_string_from_mask(mask: DmsOfflineReason): string
function dms_operating_mode_get_string(val: DmsOperatingMode): string
function dms_power_state_build_string_from_mask(mask: DmsPowerState): string
function dms_radio_interface_get_string(val: DmsRadioInterface): string
function dms_sim_capability_get_string(val: DmsSimCapability): string
function dms_swi_usb_composition_get_description(value: DmsSwiUsbComposition): string
function dms_swi_usb_composition_get_string(val: DmsSwiUsbComposition): string
function dms_time_reference_type_get_string(val: DmsTimeReferenceType): string
function dms_time_source_get_string(val: DmsTimeSource): string
function dms_uim_facility_get_string(val: DmsUimFacility): string
function dms_uim_facility_state_get_string(val: DmsUimFacilityState): string
function dms_uim_pin_id_get_string(val: DmsUimPinId): string
function dms_uim_pin_status_get_string(val: DmsUimPinStatus): string
function dms_uim_state_get_string(val: DmsUimState): string
function dsd_apn_type_get_string(val: DsdApnType): string
function dsd_apn_type_preference_build_string_from_mask(mask: DsdApnTypePreference): string
function endian_get_string(val: Endian): string
function fox_firmware_version_type_get_string(val: FoxFirmwareVersionType): string
function gas_firmware_listing_mode_get_string(val: GasFirmwareListingMode): string
function gas_usb_composition_endpoint_type_get_string(val: GasUsbCompositionEndpointType): string
function loc_delete_cell_database_build_string_from_mask(mask: LocDeleteCellDatabase): string
function loc_delete_clock_info_build_string_from_mask(mask: LocDeleteClockInfo): string
function loc_delete_gnss_data_build_string_from_mask(mask: LocDeleteGnssData): string
function loc_delete_sv_info_build_string_from_mask(mask: LocDeleteSvInfo): string
function loc_engine_state_get_string(val: LocEngineState): string
function loc_event_registration_flag_build_string_from_mask(mask: LocEventRegistrationFlag): string
function loc_fix_recurrence_type_get_string(val: LocFixRecurrenceType): string
function loc_health_status_get_string(val: LocHealthStatus): string
function loc_indication_status_get_string(val: LocIndicationStatus): string
function loc_intermediate_report_state_get_string(val: LocIntermediateReportState): string
function loc_lock_type_get_string(val: LocLockType): string
function loc_navigation_data_get_string(val: LocNavigationData): string
function loc_nmea_type_build_string_from_mask(mask: LocNmeaType): string
function loc_operation_mode_get_string(val: LocOperationMode): string
function loc_predicted_orbits_data_format_get_string(val: LocPredictedOrbitsDataFormat): string
function loc_reliability_get_string(val: LocReliability): string
function loc_satellite_status_get_string(val: LocSatelliteStatus): string
function loc_satellite_valid_information_build_string_from_mask(mask: LocSatelliteValidInformation): string
function loc_sensor_data_usage_build_string_from_mask(mask: LocSensorDataUsage): string
function loc_server_address_type_build_string_from_mask(mask: LocServerAddressType): string
function loc_server_type_get_string(val: LocServerType): string
function loc_session_status_get_string(val: LocSessionStatus): string
function loc_system_get_string(val: LocSystem): string
function loc_technology_used_build_string_from_mask(mask: LocTechnologyUsed): string
function loc_time_source_get_string(val: LocTimeSource): string
function message_add_raw_tlv(self: Message, type: number, raw: number, length: number): boolean
function message_foreach_raw_tlv(self: Message): void
function message_get_client_id(self: Message): number
function message_get_data(self: Message): [ /* returnType */ number, /* length */ number ]
function message_get_length(self: Message): number
function message_get_message_id(self: Message): number
function message_get_printable_full(self: Message, context: MessageContext, line_prefix: string): string
function message_get_raw(self: Message): [ /* returnType */ number, /* length */ number ]
function message_get_raw_tlv(self: Message, type: number): [ /* returnType */ number, /* length */ number ]
function message_get_service(self: Message): Service
function message_get_tlv_printable(self: Message, line_prefix: string, type: number, raw: number, raw_length: number): string
function message_get_transaction_id(self: Message): number
function message_is_indication(self: Message): boolean
function message_is_request(self: Message): boolean
function message_is_response(self: Message): boolean
function message_new(service: Service, client_id: number, transaction_id: number, message_id: number): Message
function message_new_from_data(service: Service, client_id: number, qmi_data: Uint8Array): [ /* returnType */ Message, /* qmi_data */ Uint8Array ]
function message_new_from_raw(raw: Uint8Array): [ /* returnType */ Message, /* raw */ Uint8Array ]
function message_ref(self: Message): Message
function message_response_new(request: Message, error: ProtocolError): Message
function message_set_transaction_id(self: Message, transaction_id: number): void
function message_tlv_read_fixed_size_string(self: Message, tlv_offset: number, offset: number, string_length: number): [ /* returnType */ boolean, /* offset */ number, /* out */ string ]
function message_tlv_read_gdouble(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_gfloat_endian(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_gint16(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_gint32(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_gint64(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_gint8(self: Message, tlv_offset: number, offset: number): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_guint16(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_guint32(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_guint64(self: Message, tlv_offset: number, offset: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_guint8(self: Message, tlv_offset: number, offset: number): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_init(self: Message, type: number): [ /* returnType */ number, /* out_tlv_length */ number ]
function message_tlv_read_remaining_size(self: Message, tlv_offset: number, offset: number): number
function message_tlv_read_sized_guint(self: Message, tlv_offset: number, offset: number, n_bytes: number, endian: Endian): [ /* returnType */ boolean, /* offset */ number, /* out */ number ]
function message_tlv_read_string(self: Message, tlv_offset: number, offset: number, n_size_prefix_bytes: number, max_size: number): [ /* returnType */ boolean, /* offset */ number, /* out */ string ]
function message_tlv_write_complete(self: Message, tlv_offset: number): boolean
function message_tlv_write_gint16(self: Message, endian: Endian, in_: number): boolean
function message_tlv_write_gint32(self: Message, endian: Endian, in_: number): boolean
function message_tlv_write_gint64(self: Message, endian: Endian, in_: number): boolean
function message_tlv_write_gint8(self: Message, in_: number): boolean
function message_tlv_write_guint16(self: Message, endian: Endian, in_: number): boolean
function message_tlv_write_guint32(self: Message, endian: Endian, in_: number): boolean
function message_tlv_write_guint64(self: Message, endian: Endian, in_: number): boolean
function message_tlv_write_guint8(self: Message, in_: number): boolean
function message_tlv_write_init(self: Message, type: number): number
function message_tlv_write_reset(self: Message, tlv_offset: number): void
function message_tlv_write_sized_guint(self: Message, n_bytes: number, endian: Endian, in_: number): boolean
function message_tlv_write_string(self: Message, n_size_prefix_bytes: number, in_: string, in_length: number): boolean
function message_unref(self: Message): void
function nas_active_band_get_string(val: NasActiveBand): string
function nas_attach_state_get_string(val: NasAttachState): string
function nas_band_preference_build_string_from_mask(mask: NasBandPreference): string
function nas_boolean_get_string(val: NasBoolean): string
function nas_call_barring_status_get_string(val: NasCallBarringStatus): string
function nas_cdma_pilot_type_get_string(val: NasCdmaPilotType): string
function nas_cdma_prl_preference_get_string(val: NasCdmaPrlPreference): string
function nas_cell_broadcast_capability_get_string(val: NasCellBroadcastCapability): string
function nas_change_duration_get_string(val: NasChangeDuration): string
function nas_data_capability_get_string(val: NasDataCapability): string
function nas_day_of_week_get_string(val: NasDayOfWeek): string
function nas_daylight_savings_adjustment_get_string(val: NasDaylightSavingsAdjustment): string
function nas_dl_bandwidth_get_string(val: NasDLBandwidth): string
function nas_drx_get_string(val: NasDrx): string
function nas_evdo_sinr_level_get_string(val: NasEvdoSinrLevel): string
function nas_gsm_wcdma_acquisition_order_preference_get_string(val: NasGsmWcdmaAcquisitionOrderPreference): string
function nas_hdr_personality_get_string(val: NasHdrPersonality): string
function nas_hdr_protocol_revision_get_string(val: NasHdrProtocolRevision): string
function nas_lte_band_preference_build_string_from_mask(mask: NasLteBandPreference): string
function nas_lte_cell_access_status_get_string(val: NasLteCellAccessStatus): string
function nas_lte_registration_domain_get_string(val: NasLteRegistrationDomain): string
function nas_lte_voice_domain_get_string(val: NasLteVoiceDomain): string
function nas_network_description_display_get_string(val: NasNetworkDescriptionDisplay): string
function nas_network_description_encoding_get_string(val: NasNetworkDescriptionEncoding): string
function nas_network_name_display_condition_build_string_from_mask(mask: NasNetworkNameDisplayCondition): string
function nas_network_name_source_get_string(val: NasNetworkNameSource): string
function nas_network_register_type_get_string(val: NasNetworkRegisterType): string
function nas_network_scan_result_get_string(val: NasNetworkScanResult): string
function nas_network_scan_type_build_string_from_mask(mask: NasNetworkScanType): string
function nas_network_selection_preference_get_string(val: NasNetworkSelectionPreference): string
function nas_network_selection_registration_restriction_get_string(val: NasNetworkSelectionRegistrationRestriction): string
function nas_network_service_domain_get_string(val: NasNetworkServiceDomain): string
function nas_network_status_build_string_from_mask(mask: NasNetworkStatus): string
function nas_network_type_get_string(val: NasNetworkType): string
function nas_plmn_access_technology_identifier_build_string_from_mask(mask: NasPlmnAccessTechnologyIdentifier): string
function nas_plmn_encoding_scheme_get_string(val: NasPlmnEncodingScheme): string
function nas_plmn_language_id_get_string(val: NasPlmnLanguageId): string
function nas_plmn_name_country_initials_get_string(val: NasPlmnNameCountryInitials): string
function nas_plmn_name_spare_bits_get_string(val: NasPlmnNameSpareBits): string
function nas_preference_duration_get_string(val: NasPreferenceDuration): string
function nas_ps_attach_action_get_string(val: NasPsAttachAction): string
function nas_radio_interface_get_string(val: NasRadioInterface): string
function nas_radio_technology_preference_build_string_from_mask(mask: NasRadioTechnologyPreference): string
function nas_rat_mode_preference_build_string_from_mask(mask: NasRatModePreference): string
function nas_read_string_from_network_description_encoded_array(encoding: NasNetworkDescriptionEncoding, array: Uint8Array): string
function nas_read_string_from_plmn_encoded_array(encoding: NasPlmnEncodingScheme, array: Uint8Array): string
function nas_registration_state_get_string(val: NasRegistrationState): string
function nas_reject_cause_get_string(val: NasRejectCause): string
function nas_roaming_indicator_status_get_string(val: NasRoamingIndicatorStatus): string
function nas_roaming_preference_get_string(val: NasRoamingPreference): string
function nas_roaming_status_get_string(val: NasRoamingStatus): string
function nas_scell_state_get_string(val: NasScellState): string
function nas_service_domain_preference_get_string(val: NasServiceDomainPreference): string
function nas_service_status_get_string(val: NasServiceStatus): string
function nas_signal_strength_request_build_string_from_mask(mask: NasSignalStrengthRequest): string
function nas_sim_reject_state_get_string(val: NasSimRejectState): string
function nas_swi_emm_connection_state_get_string(val: NasSwiEmmConnectionState): string
function nas_swi_emm_state_get_string(val: NasSwiEmmState): string
function nas_swi_ims_reg_state_get_string(val: NasSwiImsRegState): string
function nas_swi_modem_mode_get_string(val: NasSwiModemMode): string
function nas_swi_ps_state_get_string(val: NasSwiPsState): string
function nas_swi_system_mode_get_string(val: NasSwiSystemMode): string
function nas_td_scdma_band_preference_build_string_from_mask(mask: NasTdScdmaBandPreference): string
function nas_usage_preference_get_string(val: NasUsagePreference): string
function nas_voice_domain_preference_get_string(val: NasVoiceDomainPreference): string
function nas_wcdma_hs_service_get_string(val: NasWcdmaHsService): string
function nas_wcdma_rrc_state_get_string(val: NasWcdmaRrcState): string
function oma_hfa_feature_done_state_get_string(val: OmaHfaFeatureDoneState): string
function oma_session_failed_reason_get_string(val: OmaSessionFailedReason): string
function oma_session_state_get_string(val: OmaSessionState): string
function oma_session_type_get_string(val: OmaSessionType): string
function pbm_event_registration_flag_build_string_from_mask(mask: PbmEventRegistrationFlag): string
function pbm_phonebook_type_build_string_from_mask(mask: PbmPhonebookType): string
function pbm_session_type_get_string(val: PbmSessionType): string
function pdc_configuration_type_get_string(val: PdcConfigurationType): string
function pdc_refresh_event_type_get_string(val: PdcRefreshEventType): string
function pds_data_valid_build_string_from_mask(mask: PdsDataValid): string
function pds_network_mode_get_string(val: PdsNetworkMode): string
function pds_operating_mode_get_string(val: PdsOperatingMode): string
function pds_operation_mode_get_string(val: PdsOperationMode): string
function pds_position_session_status_get_string(val: PdsPositionSessionStatus): string
function pds_tracking_session_state_get_string(val: PdsTrackingSessionState): string
function protocol_error_get_string(val: ProtocolError): string
function protocol_error_quark(): GLib.Quark
function qos_event_get_string(val: QosEvent): string
function qos_status_get_string(val: QosStatus): string
function sar_rf_state_get_string(val: SarRfState): string
function service_get_string(val: Service): string
function sio_port_get_string(val: SioPort): string
function uim_card_application_personalization_feature_get_string(val: UimCardApplicationPersonalizationFeature): string
function uim_card_application_personalization_state_get_string(val: UimCardApplicationPersonalizationState): string
function uim_card_application_state_get_string(val: UimCardApplicationState): string
function uim_card_application_type_get_string(val: UimCardApplicationType): string
function uim_card_error_get_string(val: UimCardError): string
function uim_card_protocol_get_string(val: UimCardProtocol): string
function uim_card_state_get_string(val: UimCardState): string
function uim_configuration_build_string_from_mask(mask: UimConfiguration): string
function uim_depersonalization_operation_get_string(val: UimDepersonalizationOperation): string
function uim_event_registration_flag_build_string_from_mask(mask: UimEventRegistrationFlag): string
function uim_file_type_get_string(val: UimFileType): string
function uim_physical_card_state_get_string(val: UimPhysicalCardState): string
function uim_pin_id_get_string(val: UimPinId): string
function uim_pin_state_get_string(val: UimPinState): string
function uim_refresh_mode_get_string(val: UimRefreshMode): string
function uim_refresh_stage_get_string(val: UimRefreshStage): string
function uim_security_attribute_build_string_from_mask(mask: UimSecurityAttribute): string
function uim_security_attribute_logic_get_string(val: UimSecurityAttributeLogic): string
function uim_session_type_get_string(val: UimSessionType): string
function uim_slot_state_get_string(val: UimSlotState): string
function utils_get_traces_enabled(): boolean
function utils_set_traces_enabled(enabled: boolean): void
function voice_alpha_data_coding_scheme_get_string(val: VoiceAlphaDataCodingScheme): string
function voice_als_get_string(val: VoiceAls): string
function voice_call_control_result_type_get_string(val: VoiceCallControlResultType): string
function voice_call_control_supplementary_service_type_get_string(val: VoiceCallControlSupplementaryServiceType): string
function voice_call_direction_get_string(val: VoiceCallDirection): string
function voice_call_end_reason_get_string(val: VoiceCallEndReason): string
function voice_call_mode_get_string(val: VoiceCallMode): string
function voice_call_state_get_string(val: VoiceCallState): string
function voice_call_type_get_string(val: VoiceCallType): string
function voice_domain_get_string(val: VoiceDomain): string
function voice_presentation_get_string(val: VoicePresentation): string
function voice_privacy_get_string(val: VoicePrivacy): string
function voice_service_option_get_string(val: VoiceServiceOption): string
function voice_supplementary_service_action_get_string(val: VoiceSupplementaryServiceAction): string
function voice_supplementary_service_notification_type_get_string(val: VoiceSupplementaryServiceNotificationType): string
function voice_supplementary_service_reason_get_string(val: VoiceSupplementaryServiceReason): string
function voice_supplementary_service_type_get_string(val: VoiceSupplementaryServiceType): string
function voice_tty_mode_get_string(val: VoiceTtyMode): string
function voice_user_action_get_string(val: VoiceUserAction): string
function voice_uss_data_coding_scheme_get_string(val: VoiceUssDataCodingScheme): string
function voice_wcdma_amr_status_build_string_from_mask(mask: VoiceWcdmaAmrStatus): string
function wda_data_aggregation_protocol_get_string(val: WdaDataAggregationProtocol): string
function wda_link_layer_protocol_get_string(val: WdaLinkLayerProtocol): string
function wds_apn_type_mask_build_string_from_mask(mask: WdsApnTypeMask): string
function wds_attach_pdn_list_action_get_string(val: WdsAttachPdnListAction): string
function wds_authentication_build_string_from_mask(mask: WdsAuthentication): string
function wds_autoconnect_setting_get_string(val: WdsAutoconnectSetting): string
function wds_autoconnect_setting_roaming_get_string(val: WdsAutoconnectSettingRoaming): string
function wds_call_end_reason_get_string(val: WdsCallEndReason): string
function wds_call_type_get_string(val: WdsCallType): string
function wds_client_type_get_string(val: WdsClientType): string
function wds_connection_status_get_string(val: WdsConnectionStatus): string
function wds_data_bearer_technology_get_string(val: WdsDataBearerTechnology): string
function wds_data_call_status_get_string(val: WdsDataCallStatus): string
function wds_data_call_type_get_string(val: WdsDataCallType): string
function wds_data_system_get_string(val: WdsDataSystem): string
function wds_data_system_network_type_get_string(val: WdsDataSystemNetworkType): string
function wds_delivery_order_get_string(val: WdsDeliveryOrder): string
function wds_dormancy_status_get_string(val: WdsDormancyStatus): string
function wds_ds_profile_error_get_string(val: WdsDsProfileError): string
function wds_extended_data_bearer_technology_3gpp2_build_string_from_mask(mask: WdsExtendedDataBearerTechnology3gpp2): string
function wds_extended_data_bearer_technology_3gpp_build_string_from_mask(mask: WdsExtendedDataBearerTechnology3gpp): string
function wds_extended_technology_preference_get_string(val: WdsExtendedTechnologyPreference): string
function wds_get_current_settings_requested_settings_build_string_from_mask(mask: WdsGetCurrentSettingsRequestedSettings): string
function wds_ip_family_get_string(val: WdsIpFamily): string
function wds_ip_support_type_get_string(val: WdsIpSupportType): string
function wds_network_type_get_string(val: WdsNetworkType): string
function wds_packet_statistics_mask_flag_build_string_from_mask(mask: WdsPacketStatisticsMaskFlag): string
function wds_pdp_data_compression_type_get_string(val: WdsPdpDataCompressionType): string
function wds_pdp_header_compression_type_get_string(val: WdsPdpHeaderCompressionType): string
function wds_pdp_type_get_string(val: WdsPdpType): string
function wds_profile_family_get_string(val: WdsProfileFamily): string
function wds_profile_type_get_string(val: WdsProfileType): string
function wds_qos_class_identifier_get_string(val: WdsQosClassIdentifier): string
function wds_radio_access_technology_get_string(val: WdsRadioAccessTechnology): string
function wds_rat_3gpp2_build_string_from_mask(mask: WdsRat3gpp2): string
function wds_rat_3gpp_build_string_from_mask(mask: WdsRat3gpp): string
function wds_sdu_erroneous_delivery_get_string(val: WdsSduErroneousDelivery): string
function wds_sdu_error_ratio_get_string(val: WdsSduErrorRatio): string
function wds_sdu_residual_bit_error_ratio_get_string(val: WdsSduResidualBitErrorRatio): string
function wds_set_event_report_transfer_statistics_build_string_from_mask(mask: WdsSetEventReportTransferStatistics): string
function wds_so_cdma1x_build_string_from_mask(mask: WdsSoCdma1x): string
function wds_so_evdo_rev0_build_string_from_mask(mask: WdsSoEvdoRev0): string
function wds_so_evdo_reva_build_string_from_mask(mask: WdsSoEvdoRevA): string
function wds_so_evdo_revb_build_string_from_mask(mask: WdsSoEvdoRevB): string
function wds_technology_preference_build_string_from_mask(mask: WdsTechnologyPreference): string
function wds_tethered_call_type_get_string(val: WdsTetheredCallType): string
function wds_traffic_class_get_string(val: WdsTrafficClass): string
function wds_verbose_call_end_reason_3gpp_get_string(val: WdsVerboseCallEndReason3gpp): string
function wds_verbose_call_end_reason_cm_get_string(val: WdsVerboseCallEndReasonCm): string
function wds_verbose_call_end_reason_ehrpd_get_string(val: WdsVerboseCallEndReasonEhrpd): string
function wds_verbose_call_end_reason_get_string(type: WdsVerboseCallEndReasonType, reason: number): string
function wds_verbose_call_end_reason_internal_get_string(val: WdsVerboseCallEndReasonInternal): string
function wds_verbose_call_end_reason_ipv6_get_string(val: WdsVerboseCallEndReasonIpv6): string
function wds_verbose_call_end_reason_mip_get_string(val: WdsVerboseCallEndReasonMip): string
function wds_verbose_call_end_reason_ppp_get_string(val: WdsVerboseCallEndReasonPpp): string
function wds_verbose_call_end_reason_type_get_string(val: WdsVerboseCallEndReasonType): string
function wms_ack_failure_cause_get_string(val: WmsAckFailureCause): string
function wms_ack_indicator_get_string(val: WmsAckIndicator): string
function wms_cdma_cause_code_get_string(val: WmsCdmaCauseCode): string
function wms_cdma_error_class_get_string(val: WmsCdmaErrorClass): string
function wms_cdma_service_option_get_string(val: WmsCdmaServiceOption): string
function wms_gsm_umts_rp_cause_get_string(val: WmsGsmUmtsRpCause): string
function wms_gsm_umts_tp_cause_get_string(val: WmsGsmUmtsTpCause): string
function wms_message_class_get_string(val: WmsMessageClass): string
function wms_message_delivery_failure_type_get_string(val: WmsMessageDeliveryFailureType): string
function wms_message_format_get_string(val: WmsMessageFormat): string
function wms_message_mode_get_string(val: WmsMessageMode): string
function wms_message_protocol_get_string(val: WmsMessageProtocol): string
function wms_message_tag_type_get_string(val: WmsMessageTagType): string
function wms_message_type_get_string(val: WmsMessageType): string
function wms_notification_type_get_string(val: WmsNotificationType): string
function wms_receipt_action_get_string(val: WmsReceiptAction): string
function wms_storage_type_get_string(val: WmsStorageType): string
function wms_transfer_indication_get_string(val: WmsTransferIndication): string
/**
 * Callback to run when processing the command abortion. This callback
 * should parse the abort response provided by the device, and build an
 * appropriate output.
 */
interface DeviceCommandAbortableParseResponseFn {
    (self: Device, abort_response: Message): boolean
}
/**
 * Callback type to use when iterating raw TLVs with
 * qmi_message_foreach_raw_tlv().
 */
interface MessageForeachRawTlvFn {
    (type: number, value: number, length: number): void
}
interface Client_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Qmi-1.0.Qmi.Client */
    client_cid?: number
    client_device?: Device
    client_service?: Service
    client_version_major?: number
    client_version_minor?: number
}
class Client {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Client_ConstructProps)
    _init (config?: Client_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientDms_ConstructProps extends Client_ConstructProps {
}
class ClientDms {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientDms */
    /**
     * Asynchronously sends a Activate Automatic request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_activate_automatic_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsActivateAutomaticInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    activate_automatic(input: MessageDmsActivateAutomaticInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_activate_automatic().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_activate_automatic().
     */
    activate_automatic_finish(res: Gio.AsyncResult): MessageDmsActivateAutomaticOutput
    /**
     * Asynchronously sends a Activate Manual request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_activate_manual_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsActivateManualInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    activate_manual(input: MessageDmsActivateManualInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_activate_manual().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_activate_manual().
     */
    activate_manual_finish(res: Gio.AsyncResult): MessageDmsActivateManualOutput
    /**
     * Asynchronously sends a Delete Stored Image request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_delete_stored_image_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsDeleteStoredImageInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    delete_stored_image(input: MessageDmsDeleteStoredImageInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_delete_stored_image().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_delete_stored_image().
     */
    delete_stored_image_finish(res: Gio.AsyncResult): MessageDmsDeleteStoredImageOutput
    /**
     * Asynchronously sends a Foxconn Change Device Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_foxconn_change_device_mode_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsFoxconnChangeDeviceModeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    foxconn_change_device_mode(input: MessageDmsFoxconnChangeDeviceModeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_foxconn_change_device_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_foxconn_change_device_mode().
     */
    foxconn_change_device_mode_finish(res: Gio.AsyncResult): MessageDmsFoxconnChangeDeviceModeOutput
    /**
     * Asynchronously sends a Foxconn Get Firmware Version request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_foxconn_get_firmware_version_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsFoxconnGetFirmwareVersionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    foxconn_get_firmware_version(input: MessageDmsFoxconnGetFirmwareVersionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_foxconn_get_firmware_version().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_foxconn_get_firmware_version().
     */
    foxconn_get_firmware_version_finish(res: Gio.AsyncResult): MessageDmsFoxconnGetFirmwareVersionOutput
    /**
     * Asynchronously sends a Foxconn Set FCC Authentication request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_foxconn_set_fcc_authentication_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsFoxconnSetFccAuthenticationInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    foxconn_set_fcc_authentication(input: MessageDmsFoxconnSetFccAuthenticationInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_foxconn_set_fcc_authentication().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_foxconn_set_fcc_authentication().
     */
    foxconn_set_fcc_authentication_finish(res: Gio.AsyncResult): MessageDmsFoxconnSetFccAuthenticationOutput
    /**
     * Asynchronously sends a Get Activation State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_activation_state_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_activation_state(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_activation_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_activation_state().
     */
    get_activation_state_finish(res: Gio.AsyncResult): MessageDmsGetActivationStateOutput
    /**
     * Asynchronously sends a Get Alt Net Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_alt_net_config_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_alt_net_config(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_alt_net_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_alt_net_config().
     */
    get_alt_net_config_finish(res: Gio.AsyncResult): MessageDmsGetAltNetConfigOutput
    /**
     * Asynchronously sends a Get Band Capabilities request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_band_capabilities_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_band_capabilities(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_band_capabilities().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_band_capabilities().
     */
    get_band_capabilities_finish(res: Gio.AsyncResult): MessageDmsGetBandCapabilitiesOutput
    /**
     * Asynchronously sends a Get Boot Image Download Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_boot_image_download_mode_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_boot_image_download_mode(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_boot_image_download_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_boot_image_download_mode().
     */
    get_boot_image_download_mode_finish(res: Gio.AsyncResult): MessageDmsGetBootImageDownloadModeOutput
    /**
     * Asynchronously sends a Get Capabilities request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_capabilities_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_capabilities(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_capabilities().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_capabilities().
     */
    get_capabilities_finish(res: Gio.AsyncResult): MessageDmsGetCapabilitiesOutput
    /**
     * Asynchronously sends a Get Factory SKU request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_factory_sku_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_factory_sku(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_factory_sku().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_factory_sku().
     */
    get_factory_sku_finish(res: Gio.AsyncResult): MessageDmsGetFactorySkuOutput
    /**
     * Asynchronously sends a Get Firmware Preference request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_firmware_preference_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_firmware_preference(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_firmware_preference().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_firmware_preference().
     */
    get_firmware_preference_finish(res: Gio.AsyncResult): MessageDmsGetFirmwarePreferenceOutput
    /**
     * Asynchronously sends a Get Hardware Revision request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_hardware_revision_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_hardware_revision(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_hardware_revision().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_hardware_revision().
     */
    get_hardware_revision_finish(res: Gio.AsyncResult): MessageDmsGetHardwareRevisionOutput
    /**
     * Asynchronously sends a Get IDs request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_ids_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_ids(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_ids().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_ids().
     */
    get_ids_finish(res: Gio.AsyncResult): MessageDmsGetIdsOutput
    /**
     * Asynchronously sends a Get MAC Address request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_mac_address_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsGetMacAddressInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_mac_address(input: MessageDmsGetMacAddressInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_mac_address().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_mac_address().
     */
    get_mac_address_finish(res: Gio.AsyncResult): MessageDmsGetMacAddressOutput
    /**
     * Asynchronously sends a Get Manufacturer request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_manufacturer_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_manufacturer(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_manufacturer().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_manufacturer().
     */
    get_manufacturer_finish(res: Gio.AsyncResult): MessageDmsGetManufacturerOutput
    /**
     * Asynchronously sends a Get Model request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_model_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_model(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_model().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_model().
     */
    get_model_finish(res: Gio.AsyncResult): MessageDmsGetModelOutput
    /**
     * Asynchronously sends a Get MSISDN request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_msisdn_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_msisdn(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_msisdn().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_msisdn().
     */
    get_msisdn_finish(res: Gio.AsyncResult): MessageDmsGetMsisdnOutput
    /**
     * Asynchronously sends a Get Operating Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_operating_mode_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_operating_mode(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_operating_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_operating_mode().
     */
    get_operating_mode_finish(res: Gio.AsyncResult): MessageDmsGetOperatingModeOutput
    /**
     * Asynchronously sends a Get Power State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_power_state_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_power_state(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_power_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_power_state().
     */
    get_power_state_finish(res: Gio.AsyncResult): MessageDmsGetPowerStateOutput
    /**
     * Asynchronously sends a Get PRL Version request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_prl_version_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_prl_version(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_prl_version().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_prl_version().
     */
    get_prl_version_finish(res: Gio.AsyncResult): MessageDmsGetPrlVersionOutput
    /**
     * Asynchronously sends a Get Revision request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_revision_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_revision(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_revision().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_revision().
     */
    get_revision_finish(res: Gio.AsyncResult): MessageDmsGetRevisionOutput
    /**
     * Asynchronously sends a Get Software Version request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_software_version_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_software_version(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_software_version().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_software_version().
     */
    get_software_version_finish(res: Gio.AsyncResult): MessageDmsGetSoftwareVersionOutput
    /**
     * Asynchronously sends a Get Stored Image Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_stored_image_info_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsGetStoredImageInfoInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_stored_image_info(input: MessageDmsGetStoredImageInfoInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_stored_image_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_stored_image_info().
     */
    get_stored_image_info_finish(res: Gio.AsyncResult): MessageDmsGetStoredImageInfoOutput
    /**
     * Asynchronously sends a Get Supported Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_supported_messages_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_supported_messages(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_supported_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_supported_messages().
     */
    get_supported_messages_finish(res: Gio.AsyncResult): MessageDmsGetSupportedMessagesOutput
    /**
     * Asynchronously sends a Get Time request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_time_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_time(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_time().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_time().
     */
    get_time_finish(res: Gio.AsyncResult): MessageDmsGetTimeOutput
    /**
     * Asynchronously sends a Get User Lock State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_get_user_lock_state_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_user_lock_state(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_get_user_lock_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_user_lock_state().
     */
    get_user_lock_state_finish(res: Gio.AsyncResult): MessageDmsGetUserLockStateOutput
    /**
     * Asynchronously sends a HP Change Device Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_hp_change_device_mode_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsHpChangeDeviceModeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    hp_change_device_mode(input: MessageDmsHpChangeDeviceModeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_hp_change_device_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_hp_change_device_mode().
     */
    hp_change_device_mode_finish(res: Gio.AsyncResult): MessageDmsHpChangeDeviceModeOutput
    /**
     * Asynchronously sends a List Stored Images request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_list_stored_images_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    list_stored_images(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_list_stored_images().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_list_stored_images().
     */
    list_stored_images_finish(res: Gio.AsyncResult): MessageDmsListStoredImagesOutput
    /**
     * Asynchronously sends a Read ERI File request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_read_eri_file_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    read_eri_file(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_read_eri_file().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_read_eri_file().
     */
    read_eri_file_finish(res: Gio.AsyncResult): MessageDmsReadEriFileOutput
    /**
     * Asynchronously sends a Read User Data request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_read_user_data_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    read_user_data(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_read_user_data().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_read_user_data().
     */
    read_user_data_finish(res: Gio.AsyncResult): MessageDmsReadUserDataOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessageDmsResetOutput
    /**
     * Asynchronously sends a Restore Factory Defaults request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_restore_factory_defaults_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsRestoreFactoryDefaultsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    restore_factory_defaults(input: MessageDmsRestoreFactoryDefaultsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_restore_factory_defaults().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_restore_factory_defaults().
     */
    restore_factory_defaults_finish(res: Gio.AsyncResult): MessageDmsRestoreFactoryDefaultsOutput
    /**
     * Asynchronously sends a Set Alt Net Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_alt_net_config_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetAltNetConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_alt_net_config(input: MessageDmsSetAltNetConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_alt_net_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_alt_net_config().
     */
    set_alt_net_config_finish(res: Gio.AsyncResult): MessageDmsSetAltNetConfigOutput
    /**
     * Asynchronously sends a Set Boot Image Download Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_boot_image_download_mode_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetBootImageDownloadModeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_boot_image_download_mode(input: MessageDmsSetBootImageDownloadModeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_boot_image_download_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_boot_image_download_mode().
     */
    set_boot_image_download_mode_finish(res: Gio.AsyncResult): MessageDmsSetBootImageDownloadModeOutput
    /**
     * Asynchronously sends a Set Event Report request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_event_report_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetEventReportInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_event_report(input: MessageDmsSetEventReportInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_event_report().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_event_report().
     */
    set_event_report_finish(res: Gio.AsyncResult): MessageDmsSetEventReportOutput
    /**
     * Asynchronously sends a Set FCC Authentication request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_fcc_authentication_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_fcc_authentication(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_fcc_authentication().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_fcc_authentication().
     */
    set_fcc_authentication_finish(res: Gio.AsyncResult): MessageDmsSetFccAuthenticationOutput
    /**
     * Asynchronously sends a Set Firmware ID request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_firmware_id_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_firmware_id(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_firmware_id().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_firmware_id().
     */
    set_firmware_id_finish(res: Gio.AsyncResult): MessageDmsSetFirmwareIdOutput
    /**
     * Asynchronously sends a Set Firmware Preference request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_firmware_preference_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetFirmwarePreferenceInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_firmware_preference(input: MessageDmsSetFirmwarePreferenceInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_firmware_preference().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_firmware_preference().
     */
    set_firmware_preference_finish(res: Gio.AsyncResult): MessageDmsSetFirmwarePreferenceOutput
    /**
     * Asynchronously sends a Set Operating Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_operating_mode_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetOperatingModeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_operating_mode(input: MessageDmsSetOperatingModeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_operating_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_operating_mode().
     */
    set_operating_mode_finish(res: Gio.AsyncResult): MessageDmsSetOperatingModeOutput
    /**
     * Asynchronously sends a Set Service Programming Code request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_service_programming_code_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetServiceProgrammingCodeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_service_programming_code(input: MessageDmsSetServiceProgrammingCodeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_service_programming_code().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_service_programming_code().
     */
    set_service_programming_code_finish(res: Gio.AsyncResult): MessageDmsSetServiceProgrammingCodeOutput
    /**
     * Asynchronously sends a Set Time request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_time_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetTimeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_time(input: MessageDmsSetTimeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_time().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_time().
     */
    set_time_finish(res: Gio.AsyncResult): MessageDmsSetTimeOutput
    /**
     * Asynchronously sends a Set User Lock Code request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_user_lock_code_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetUserLockCodeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_user_lock_code(input: MessageDmsSetUserLockCodeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_user_lock_code().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_user_lock_code().
     */
    set_user_lock_code_finish(res: Gio.AsyncResult): MessageDmsSetUserLockCodeOutput
    /**
     * Asynchronously sends a Set User Lock State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_set_user_lock_state_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSetUserLockStateInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_user_lock_state(input: MessageDmsSetUserLockStateInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_set_user_lock_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_user_lock_state().
     */
    set_user_lock_state_finish(res: Gio.AsyncResult): MessageDmsSetUserLockStateOutput
    /**
     * Asynchronously sends a Swi Get Current Firmware request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_swi_get_current_firmware_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    swi_get_current_firmware(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_swi_get_current_firmware().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_swi_get_current_firmware().
     */
    swi_get_current_firmware_finish(res: Gio.AsyncResult): MessageDmsSwiGetCurrentFirmwareOutput
    /**
     * Asynchronously sends a Swi Get USB Composition request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_swi_get_usb_composition_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    swi_get_usb_composition(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_swi_get_usb_composition().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_swi_get_usb_composition().
     */
    swi_get_usb_composition_finish(res: Gio.AsyncResult): MessageDmsSwiGetUsbCompositionOutput
    /**
     * Asynchronously sends a Swi Set USB Composition request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_swi_set_usb_composition_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsSwiSetUsbCompositionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    swi_set_usb_composition(input: MessageDmsSwiSetUsbCompositionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_swi_set_usb_composition().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_swi_set_usb_composition().
     */
    swi_set_usb_composition_finish(res: Gio.AsyncResult): MessageDmsSwiSetUsbCompositionOutput
    /**
     * Asynchronously sends a UIM Change PIN request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_change_pin_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsUimChangePinInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_change_pin(input: MessageDmsUimChangePinInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_change_pin().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_change_pin().
     */
    uim_change_pin_finish(res: Gio.AsyncResult): MessageDmsUimChangePinOutput
    /**
     * Asynchronously sends a UIM Get CK Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_get_ck_status_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsUimGetCkStatusInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_get_ck_status(input: MessageDmsUimGetCkStatusInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_get_ck_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_ck_status().
     */
    uim_get_ck_status_finish(res: Gio.AsyncResult): MessageDmsUimGetCkStatusOutput
    /**
     * Asynchronously sends a UIM Get ICCID request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_get_iccid_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_get_iccid(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_get_iccid().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_iccid().
     */
    uim_get_iccid_finish(res: Gio.AsyncResult): MessageDmsUimGetIccidOutput
    /**
     * Asynchronously sends a UIM Get IMSI request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_get_imsi_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_get_imsi(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_get_imsi().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_imsi().
     */
    uim_get_imsi_finish(res: Gio.AsyncResult): MessageDmsUimGetImsiOutput
    /**
     * Asynchronously sends a UIM Get PIN Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_get_pin_status_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_get_pin_status(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_get_pin_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_pin_status().
     */
    uim_get_pin_status_finish(res: Gio.AsyncResult): MessageDmsUimGetPinStatusOutput
    /**
     * Asynchronously sends a UIM Get State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_get_state_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_get_state(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_get_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_state().
     */
    uim_get_state_finish(res: Gio.AsyncResult): MessageDmsUimGetStateOutput
    /**
     * Asynchronously sends a UIM Set CK Protection request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_set_ck_protection_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsUimSetCkProtectionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_set_ck_protection(input: MessageDmsUimSetCkProtectionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_set_ck_protection().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_set_ck_protection().
     */
    uim_set_ck_protection_finish(res: Gio.AsyncResult): MessageDmsUimSetCkProtectionOutput
    /**
     * Asynchronously sends a UIM Set PIN Protection request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_set_pin_protection_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsUimSetPinProtectionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_set_pin_protection(input: MessageDmsUimSetPinProtectionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_set_pin_protection().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_set_pin_protection().
     */
    uim_set_pin_protection_finish(res: Gio.AsyncResult): MessageDmsUimSetPinProtectionOutput
    /**
     * Asynchronously sends a UIM Unblock CK request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_unblock_ck_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsUimUnblockCkInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_unblock_ck(input: MessageDmsUimUnblockCkInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_unblock_ck().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_unblock_ck().
     */
    uim_unblock_ck_finish(res: Gio.AsyncResult): MessageDmsUimUnblockCkOutput
    /**
     * Asynchronously sends a UIM Unblock PIN request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_unblock_pin_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsUimUnblockPinInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_unblock_pin(input: MessageDmsUimUnblockPinInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_unblock_pin().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_unblock_pin().
     */
    uim_unblock_pin_finish(res: Gio.AsyncResult): MessageDmsUimUnblockPinOutput
    /**
     * Asynchronously sends a UIM Verify PIN request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_uim_verify_pin_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsUimVerifyPinInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    uim_verify_pin(input: MessageDmsUimVerifyPinInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_uim_verify_pin().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_verify_pin().
     */
    uim_verify_pin_finish(res: Gio.AsyncResult): MessageDmsUimVerifyPinOutput
    /**
     * Asynchronously sends a Validate Service Programming Code request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_validate_service_programming_code_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsValidateServiceProgrammingCodeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    validate_service_programming_code(input: MessageDmsValidateServiceProgrammingCodeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_validate_service_programming_code().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_validate_service_programming_code().
     */
    validate_service_programming_code_finish(res: Gio.AsyncResult): MessageDmsValidateServiceProgrammingCodeOutput
    /**
     * Asynchronously sends a Write User Data request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dms_write_user_data_finish() to get the result of the operation.
     * @param input a #QmiMessageDmsWriteUserDataInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    write_user_data(input: MessageDmsWriteUserDataInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dms_write_user_data().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_write_user_data().
     */
    write_user_data_finish(res: Gio.AsyncResult): MessageDmsWriteUserDataOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientDms */
    /**
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-DMS-Event-Report-indication.top_of_page">Event Report</link>' indication is received.
     * @param output A #QmiIndicationDmsEventReportOutput.
     */
    connect(sigName: "event-report", callback: (($obj: ClientDms, output: IndicationDmsEventReportOutput) => void)): number
    connect_after(sigName: "event-report", callback: (($obj: ClientDms, output: IndicationDmsEventReportOutput) => void)): number
    emit(sigName: "event-report", output: IndicationDmsEventReportOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientDms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientDms_ConstructProps)
    _init (config?: ClientDms_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientDpm_ConstructProps extends Client_ConstructProps {
}
class ClientDpm {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientDpm */
    /**
     * Asynchronously sends a Close Port request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dpm_close_port_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    close_port(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dpm_close_port().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dpm_close_port().
     */
    close_port_finish(res: Gio.AsyncResult): MessageDpmClosePortOutput
    /**
     * Asynchronously sends a Open Port request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dpm_open_port_finish() to get the result of the operation.
     * @param input a #QmiMessageDpmOpenPortInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    open_port(input: MessageDpmOpenPortInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dpm_open_port().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dpm_open_port().
     */
    open_port_finish(res: Gio.AsyncResult): MessageDpmOpenPortOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientDpm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientDpm_ConstructProps)
    _init (config?: ClientDpm_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientDsd_ConstructProps extends Client_ConstructProps {
}
class ClientDsd {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientDsd */
    /**
     * Asynchronously sends a Get APN Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dsd_get_apn_info_finish() to get the result of the operation.
     * @param input a #QmiMessageDsdGetApnInfoInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_apn_info(input: MessageDsdGetApnInfoInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dsd_get_apn_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dsd_get_apn_info().
     */
    get_apn_info_finish(res: Gio.AsyncResult): MessageDsdGetApnInfoOutput
    /**
     * Asynchronously sends a Set APN Type request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_dsd_set_apn_type_finish() to get the result of the operation.
     * @param input a #QmiMessageDsdSetApnTypeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_apn_type(input: MessageDsdSetApnTypeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_dsd_set_apn_type().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dsd_set_apn_type().
     */
    set_apn_type_finish(res: Gio.AsyncResult): MessageDsdSetApnTypeOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientDsd, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientDsd_ConstructProps)
    _init (config?: ClientDsd_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientFox_ConstructProps extends Client_ConstructProps {
}
class ClientFox {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientFox */
    /**
     * Asynchronously sends a Get Firmware Version request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_fox_get_firmware_version_finish() to get the result of the operation.
     * @param input a #QmiMessageFoxGetFirmwareVersionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_firmware_version(input: MessageFoxGetFirmwareVersionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_fox_get_firmware_version().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_fox_get_firmware_version().
     */
    get_firmware_version_finish(res: Gio.AsyncResult): MessageFoxGetFirmwareVersionOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientFox, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientFox_ConstructProps)
    _init (config?: ClientFox_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientGas_ConstructProps extends Client_ConstructProps {
}
class ClientGas {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientGas */
    /**
     * Asynchronously sends a DMS Get Firmware List request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_gas_dms_get_firmware_list_finish() to get the result of the operation.
     * @param input a #QmiMessageGasDmsGetFirmwareListInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    dms_get_firmware_list(input: MessageGasDmsGetFirmwareListInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_gas_dms_get_firmware_list().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_get_firmware_list().
     */
    dms_get_firmware_list_finish(res: Gio.AsyncResult): MessageGasDmsGetFirmwareListOutput
    /**
     * Asynchronously sends a DMS Get USB Composition request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_gas_dms_get_usb_composition_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    dms_get_usb_composition(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_gas_dms_get_usb_composition().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_get_usb_composition().
     */
    dms_get_usb_composition_finish(res: Gio.AsyncResult): MessageGasDmsGetUsbCompositionOutput
    /**
     * Asynchronously sends a DMS Set Active Firmware request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_gas_dms_set_active_firmware_finish() to get the result of the operation.
     * @param input a #QmiMessageGasDmsSetActiveFirmwareInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    dms_set_active_firmware(input: MessageGasDmsSetActiveFirmwareInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_gas_dms_set_active_firmware().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_set_active_firmware().
     */
    dms_set_active_firmware_finish(res: Gio.AsyncResult): MessageGasDmsSetActiveFirmwareOutput
    /**
     * Asynchronously sends a DMS Set USB Composition request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_gas_dms_set_usb_composition_finish() to get the result of the operation.
     * @param input a #QmiMessageGasDmsSetUsbCompositionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    dms_set_usb_composition(input: MessageGasDmsSetUsbCompositionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_gas_dms_set_usb_composition().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_set_usb_composition().
     */
    dms_set_usb_composition_finish(res: Gio.AsyncResult): MessageGasDmsSetUsbCompositionOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientGas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientGas_ConstructProps)
    _init (config?: ClientGas_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientGms_ConstructProps extends Client_ConstructProps {
}
class ClientGms {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientGms */
    /**
     * Asynchronously sends a Test Get Value request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_gms_test_get_value_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    test_get_value(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_gms_test_get_value().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gms_test_get_value().
     */
    test_get_value_finish(res: Gio.AsyncResult): MessageGmsTestGetValueOutput
    /**
     * Asynchronously sends a Test Set Value request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_gms_test_set_value_finish() to get the result of the operation.
     * @param input a #QmiMessageGmsTestSetValueInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    test_set_value(input: MessageGmsTestSetValueInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_gms_test_set_value().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gms_test_set_value().
     */
    test_set_value_finish(res: Gio.AsyncResult): MessageGmsTestSetValueOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientGms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientGms_ConstructProps)
    _init (config?: ClientGms_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientLoc_ConstructProps extends Client_ConstructProps {
}
class ClientLoc {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientLoc */
    /**
     * Asynchronously sends a Delete Assistance Data request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_delete_assistance_data_finish() to get the result of the operation.
     * @param input a #QmiMessageLocDeleteAssistanceDataInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    delete_assistance_data(input: MessageLocDeleteAssistanceDataInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_delete_assistance_data().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_delete_assistance_data().
     */
    delete_assistance_data_finish(res: Gio.AsyncResult): MessageLocDeleteAssistanceDataOutput
    /**
     * Asynchronously sends a Get Engine Lock request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_get_engine_lock_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_engine_lock(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_get_engine_lock().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_engine_lock().
     */
    get_engine_lock_finish(res: Gio.AsyncResult): MessageLocGetEngineLockOutput
    /**
     * Asynchronously sends a Get NMEA Types request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_get_nmea_types_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_nmea_types(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_get_nmea_types().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_nmea_types().
     */
    get_nmea_types_finish(res: Gio.AsyncResult): MessageLocGetNmeaTypesOutput
    /**
     * Asynchronously sends a Get Operation Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_get_operation_mode_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_operation_mode(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_get_operation_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_operation_mode().
     */
    get_operation_mode_finish(res: Gio.AsyncResult): MessageLocGetOperationModeOutput
    /**
     * Asynchronously sends a Get Predicted Orbits Data Source request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_get_predicted_orbits_data_source_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_predicted_orbits_data_source(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_get_predicted_orbits_data_source().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_predicted_orbits_data_source().
     */
    get_predicted_orbits_data_source_finish(res: Gio.AsyncResult): MessageLocGetPredictedOrbitsDataSourceOutput
    /**
     * Asynchronously sends a Get Server request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_get_server_finish() to get the result of the operation.
     * @param input a #QmiMessageLocGetServerInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_server(input: MessageLocGetServerInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_get_server().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_server().
     */
    get_server_finish(res: Gio.AsyncResult): MessageLocGetServerOutput
    /**
     * Asynchronously sends a Inject Predicted Orbits Data request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_inject_predicted_orbits_data_finish() to get the result of the operation.
     * @param input a #QmiMessageLocInjectPredictedOrbitsDataInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    inject_predicted_orbits_data(input: MessageLocInjectPredictedOrbitsDataInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_inject_predicted_orbits_data().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_inject_predicted_orbits_data().
     */
    inject_predicted_orbits_data_finish(res: Gio.AsyncResult): MessageLocInjectPredictedOrbitsDataOutput
    /**
     * Asynchronously sends a Inject Xtra Data request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_inject_xtra_data_finish() to get the result of the operation.
     * @param input a #QmiMessageLocInjectXtraDataInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    inject_xtra_data(input: MessageLocInjectXtraDataInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_inject_xtra_data().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_inject_xtra_data().
     */
    inject_xtra_data_finish(res: Gio.AsyncResult): MessageLocInjectXtraDataOutput
    /**
     * Asynchronously sends a Register Events request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_register_events_finish() to get the result of the operation.
     * @param input a #QmiMessageLocRegisterEventsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    register_events(input: MessageLocRegisterEventsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_register_events().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_register_events().
     */
    register_events_finish(res: Gio.AsyncResult): MessageLocRegisterEventsOutput
    /**
     * Asynchronously sends a Set Engine Lock request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_set_engine_lock_finish() to get the result of the operation.
     * @param input a #QmiMessageLocSetEngineLockInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_engine_lock(input: MessageLocSetEngineLockInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_set_engine_lock().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_engine_lock().
     */
    set_engine_lock_finish(res: Gio.AsyncResult): MessageLocSetEngineLockOutput
    /**
     * Asynchronously sends a Set NMEA Types request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_set_nmea_types_finish() to get the result of the operation.
     * @param input a #QmiMessageLocSetNmeaTypesInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_nmea_types(input: MessageLocSetNmeaTypesInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_set_nmea_types().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_nmea_types().
     */
    set_nmea_types_finish(res: Gio.AsyncResult): MessageLocSetNmeaTypesOutput
    /**
     * Asynchronously sends a Set Operation Mode request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_set_operation_mode_finish() to get the result of the operation.
     * @param input a #QmiMessageLocSetOperationModeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_operation_mode(input: MessageLocSetOperationModeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_set_operation_mode().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_operation_mode().
     */
    set_operation_mode_finish(res: Gio.AsyncResult): MessageLocSetOperationModeOutput
    /**
     * Asynchronously sends a Set Server request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_set_server_finish() to get the result of the operation.
     * @param input a #QmiMessageLocSetServerInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_server(input: MessageLocSetServerInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_set_server().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_server().
     */
    set_server_finish(res: Gio.AsyncResult): MessageLocSetServerOutput
    /**
     * Asynchronously sends a Start request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_start_finish() to get the result of the operation.
     * @param input a #QmiMessageLocStartInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    start(input: MessageLocStartInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_start().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_start().
     */
    start_finish(res: Gio.AsyncResult): MessageLocStartOutput
    /**
     * Asynchronously sends a Stop request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_loc_stop_finish() to get the result of the operation.
     * @param input a #QmiMessageLocStopInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    stop(input: MessageLocStopInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_loc_stop().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_stop().
     */
    stop_finish(res: Gio.AsyncResult): MessageLocStopOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientLoc */
    /**
     * The ::delete-assistance-data signal gets emitted when a '<link linkend="libqmi-glib-LOC-Delete-Assistance-Data-indication.top_of_page">Delete Assistance Data</link>' indication is received.
     * @param output A #QmiIndicationLocDeleteAssistanceDataOutput.
     */
    connect(sigName: "delete-assistance-data", callback: (($obj: ClientLoc, output: IndicationLocDeleteAssistanceDataOutput) => void)): number
    connect_after(sigName: "delete-assistance-data", callback: (($obj: ClientLoc, output: IndicationLocDeleteAssistanceDataOutput) => void)): number
    emit(sigName: "delete-assistance-data", output: IndicationLocDeleteAssistanceDataOutput): void
    /**
     * The ::engine-state signal gets emitted when a '<link linkend="libqmi-glib-LOC-Engine-State-indication.top_of_page">Engine State</link>' indication is received.
     * @param output A #QmiIndicationLocEngineStateOutput.
     */
    connect(sigName: "engine-state", callback: (($obj: ClientLoc, output: IndicationLocEngineStateOutput) => void)): number
    connect_after(sigName: "engine-state", callback: (($obj: ClientLoc, output: IndicationLocEngineStateOutput) => void)): number
    emit(sigName: "engine-state", output: IndicationLocEngineStateOutput): void
    /**
     * The ::fix-recurrence-type signal gets emitted when a '<link linkend="libqmi-glib-LOC-Fix-Recurrence-Type-indication.top_of_page">Fix Recurrence Type</link>' indication is received.
     * @param output A #QmiIndicationLocFixRecurrenceTypeOutput.
     */
    connect(sigName: "fix-recurrence-type", callback: (($obj: ClientLoc, output: IndicationLocFixRecurrenceTypeOutput) => void)): number
    connect_after(sigName: "fix-recurrence-type", callback: (($obj: ClientLoc, output: IndicationLocFixRecurrenceTypeOutput) => void)): number
    emit(sigName: "fix-recurrence-type", output: IndicationLocFixRecurrenceTypeOutput): void
    /**
     * The ::get-engine-lock signal gets emitted when a '<link linkend="libqmi-glib-LOC-Get-Engine-Lock-indication.top_of_page">Get Engine Lock</link>' indication is received.
     * @param output A #QmiIndicationLocGetEngineLockOutput.
     */
    connect(sigName: "get-engine-lock", callback: (($obj: ClientLoc, output: IndicationLocGetEngineLockOutput) => void)): number
    connect_after(sigName: "get-engine-lock", callback: (($obj: ClientLoc, output: IndicationLocGetEngineLockOutput) => void)): number
    emit(sigName: "get-engine-lock", output: IndicationLocGetEngineLockOutput): void
    /**
     * The ::get-nmea-types signal gets emitted when a '<link linkend="libqmi-glib-LOC-Get-NMEA-Types-indication.top_of_page">Get NMEA Types</link>' indication is received.
     * @param output A #QmiIndicationLocGetNmeaTypesOutput.
     */
    connect(sigName: "get-nmea-types", callback: (($obj: ClientLoc, output: IndicationLocGetNmeaTypesOutput) => void)): number
    connect_after(sigName: "get-nmea-types", callback: (($obj: ClientLoc, output: IndicationLocGetNmeaTypesOutput) => void)): number
    emit(sigName: "get-nmea-types", output: IndicationLocGetNmeaTypesOutput): void
    /**
     * The ::get-operation-mode signal gets emitted when a '<link linkend="libqmi-glib-LOC-Get-Operation-Mode-indication.top_of_page">Get Operation Mode</link>' indication is received.
     * @param output A #QmiIndicationLocGetOperationModeOutput.
     */
    connect(sigName: "get-operation-mode", callback: (($obj: ClientLoc, output: IndicationLocGetOperationModeOutput) => void)): number
    connect_after(sigName: "get-operation-mode", callback: (($obj: ClientLoc, output: IndicationLocGetOperationModeOutput) => void)): number
    emit(sigName: "get-operation-mode", output: IndicationLocGetOperationModeOutput): void
    /**
     * The ::get-predicted-orbits-data-source signal gets emitted when a '<link linkend="libqmi-glib-LOC-Get-Predicted-Orbits-Data-Source-indication.top_of_page">Get Predicted Orbits Data Source</link>' indication is received.
     * @param output A #QmiIndicationLocGetPredictedOrbitsDataSourceOutput.
     */
    connect(sigName: "get-predicted-orbits-data-source", callback: (($obj: ClientLoc, output: IndicationLocGetPredictedOrbitsDataSourceOutput) => void)): number
    connect_after(sigName: "get-predicted-orbits-data-source", callback: (($obj: ClientLoc, output: IndicationLocGetPredictedOrbitsDataSourceOutput) => void)): number
    emit(sigName: "get-predicted-orbits-data-source", output: IndicationLocGetPredictedOrbitsDataSourceOutput): void
    /**
     * The ::get-server signal gets emitted when a '<link linkend="libqmi-glib-LOC-Get-Server-indication.top_of_page">Get Server</link>' indication is received.
     * @param output A #QmiIndicationLocGetServerOutput.
     */
    connect(sigName: "get-server", callback: (($obj: ClientLoc, output: IndicationLocGetServerOutput) => void)): number
    connect_after(sigName: "get-server", callback: (($obj: ClientLoc, output: IndicationLocGetServerOutput) => void)): number
    emit(sigName: "get-server", output: IndicationLocGetServerOutput): void
    /**
     * The ::gnss-sv-info signal gets emitted when a '<link linkend="libqmi-glib-LOC-GNSS-Sv-Info-indication.top_of_page">GNSS Sv Info</link>' indication is received.
     * @param output A #QmiIndicationLocGnssSvInfoOutput.
     */
    connect(sigName: "gnss-sv-info", callback: (($obj: ClientLoc, output: IndicationLocGnssSvInfoOutput) => void)): number
    connect_after(sigName: "gnss-sv-info", callback: (($obj: ClientLoc, output: IndicationLocGnssSvInfoOutput) => void)): number
    emit(sigName: "gnss-sv-info", output: IndicationLocGnssSvInfoOutput): void
    /**
     * The ::inject-predicted-orbits-data signal gets emitted when a '<link linkend="libqmi-glib-LOC-Inject-Predicted-Orbits-Data-indication.top_of_page">Inject Predicted Orbits Data</link>' indication is received.
     * @param output A #QmiIndicationLocInjectPredictedOrbitsDataOutput.
     */
    connect(sigName: "inject-predicted-orbits-data", callback: (($obj: ClientLoc, output: IndicationLocInjectPredictedOrbitsDataOutput) => void)): number
    connect_after(sigName: "inject-predicted-orbits-data", callback: (($obj: ClientLoc, output: IndicationLocInjectPredictedOrbitsDataOutput) => void)): number
    emit(sigName: "inject-predicted-orbits-data", output: IndicationLocInjectPredictedOrbitsDataOutput): void
    /**
     * The ::inject-xtra-data signal gets emitted when a '<link linkend="libqmi-glib-LOC-Inject-Xtra-Data-indication.top_of_page">Inject Xtra Data</link>' indication is received.
     * @param output A #QmiIndicationLocInjectXtraDataOutput.
     */
    connect(sigName: "inject-xtra-data", callback: (($obj: ClientLoc, output: IndicationLocInjectXtraDataOutput) => void)): number
    connect_after(sigName: "inject-xtra-data", callback: (($obj: ClientLoc, output: IndicationLocInjectXtraDataOutput) => void)): number
    emit(sigName: "inject-xtra-data", output: IndicationLocInjectXtraDataOutput): void
    /**
     * The ::nmea signal gets emitted when a '<link linkend="libqmi-glib-LOC-NMEA-indication.top_of_page">NMEA</link>' indication is received.
     * @param output A #QmiIndicationLocNmeaOutput.
     */
    connect(sigName: "nmea", callback: (($obj: ClientLoc, output: IndicationLocNmeaOutput) => void)): number
    connect_after(sigName: "nmea", callback: (($obj: ClientLoc, output: IndicationLocNmeaOutput) => void)): number
    emit(sigName: "nmea", output: IndicationLocNmeaOutput): void
    /**
     * The ::position-report signal gets emitted when a '<link linkend="libqmi-glib-LOC-Position-Report-indication.top_of_page">Position Report</link>' indication is received.
     * @param output A #QmiIndicationLocPositionReportOutput.
     */
    connect(sigName: "position-report", callback: (($obj: ClientLoc, output: IndicationLocPositionReportOutput) => void)): number
    connect_after(sigName: "position-report", callback: (($obj: ClientLoc, output: IndicationLocPositionReportOutput) => void)): number
    emit(sigName: "position-report", output: IndicationLocPositionReportOutput): void
    /**
     * The ::set-engine-lock signal gets emitted when a '<link linkend="libqmi-glib-LOC-Set-Engine-Lock-indication.top_of_page">Set Engine Lock</link>' indication is received.
     * @param output A #QmiIndicationLocSetEngineLockOutput.
     */
    connect(sigName: "set-engine-lock", callback: (($obj: ClientLoc, output: IndicationLocSetEngineLockOutput) => void)): number
    connect_after(sigName: "set-engine-lock", callback: (($obj: ClientLoc, output: IndicationLocSetEngineLockOutput) => void)): number
    emit(sigName: "set-engine-lock", output: IndicationLocSetEngineLockOutput): void
    /**
     * The ::set-nmea-types signal gets emitted when a '<link linkend="libqmi-glib-LOC-Set-NMEA-Types-indication.top_of_page">Set NMEA Types</link>' indication is received.
     * @param output A #QmiIndicationLocSetNmeaTypesOutput.
     */
    connect(sigName: "set-nmea-types", callback: (($obj: ClientLoc, output: IndicationLocSetNmeaTypesOutput) => void)): number
    connect_after(sigName: "set-nmea-types", callback: (($obj: ClientLoc, output: IndicationLocSetNmeaTypesOutput) => void)): number
    emit(sigName: "set-nmea-types", output: IndicationLocSetNmeaTypesOutput): void
    /**
     * The ::set-operation-mode signal gets emitted when a '<link linkend="libqmi-glib-LOC-Set-Operation-Mode-indication.top_of_page">Set Operation Mode</link>' indication is received.
     * @param output A #QmiIndicationLocSetOperationModeOutput.
     */
    connect(sigName: "set-operation-mode", callback: (($obj: ClientLoc, output: IndicationLocSetOperationModeOutput) => void)): number
    connect_after(sigName: "set-operation-mode", callback: (($obj: ClientLoc, output: IndicationLocSetOperationModeOutput) => void)): number
    emit(sigName: "set-operation-mode", output: IndicationLocSetOperationModeOutput): void
    /**
     * The ::set-server signal gets emitted when a '<link linkend="libqmi-glib-LOC-Set-Server-indication.top_of_page">Set Server</link>' indication is received.
     * @param output A #QmiIndicationLocSetServerOutput.
     */
    connect(sigName: "set-server", callback: (($obj: ClientLoc, output: IndicationLocSetServerOutput) => void)): number
    connect_after(sigName: "set-server", callback: (($obj: ClientLoc, output: IndicationLocSetServerOutput) => void)): number
    emit(sigName: "set-server", output: IndicationLocSetServerOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientLoc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientLoc_ConstructProps)
    _init (config?: ClientLoc_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientNas_ConstructProps extends Client_ConstructProps {
}
class ClientNas {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientNas */
    /**
     * Asynchronously sends a Attach Detach request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_attach_detach_finish() to get the result of the operation.
     * @param input a #QmiMessageNasAttachDetachInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    attach_detach(input: MessageNasAttachDetachInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_attach_detach().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_attach_detach().
     */
    attach_detach_finish(res: Gio.AsyncResult): MessageNasAttachDetachOutput
    /**
     * Asynchronously sends a Config Signal Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_config_signal_info_finish() to get the result of the operation.
     * @param input a #QmiMessageNasConfigSignalInfoInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    config_signal_info(input: MessageNasConfigSignalInfoInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_config_signal_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_config_signal_info().
     */
    config_signal_info_finish(res: Gio.AsyncResult): MessageNasConfigSignalInfoOutput
    /**
     * Asynchronously sends a Force Network Search request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_force_network_search_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    force_network_search(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_force_network_search().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_force_network_search().
     */
    force_network_search_finish(res: Gio.AsyncResult): MessageNasForceNetworkSearchOutput
    /**
     * Asynchronously sends a Get CDMA Position Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_cdma_position_info_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_cdma_position_info(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_cdma_position_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_cdma_position_info().
     */
    get_cdma_position_info_finish(res: Gio.AsyncResult): MessageNasGetCdmaPositionInfoOutput
    /**
     * Asynchronously sends a Get Cell Location Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_cell_location_info_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_cell_location_info(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_cell_location_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_cell_location_info().
     */
    get_cell_location_info_finish(res: Gio.AsyncResult): MessageNasGetCellLocationInfoOutput
    /**
     * Asynchronously sends a Get DRX request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_drx_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_drx(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_drx().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_drx().
     */
    get_drx_finish(res: Gio.AsyncResult): MessageNasGetDrxOutput
    /**
     * Asynchronously sends a Get Home Network request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_home_network_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_home_network(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_home_network().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_home_network().
     */
    get_home_network_finish(res: Gio.AsyncResult): MessageNasGetHomeNetworkOutput
    /**
     * Asynchronously sends a Get LTE Cphy CA Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_lte_cphy_ca_info_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_lte_cphy_ca_info(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_lte_cphy_ca_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_lte_cphy_ca_info().
     */
    get_lte_cphy_ca_info_finish(res: Gio.AsyncResult): MessageNasGetLteCphyCaInfoOutput
    /**
     * Asynchronously sends a Get Operator Name request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_operator_name_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_operator_name(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_operator_name().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_operator_name().
     */
    get_operator_name_finish(res: Gio.AsyncResult): MessageNasGetOperatorNameOutput
    /**
     * Asynchronously sends a Get PLMN Name request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_plmn_name_finish() to get the result of the operation.
     * @param input a #QmiMessageNasGetPlmnNameInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_plmn_name(input: MessageNasGetPlmnNameInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_plmn_name().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_plmn_name().
     */
    get_plmn_name_finish(res: Gio.AsyncResult): MessageNasGetPlmnNameOutput
    /**
     * Asynchronously sends a Get Preferred Networks request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_preferred_networks_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_preferred_networks(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_preferred_networks().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_preferred_networks().
     */
    get_preferred_networks_finish(res: Gio.AsyncResult): MessageNasGetPreferredNetworksOutput
    /**
     * Asynchronously sends a Get RF Band Information request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_rf_band_information_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_rf_band_information(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_rf_band_information().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_rf_band_information().
     */
    get_rf_band_information_finish(res: Gio.AsyncResult): MessageNasGetRfBandInformationOutput
    /**
     * Asynchronously sends a Get Serving System request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_serving_system_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_serving_system(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_serving_system().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_serving_system().
     */
    get_serving_system_finish(res: Gio.AsyncResult): MessageNasGetServingSystemOutput
    /**
     * Asynchronously sends a Get Signal Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_signal_info_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_signal_info(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_signal_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_signal_info().
     */
    get_signal_info_finish(res: Gio.AsyncResult): MessageNasGetSignalInfoOutput
    /**
     * Asynchronously sends a Get Signal Strength request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_signal_strength_finish() to get the result of the operation.
     * @param input a #QmiMessageNasGetSignalStrengthInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_signal_strength(input: MessageNasGetSignalStrengthInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_signal_strength().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_signal_strength().
     */
    get_signal_strength_finish(res: Gio.AsyncResult): MessageNasGetSignalStrengthOutput
    /**
     * Asynchronously sends a Get Supported Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_supported_messages_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_supported_messages(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_supported_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_supported_messages().
     */
    get_supported_messages_finish(res: Gio.AsyncResult): MessageNasGetSupportedMessagesOutput
    /**
     * Asynchronously sends a Get System Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_system_info_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_system_info(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_system_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_system_info().
     */
    get_system_info_finish(res: Gio.AsyncResult): MessageNasGetSystemInfoOutput
    /**
     * Asynchronously sends a Get System Selection Preference request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_system_selection_preference_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_system_selection_preference(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_system_selection_preference().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_system_selection_preference().
     */
    get_system_selection_preference_finish(res: Gio.AsyncResult): MessageNasGetSystemSelectionPreferenceOutput
    /**
     * Asynchronously sends a Get Technology Preference request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_technology_preference_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_technology_preference(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_technology_preference().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_technology_preference().
     */
    get_technology_preference_finish(res: Gio.AsyncResult): MessageNasGetTechnologyPreferenceOutput
    /**
     * Asynchronously sends a Get Tx Rx Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_get_tx_rx_info_finish() to get the result of the operation.
     * @param input a #QmiMessageNasGetTxRxInfoInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_tx_rx_info(input: MessageNasGetTxRxInfoInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_get_tx_rx_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_tx_rx_info().
     */
    get_tx_rx_info_finish(res: Gio.AsyncResult): MessageNasGetTxRxInfoOutput
    /**
     * Asynchronously sends a Initiate Network Register request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_initiate_network_register_finish() to get the result of the operation.
     * @param input a #QmiMessageNasInitiateNetworkRegisterInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    initiate_network_register(input: MessageNasInitiateNetworkRegisterInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_initiate_network_register().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_initiate_network_register().
     */
    initiate_network_register_finish(res: Gio.AsyncResult): MessageNasInitiateNetworkRegisterOutput
    /**
     * Asynchronously sends a Network Scan request to the device.
     * 
     * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
     * an abort request will be sent to the device, and the asynchronous operation will
     * not return until the abort response is received. It is not an error if a successful
     * response is returned for the asynchronous operation even after the user has cancelled
     * the cancellable, because it may happen that the response is received before the
     * modem had a chance to run the abort.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_network_scan_finish() to get the result of the operation.
     * @param input a #QmiMessageNasNetworkScanInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    network_scan(input: MessageNasNetworkScanInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_network_scan().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_network_scan().
     */
    network_scan_finish(res: Gio.AsyncResult): MessageNasNetworkScanOutput
    /**
     * Asynchronously sends a Register Indications request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_register_indications_finish() to get the result of the operation.
     * @param input a #QmiMessageNasRegisterIndicationsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    register_indications(input: MessageNasRegisterIndicationsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_register_indications().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_register_indications().
     */
    register_indications_finish(res: Gio.AsyncResult): MessageNasRegisterIndicationsOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessageNasResetOutput
    /**
     * Asynchronously sends a Set Event Report request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_set_event_report_finish() to get the result of the operation.
     * @param input a #QmiMessageNasSetEventReportInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_event_report(input: MessageNasSetEventReportInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_set_event_report().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_event_report().
     */
    set_event_report_finish(res: Gio.AsyncResult): MessageNasSetEventReportOutput
    /**
     * Asynchronously sends a Set Preferred Networks request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_set_preferred_networks_finish() to get the result of the operation.
     * @param input a #QmiMessageNasSetPreferredNetworksInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_preferred_networks(input: MessageNasSetPreferredNetworksInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_set_preferred_networks().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_preferred_networks().
     */
    set_preferred_networks_finish(res: Gio.AsyncResult): MessageNasSetPreferredNetworksOutput
    /**
     * Asynchronously sends a Set System Selection Preference request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_set_system_selection_preference_finish() to get the result of the operation.
     * @param input a #QmiMessageNasSetSystemSelectionPreferenceInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_system_selection_preference(input: MessageNasSetSystemSelectionPreferenceInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_set_system_selection_preference().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_system_selection_preference().
     */
    set_system_selection_preference_finish(res: Gio.AsyncResult): MessageNasSetSystemSelectionPreferenceOutput
    /**
     * Asynchronously sends a Set Technology Preference request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_set_technology_preference_finish() to get the result of the operation.
     * @param input a #QmiMessageNasSetTechnologyPreferenceInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_technology_preference(input: MessageNasSetTechnologyPreferenceInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_set_technology_preference().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_technology_preference().
     */
    set_technology_preference_finish(res: Gio.AsyncResult): MessageNasSetTechnologyPreferenceOutput
    /**
     * Asynchronously sends a Swi Get Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_nas_swi_get_status_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    swi_get_status(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_nas_swi_get_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_swi_get_status().
     */
    swi_get_status_finish(res: Gio.AsyncResult): MessageNasSwiGetStatusOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientNas */
    /**
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-NAS-Event-Report-indication.top_of_page">Event Report</link>' indication is received.
     * @param output A #QmiIndicationNasEventReportOutput.
     */
    connect(sigName: "event-report", callback: (($obj: ClientNas, output: IndicationNasEventReportOutput) => void)): number
    connect_after(sigName: "event-report", callback: (($obj: ClientNas, output: IndicationNasEventReportOutput) => void)): number
    emit(sigName: "event-report", output: IndicationNasEventReportOutput): void
    /**
     * The ::network-reject signal gets emitted when a '<link linkend="libqmi-glib-NAS-Network-Reject-indication.top_of_page">Network Reject</link>' indication is received.
     * @param output A #QmiIndicationNasNetworkRejectOutput.
     */
    connect(sigName: "network-reject", callback: (($obj: ClientNas, output: IndicationNasNetworkRejectOutput) => void)): number
    connect_after(sigName: "network-reject", callback: (($obj: ClientNas, output: IndicationNasNetworkRejectOutput) => void)): number
    emit(sigName: "network-reject", output: IndicationNasNetworkRejectOutput): void
    /**
     * The ::network-time signal gets emitted when a '<link linkend="libqmi-glib-NAS-Network-Time-indication.top_of_page">Network Time</link>' indication is received.
     * @param output A #QmiIndicationNasNetworkTimeOutput.
     */
    connect(sigName: "network-time", callback: (($obj: ClientNas, output: IndicationNasNetworkTimeOutput) => void)): number
    connect_after(sigName: "network-time", callback: (($obj: ClientNas, output: IndicationNasNetworkTimeOutput) => void)): number
    emit(sigName: "network-time", output: IndicationNasNetworkTimeOutput): void
    /**
     * The ::operator-name signal gets emitted when a '<link linkend="libqmi-glib-NAS-Operator-Name-indication.top_of_page">Operator Name</link>' indication is received.
     * @param output A #QmiIndicationNasOperatorNameOutput.
     */
    connect(sigName: "operator-name", callback: (($obj: ClientNas, output: IndicationNasOperatorNameOutput) => void)): number
    connect_after(sigName: "operator-name", callback: (($obj: ClientNas, output: IndicationNasOperatorNameOutput) => void)): number
    emit(sigName: "operator-name", output: IndicationNasOperatorNameOutput): void
    /**
     * The ::serving-system signal gets emitted when a '<link linkend="libqmi-glib-NAS-Serving-System-indication.top_of_page">Serving System</link>' indication is received.
     * @param output A #QmiIndicationNasServingSystemOutput.
     */
    connect(sigName: "serving-system", callback: (($obj: ClientNas, output: IndicationNasServingSystemOutput) => void)): number
    connect_after(sigName: "serving-system", callback: (($obj: ClientNas, output: IndicationNasServingSystemOutput) => void)): number
    emit(sigName: "serving-system", output: IndicationNasServingSystemOutput): void
    /**
     * The ::signal-info signal gets emitted when a '<link linkend="libqmi-glib-NAS-Signal-Info-indication.top_of_page">Signal Info</link>' indication is received.
     * @param output A #QmiIndicationNasSignalInfoOutput.
     */
    connect(sigName: "signal-info", callback: (($obj: ClientNas, output: IndicationNasSignalInfoOutput) => void)): number
    connect_after(sigName: "signal-info", callback: (($obj: ClientNas, output: IndicationNasSignalInfoOutput) => void)): number
    emit(sigName: "signal-info", output: IndicationNasSignalInfoOutput): void
    /**
     * The ::system-info signal gets emitted when a '<link linkend="libqmi-glib-NAS-System-Info-indication.top_of_page">System Info</link>' indication is received.
     * @param output A #QmiIndicationNasSystemInfoOutput.
     */
    connect(sigName: "system-info", callback: (($obj: ClientNas, output: IndicationNasSystemInfoOutput) => void)): number
    connect_after(sigName: "system-info", callback: (($obj: ClientNas, output: IndicationNasSystemInfoOutput) => void)): number
    emit(sigName: "system-info", output: IndicationNasSystemInfoOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientNas, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientNas_ConstructProps)
    _init (config?: ClientNas_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientOma_ConstructProps extends Client_ConstructProps {
}
class ClientOma {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientOma */
    /**
     * Asynchronously sends a Cancel Session request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_cancel_session_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    cancel_session(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_cancel_session().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_cancel_session().
     */
    cancel_session_finish(res: Gio.AsyncResult): MessageOmaCancelSessionOutput
    /**
     * Asynchronously sends a Get Feature Setting request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_get_feature_setting_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_feature_setting(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_get_feature_setting().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_get_feature_setting().
     */
    get_feature_setting_finish(res: Gio.AsyncResult): MessageOmaGetFeatureSettingOutput
    /**
     * Asynchronously sends a Get Session Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_get_session_info_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_session_info(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_get_session_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_get_session_info().
     */
    get_session_info_finish(res: Gio.AsyncResult): MessageOmaGetSessionInfoOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessageOmaResetOutput
    /**
     * Asynchronously sends a Send Selection request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_send_selection_finish() to get the result of the operation.
     * @param input a #QmiMessageOmaSendSelectionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    send_selection(input: MessageOmaSendSelectionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_send_selection().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_send_selection().
     */
    send_selection_finish(res: Gio.AsyncResult): MessageOmaSendSelectionOutput
    /**
     * Asynchronously sends a Set Event Report request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_set_event_report_finish() to get the result of the operation.
     * @param input a #QmiMessageOmaSetEventReportInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_event_report(input: MessageOmaSetEventReportInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_set_event_report().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_set_event_report().
     */
    set_event_report_finish(res: Gio.AsyncResult): MessageOmaSetEventReportOutput
    /**
     * Asynchronously sends a Set Feature Setting request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_set_feature_setting_finish() to get the result of the operation.
     * @param input a #QmiMessageOmaSetFeatureSettingInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_feature_setting(input: MessageOmaSetFeatureSettingInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_set_feature_setting().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_set_feature_setting().
     */
    set_feature_setting_finish(res: Gio.AsyncResult): MessageOmaSetFeatureSettingOutput
    /**
     * Asynchronously sends a Start Session request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_oma_start_session_finish() to get the result of the operation.
     * @param input a #QmiMessageOmaStartSessionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    start_session(input: MessageOmaStartSessionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_oma_start_session().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_start_session().
     */
    start_session_finish(res: Gio.AsyncResult): MessageOmaStartSessionOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientOma */
    /**
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-OMA-Event-Report-indication.top_of_page">Event Report</link>' indication is received.
     * @param output A #QmiIndicationOmaEventReportOutput.
     */
    connect(sigName: "event-report", callback: (($obj: ClientOma, output: IndicationOmaEventReportOutput) => void)): number
    connect_after(sigName: "event-report", callback: (($obj: ClientOma, output: IndicationOmaEventReportOutput) => void)): number
    emit(sigName: "event-report", output: IndicationOmaEventReportOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientOma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientOma_ConstructProps)
    _init (config?: ClientOma_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientPbm_ConstructProps extends Client_ConstructProps {
}
class ClientPbm {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientPbm */
    /**
     * Asynchronously sends a Get All Capabilities request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pbm_get_all_capabilities_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_all_capabilities(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pbm_get_all_capabilities().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pbm_get_all_capabilities().
     */
    get_all_capabilities_finish(res: Gio.AsyncResult): MessagePbmGetAllCapabilitiesOutput
    /**
     * Asynchronously sends a Get Capabilities request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pbm_get_capabilities_finish() to get the result of the operation.
     * @param input a #QmiMessagePbmGetCapabilitiesInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_capabilities(input: MessagePbmGetCapabilitiesInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pbm_get_capabilities().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pbm_get_capabilities().
     */
    get_capabilities_finish(res: Gio.AsyncResult): MessagePbmGetCapabilitiesOutput
    /**
     * Asynchronously sends a Indication Register request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pbm_indication_register_finish() to get the result of the operation.
     * @param input a #QmiMessagePbmIndicationRegisterInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    indication_register(input: MessagePbmIndicationRegisterInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pbm_indication_register().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pbm_indication_register().
     */
    indication_register_finish(res: Gio.AsyncResult): MessagePbmIndicationRegisterOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientPbm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientPbm_ConstructProps)
    _init (config?: ClientPbm_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientPdc_ConstructProps extends Client_ConstructProps {
}
class ClientPdc {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientPdc */
    /**
     * Asynchronously sends a Activate Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_activate_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcActivateConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    activate_config(input: MessagePdcActivateConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_activate_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_activate_config().
     */
    activate_config_finish(res: Gio.AsyncResult): MessagePdcActivateConfigOutput
    /**
     * Asynchronously sends a Config Change request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_config_change_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcConfigChangeInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    config_change(input: MessagePdcConfigChangeInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_config_change().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_config_change().
     */
    config_change_finish(res: Gio.AsyncResult): MessagePdcConfigChangeOutput
    /**
     * Asynchronously sends a Deactivate Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_deactivate_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcDeactivateConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    deactivate_config(input: MessagePdcDeactivateConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_deactivate_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_deactivate_config().
     */
    deactivate_config_finish(res: Gio.AsyncResult): MessagePdcDeactivateConfigOutput
    /**
     * Asynchronously sends a Delete Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_delete_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcDeleteConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    delete_config(input: MessagePdcDeleteConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_delete_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_delete_config().
     */
    delete_config_finish(res: Gio.AsyncResult): MessagePdcDeleteConfigOutput
    /**
     * Asynchronously sends a Get Config Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_get_config_info_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcGetConfigInfoInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_config_info(input: MessagePdcGetConfigInfoInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_get_config_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_config_info().
     */
    get_config_info_finish(res: Gio.AsyncResult): MessagePdcGetConfigInfoOutput
    /**
     * Asynchronously sends a Get Config Limits request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_get_config_limits_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcGetConfigLimitsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_config_limits(input: MessagePdcGetConfigLimitsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_get_config_limits().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_config_limits().
     */
    get_config_limits_finish(res: Gio.AsyncResult): MessagePdcGetConfigLimitsOutput
    /**
     * Asynchronously sends a Get Default Config Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_get_default_config_info_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcGetDefaultConfigInfoInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_default_config_info(input: MessagePdcGetDefaultConfigInfoInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_get_default_config_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_default_config_info().
     */
    get_default_config_info_finish(res: Gio.AsyncResult): MessagePdcGetDefaultConfigInfoOutput
    /**
     * Asynchronously sends a Get Selected Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_get_selected_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcGetSelectedConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_selected_config(input: MessagePdcGetSelectedConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_get_selected_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_selected_config().
     */
    get_selected_config_finish(res: Gio.AsyncResult): MessagePdcGetSelectedConfigOutput
    /**
     * Asynchronously sends a List Configs request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_list_configs_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcListConfigsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    list_configs(input: MessagePdcListConfigsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_list_configs().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_list_configs().
     */
    list_configs_finish(res: Gio.AsyncResult): MessagePdcListConfigsOutput
    /**
     * Asynchronously sends a Load Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_load_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcLoadConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    load_config(input: MessagePdcLoadConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_load_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_load_config().
     */
    load_config_finish(res: Gio.AsyncResult): MessagePdcLoadConfigOutput
    /**
     * Asynchronously sends a Register request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_register_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcRegisterInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    register(input: MessagePdcRegisterInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_register().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_register().
     */
    register_finish(res: Gio.AsyncResult): MessagePdcRegisterOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessagePdcResetOutput
    /**
     * Asynchronously sends a Set Selected Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pdc_set_selected_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdcSetSelectedConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_selected_config(input: MessagePdcSetSelectedConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pdc_set_selected_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_set_selected_config().
     */
    set_selected_config_finish(res: Gio.AsyncResult): MessagePdcSetSelectedConfigOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientPdc */
    /**
     * The ::activate-config signal gets emitted when a '<link linkend="libqmi-glib-PDC-Activate-Config-indication.top_of_page">Activate Config</link>' indication is received.
     * @param output A #QmiIndicationPdcActivateConfigOutput.
     */
    connect(sigName: "activate-config", callback: (($obj: ClientPdc, output: IndicationPdcActivateConfigOutput) => void)): number
    connect_after(sigName: "activate-config", callback: (($obj: ClientPdc, output: IndicationPdcActivateConfigOutput) => void)): number
    emit(sigName: "activate-config", output: IndicationPdcActivateConfigOutput): void
    /**
     * The ::deactivate-config signal gets emitted when a '<link linkend="libqmi-glib-PDC-Deactivate-Config-indication.top_of_page">Deactivate Config</link>' indication is received.
     * @param output A #QmiIndicationPdcDeactivateConfigOutput.
     */
    connect(sigName: "deactivate-config", callback: (($obj: ClientPdc, output: IndicationPdcDeactivateConfigOutput) => void)): number
    connect_after(sigName: "deactivate-config", callback: (($obj: ClientPdc, output: IndicationPdcDeactivateConfigOutput) => void)): number
    emit(sigName: "deactivate-config", output: IndicationPdcDeactivateConfigOutput): void
    /**
     * The ::get-config-info signal gets emitted when a '<link linkend="libqmi-glib-PDC-Get-Config-Info-indication.top_of_page">Get Config Info</link>' indication is received.
     * @param output A #QmiIndicationPdcGetConfigInfoOutput.
     */
    connect(sigName: "get-config-info", callback: (($obj: ClientPdc, output: IndicationPdcGetConfigInfoOutput) => void)): number
    connect_after(sigName: "get-config-info", callback: (($obj: ClientPdc, output: IndicationPdcGetConfigInfoOutput) => void)): number
    emit(sigName: "get-config-info", output: IndicationPdcGetConfigInfoOutput): void
    /**
     * The ::get-selected-config signal gets emitted when a '<link linkend="libqmi-glib-PDC-Get-Selected-Config-indication.top_of_page">Get Selected Config</link>' indication is received.
     * @param output A #QmiIndicationPdcGetSelectedConfigOutput.
     */
    connect(sigName: "get-selected-config", callback: (($obj: ClientPdc, output: IndicationPdcGetSelectedConfigOutput) => void)): number
    connect_after(sigName: "get-selected-config", callback: (($obj: ClientPdc, output: IndicationPdcGetSelectedConfigOutput) => void)): number
    emit(sigName: "get-selected-config", output: IndicationPdcGetSelectedConfigOutput): void
    /**
     * The ::list-configs signal gets emitted when a '<link linkend="libqmi-glib-PDC-List-Configs-indication.top_of_page">List Configs</link>' indication is received.
     * @param output A #QmiIndicationPdcListConfigsOutput.
     */
    connect(sigName: "list-configs", callback: (($obj: ClientPdc, output: IndicationPdcListConfigsOutput) => void)): number
    connect_after(sigName: "list-configs", callback: (($obj: ClientPdc, output: IndicationPdcListConfigsOutput) => void)): number
    emit(sigName: "list-configs", output: IndicationPdcListConfigsOutput): void
    /**
     * The ::load-config signal gets emitted when a '<link linkend="libqmi-glib-PDC-Load-Config-indication.top_of_page">Load Config</link>' indication is received.
     * @param output A #QmiIndicationPdcLoadConfigOutput.
     */
    connect(sigName: "load-config", callback: (($obj: ClientPdc, output: IndicationPdcLoadConfigOutput) => void)): number
    connect_after(sigName: "load-config", callback: (($obj: ClientPdc, output: IndicationPdcLoadConfigOutput) => void)): number
    emit(sigName: "load-config", output: IndicationPdcLoadConfigOutput): void
    /**
     * The ::refresh signal gets emitted when a '<link linkend="libqmi-glib-PDC-Refresh-indication.top_of_page">Refresh</link>' indication is received.
     * @param output A #QmiIndicationPdcRefreshOutput.
     */
    connect(sigName: "refresh", callback: (($obj: ClientPdc, output: IndicationPdcRefreshOutput) => void)): number
    connect_after(sigName: "refresh", callback: (($obj: ClientPdc, output: IndicationPdcRefreshOutput) => void)): number
    emit(sigName: "refresh", output: IndicationPdcRefreshOutput): void
    /**
     * The ::set-selected-config signal gets emitted when a '<link linkend="libqmi-glib-PDC-Set-Selected-Config-indication.top_of_page">Set Selected Config</link>' indication is received.
     * @param output A #QmiIndicationPdcSetSelectedConfigOutput.
     */
    connect(sigName: "set-selected-config", callback: (($obj: ClientPdc, output: IndicationPdcSetSelectedConfigOutput) => void)): number
    connect_after(sigName: "set-selected-config", callback: (($obj: ClientPdc, output: IndicationPdcSetSelectedConfigOutput) => void)): number
    emit(sigName: "set-selected-config", output: IndicationPdcSetSelectedConfigOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientPdc, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientPdc_ConstructProps)
    _init (config?: ClientPdc_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientPds_ConstructProps extends Client_ConstructProps {
}
class ClientPds {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientPds */
    /**
     * Asynchronously sends a Get AGPS Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_get_agps_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdsGetAgpsConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_agps_config(input: MessagePdsGetAgpsConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_get_agps_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_agps_config().
     */
    get_agps_config_finish(res: Gio.AsyncResult): MessagePdsGetAgpsConfigOutput
    /**
     * Asynchronously sends a Get Auto Tracking State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_get_auto_tracking_state_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_auto_tracking_state(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_get_auto_tracking_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_auto_tracking_state().
     */
    get_auto_tracking_state_finish(res: Gio.AsyncResult): MessagePdsGetAutoTrackingStateOutput
    /**
     * Asynchronously sends a Get Default Tracking Session request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_get_default_tracking_session_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_default_tracking_session(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_get_default_tracking_session().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_default_tracking_session().
     */
    get_default_tracking_session_finish(res: Gio.AsyncResult): MessagePdsGetDefaultTrackingSessionOutput
    /**
     * Asynchronously sends a Get GPS Service State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_get_gps_service_state_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_gps_service_state(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_get_gps_service_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_gps_service_state().
     */
    get_gps_service_state_finish(res: Gio.AsyncResult): MessagePdsGetGpsServiceStateOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessagePdsResetOutput
    /**
     * Asynchronously sends a Set AGPS Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_set_agps_config_finish() to get the result of the operation.
     * @param input a #QmiMessagePdsSetAgpsConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_agps_config(input: MessagePdsSetAgpsConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_set_agps_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_agps_config().
     */
    set_agps_config_finish(res: Gio.AsyncResult): MessagePdsSetAgpsConfigOutput
    /**
     * Asynchronously sends a Set Auto Tracking State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_set_auto_tracking_state_finish() to get the result of the operation.
     * @param input a #QmiMessagePdsSetAutoTrackingStateInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_auto_tracking_state(input: MessagePdsSetAutoTrackingStateInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_set_auto_tracking_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_auto_tracking_state().
     */
    set_auto_tracking_state_finish(res: Gio.AsyncResult): MessagePdsSetAutoTrackingStateOutput
    /**
     * Asynchronously sends a Set Default Tracking Session request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_set_default_tracking_session_finish() to get the result of the operation.
     * @param input a #QmiMessagePdsSetDefaultTrackingSessionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_default_tracking_session(input: MessagePdsSetDefaultTrackingSessionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_set_default_tracking_session().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_default_tracking_session().
     */
    set_default_tracking_session_finish(res: Gio.AsyncResult): MessagePdsSetDefaultTrackingSessionOutput
    /**
     * Asynchronously sends a Set Event Report request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_set_event_report_finish() to get the result of the operation.
     * @param input a #QmiMessagePdsSetEventReportInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_event_report(input: MessagePdsSetEventReportInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_set_event_report().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_event_report().
     */
    set_event_report_finish(res: Gio.AsyncResult): MessagePdsSetEventReportOutput
    /**
     * Asynchronously sends a Set GPS Service State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_pds_set_gps_service_state_finish() to get the result of the operation.
     * @param input a #QmiMessagePdsSetGpsServiceStateInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_gps_service_state(input: MessagePdsSetGpsServiceStateInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_pds_set_gps_service_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_gps_service_state().
     */
    set_gps_service_state_finish(res: Gio.AsyncResult): MessagePdsSetGpsServiceStateOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientPds */
    /**
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-PDS-Event-Report-indication.top_of_page">Event Report</link>' indication is received.
     * @param output A #QmiIndicationPdsEventReportOutput.
     */
    connect(sigName: "event-report", callback: (($obj: ClientPds, output: IndicationPdsEventReportOutput) => void)): number
    connect_after(sigName: "event-report", callback: (($obj: ClientPds, output: IndicationPdsEventReportOutput) => void)): number
    emit(sigName: "event-report", output: IndicationPdsEventReportOutput): void
    /**
     * The ::gps-ready signal gets emitted when a 'GPS Ready' indication is received.
     */
    connect(sigName: "gps-ready", callback: (($obj: ClientPds) => void)): number
    connect_after(sigName: "gps-ready", callback: (($obj: ClientPds) => void)): number
    emit(sigName: "gps-ready"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientPds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientPds_ConstructProps)
    _init (config?: ClientPds_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientQos_ConstructProps extends Client_ConstructProps {
}
class ClientQos {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientQos */
    /**
     * Asynchronously sends a Get Flow Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_qos_get_flow_status_finish() to get the result of the operation.
     * @param input a #QmiMessageQosGetFlowStatusInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_flow_status(input: MessageQosGetFlowStatusInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_qos_get_flow_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_get_flow_status().
     */
    get_flow_status_finish(res: Gio.AsyncResult): MessageQosGetFlowStatusOutput
    /**
     * Asynchronously sends a Get Network Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_qos_get_network_status_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_network_status(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_qos_get_network_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_get_network_status().
     */
    get_network_status_finish(res: Gio.AsyncResult): MessageQosGetNetworkStatusOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_qos_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_qos_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessageQosResetOutput
    /**
     * Asynchronously sends a Swi Read Data Stats request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_qos_swi_read_data_stats_finish() to get the result of the operation.
     * @param input a #QmiMessageQosSwiReadDataStatsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    swi_read_data_stats(input: MessageQosSwiReadDataStatsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_qos_swi_read_data_stats().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_swi_read_data_stats().
     */
    swi_read_data_stats_finish(res: Gio.AsyncResult): MessageQosSwiReadDataStatsOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientQos */
    /**
     * The ::flow-status signal gets emitted when a '<link linkend="libqmi-glib-QOS-Flow-Status-indication.top_of_page">Flow Status</link>' indication is received.
     * @param output A #QmiIndicationQosFlowStatusOutput.
     */
    connect(sigName: "flow-status", callback: (($obj: ClientQos, output: IndicationQosFlowStatusOutput) => void)): number
    connect_after(sigName: "flow-status", callback: (($obj: ClientQos, output: IndicationQosFlowStatusOutput) => void)): number
    emit(sigName: "flow-status", output: IndicationQosFlowStatusOutput): void
    /**
     * The ::network-status signal gets emitted when a '<link linkend="libqmi-glib-QOS-Network-Status-indication.top_of_page">Network Status</link>' indication is received.
     * @param output A #QmiIndicationQosNetworkStatusOutput.
     */
    connect(sigName: "network-status", callback: (($obj: ClientQos, output: IndicationQosNetworkStatusOutput) => void)): number
    connect_after(sigName: "network-status", callback: (($obj: ClientQos, output: IndicationQosNetworkStatusOutput) => void)): number
    emit(sigName: "network-status", output: IndicationQosNetworkStatusOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientQos, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientQos_ConstructProps)
    _init (config?: ClientQos_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientSar_ConstructProps extends Client_ConstructProps {
}
class ClientSar {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientSar */
    /**
     * Asynchronously sends a RF Get State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_sar_rf_get_state_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    rf_get_state(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_sar_rf_get_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_sar_rf_get_state().
     */
    rf_get_state_finish(res: Gio.AsyncResult): MessageSarRfGetStateOutput
    /**
     * Asynchronously sends a RF Set State request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_sar_rf_set_state_finish() to get the result of the operation.
     * @param input a #QmiMessageSarRfSetStateInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    rf_set_state(input: MessageSarRfSetStateInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_sar_rf_set_state().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_sar_rf_set_state().
     */
    rf_set_state_finish(res: Gio.AsyncResult): MessageSarRfSetStateOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientSar, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientSar_ConstructProps)
    _init (config?: ClientSar_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientUim_ConstructProps extends Client_ConstructProps {
}
class ClientUim {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientUim */
    /**
     * Asynchronously sends a Change PIN request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_change_pin_finish() to get the result of the operation.
     * @param input a #QmiMessageUimChangePinInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    change_pin(input: MessageUimChangePinInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_change_pin().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_change_pin().
     */
    change_pin_finish(res: Gio.AsyncResult): MessageUimChangePinOutput
    /**
     * Asynchronously sends a Change Provisioning Session request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_change_provisioning_session_finish() to get the result of the operation.
     * @param input a #QmiMessageUimChangeProvisioningSessionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    change_provisioning_session(input: MessageUimChangeProvisioningSessionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_change_provisioning_session().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_change_provisioning_session().
     */
    change_provisioning_session_finish(res: Gio.AsyncResult): MessageUimChangeProvisioningSessionOutput
    /**
     * Asynchronously sends a Depersonalization request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_depersonalization_finish() to get the result of the operation.
     * @param input a #QmiMessageUimDepersonalizationInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    depersonalization(input: MessageUimDepersonalizationInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_depersonalization().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_depersonalization().
     */
    depersonalization_finish(res: Gio.AsyncResult): MessageUimDepersonalizationOutput
    /**
     * Asynchronously sends a Get Card Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_get_card_status_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_card_status(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_get_card_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_card_status().
     */
    get_card_status_finish(res: Gio.AsyncResult): MessageUimGetCardStatusOutput
    /**
     * Asynchronously sends a Get Configuration request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_get_configuration_finish() to get the result of the operation.
     * @param input a #QmiMessageUimGetConfigurationInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_configuration(input: MessageUimGetConfigurationInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_get_configuration().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_configuration().
     */
    get_configuration_finish(res: Gio.AsyncResult): MessageUimGetConfigurationOutput
    /**
     * Asynchronously sends a Get File Attributes request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_get_file_attributes_finish() to get the result of the operation.
     * @param input a #QmiMessageUimGetFileAttributesInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_file_attributes(input: MessageUimGetFileAttributesInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_get_file_attributes().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_file_attributes().
     */
    get_file_attributes_finish(res: Gio.AsyncResult): MessageUimGetFileAttributesOutput
    /**
     * Asynchronously sends a Get Slot Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_get_slot_status_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_slot_status(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_get_slot_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_slot_status().
     */
    get_slot_status_finish(res: Gio.AsyncResult): MessageUimGetSlotStatusOutput
    /**
     * Asynchronously sends a Get Supported Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_get_supported_messages_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_supported_messages(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_get_supported_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_supported_messages().
     */
    get_supported_messages_finish(res: Gio.AsyncResult): MessageUimGetSupportedMessagesOutput
    /**
     * Asynchronously sends a Power Off SIM request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_power_off_sim_finish() to get the result of the operation.
     * @param input a #QmiMessageUimPowerOffSimInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    power_off_sim(input: MessageUimPowerOffSimInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_power_off_sim().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_power_off_sim().
     */
    power_off_sim_finish(res: Gio.AsyncResult): MessageUimPowerOffSimOutput
    /**
     * Asynchronously sends a Power On SIM request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_power_on_sim_finish() to get the result of the operation.
     * @param input a #QmiMessageUimPowerOnSimInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    power_on_sim(input: MessageUimPowerOnSimInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_power_on_sim().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_power_on_sim().
     */
    power_on_sim_finish(res: Gio.AsyncResult): MessageUimPowerOnSimOutput
    /**
     * Asynchronously sends a Read Record request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_read_record_finish() to get the result of the operation.
     * @param input a #QmiMessageUimReadRecordInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    read_record(input: MessageUimReadRecordInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_read_record().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_read_record().
     */
    read_record_finish(res: Gio.AsyncResult): MessageUimReadRecordOutput
    /**
     * Asynchronously sends a Read Transparent request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_read_transparent_finish() to get the result of the operation.
     * @param input a #QmiMessageUimReadTransparentInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    read_transparent(input: MessageUimReadTransparentInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_read_transparent().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_read_transparent().
     */
    read_transparent_finish(res: Gio.AsyncResult): MessageUimReadTransparentOutput
    /**
     * Asynchronously sends a Refresh Complete request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_refresh_complete_finish() to get the result of the operation.
     * @param input a #QmiMessageUimRefreshCompleteInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    refresh_complete(input: MessageUimRefreshCompleteInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_refresh_complete().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_refresh_complete().
     */
    refresh_complete_finish(res: Gio.AsyncResult): MessageUimRefreshCompleteOutput
    /**
     * Asynchronously sends a Refresh Register request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_refresh_register_finish() to get the result of the operation.
     * @param input a #QmiMessageUimRefreshRegisterInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    refresh_register(input: MessageUimRefreshRegisterInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Asynchronously sends a Refresh Register All request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_refresh_register_all_finish() to get the result of the operation.
     * @param input a #QmiMessageUimRefreshRegisterAllInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    refresh_register_all(input: MessageUimRefreshRegisterAllInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_refresh_register_all().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_refresh_register_all().
     */
    refresh_register_all_finish(res: Gio.AsyncResult): MessageUimRefreshRegisterAllOutput
    /**
     * Finishes an async operation started with qmi_client_uim_refresh_register().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_refresh_register().
     */
    refresh_register_finish(res: Gio.AsyncResult): MessageUimRefreshRegisterOutput
    /**
     * Asynchronously sends a Register Events request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_register_events_finish() to get the result of the operation.
     * @param input a #QmiMessageUimRegisterEventsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    register_events(input: MessageUimRegisterEventsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_register_events().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_register_events().
     */
    register_events_finish(res: Gio.AsyncResult): MessageUimRegisterEventsOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessageUimResetOutput
    /**
     * Asynchronously sends a Set PIN Protection request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_set_pin_protection_finish() to get the result of the operation.
     * @param input a #QmiMessageUimSetPinProtectionInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_pin_protection(input: MessageUimSetPinProtectionInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_set_pin_protection().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_set_pin_protection().
     */
    set_pin_protection_finish(res: Gio.AsyncResult): MessageUimSetPinProtectionOutput
    /**
     * Asynchronously sends a Switch Slot request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_switch_slot_finish() to get the result of the operation.
     * @param input a #QmiMessageUimSwitchSlotInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    switch_slot(input: MessageUimSwitchSlotInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_switch_slot().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_switch_slot().
     */
    switch_slot_finish(res: Gio.AsyncResult): MessageUimSwitchSlotOutput
    /**
     * Asynchronously sends a Unblock PIN request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_unblock_pin_finish() to get the result of the operation.
     * @param input a #QmiMessageUimUnblockPinInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    unblock_pin(input: MessageUimUnblockPinInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_unblock_pin().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_unblock_pin().
     */
    unblock_pin_finish(res: Gio.AsyncResult): MessageUimUnblockPinOutput
    /**
     * Asynchronously sends a Verify PIN request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_uim_verify_pin_finish() to get the result of the operation.
     * @param input a #QmiMessageUimVerifyPinInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    verify_pin(input: MessageUimVerifyPinInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_uim_verify_pin().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_verify_pin().
     */
    verify_pin_finish(res: Gio.AsyncResult): MessageUimVerifyPinOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientUim */
    /**
     * The ::card-status signal gets emitted when a '<link linkend="libqmi-glib-UIM-Card-Status-indication.top_of_page">Card Status</link>' indication is received.
     * @param output A #QmiIndicationUimCardStatusOutput.
     */
    connect(sigName: "card-status", callback: (($obj: ClientUim, output: IndicationUimCardStatusOutput) => void)): number
    connect_after(sigName: "card-status", callback: (($obj: ClientUim, output: IndicationUimCardStatusOutput) => void)): number
    emit(sigName: "card-status", output: IndicationUimCardStatusOutput): void
    /**
     * The ::refresh signal gets emitted when a '<link linkend="libqmi-glib-UIM-Refresh-indication.top_of_page">Refresh</link>' indication is received.
     * @param output A #QmiIndicationUimRefreshOutput.
     */
    connect(sigName: "refresh", callback: (($obj: ClientUim, output: IndicationUimRefreshOutput) => void)): number
    connect_after(sigName: "refresh", callback: (($obj: ClientUim, output: IndicationUimRefreshOutput) => void)): number
    emit(sigName: "refresh", output: IndicationUimRefreshOutput): void
    /**
     * The ::slot-status signal gets emitted when a '<link linkend="libqmi-glib-UIM-Slot-Status-indication.top_of_page">Slot Status</link>' indication is received.
     * @param output A #QmiIndicationUimSlotStatusOutput.
     */
    connect(sigName: "slot-status", callback: (($obj: ClientUim, output: IndicationUimSlotStatusOutput) => void)): number
    connect_after(sigName: "slot-status", callback: (($obj: ClientUim, output: IndicationUimSlotStatusOutput) => void)): number
    emit(sigName: "slot-status", output: IndicationUimSlotStatusOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientUim, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientUim_ConstructProps)
    _init (config?: ClientUim_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientVoice_ConstructProps extends Client_ConstructProps {
}
class ClientVoice {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientVoice */
    /**
     * Asynchronously sends a Answer Call request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_answer_call_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceAnswerCallInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    answer_call(input: MessageVoiceAnswerCallInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_answer_call().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_answer_call().
     */
    answer_call_finish(res: Gio.AsyncResult): MessageVoiceAnswerCallOutput
    /**
     * Asynchronously sends a Answer USSD request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_answer_ussd_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceAnswerUssdInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    answer_ussd(input: MessageVoiceAnswerUssdInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_answer_ussd().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_answer_ussd().
     */
    answer_ussd_finish(res: Gio.AsyncResult): MessageVoiceAnswerUssdOutput
    /**
     * Asynchronously sends a Cancel USSD request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_cancel_ussd_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    cancel_ussd(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_cancel_ussd().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_cancel_ussd().
     */
    cancel_ussd_finish(res: Gio.AsyncResult): MessageVoiceCancelUssdOutput
    /**
     * Asynchronously sends a Dial Call request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_dial_call_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceDialCallInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    dial_call(input: MessageVoiceDialCallInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_dial_call().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_dial_call().
     */
    dial_call_finish(res: Gio.AsyncResult): MessageVoiceDialCallOutput
    /**
     * Asynchronously sends a End Call request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_end_call_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceEndCallInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    end_call(input: MessageVoiceEndCallInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_end_call().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_end_call().
     */
    end_call_finish(res: Gio.AsyncResult): MessageVoiceEndCallOutput
    /**
     * Asynchronously sends a Get All Call Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_get_all_call_info_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_all_call_info(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_get_all_call_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_all_call_info().
     */
    get_all_call_info_finish(res: Gio.AsyncResult): MessageVoiceGetAllCallInfoOutput
    /**
     * Asynchronously sends a Get Call Waiting request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_get_call_waiting_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceGetCallWaitingInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_call_waiting(input: MessageVoiceGetCallWaitingInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_get_call_waiting().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_call_waiting().
     */
    get_call_waiting_finish(res: Gio.AsyncResult): MessageVoiceGetCallWaitingOutput
    /**
     * Asynchronously sends a Get Config request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_get_config_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceGetConfigInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_config(input: MessageVoiceGetConfigInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_get_config().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_config().
     */
    get_config_finish(res: Gio.AsyncResult): MessageVoiceGetConfigOutput
    /**
     * Asynchronously sends a Get Supported Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_get_supported_messages_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_supported_messages(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_get_supported_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_supported_messages().
     */
    get_supported_messages_finish(res: Gio.AsyncResult): MessageVoiceGetSupportedMessagesOutput
    /**
     * Asynchronously sends a Indication Register request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_indication_register_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceIndicationRegisterInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    indication_register(input: MessageVoiceIndicationRegisterInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_indication_register().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_indication_register().
     */
    indication_register_finish(res: Gio.AsyncResult): MessageVoiceIndicationRegisterOutput
    /**
     * Asynchronously sends a Manage Calls request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_manage_calls_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceManageCallsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    manage_calls(input: MessageVoiceManageCallsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_manage_calls().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_manage_calls().
     */
    manage_calls_finish(res: Gio.AsyncResult): MessageVoiceManageCallsOutput
    /**
     * Asynchronously sends a Originate USSD request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_originate_ussd_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceOriginateUssdInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    originate_ussd(input: MessageVoiceOriginateUssdInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_originate_ussd().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_originate_ussd().
     */
    originate_ussd_finish(res: Gio.AsyncResult): MessageVoiceOriginateUssdOutput
    /**
     * Asynchronously sends a Originate USSD No Wait request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_originate_ussd_no_wait_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceOriginateUssdNoWaitInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    originate_ussd_no_wait(input: MessageVoiceOriginateUssdNoWaitInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_originate_ussd_no_wait().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_originate_ussd_no_wait().
     */
    originate_ussd_no_wait_finish(res: Gio.AsyncResult): MessageVoiceOriginateUssdNoWaitOutput
    /**
     * Asynchronously sends a Set Supplementary Service request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_voice_set_supplementary_service_finish() to get the result of the operation.
     * @param input a #QmiMessageVoiceSetSupplementaryServiceInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_supplementary_service(input: MessageVoiceSetSupplementaryServiceInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_voice_set_supplementary_service().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_set_supplementary_service().
     */
    set_supplementary_service_finish(res: Gio.AsyncResult): MessageVoiceSetSupplementaryServiceOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientVoice */
    /**
     * The ::all-call-status signal gets emitted when a '<link linkend="libqmi-glib-VOICE-All-Call-Status-indication.top_of_page">All Call Status</link>' indication is received.
     * @param output A #QmiIndicationVoiceAllCallStatusOutput.
     */
    connect(sigName: "all-call-status", callback: (($obj: ClientVoice, output: IndicationVoiceAllCallStatusOutput) => void)): number
    connect_after(sigName: "all-call-status", callback: (($obj: ClientVoice, output: IndicationVoiceAllCallStatusOutput) => void)): number
    emit(sigName: "all-call-status", output: IndicationVoiceAllCallStatusOutput): void
    /**
     * The ::originate-ussd-no-wait signal gets emitted when a '<link linkend="libqmi-glib-VOICE-Originate-USSD-No-Wait-indication.top_of_page">Originate USSD No Wait</link>' indication is received.
     * @param output A #QmiIndicationVoiceOriginateUssdNoWaitOutput.
     */
    connect(sigName: "originate-ussd-no-wait", callback: (($obj: ClientVoice, output: IndicationVoiceOriginateUssdNoWaitOutput) => void)): number
    connect_after(sigName: "originate-ussd-no-wait", callback: (($obj: ClientVoice, output: IndicationVoiceOriginateUssdNoWaitOutput) => void)): number
    emit(sigName: "originate-ussd-no-wait", output: IndicationVoiceOriginateUssdNoWaitOutput): void
    /**
     * The ::release-ussd signal gets emitted when a 'Release USSD' indication is received.
     */
    connect(sigName: "release-ussd", callback: (($obj: ClientVoice) => void)): number
    connect_after(sigName: "release-ussd", callback: (($obj: ClientVoice) => void)): number
    emit(sigName: "release-ussd"): void
    /**
     * The ::supplementary-service signal gets emitted when a '<link linkend="libqmi-glib-VOICE-Supplementary-Service-indication.top_of_page">Supplementary Service</link>' indication is received.
     * @param output A #QmiIndicationVoiceSupplementaryServiceOutput.
     */
    connect(sigName: "supplementary-service", callback: (($obj: ClientVoice, output: IndicationVoiceSupplementaryServiceOutput) => void)): number
    connect_after(sigName: "supplementary-service", callback: (($obj: ClientVoice, output: IndicationVoiceSupplementaryServiceOutput) => void)): number
    emit(sigName: "supplementary-service", output: IndicationVoiceSupplementaryServiceOutput): void
    /**
     * The ::ussd signal gets emitted when a '<link linkend="libqmi-glib-VOICE-USSD-indication.top_of_page">USSD</link>' indication is received.
     * @param output A #QmiIndicationVoiceUssdOutput.
     */
    connect(sigName: "ussd", callback: (($obj: ClientVoice, output: IndicationVoiceUssdOutput) => void)): number
    connect_after(sigName: "ussd", callback: (($obj: ClientVoice, output: IndicationVoiceUssdOutput) => void)): number
    emit(sigName: "ussd", output: IndicationVoiceUssdOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientVoice, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientVoice_ConstructProps)
    _init (config?: ClientVoice_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientWda_ConstructProps extends Client_ConstructProps {
}
class ClientWda {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientWda */
    /**
     * Asynchronously sends a Get Data Format request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wda_get_data_format_finish() to get the result of the operation.
     * @param input a #QmiMessageWdaGetDataFormatInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_data_format(input: MessageWdaGetDataFormatInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wda_get_data_format().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wda_get_data_format().
     */
    get_data_format_finish(res: Gio.AsyncResult): MessageWdaGetDataFormatOutput
    /**
     * Asynchronously sends a Get Supported Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wda_get_supported_messages_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_supported_messages(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wda_get_supported_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wda_get_supported_messages().
     */
    get_supported_messages_finish(res: Gio.AsyncResult): MessageWdaGetSupportedMessagesOutput
    /**
     * Asynchronously sends a Set Data Format request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wda_set_data_format_finish() to get the result of the operation.
     * @param input a #QmiMessageWdaSetDataFormatInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_data_format(input: MessageWdaSetDataFormatInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wda_set_data_format().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wda_set_data_format().
     */
    set_data_format_finish(res: Gio.AsyncResult): MessageWdaSetDataFormatOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientWda, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientWda_ConstructProps)
    _init (config?: ClientWda_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientWds_ConstructProps extends Client_ConstructProps {
}
class ClientWds {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientWds */
    /**
     * Asynchronously sends a Bind Data Port request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_bind_data_port_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsBindDataPortInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    bind_data_port(input: MessageWdsBindDataPortInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_bind_data_port().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_bind_data_port().
     */
    bind_data_port_finish(res: Gio.AsyncResult): MessageWdsBindDataPortOutput
    /**
     * Asynchronously sends a Bind Mux Data Port request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_bind_mux_data_port_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsBindMuxDataPortInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    bind_mux_data_port(input: MessageWdsBindMuxDataPortInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_bind_mux_data_port().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_bind_mux_data_port().
     */
    bind_mux_data_port_finish(res: Gio.AsyncResult): MessageWdsBindMuxDataPortOutput
    /**
     * Asynchronously sends a Create Profile request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_create_profile_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsCreateProfileInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    create_profile(input: MessageWdsCreateProfileInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_create_profile().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_create_profile().
     */
    create_profile_finish(res: Gio.AsyncResult): MessageWdsCreateProfileOutput
    /**
     * Asynchronously sends a Delete Profile request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_delete_profile_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsDeleteProfileInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    delete_profile(input: MessageWdsDeleteProfileInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_delete_profile().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_delete_profile().
     */
    delete_profile_finish(res: Gio.AsyncResult): MessageWdsDeleteProfileOutput
    /**
     * Asynchronously sends a Get Autoconnect Settings request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_autoconnect_settings_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_autoconnect_settings(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_autoconnect_settings().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_autoconnect_settings().
     */
    get_autoconnect_settings_finish(res: Gio.AsyncResult): MessageWdsGetAutoconnectSettingsOutput
    /**
     * Asynchronously sends a Get Channel Rates request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_channel_rates_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_channel_rates(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_channel_rates().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_channel_rates().
     */
    get_channel_rates_finish(res: Gio.AsyncResult): MessageWdsGetChannelRatesOutput
    /**
     * Asynchronously sends a Get Current Data Bearer Technology request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_current_data_bearer_technology_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_current_data_bearer_technology(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_current_data_bearer_technology().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_current_data_bearer_technology().
     */
    get_current_data_bearer_technology_finish(res: Gio.AsyncResult): MessageWdsGetCurrentDataBearerTechnologyOutput
    /**
     * Asynchronously sends a Get Current Settings request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_current_settings_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsGetCurrentSettingsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_current_settings(input: MessageWdsGetCurrentSettingsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_current_settings().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_current_settings().
     */
    get_current_settings_finish(res: Gio.AsyncResult): MessageWdsGetCurrentSettingsOutput
    /**
     * Asynchronously sends a Get Data Bearer Technology request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_data_bearer_technology_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_data_bearer_technology(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_data_bearer_technology().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_data_bearer_technology().
     */
    get_data_bearer_technology_finish(res: Gio.AsyncResult): MessageWdsGetDataBearerTechnologyOutput
    /**
     * Asynchronously sends a Get Default Profile Number request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_default_profile_number_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsGetDefaultProfileNumberInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_default_profile_number(input: MessageWdsGetDefaultProfileNumberInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_default_profile_number().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_default_profile_number().
     */
    get_default_profile_number_finish(res: Gio.AsyncResult): MessageWdsGetDefaultProfileNumberOutput
    /**
     * Asynchronously sends a Get Default Settings request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_default_settings_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsGetDefaultSettingsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_default_settings(input: MessageWdsGetDefaultSettingsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_default_settings().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_default_settings().
     */
    get_default_settings_finish(res: Gio.AsyncResult): MessageWdsGetDefaultSettingsOutput
    /**
     * Asynchronously sends a Get Dormancy Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_dormancy_status_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_dormancy_status(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_dormancy_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_dormancy_status().
     */
    get_dormancy_status_finish(res: Gio.AsyncResult): MessageWdsGetDormancyStatusOutput
    /**
     * Asynchronously sends a Get LTE Attach Parameters request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_lte_attach_parameters_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_lte_attach_parameters(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_lte_attach_parameters().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_lte_attach_parameters().
     */
    get_lte_attach_parameters_finish(res: Gio.AsyncResult): MessageWdsGetLteAttachParametersOutput
    /**
     * Asynchronously sends a Get LTE Attach PDN List request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_lte_attach_pdn_list_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_lte_attach_pdn_list(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_lte_attach_pdn_list().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_lte_attach_pdn_list().
     */
    get_lte_attach_pdn_list_finish(res: Gio.AsyncResult): MessageWdsGetLteAttachPdnListOutput
    /**
     * Asynchronously sends a Get Max LTE Attach PDN Number request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_max_lte_attach_pdn_number_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_max_lte_attach_pdn_number(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_max_lte_attach_pdn_number().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_max_lte_attach_pdn_number().
     */
    get_max_lte_attach_pdn_number_finish(res: Gio.AsyncResult): MessageWdsGetMaxLteAttachPdnNumberOutput
    /**
     * Asynchronously sends a Get Packet Service Status request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_packet_service_status_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_packet_service_status(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_packet_service_status().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_packet_service_status().
     */
    get_packet_service_status_finish(res: Gio.AsyncResult): MessageWdsGetPacketServiceStatusOutput
    /**
     * Asynchronously sends a Get Packet Statistics request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_packet_statistics_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsGetPacketStatisticsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_packet_statistics(input: MessageWdsGetPacketStatisticsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_packet_statistics().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_packet_statistics().
     */
    get_packet_statistics_finish(res: Gio.AsyncResult): MessageWdsGetPacketStatisticsOutput
    /**
     * Asynchronously sends a Get PDN Throttle Info request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_pdn_throttle_info_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsGetPdnThrottleInfoInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_pdn_throttle_info(input: MessageWdsGetPdnThrottleInfoInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_pdn_throttle_info().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_pdn_throttle_info().
     */
    get_pdn_throttle_info_finish(res: Gio.AsyncResult): MessageWdsGetPdnThrottleInfoOutput
    /**
     * Asynchronously sends a Get Profile List request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_profile_list_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsGetProfileListInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_profile_list(input: MessageWdsGetProfileListInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_profile_list().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_profile_list().
     */
    get_profile_list_finish(res: Gio.AsyncResult): MessageWdsGetProfileListOutput
    /**
     * Asynchronously sends a Get Profile Settings request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_profile_settings_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsGetProfileSettingsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_profile_settings(input: MessageWdsGetProfileSettingsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_profile_settings().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_profile_settings().
     */
    get_profile_settings_finish(res: Gio.AsyncResult): MessageWdsGetProfileSettingsOutput
    /**
     * Asynchronously sends a Get Supported Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_get_supported_messages_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_supported_messages(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_get_supported_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_supported_messages().
     */
    get_supported_messages_finish(res: Gio.AsyncResult): MessageWdsGetSupportedMessagesOutput
    /**
     * Asynchronously sends a Go Active request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_go_active_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    go_active(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_go_active().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_go_active().
     */
    go_active_finish(res: Gio.AsyncResult): MessageWdsGoActiveOutput
    /**
     * Asynchronously sends a Go Dormant request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_go_dormant_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    go_dormant(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_go_dormant().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_go_dormant().
     */
    go_dormant_finish(res: Gio.AsyncResult): MessageWdsGoDormantOutput
    /**
     * Asynchronously sends a Modify Profile request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_modify_profile_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsModifyProfileInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    modify_profile(input: MessageWdsModifyProfileInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_modify_profile().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_modify_profile().
     */
    modify_profile_finish(res: Gio.AsyncResult): MessageWdsModifyProfileOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessageWdsResetOutput
    /**
     * Asynchronously sends a Set Autoconnect Settings request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_set_autoconnect_settings_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsSetAutoconnectSettingsInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_autoconnect_settings(input: MessageWdsSetAutoconnectSettingsInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_set_autoconnect_settings().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_autoconnect_settings().
     */
    set_autoconnect_settings_finish(res: Gio.AsyncResult): MessageWdsSetAutoconnectSettingsOutput
    /**
     * Asynchronously sends a Set Default Profile Number request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_set_default_profile_number_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsSetDefaultProfileNumberInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_default_profile_number(input: MessageWdsSetDefaultProfileNumberInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_set_default_profile_number().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_default_profile_number().
     */
    set_default_profile_number_finish(res: Gio.AsyncResult): MessageWdsSetDefaultProfileNumberOutput
    /**
     * Asynchronously sends a Set Event Report request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_set_event_report_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsSetEventReportInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_event_report(input: MessageWdsSetEventReportInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_set_event_report().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_event_report().
     */
    set_event_report_finish(res: Gio.AsyncResult): MessageWdsSetEventReportOutput
    /**
     * Asynchronously sends a Set IP Family request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_set_ip_family_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsSetIpFamilyInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_ip_family(input: MessageWdsSetIpFamilyInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_set_ip_family().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_ip_family().
     */
    set_ip_family_finish(res: Gio.AsyncResult): MessageWdsSetIpFamilyOutput
    /**
     * Asynchronously sends a Set LTE Attach PDN List request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_set_lte_attach_pdn_list_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsSetLteAttachPdnListInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_lte_attach_pdn_list(input: MessageWdsSetLteAttachPdnListInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_set_lte_attach_pdn_list().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_lte_attach_pdn_list().
     */
    set_lte_attach_pdn_list_finish(res: Gio.AsyncResult): MessageWdsSetLteAttachPdnListOutput
    /**
     * Asynchronously sends a Start Network request to the device.
     * 
     * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
     * an abort request will be sent to the device, and the asynchronous operation will
     * not return until the abort response is received. It is not an error if a successful
     * response is returned for the asynchronous operation even after the user has cancelled
     * the cancellable, because it may happen that the response is received before the
     * modem had a chance to run the abort.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_start_network_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsStartNetworkInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    start_network(input: MessageWdsStartNetworkInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_start_network().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_start_network().
     */
    start_network_finish(res: Gio.AsyncResult): MessageWdsStartNetworkOutput
    /**
     * Asynchronously sends a Stop Network request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_stop_network_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsStopNetworkInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    stop_network(input: MessageWdsStopNetworkInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_stop_network().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_stop_network().
     */
    stop_network_finish(res: Gio.AsyncResult): MessageWdsStopNetworkOutput
    /**
     * Asynchronously sends a Swi Create Profile Indexed request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wds_swi_create_profile_indexed_finish() to get the result of the operation.
     * @param input a #QmiMessageWdsSwiCreateProfileIndexedInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    swi_create_profile_indexed(input: MessageWdsSwiCreateProfileIndexedInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wds_swi_create_profile_indexed().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_swi_create_profile_indexed().
     */
    swi_create_profile_indexed_finish(res: Gio.AsyncResult): MessageWdsSwiCreateProfileIndexedOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientWds */
    /**
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-WDS-Event-Report-indication.top_of_page">Event Report</link>' indication is received.
     * @param output A #QmiIndicationWdsEventReportOutput.
     */
    connect(sigName: "event-report", callback: (($obj: ClientWds, output: IndicationWdsEventReportOutput) => void)): number
    connect_after(sigName: "event-report", callback: (($obj: ClientWds, output: IndicationWdsEventReportOutput) => void)): number
    emit(sigName: "event-report", output: IndicationWdsEventReportOutput): void
    /**
     * The ::packet-service-status signal gets emitted when a '<link linkend="libqmi-glib-WDS-Packet-Service-Status-indication.top_of_page">Packet Service Status</link>' indication is received.
     * @param output A #QmiIndicationWdsPacketServiceStatusOutput.
     */
    connect(sigName: "packet-service-status", callback: (($obj: ClientWds, output: IndicationWdsPacketServiceStatusOutput) => void)): number
    connect_after(sigName: "packet-service-status", callback: (($obj: ClientWds, output: IndicationWdsPacketServiceStatusOutput) => void)): number
    emit(sigName: "packet-service-status", output: IndicationWdsPacketServiceStatusOutput): void
    /**
     * The ::set-lte-attach-pdn-list signal gets emitted when a '<link linkend="libqmi-glib-WDS-Set-LTE-Attach-PDN-List-indication.top_of_page">Set LTE Attach PDN List</link>' indication is received.
     * @param output A #QmiIndicationWdsSetLteAttachPdnListOutput.
     */
    connect(sigName: "set-lte-attach-pdn-list", callback: (($obj: ClientWds, output: IndicationWdsSetLteAttachPdnListOutput) => void)): number
    connect_after(sigName: "set-lte-attach-pdn-list", callback: (($obj: ClientWds, output: IndicationWdsSetLteAttachPdnListOutput) => void)): number
    emit(sigName: "set-lte-attach-pdn-list", output: IndicationWdsSetLteAttachPdnListOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientWds, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientWds_ConstructProps)
    _init (config?: ClientWds_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClientWms_ConstructProps extends Client_ConstructProps {
}
class ClientWms {
    /* Properties of Qmi-1.0.Qmi.Client */
    client_cid: number
    client_device: Device
    client_service: Service
    readonly client_valid: boolean
    client_version_major: number
    client_version_minor: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.ClientWms */
    /**
     * Asynchronously sends a Delete request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_delete_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsDeleteInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    delete(input: MessageWmsDeleteInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_delete().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_delete().
     */
    delete_finish(res: Gio.AsyncResult): MessageWmsDeleteOutput
    /**
     * Asynchronously sends a Get Message Protocol request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_get_message_protocol_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_message_protocol(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_get_message_protocol().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_get_message_protocol().
     */
    get_message_protocol_finish(res: Gio.AsyncResult): MessageWmsGetMessageProtocolOutput
    /**
     * Asynchronously sends a Get Routes request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_get_routes_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_routes(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_get_routes().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_get_routes().
     */
    get_routes_finish(res: Gio.AsyncResult): MessageWmsGetRoutesOutput
    /**
     * Asynchronously sends a Get Supported Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_get_supported_messages_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_supported_messages(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_get_supported_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_get_supported_messages().
     */
    get_supported_messages_finish(res: Gio.AsyncResult): MessageWmsGetSupportedMessagesOutput
    /**
     * Asynchronously sends a List Messages request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_list_messages_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsListMessagesInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    list_messages(input: MessageWmsListMessagesInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_list_messages().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_list_messages().
     */
    list_messages_finish(res: Gio.AsyncResult): MessageWmsListMessagesOutput
    /**
     * Asynchronously sends a Modify Tag request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_modify_tag_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsModifyTagInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    modify_tag(input: MessageWmsModifyTagInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_modify_tag().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_modify_tag().
     */
    modify_tag_finish(res: Gio.AsyncResult): MessageWmsModifyTagOutput
    /**
     * Asynchronously sends a Raw Read request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_raw_read_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsRawReadInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    raw_read(input: MessageWmsRawReadInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_raw_read().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_raw_read().
     */
    raw_read_finish(res: Gio.AsyncResult): MessageWmsRawReadOutput
    /**
     * Asynchronously sends a Raw Send request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_raw_send_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsRawSendInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    raw_send(input: MessageWmsRawSendInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_raw_send().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_raw_send().
     */
    raw_send_finish(res: Gio.AsyncResult): MessageWmsRawSendOutput
    /**
     * Asynchronously sends a Raw Write request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_raw_write_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsRawWriteInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    raw_write(input: MessageWmsRawWriteInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_raw_write().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_raw_write().
     */
    raw_write_finish(res: Gio.AsyncResult): MessageWmsRawWriteOutput
    /**
     * Asynchronously sends a Reset request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_reset_finish() to get the result of the operation.
     * @param unused %NULL. This message doesn't have any input bundle.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    reset(unused: object | null, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_reset().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_reset().
     */
    reset_finish(res: Gio.AsyncResult): MessageWmsResetOutput
    /**
     * Asynchronously sends a Send Ack request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_send_ack_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsSendAckInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    send_ack(input: MessageWmsSendAckInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_send_ack().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_send_ack().
     */
    send_ack_finish(res: Gio.AsyncResult): MessageWmsSendAckOutput
    /**
     * Asynchronously sends a Send From Memory Storage request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_send_from_memory_storage_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsSendFromMemoryStorageInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    send_from_memory_storage(input: MessageWmsSendFromMemoryStorageInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_send_from_memory_storage().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_send_from_memory_storage().
     */
    send_from_memory_storage_finish(res: Gio.AsyncResult): MessageWmsSendFromMemoryStorageOutput
    /**
     * Asynchronously sends a Set Event Report request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_set_event_report_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsSetEventReportInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_event_report(input: MessageWmsSetEventReportInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_set_event_report().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_set_event_report().
     */
    set_event_report_finish(res: Gio.AsyncResult): MessageWmsSetEventReportOutput
    /**
     * Asynchronously sends a Set Routes request to the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_client_wms_set_routes_finish() to get the result of the operation.
     * @param input a #QmiMessageWmsSetRoutesInput.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    set_routes(input: MessageWmsSetRoutesInput, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an async operation started with qmi_client_wms_set_routes().
     * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_set_routes().
     */
    set_routes_finish(res: Gio.AsyncResult): MessageWmsSetRoutesOutput
    /* Methods of Qmi-1.0.Qmi.Client */
    /**
     * Checks if the version of the service handled by this #QmiClient is greater
     * or equal than the given version.
     * @param major a major version.
     * @param minor a minor version.
     */
    check_version(major: number, minor: number): boolean
    /**
     * Get the client ID of this #QmiClient.
     */
    get_cid(): number
    /**
     * Get the #QmiDevice associated with this #QmiClient.
     */
    get_device(): GObject.Object
    /**
     * Acquire the next transaction ID of this #QmiClient.
     * The internal transaction ID gets incremented.
     */
    get_next_transaction_id(): number
    /**
     * Get the service being used by this #QmiClient.
     */
    get_service(): Service
    /**
     * Get the version of the service handled by this #QmiClient.
     * @param major placeholder for the output major version.
     * @param minor placeholder for the output minor version.
     */
    get_version(major: number, minor: number): boolean
    /**
     * Checks whether #QmiClient is a valid and usable client.
     * 
     * The client is marked as invalid as soon as the client id is released or when
     * the associated #QmiDevice is closed.
     * 
     * This method may be used if the caller needs to ensure validity before a
     * command is attempted, e.g. if the lifecycle of the object is managed in some
     * other place and the caller just has a reference to the #QmiClient.
     */
    is_valid(): boolean
    /**
     * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
     * on the returned object.
     */
    peek_device(): GObject.Object
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Qmi-1.0.Qmi.Client */
    vfunc_process_indication(message: Message): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.ClientWms */
    /**
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-WMS-Event-Report-indication.top_of_page">Event Report</link>' indication is received.
     * @param output A #QmiIndicationWmsEventReportOutput.
     */
    connect(sigName: "event-report", callback: (($obj: ClientWms, output: IndicationWmsEventReportOutput) => void)): number
    connect_after(sigName: "event-report", callback: (($obj: ClientWms, output: IndicationWmsEventReportOutput) => void)): number
    emit(sigName: "event-report", output: IndicationWmsEventReportOutput): void
    /**
     * The ::smsc-address signal gets emitted when a '<link linkend="libqmi-glib-WMS-SMSC-Address-indication.top_of_page">SMSC Address</link>' indication is received.
     * @param output A #QmiIndicationWmsSmscAddressOutput.
     */
    connect(sigName: "smsc-address", callback: (($obj: ClientWms, output: IndicationWmsSmscAddressOutput) => void)): number
    connect_after(sigName: "smsc-address", callback: (($obj: ClientWms, output: IndicationWmsSmscAddressOutput) => void)): number
    emit(sigName: "smsc-address", output: IndicationWmsSmscAddressOutput): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client-cid", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cid", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-device", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-device", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-service", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-service", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-valid", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-valid", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-major", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-major", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-version-minor", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-version-minor", callback: (($obj: ClientWms, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ClientWms_ConstructProps)
    _init (config?: ClientWms_ConstructProps): void
    static $gtype: GObject.Type
}
interface Device_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Qmi-1.0.Qmi.Device */
    device_file?: Gio.File
    device_no_file_check?: boolean
    device_proxy_path?: string
}
class Device {
    /* Properties of Qmi-1.0.Qmi.Device */
    readonly device_file: Gio.File
    readonly device_no_file_check: boolean
    readonly device_proxy_path: string
    readonly device_wwan_iface: string
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.Device */
    /**
     * Asynchronously creates a new virtual network device node with a custom prefix
     * on top of `base_ifname`. This allows having multiple net interfaces running on
     * top of another using multiplexing.
     * 
     * If the kernel driver doesn't allow this functionality, a
     * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
     * 
     * The operation may fail if the given interface name is not associated to the
     * QMI control port managed by the #QmiDevice.
     * 
     * Depending on the kernel driver in use and the multiplexing method, the given
     * `ifname_prefix` may be ignored. The user should not assume that the returned
     * link interface name is prefixed with `ifname_prefix` as it may not be the
     * case.
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_add_link_finish() to get the result of the operation.
     * 
     * <note><para>
     * When using the qmi_wwan kernel driver, the configured expected kernel data
     * format will be used to select the type of multiplexing method. If the
     * format is %QMI_DEVICE_EXPECTED_DATA_FORMAT_RAW_IP the qmi_wwan specific
     * add_mux/del_mux operations will be used. If the format is
     * %QMI_DEVICE_EXPECTED_DATA_FORMAT_QMAP_PASS_THROUGH, the generic rmnet netlink
     * operations will be used. No multiplexing support exists when the format is
     * %QMI_DEVICE_EXPECTED_DATA_FORMAT_802_3.
     * </para><para>
     * For every other kernel driver (e.g. ipa), rmnet netlink operations are
     * assumed to be supported.
     * </para></note>
     * 
     * <note><para>
     * When using the qmi_wwan driver from a kernel older than v5.12, some of the
     * multiplexing features like using %QMI_DEVICE_MUX_ID_AUTOMATIC may not be fully
     * available for programs that use ephimeral #QmiDevice objects for single
     * operations.
     * </para></note>
     * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
     * @param base_ifname the interface which the new link will be created on.
     * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
     * @param cancellable a #GCancellable, or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    add_link(mux_id: number, base_ifname: string, ifname_prefix: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_add_link().
     * @param res a #GAsyncResult.
     * @param mux_id the mux ID for the link created.
     */
    add_link_finish(res: Gio.AsyncResult, mux_id: number): string
    /**
     * Asynchronously creates a new virtual network device in the same way as
     * qmi_device_add_link() does, but passing the additional `flags` to the kernel
     * during the operation.
     * 
     * Using %QMI_DEVICE_ADD_LINK_FLAGS_NONE as `flags` is equivalent to calling
     * qmi_device_add_link() directly.
     * 
     * If the link creation with the given set of `flags` is unsupported by the
     * backend, the operation may fail.
     * 
     * <note><para>
     * None of the `flags` supported are applicable when using the multiplexing
     * support provided by the qmi_wwan kernel driver, they are only used if using
     * the rmnet backend for link management support.
     * </para></note>
     * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
     * @param base_ifname the interface which the new link will be created on.
     * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
     * @param flags bitmask of %QmiDeviceAddLinkFlags values to pass to the kernel when   creating the new link.
     * @param cancellable a #GCancellable, or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    add_link_with_flags(mux_id: number, base_ifname: string, ifname_prefix: string, flags: DeviceAddLinkFlags, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_add_link_finish().
     * @param res a #GAsyncResult.
     * @param mux_id the mux ID for the link created.
     */
    add_link_with_flags_finish(res: Gio.AsyncResult, mux_id: number): string
    /**
     * Asynchronously allocates a new #QmiClient in `self`.
     * 
     * If %QMI_CID_NONE is given in `cid,` a new client ID will be allocated;
     * otherwise a client with the given `cid` will be generated.
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_allocate_client_finish() to get the result of the operation.
     * 
     * Note: Clients for the %QMI_SERVICE_CTL cannot be created with this method;
     * instead get/peek the implicit one from `self`.
     * @param service a valid #QmiService.
     * @param cid a valid client ID, or %QMI_CID_NONE.
     * @param timeout maximum time to wait.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    allocate_client(service: Service, cid: number, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_allocate_client().
     * @param res a #GAsyncResult.
     */
    allocate_client_finish(res: Gio.AsyncResult): Client
    /**
     * Checks whether the given data format is supported by the kernel.
     * interface.
     * 
     * <note><para>
     * This method is only applicable when using the qmi_wwan kernel driver.
     * </para></note>
     * @param format a known #QmiDeviceExpectedDataFormat.
     */
    check_expected_data_format_supported(format: DeviceExpectedDataFormat): boolean
    /**
     * Checks whether link management is supported by the kernel.
     */
    check_link_supported(): boolean
    /**
     * Asynchronously closes a #QmiDevice, preventing any further I/O.
     * 
     * If this device was opened with `QMI_DEVICE_OPEN_FLAGS_MBIM,` this
     * operation will wait for the response of the underlying MBIM close
     * sequence.
     * 
     * Closing a #QmiDevice multiple times will not return an error.
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_close_finish() to get the result of the operation.
     * @param timeout maximum time, in seconds, to wait for the device to be closed.
     * @param cancellable a #GCancellable, or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    close_async(timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_close_async().
     * @param res a #GAsyncResult.
     */
    close_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes an operation started with qmi_device_command_abortable().
     * @param res a #GAsyncResult.
     */
    command_abortable_finish(res: Gio.AsyncResult): Message
    /**
     * Asynchronously sends a #QmiMessage to the device.
     * 
     * The message will be processed according to the specific `message_context`
     * given. If no `context` given, the behavior is the same as qmi_device_command().
     * 
     * If the operation is cancelled via `cancellable,` a %QMI_PROTOCOL_ERROR_ABORTED
     * error will be returned always. If the QMI method may be aborted, there is
     * no guarantee that the operation is truly aborted before the error is returned
     * so it may really happen that the operation really succeeded and the method
     * would still return %QMI_PROTOCOL_ERROR_ABORTED. In order to use abortable
     * methods and make sure the response is the correct one, use
     * qmi_device_command_abortable().
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_command_full_finish() to get the result of the operation.
     * @param message the message to send.
     * @param message_context the context of the message.
     * @param timeout maximum time, in seconds, to wait for the response.
     * @param cancellable a #GCancellable, or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    command_full(message: Message, message_context: MessageContext, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_command_full().
     * @param res a #GAsyncResult.
     */
    command_full_finish(res: Gio.AsyncResult): Message
    /**
     * Asynchronously deletes all virtual network interfaces that have been previously
     * created with qmi_device_add_link() in `base_ifname`.
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_delete_link_finish() to get the result of the operation.
     * 
     * <note><para>
     * There is no guarantee that other processes haven't created new links by the
     * time this method returns. This method should be used with caution, or in setups
     * where only one single process is expected to do QMI network interface link
     * management.
     * </para></note>
     * @param base_ifname the interface where all links are available.
     * @param cancellable a #GCancellable, or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    delete_all_links(base_ifname: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_delete_all_links().
     * @param res a #GAsyncResult.
     */
    delete_all_links_finish(res: Gio.AsyncResult): boolean
    /**
     * Asynchronously deletes a virtual network interface that has been previously
     * created with qmi_device_add_link().
     * 
     * If the kernel driver doesn't allow this functionality, a
     * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_delete_link_finish() to get the result of the operation.
     * 
     * <note><para>
     * The %QMI_DEVICE_MUX_ID_UNBOUND value may be given as `mux_id` if the user
     * can guarantee that the underlying kernel support doesn't require the
     * mux id info to delete the link. When using the qmi_wwan driver from a kernel
     * older than v5.12, a valid `mux_id` is required.
     * </para></note>
     * @param ifname the name of the link to remove.
     * @param mux_id the mux ID of the link to remove.
     * @param cancellable a #GCancellable, or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    delete_link(ifname: string, mux_id: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_delete_link().
     * @param res a #GAsyncResult.
     */
    delete_link_finish(res: Gio.AsyncResult): boolean
    /**
     * Retrieves the data format currently expected by the kernel in the network
     * interface.
     * 
     * If `QMI_DEVICE_EXPECTED_DATA_FORMAT_UNKNOWN` is returned, the user should
     * assume that 802.3 is the expected format, as that is what the qmi_wwan
     * driver expected by default before kernel 4.5.
     * 
     * <note><para>
     * This method is only applicable when using the qmi_wwan kernel driver.
     * </para></note>
     */
    get_expected_data_format(): DeviceExpectedDataFormat
    /**
     * Get the #GFile associated with this #QmiDevice.
     */
    get_file(): Gio.File
    /**
     * Get the system path of the underlying QMI device.
     */
    get_path(): string
    /**
     * Get the system path of the underlying QMI device in UTF-8.
     */
    get_path_display(): string
    /**
     * Asynchronously requests the service version information of the device.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
     * 
     * You can then call qmi_device_get_service_version_info_finish() to get the result of the operation.
     * @param timeout maximum time to wait for the method to complete, in seconds.
     * @param cancellable a #GCancellable or %NULL.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
     */
    get_service_version_info(timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_get_service_version_info().
     * @param res a #GAsyncResult.
     */
    get_service_version_info_finish(res: Gio.AsyncResult): DeviceServiceVersionInfo[]
    /**
     * Get the WWAN interface name associated with the QMI control port.
     * This value will be loaded every time it's asked for it.
     * 
     * <note><para>
     * This method is only applicable when using the qmi_wwan kernel driver.
     * </para></note>
     */
    get_wwan_iface(): string
    /**
     * Checks whether the #QmiDevice is open for I/O.
     */
    is_open(): boolean
    /**
     * Synchronously lists all virtual network interfaces that have been previously
     * created with qmi_device_add_link() in `base_ifname`.
     * @param base_ifname the base interface.
     */
    list_links(base_ifname: string): [ /* returnType */ boolean, /* out_links */ string[] ]
    /**
     * Asynchronously opens a #QmiDevice for I/O.
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_open_finish() to get the result of the operation.
     * @param flags mask of #QmiDeviceOpenFlags specifying how the device should be opened.
     * @param timeout maximum time, in seconds, to wait for the device to be opened.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    open(flags: DeviceOpenFlags, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an asynchronous open operation started with qmi_device_open().
     * @param res a #GAsyncResult.
     */
    open_finish(res: Gio.AsyncResult): boolean
    /**
     * Get the #GFile associated with this #QmiDevice, without increasing the reference count
     * on the returned object.
     */
    peek_file(): Gio.File
    /**
     * Asynchronously releases the #QmiClient from the #QmiDevice.
     * 
     * Once the #QmiClient has been released, it cannot be used any more to
     * perform operations.
     * 
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_release_client_finish() to get the result of the operation.
     * @param client the #QmiClient to release.
     * @param flags mask of #QmiDeviceReleaseClientFlags specifying how the client should be released.
     * @param timeout maximum time to wait.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    release_client(client: Client, flags: DeviceReleaseClientFlags, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_release_client().
     * 
     * Note that even if the release operation returns an error, the client should
     * anyway be considered released, and shouldn't be used afterwards.
     * @param res a #GAsyncResult.
     */
    release_client_finish(res: Gio.AsyncResult): boolean
    /**
     * Configures the data format currently expected by the kernel in the network
     * interface.
     * 
     * <note><para>
     * This method is only applicable when using the qmi_wwan kernel driver.
     * </para></note>
     * @param format a known #QmiDeviceExpectedDataFormat.
     */
    set_expected_data_format(format: DeviceExpectedDataFormat): boolean
    /**
     * Sets the instance ID of the #QmiDevice.
     * 
     * When the operation is finished `callback` will be called. You can then call
     * qmi_device_set_instance_id_finish() to get the result of the operation.
     * @param instance_id the instance ID.
     * @param timeout maximum time to wait.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the operation is finished.
     */
    set_instance_id(instance_id: number, timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with qmi_device_set_instance_id().
     * @param res a #GAsyncResult.
     * @param link_id a placeholder for the output #guint16, or %NULL if not required.
     */
    set_instance_id_finish(res: Gio.AsyncResult, link_id: number): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     * @param res a #GAsyncResult.
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     * @param res the #GAsyncResult from the callback
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Virtual methods of Qmi-1.0.Qmi.Device */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     * @param res a #GAsyncResult.
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Qmi-1.0.Qmi.Device */
    /**
     * The ::device-removed signal is emitted when an unexpected port hang-up is received.
     */
    connect(sigName: "device-removed", callback: (($obj: Device) => void)): number
    connect_after(sigName: "device-removed", callback: (($obj: Device) => void)): number
    emit(sigName: "device-removed"): void
    /**
     * The ::indication signal gets emitted when a QMI indication is received.
     * @param output A #QmiMessage.
     */
    connect(sigName: "indication", callback: (($obj: Device, output: Uint8Array) => void)): number
    connect_after(sigName: "indication", callback: (($obj: Device, output: Uint8Array) => void)): number
    emit(sigName: "indication", output: Uint8Array): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::device-file", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-file", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-no-file-check", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-no-file-check", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-proxy-path", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-proxy-path", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-wwan-iface", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-wwan-iface", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Device_ConstructProps)
    _init (config?: Device_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new_finish(res: Gio.AsyncResult): Device
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     * @param object_type a #GType supporting #GAsyncInitable.
     * @param n_parameters the number of parameters in `parameters`
     * @param parameters the parameters to use to construct the object
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the initialization is     finished
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    static $gtype: GObject.Type
}
interface Proxy_ConstructProps extends GObject.Object_ConstructProps {
}
class Proxy {
    /* Properties of Qmi-1.0.Qmi.Proxy */
    readonly qmi_proxy_n_clients: number
    /* Fields of GObject-2.0.GObject.Object */
    g_type_instance: GObject.TypeInstance
    /* Methods of Qmi-1.0.Qmi.Proxy */
    /**
     * Get the number of clients currently connected to the proxy.
     */
    get_n_clients(): number
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Proxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Proxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::qmi-proxy-n-clients", callback: (($obj: Proxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::qmi-proxy-n-clients", callback: (($obj: Proxy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Proxy_ConstructProps)
    _init (config?: Proxy_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Proxy
    static $gtype: GObject.Type
}
abstract class ClientClass {
    /* Fields of Qmi-1.0.Qmi.ClientClass */
    process_indication: (self: Client, message: Message) => void
    static name: string
}
abstract class ClientDmsClass {
    static name: string
}
abstract class ClientDpmClass {
    static name: string
}
abstract class ClientDsdClass {
    static name: string
}
abstract class ClientFoxClass {
    static name: string
}
abstract class ClientGasClass {
    static name: string
}
abstract class ClientGmsClass {
    static name: string
}
abstract class ClientLocClass {
    static name: string
}
abstract class ClientNasClass {
    static name: string
}
abstract class ClientOmaClass {
    static name: string
}
abstract class ClientPbmClass {
    static name: string
}
abstract class ClientPdcClass {
    static name: string
}
abstract class ClientPdsClass {
    static name: string
}
class ClientPrivate {
    static name: string
}
abstract class ClientQosClass {
    static name: string
}
abstract class ClientSarClass {
    static name: string
}
abstract class ClientUimClass {
    static name: string
}
abstract class ClientVoiceClass {
    static name: string
}
abstract class ClientWdaClass {
    static name: string
}
abstract class ClientWdsClass {
    static name: string
}
abstract class ClientWmsClass {
    static name: string
}
abstract class DeviceClass {
    static name: string
}
class DevicePrivate {
    static name: string
}
class DeviceServiceVersionInfo {
    /* Fields of Qmi-1.0.Qmi.DeviceServiceVersionInfo */
    /**
     * a #QmiService.
     */
    service: Service
    /**
     * major version of the service.
     */
    major_version: number
    /**
     * minor version of the service.
     */
    minor_version: number
    static name: string
}
class IndicationDmsEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationDmsEventReportOutput */
    /**
     * Get the 'Activation State' field from `self`.
     */
    get_activation_state(): [ /* returnType */ boolean, /* value_activation_state */ DmsActivationState | null ]
    /**
     * Get the 'Operating Mode' field from `self`.
     */
    get_operating_mode(): [ /* returnType */ boolean, /* value_operating_mode */ DmsOperatingMode | null ]
    /**
     * Get the 'PIN1 Status' field from `self`.
     */
    get_pin1_status(): [ /* returnType */ boolean, /* value_pin1_status_current_status */ DmsUimPinStatus | null, /* value_pin1_status_verify_retries_left */ number | null, /* value_pin1_status_unblock_retries_left */ number | null ]
    /**
     * Get the 'PIN2 Status' field from `self`.
     */
    get_pin2_status(): [ /* returnType */ boolean, /* value_pin2_status_current_status */ DmsUimPinStatus | null, /* value_pin2_status_verify_retries_left */ number | null, /* value_pin2_status_unblock_retries_left */ number | null ]
    /**
     * Get the 'Power State' field from `self`.
     */
    get_power_state(): [ /* returnType */ boolean, /* value_power_state_power_state_flags */ number | null, /* value_power_state_battery_level */ number | null ]
    /**
     * Get the 'PRL Init Notification' field from `self`.
     */
    get_prl_init_notification(): [ /* returnType */ boolean, /* value_prl_init_notification */ boolean | null ]
    /**
     * Get the 'UIM State' field from `self`.
     */
    get_uim_state(): [ /* returnType */ boolean, /* value_uim_state */ DmsUimState | null ]
    /**
     * Get the 'Wireless Disable State' field from `self`.
     */
    get_wireless_disable_state(): [ /* returnType */ boolean, /* value_wireless_disable_state */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationDmsEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocDeleteAssistanceDataOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocDeleteAssistanceDataOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocDeleteAssistanceDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocEngineStateOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocEngineStateOutput */
    /**
     * Get the 'Engine State' field from `self`.
     */
    get_engine_state(): [ /* returnType */ boolean, /* value_engine_state */ LocEngineState | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocEngineStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocFixRecurrenceTypeOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocFixRecurrenceTypeOutput */
    /**
     * Get the 'Fix Recurrence Type' field from `self`.
     */
    get_fix_recurrence_type(): [ /* returnType */ boolean, /* value_fix_recurrence_type */ LocFixRecurrenceType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocFixRecurrenceTypeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocGetEngineLockOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocGetEngineLockOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Get the 'Lock Type' field from `self`.
     */
    get_lock_type(): [ /* returnType */ boolean, /* value_lock_type */ LocLockType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocGetEngineLockOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocGetNmeaTypesOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocGetNmeaTypesOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Get the 'NMEA Types' field from `self`.
     */
    get_nmea_types(): [ /* returnType */ boolean, /* value_nmea_types */ LocNmeaType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocGetNmeaTypesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocGetOperationModeOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocGetOperationModeOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Get the 'Operation Mode' field from `self`.
     */
    get_operation_mode(): [ /* returnType */ boolean, /* value_operation_mode */ LocOperationMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocGetOperationModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocGetPredictedOrbitsDataSourceOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocGetPredictedOrbitsDataSourceOutput */
    /**
     * Get the 'Allowed Sizes' field from `self`.
     */
    get_allowed_sizes(): [ /* returnType */ boolean, /* value_allowed_sizes_max_file_size */ number | null, /* value_allowed_sizes_max_part_size */ number | null ]
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Get the 'Server List' field from `self`.
     */
    get_server_list(): [ /* returnType */ boolean, /* value_server_list */ string[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocGetPredictedOrbitsDataSourceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocGetServerOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocGetServerOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Get the 'IPv4' field from `self`.
     */
    get_ipv4(): [ /* returnType */ boolean, /* value_ipv4_ipv4_address */ number | null, /* value_ipv4_ipv4_port */ number | null ]
    /**
     * Get the 'IPv6' field from `self`.
     */
    get_ipv6(): [ /* returnType */ boolean, /* value_ipv6_ipv6_address */ number[] | null, /* value_ipv6_ipv6_port */ number | null ]
    /**
     * Get the 'Server Type' field from `self`.
     */
    get_server_type(): [ /* returnType */ boolean, /* value_server_type */ LocServerType | null ]
    /**
     * Get the 'URL' field from `self`.
     */
    get_url(): [ /* returnType */ boolean, /* value_url */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocGetServerOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocGnssSvInfoOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocGnssSvInfoOutput */
    /**
     * Get the 'Altitude Assumed' field from `self`.
     */
    get_altitude_assumed(): [ /* returnType */ boolean, /* value_altitude_assumed */ boolean | null ]
    /**
     * Get the 'List' field from `self`.
     * 
     * Version of qmi_indication_loc_gnss_sv_info_output_get_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_list(): [ /* returnType */ boolean, /* value_list_ptr */ IndicationLocGnssSvInfoOutputListElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocGnssSvInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocGnssSvInfoOutputListElement {
    /* Fields of Qmi-1.0.Qmi.IndicationLocGnssSvInfoOutputListElement */
    /**
     * a #QmiLocSatelliteValidInformation.
     */
    valid_information: LocSatelliteValidInformation
    /**
     * a #QmiLocSystem.
     */
    system: LocSystem
    /**
     * a #guint16.
     */
    gnss_satellite_id: number
    /**
     * a #QmiLocHealthStatus.
     */
    health_status: LocHealthStatus
    /**
     * a #QmiLocSatelliteStatus.
     */
    satellite_status: LocSatelliteStatus
    /**
     * a #QmiLocNavigationData.
     */
    navigation_data: LocNavigationData
    /**
     * a #gfloat.
     */
    elevation_degrees: number
    /**
     * a #gfloat.
     */
    azimuth_degrees: number
    /**
     * a #gfloat.
     */
    signal_to_noise_ratio_bhz: number
    static name: string
}
class IndicationLocInjectPredictedOrbitsDataOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocInjectPredictedOrbitsDataOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Get the 'Part Number' field from `self`.
     */
    get_part_number(): [ /* returnType */ boolean, /* value_part_number */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocInjectPredictedOrbitsDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocInjectXtraDataOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocInjectXtraDataOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Get the 'Part Number' field from `self`.
     */
    get_part_number(): [ /* returnType */ boolean, /* value_part_number */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocInjectXtraDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocNmeaOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocNmeaOutput */
    /**
     * Get the 'NMEA String' field from `self`.
     */
    get_nmea_string(): [ /* returnType */ boolean, /* value_nmea_string */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocNmeaOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocPositionReportOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocPositionReportOutput */
    /**
     * Get the 'Altitude Assumed' field from `self`.
     */
    get_altitude_assumed(): [ /* returnType */ boolean, /* value_altitude_assumed */ boolean | null ]
    /**
     * Get the 'Altitude from Ellipsoid' field from `self`.
     */
    get_altitude_from_ellipsoid(): [ /* returnType */ boolean, /* value_altitude_from_ellipsoid */ number | null ]
    /**
     * Get the 'Altitude from Sealevel' field from `self`.
     */
    get_altitude_from_sealevel(): [ /* returnType */ boolean, /* value_altitude_from_sealevel */ number | null ]
    /**
     * Get the 'DOP' field from `self`.
     */
    get_dop(): [ /* returnType */ boolean, /* value_dop_pdop */ number | null, /* value_dop_hdop */ number | null, /* value_dop_vdop */ number | null ]
    /**
     * Get the 'GPS Date Time' field from `self`.
     */
    get_gps_date_time(): [ /* returnType */ boolean, /* value_gps_date_time_gps_weeks */ number | null, /* value_gps_date_time_gps_time_of_week_milliseconds */ number | null ]
    /**
     * Get the 'Heading' field from `self`.
     */
    get_heading(): [ /* returnType */ boolean, /* value_heading */ number | null ]
    /**
     * Get the 'Heading Uncertainty' field from `self`.
     */
    get_heading_uncertainty(): [ /* returnType */ boolean, /* value_heading_uncertainty */ number | null ]
    /**
     * Get the 'Horizontal Confidence' field from `self`.
     */
    get_horizontal_confidence(): [ /* returnType */ boolean, /* value_horizontal_confidence */ number | null ]
    /**
     * Get the 'Horizontal Reliability' field from `self`.
     */
    get_horizontal_reliability(): [ /* returnType */ boolean, /* value_horizontal_reliability */ LocReliability | null ]
    /**
     * Get the 'Horizontal Speed' field from `self`.
     */
    get_horizontal_speed(): [ /* returnType */ boolean, /* value_horizontal_speed */ number | null ]
    /**
     * Get the 'Horizontal Uncertainty Circular' field from `self`.
     */
    get_horizontal_uncertainty_circular(): [ /* returnType */ boolean, /* value_horizontal_uncertainty_circular */ number | null ]
    /**
     * Get the 'Horizontal Uncertainty Elliptical Azimuth' field from `self`.
     */
    get_horizontal_uncertainty_elliptical_azimuth(): [ /* returnType */ boolean, /* value_horizontal_uncertainty_elliptical_azimuth */ number | null ]
    /**
     * Get the 'Horizontal Uncertainty Elliptical Major' field from `self`.
     */
    get_horizontal_uncertainty_elliptical_major(): [ /* returnType */ boolean, /* value_horizontal_uncertainty_elliptical_major */ number | null ]
    /**
     * Get the 'Horizontal Uncertainty Elliptical Minor' field from `self`.
     */
    get_horizontal_uncertainty_elliptical_minor(): [ /* returnType */ boolean, /* value_horizontal_uncertainty_elliptical_minor */ number | null ]
    /**
     * Get the 'Latitude' field from `self`.
     */
    get_latitude(): [ /* returnType */ boolean, /* value_latitude */ number | null ]
    /**
     * Get the 'Leap Seconds' field from `self`.
     */
    get_leap_seconds(): [ /* returnType */ boolean, /* value_leap_seconds */ number | null ]
    /**
     * Get the 'Longitude' field from `self`.
     */
    get_longitude(): [ /* returnType */ boolean, /* value_longitude */ number | null ]
    /**
     * Get the 'Magnetic Deviation' field from `self`.
     */
    get_magnetic_deviation(): [ /* returnType */ boolean, /* value_magnetic_deviation */ number | null ]
    /**
     * Get the 'Satellites Used' field from `self`.
     */
    get_satellites_used(): [ /* returnType */ boolean, /* value_satellites_used */ number[] | null ]
    /**
     * Get the 'Sensor Data Usage' field from `self`.
     */
    get_sensor_data_usage(): [ /* returnType */ boolean, /* value_sensor_data_usage */ LocSensorDataUsage | null ]
    /**
     * Get the 'Session Fix Count' field from `self`.
     */
    get_session_fix_count(): [ /* returnType */ boolean, /* value_session_fix_count */ number | null ]
    /**
     * Get the 'Session ID' field from `self`.
     */
    get_session_id(): [ /* returnType */ boolean, /* value_session_id */ number | null ]
    /**
     * Get the 'Session Status' field from `self`.
     */
    get_session_status(): [ /* returnType */ boolean, /* value_session_status */ LocSessionStatus | null ]
    /**
     * Get the 'Speed Uncertainty' field from `self`.
     */
    get_speed_uncertainty(): [ /* returnType */ boolean, /* value_speed_uncertainty */ number | null ]
    /**
     * Get the 'Technology Used' field from `self`.
     */
    get_technology_used(): [ /* returnType */ boolean, /* value_technology_used */ LocTechnologyUsed | null ]
    /**
     * Get the 'Time Source' field from `self`.
     */
    get_time_source(): [ /* returnType */ boolean, /* value_time_source */ LocTimeSource | null ]
    /**
     * Get the 'Time Uncertainty' field from `self`.
     */
    get_time_uncertainty(): [ /* returnType */ boolean, /* value_time_uncertainty */ number | null ]
    /**
     * Get the 'UTC Timestamp' field from `self`.
     */
    get_utc_timestamp(): [ /* returnType */ boolean, /* value_utc_timestamp */ number | null ]
    /**
     * Get the 'Vertical Confidence' field from `self`.
     */
    get_vertical_confidence(): [ /* returnType */ boolean, /* value_vertical_confidence */ number | null ]
    /**
     * Get the 'Vertical Reliability' field from `self`.
     */
    get_vertical_reliability(): [ /* returnType */ boolean, /* value_vertical_reliability */ number | null ]
    /**
     * Get the 'Vertical Speed' field from `self`.
     */
    get_vertical_speed(): [ /* returnType */ boolean, /* value_vertical_speed */ number | null ]
    /**
     * Get the 'Vertical Uncertainty' field from `self`.
     */
    get_vertical_uncertainty(): [ /* returnType */ boolean, /* value_vertical_uncertainty */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocPositionReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocSetEngineLockOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocSetEngineLockOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocSetEngineLockOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocSetNmeaTypesOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocSetNmeaTypesOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocSetNmeaTypesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocSetOperationModeOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocSetOperationModeOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocSetOperationModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationLocSetServerOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationLocSetServerOutput */
    /**
     * Get the 'Indication Status' field from `self`.
     */
    get_indication_status(): [ /* returnType */ boolean, /* value_indication_status */ LocIndicationStatus | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationLocSetServerOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationNasEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationNasEventReportOutput */
    /**
     * Get the 'ECIO' field from `self`.
     */
    get_ecio(): [ /* returnType */ boolean, /* value_ecio_ecio */ number | null, /* value_ecio_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'Error Rate' field from `self`.
     */
    get_error_rate(): [ /* returnType */ boolean, /* value_error_rate_rate */ number | null, /* value_error_rate_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'IO' field from `self`.
     */
    get_io(): [ /* returnType */ boolean, /* value_io */ number | null ]
    /**
     * Get the 'LTE RSRP' field from `self`.
     */
    get_lte_rsrp(): [ /* returnType */ boolean, /* value_lte_rsrp */ number | null ]
    /**
     * Get the 'LTE SNR' field from `self`.
     */
    get_lte_snr(): [ /* returnType */ boolean, /* value_lte_snr */ number | null ]
    /**
     * Get the 'Registration Reject Reason' field from `self`.
     */
    get_registration_reject_reason(): [ /* returnType */ boolean, /* value_registration_reject_reason_service_domain */ NasNetworkServiceDomain | null, /* value_registration_reject_reason_reject_cause */ number | null ]
    /**
     * Get the 'RF Band Information' field from `self`.
     * 
     * Version of qmi_indication_nas_event_report_output_get_rf_band_information() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_rf_band_information(): [ /* returnType */ boolean, /* value_rf_band_information_ptr */ IndicationNasEventReportOutputRfBandInformationElement[] | null ]
    /**
     * Get the 'RSRQ' field from `self`.
     */
    get_rsrq(): [ /* returnType */ boolean, /* value_rsrq_rsrq */ number | null, /* value_rsrq_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'RSSI' field from `self`.
     */
    get_rssi(): [ /* returnType */ boolean, /* value_rssi_rssi */ number | null, /* value_rssi_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'Signal Strength' field from `self`.
     */
    get_signal_strength(): [ /* returnType */ boolean, /* value_signal_strength_strength */ number | null, /* value_signal_strength_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'SINR' field from `self`.
     */
    get_sinr(): [ /* returnType */ boolean, /* value_sinr */ NasEvdoSinrLevel | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationNasEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationNasEventReportOutputRfBandInformationElement {
    /* Fields of Qmi-1.0.Qmi.IndicationNasEventReportOutputRfBandInformationElement */
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    /**
     * a #QmiNasActiveBand.
     */
    active_band_class: NasActiveBand
    /**
     * a #guint16.
     */
    active_channel: number
    static name: string
}
class IndicationNasNetworkRejectOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationNasNetworkRejectOutput */
    /**
     * Get the 'Closed Subscriber Group' field from `self`.
     */
    get_closed_subscriber_group(): [ /* returnType */ boolean, /* value_closed_subscriber_group */ number | null ]
    /**
     * Get the 'PLMN' field from `self`.
     */
    get_plmn(): [ /* returnType */ boolean, /* value_plmn_mcc */ number | null, /* value_plmn_mnc */ number | null, /* value_plmn_includes_pcs_digit */ boolean | null ]
    /**
     * Get the 'Radio Interface' field from `self`.
     */
    get_radio_interface(): [ /* returnType */ boolean, /* value_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'Reject Cause' field from `self`.
     */
    get_reject_cause(): [ /* returnType */ boolean, /* value_reject_cause */ NasRejectCause | null ]
    /**
     * Get the 'Service Domain' field from `self`.
     */
    get_service_domain(): [ /* returnType */ boolean, /* value_service_domain */ NasNetworkServiceDomain | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationNasNetworkRejectOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationNasNetworkTimeOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationNasNetworkTimeOutput */
    /**
     * Get the 'Daylight Savings Adjustment' field from `self`.
     */
    get_daylight_savings_adjustment(): [ /* returnType */ boolean, /* value_daylight_savings_adjustment */ NasDaylightSavingsAdjustment | null ]
    /**
     * Get the 'Radio Interface' field from `self`.
     */
    get_radio_interface(): [ /* returnType */ boolean, /* value_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'Timezone Offset' field from `self`.
     */
    get_timezone_offset(): [ /* returnType */ boolean, /* value_timezone_offset */ number | null ]
    /**
     * Get the 'Universal Time' field from `self`.
     */
    get_universal_time(): [ /* returnType */ boolean, /* value_universal_time_year */ number | null, /* value_universal_time_month */ number | null, /* value_universal_time_day */ number | null, /* value_universal_time_hour */ number | null, /* value_universal_time_minute */ number | null, /* value_universal_time_second */ number | null, /* value_universal_time_day_of_week */ NasDayOfWeek | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationNasNetworkTimeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationNasOperatorNameOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationNasOperatorNameOutput */
    /**
     * Get the 'NITZ Information' field from `self`.
     */
    get_nitz_information(): [ /* returnType */ boolean, /* value_nitz_information_name_encoding */ NasPlmnEncodingScheme | null, /* value_nitz_information_short_country_initials */ NasPlmnNameCountryInitials | null, /* value_nitz_information_long_name_spare_bits */ NasPlmnNameSpareBits | null, /* value_nitz_information_short_name_spare_bits */ NasPlmnNameSpareBits | null, /* value_nitz_information_long_name */ Uint8Array | null, /* value_nitz_information_short_name */ Uint8Array | null ]
    /**
     * Get the 'Operator PLMN List' field from `self`.
     * 
     * Version of qmi_indication_nas_operator_name_output_get_operator_plmn_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_operator_plmn_list(): [ /* returnType */ boolean, /* value_operator_plmn_list_ptr */ IndicationNasOperatorNameOutputOperatorPlmnListElement[] | null ]
    /**
     * Get the 'Operator PLMN Name' field from `self`.
     * 
     * Version of qmi_indication_nas_operator_name_output_get_operator_plmn_name() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_operator_plmn_name(): [ /* returnType */ boolean, /* value_operator_plmn_name_ptr */ IndicationNasOperatorNameOutputOperatorPlmnNameElement[] | null ]
    /**
     * Get the 'Operator String Name' field from `self`.
     */
    get_operator_string_name(): [ /* returnType */ boolean, /* value_operator_string_name */ string | null ]
    /**
     * Get the 'Service Provider Name' field from `self`.
     */
    get_service_provider_name(): [ /* returnType */ boolean, /* value_service_provider_name_name_display_condition */ NasNetworkNameDisplayCondition | null, /* value_service_provider_name_name */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationNasOperatorNameOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationNasOperatorNameOutputOperatorPlmnListElement {
    /* Fields of Qmi-1.0.Qmi.IndicationNasOperatorNameOutputOperatorPlmnListElement */
    /**
     * a string of exactly 3 characters.
     */
    mcc: string
    /**
     * a string of exactly 3 characters.
     */
    mnc: string
    /**
     * a #guint16.
     */
    lac1: number
    /**
     * a #guint16.
     */
    lac2: number
    /**
     * a #guint8.
     */
    plmn_name_record_identifier: number
    static name: string
}
class IndicationNasOperatorNameOutputOperatorPlmnNameElement {
    /* Fields of Qmi-1.0.Qmi.IndicationNasOperatorNameOutputOperatorPlmnNameElement */
    /**
     * a #QmiNasPlmnEncodingScheme.
     */
    name_encoding: NasPlmnEncodingScheme
    /**
     * a #QmiNasPlmnNameCountryInitials.
     */
    short_country_initials: NasPlmnNameCountryInitials
    /**
     * a #QmiNasPlmnNameSpareBits.
     */
    long_name_spare_bits: NasPlmnNameSpareBits
    /**
     * a #QmiNasPlmnNameSpareBits.
     */
    short_name_spare_bits: NasPlmnNameSpareBits
    /**
     * a #GArray of #guint8 elements.
     */
    long_name: object[]
    /**
     * a #GArray of #guint8 elements.
     */
    short_name: object[]
    static name: string
}
class IndicationNasServingSystemOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationNasServingSystemOutput */
    /**
     * Get the 'Call Barring Status' field from `self`.
     */
    get_call_barring_status(): [ /* returnType */ boolean, /* value_call_barring_status_cs_status */ NasCallBarringStatus | null, /* value_call_barring_status_ps_status */ NasCallBarringStatus | null ]
    /**
     * Get the 'CDMA Base Station Info' field from `self`.
     */
    get_cdma_base_station_info(): [ /* returnType */ boolean, /* value_cdma_base_station_info_base_station_id */ number | null, /* value_cdma_base_station_info_base_station_latitude */ number | null, /* value_cdma_base_station_info_base_station_longitude */ number | null ]
    /**
     * Get the 'CDMA P Rev' field from `self`.
     */
    get_cdma_p_rev(): [ /* returnType */ boolean, /* value_cdma_p_rev */ number | null ]
    /**
     * Get the 'CDMA System ID' field from `self`.
     */
    get_cdma_system_id(): [ /* returnType */ boolean, /* value_cdma_system_id_sid */ number | null, /* value_cdma_system_id_nid */ number | null ]
    /**
     * Get the 'CDMA System Info' field from `self`.
     */
    get_cdma_system_info(): [ /* returnType */ boolean, /* value_cdma_system_info_mcc */ number | null, /* value_cdma_system_info_imsi_11_12 */ number | null ]
    /**
     * Get the 'CID 3GPP' field from `self`.
     */
    get_cid_3gpp(): [ /* returnType */ boolean, /* value_cid_3gpp */ number | null ]
    /**
     * Get the 'Concurrent Service Info 3GPP2' field from `self`.
     */
    get_concurrent_service_info_3gpp2(): [ /* returnType */ boolean, /* value_concurrent_service_info_3gpp2 */ boolean | null ]
    /**
     * Get the 'Current PLMN' field from `self`.
     */
    get_current_plmn(): [ /* returnType */ boolean, /* value_current_plmn_mcc */ number | null, /* value_current_plmn_mnc */ number | null, /* value_current_plmn_description */ string | null ]
    /**
     * Get the 'Data Service Capability' field from `self`.
     */
    get_data_service_capability(): [ /* returnType */ boolean, /* value_data_service_capability */ NasDataCapability[] | null ]
    /**
     * Get the 'Daylight Saving Time Adjustment 3GPP' field from `self`.
     */
    get_daylight_saving_time_adjustment_3gpp(): [ /* returnType */ boolean, /* value_daylight_saving_time_adjustment_3gpp */ number | null ]
    /**
     * Get the 'Default Roaming Indicator' field from `self`.
     */
    get_default_roaming_indicator(): [ /* returnType */ boolean, /* value_default_roaming_indicator */ NasRoamingIndicatorStatus | null ]
    /**
     * Get the 'Detailed Service Status' field from `self`.
     */
    get_detailed_service_status(): [ /* returnType */ boolean, /* value_detailed_service_status_status */ NasServiceStatus | null, /* value_detailed_service_status_capability */ NasNetworkServiceDomain | null, /* value_detailed_service_status_hdr_status */ NasServiceStatus | null, /* value_detailed_service_status_hdr_hybrid */ boolean | null, /* value_detailed_service_status_forbidden */ boolean | null ]
    /**
     * Get the 'DTM Support' field from `self`.
     */
    get_dtm_support(): [ /* returnType */ boolean, /* value_dtm_support */ boolean | null ]
    /**
     * Get the 'HDR Personality' field from `self`.
     */
    get_hdr_personality(): [ /* returnType */ boolean, /* value_hdr_personality */ NasHdrPersonality | null ]
    /**
     * Get the 'LAC 3GPP' field from `self`.
     */
    get_lac_3gpp(): [ /* returnType */ boolean, /* value_lac_3gpp */ number | null ]
    /**
     * Get the 'LTE TAC' field from `self`.
     */
    get_lte_tac(): [ /* returnType */ boolean, /* value_lte_tac */ number | null ]
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status_mcc */ number | null, /* value_mnc_pcs_digit_include_status_mnc */ number | null, /* value_mnc_pcs_digit_include_status_includes_pcs_digit */ boolean | null ]
    /**
     * Get the 'Network Name Source' field from `self`.
     */
    get_network_name_source(): [ /* returnType */ boolean, /* value_network_name_source */ NasNetworkNameSource | null ]
    /**
     * Get the 'PLMN Name Flag 3GPP' field from `self`.
     */
    get_plmn_name_flag_3gpp(): [ /* returnType */ boolean, /* value_plmn_name_flag_3gpp */ boolean | null ]
    /**
     * Get the 'PLMN Not Changed Indication' field from `self`.
     */
    get_plmn_not_changed_indication(): [ /* returnType */ boolean, /* value_plmn_not_changed_indication */ boolean | null ]
    /**
     * Get the 'PRL Indicator 3GPP2' field from `self`.
     */
    get_prl_indicator_3gpp2(): [ /* returnType */ boolean, /* value_prl_indicator_3gpp2 */ boolean | null ]
    /**
     * Get the 'Roaming Indicator' field from `self`.
     */
    get_roaming_indicator(): [ /* returnType */ boolean, /* value_roaming_indicator */ NasRoamingIndicatorStatus | null ]
    /**
     * Get the 'Roaming Indicator List' field from `self`.
     * 
     * Version of qmi_indication_nas_serving_system_output_get_roaming_indicator_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_roaming_indicator_list(): [ /* returnType */ boolean, /* value_roaming_indicator_list_ptr */ IndicationNasServingSystemOutputRoamingIndicatorListElement[] | null ]
    /**
     * Get the 'Serving System' field from `self`.
     */
    get_serving_system(): [ /* returnType */ boolean, /* value_serving_system_registration_state */ NasRegistrationState | null, /* value_serving_system_cs_attach_state */ NasAttachState | null, /* value_serving_system_ps_attach_state */ NasAttachState | null, /* value_serving_system_selected_network */ NasNetworkType | null, /* value_serving_system_radio_interfaces */ NasRadioInterface[] | null ]
    /**
     * Get the 'Time Zone 3GPP' field from `self`.
     */
    get_time_zone_3gpp(): [ /* returnType */ boolean, /* value_time_zone_3gpp */ number | null ]
    /**
     * Get the 'Time Zone 3GPP2' field from `self`.
     */
    get_time_zone_3gpp2(): [ /* returnType */ boolean, /* value_time_zone_3gpp2_leap_seconds */ number | null, /* value_time_zone_3gpp2_local_time_offset */ number | null, /* value_time_zone_3gpp2_daylight_saving_time */ boolean | null ]
    /**
     * Get the 'UMTS Primary Scrambling Code' field from `self`.
     */
    get_umts_primary_scrambling_code(): [ /* returnType */ boolean, /* value_umts_primary_scrambling_code */ number | null ]
    /**
     * Get the 'Universal Time and Local Time Zone 3GPP' field from `self`.
     */
    get_universal_time_and_local_time_zone_3gpp(): [ /* returnType */ boolean, /* value_universal_time_and_local_time_zone_3gpp_year */ number | null, /* value_universal_time_and_local_time_zone_3gpp_month */ number | null, /* value_universal_time_and_local_time_zone_3gpp_day */ number | null, /* value_universal_time_and_local_time_zone_3gpp_hour */ number | null, /* value_universal_time_and_local_time_zone_3gpp_minute */ number | null, /* value_universal_time_and_local_time_zone_3gpp_second */ number | null, /* value_universal_time_and_local_time_zone_3gpp_time_zone */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationNasServingSystemOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationNasServingSystemOutputRoamingIndicatorListElement {
    /* Fields of Qmi-1.0.Qmi.IndicationNasServingSystemOutputRoamingIndicatorListElement */
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    /**
     * a #QmiNasRoamingIndicatorStatus.
     */
    roaming_indicator: NasRoamingIndicatorStatus
    static name: string
}
class IndicationNasSignalInfoOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationNasSignalInfoOutput */
    /**
     * Get the '5G Signal Strength' field from `self`.
     */
    get_5g_signal_strength(): [ /* returnType */ boolean, /* value_5g_signal_strength_rsrp */ number | null, /* value_5g_signal_strength_snr */ number | null ]
    /**
     * Get the '5G Signal Strength Extended' field from `self`.
     */
    get_5g_signal_strength_extended(): [ /* returnType */ boolean, /* value_5g_signal_strength_extended */ number | null ]
    /**
     * Get the 'CDMA Signal Strength' field from `self`.
     */
    get_cdma_signal_strength(): [ /* returnType */ boolean, /* value_cdma_signal_strength_rssi */ number | null, /* value_cdma_signal_strength_ecio */ number | null ]
    /**
     * Get the 'GSM Signal Strength' field from `self`.
     */
    get_gsm_signal_strength(): [ /* returnType */ boolean, /* value_gsm_signal_strength */ number | null ]
    /**
     * Get the 'HDR Signal Strength' field from `self`.
     */
    get_hdr_signal_strength(): [ /* returnType */ boolean, /* value_hdr_signal_strength_rssi */ number | null, /* value_hdr_signal_strength_ecio */ number | null, /* value_hdr_signal_strength_sinr */ NasEvdoSinrLevel | null, /* value_hdr_signal_strength_io */ number | null ]
    /**
     * Get the 'LTE Signal Strength' field from `self`.
     */
    get_lte_signal_strength(): [ /* returnType */ boolean, /* value_lte_signal_strength_rssi */ number | null, /* value_lte_signal_strength_rsrq */ number | null, /* value_lte_signal_strength_rsrp */ number | null, /* value_lte_signal_strength_snr */ number | null ]
    /**
     * Get the 'TDMA Signal Strength' field from `self`.
     */
    get_tdma_signal_strength(): [ /* returnType */ boolean, /* value_tdma_signal_strength */ number | null ]
    /**
     * Get the 'WCDMA Signal Strength' field from `self`.
     */
    get_wcdma_signal_strength(): [ /* returnType */ boolean, /* value_wcdma_signal_strength_rssi */ number | null, /* value_wcdma_signal_strength_ecio */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationNasSignalInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationNasSystemInfoOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationNasSystemInfoOutput */
    /**
     * Get the 'Additional CDMA System Info' field from `self`.
     */
    get_additional_cdma_system_info(): [ /* returnType */ boolean, /* value_additional_cdma_system_info_geo_system_index */ number | null, /* value_additional_cdma_system_info_registration_period */ number | null ]
    /**
     * Get the 'Additional GSM System Info' field from `self`.
     */
    get_additional_gsm_system_info(): [ /* returnType */ boolean, /* value_additional_gsm_system_info_geo_system_index */ number | null, /* value_additional_gsm_system_info_cell_broadcast_support */ NasCellBroadcastCapability | null ]
    /**
     * Get the 'Additional HDR System Info' field from `self`.
     */
    get_additional_hdr_system_info(): [ /* returnType */ boolean, /* value_additional_hdr_system_info_geo_system_index */ number | null ]
    /**
     * Get the 'Additional LTE System Info' field from `self`.
     */
    get_additional_lte_system_info(): [ /* returnType */ boolean, /* value_additional_lte_system_info_geo_system_index */ number | null ]
    /**
     * Get the 'Additional WCDMA System Info' field from `self`.
     */
    get_additional_wcdma_system_info(): [ /* returnType */ boolean, /* value_additional_wcdma_system_info_geo_system_index */ number | null, /* value_additional_wcdma_system_info_cell_broadcast_support */ NasCellBroadcastCapability | null ]
    /**
     * Get the 'CDMA Service Status' field from `self`.
     */
    get_cdma_service_status(): [ /* returnType */ boolean, /* value_cdma_service_status_service_status */ NasServiceStatus | null, /* value_cdma_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'CDMA System Info' field from `self`.
     */
    get_cdma_system_info(): [ /* returnType */ boolean, /* value_cdma_system_info_domain_valid */ boolean | null, /* value_cdma_system_info_domain */ NasNetworkServiceDomain | null, /* value_cdma_system_info_service_capability_valid */ boolean | null, /* value_cdma_system_info_service_capability */ NasNetworkServiceDomain | null, /* value_cdma_system_info_roaming_status_valid */ boolean | null, /* value_cdma_system_info_roaming_status */ NasRoamingStatus | null, /* value_cdma_system_info_forbidden_valid */ boolean | null, /* value_cdma_system_info_forbidden */ boolean | null, /* value_cdma_system_info_prl_match_valid */ boolean | null, /* value_cdma_system_info_prl_match */ boolean | null, /* value_cdma_system_info_p_rev_valid */ boolean | null, /* value_cdma_system_info_p_rev */ number | null, /* value_cdma_system_info_base_station_p_rev_valid */ boolean | null, /* value_cdma_system_info_base_station_p_rev */ number | null, /* value_cdma_system_info_concurrent_service_support_valid */ boolean | null, /* value_cdma_system_info_concurrent_service_support */ boolean | null, /* value_cdma_system_info_cdma_system_id_valid */ boolean | null, /* value_cdma_system_info_sid */ number | null, /* value_cdma_system_info_nid */ number | null, /* value_cdma_system_info_base_station_info_valid */ boolean | null, /* value_cdma_system_info_base_station_id */ number | null, /* value_cdma_system_info_base_station_latitude */ number | null, /* value_cdma_system_info_base_station_longitude */ number | null, /* value_cdma_system_info_packet_zone_valid */ boolean | null, /* value_cdma_system_info_packet_zone */ number | null, /* value_cdma_system_info_network_id_valid */ boolean | null, /* value_cdma_system_info_mcc */ string | null, /* value_cdma_system_info_mnc */ string | null ]
    /**
     * Get the 'DCNR restriction Info' field from `self`.
     */
    get_dcnr_restriction_info(): [ /* returnType */ boolean, /* value_dcnr_restriction_info */ boolean | null ]
    /**
     * Get the 'EUTRA with NR5G availability' field from `self`.
     */
    get_eutra_with_nr5g_availability(): [ /* returnType */ boolean, /* value_eutra_with_nr5g_availability */ boolean | null ]
    /**
     * Get the 'GSM Call Barring Status' field from `self`.
     */
    get_gsm_call_barring_status(): [ /* returnType */ boolean, /* value_gsm_call_barring_status_cs_status */ NasCallBarringStatus | null, /* value_gsm_call_barring_status_ps_status */ NasCallBarringStatus | null ]
    /**
     * Get the 'GSM Cipher Domain' field from `self`.
     */
    get_gsm_cipher_domain(): [ /* returnType */ boolean, /* value_gsm_cipher_domain */ NasNetworkServiceDomain | null ]
    /**
     * Get the 'GSM Service Status' field from `self`.
     */
    get_gsm_service_status(): [ /* returnType */ boolean, /* value_gsm_service_status_service_status */ NasServiceStatus | null, /* value_gsm_service_status_true_service_status */ NasServiceStatus | null, /* value_gsm_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'GSM System Info v2' field from `self`.
     */
    get_gsm_system_info_v2(): [ /* returnType */ boolean, /* value_gsm_system_info_v2_domain_valid */ boolean | null, /* value_gsm_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_gsm_system_info_v2_service_capability_valid */ boolean | null, /* value_gsm_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_gsm_system_info_v2_roaming_status_valid */ boolean | null, /* value_gsm_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_gsm_system_info_v2_forbidden_valid */ boolean | null, /* value_gsm_system_info_v2_forbidden */ boolean | null, /* value_gsm_system_info_v2_lac_valid */ boolean | null, /* value_gsm_system_info_v2_lac */ number | null, /* value_gsm_system_info_v2_cid_valid */ boolean | null, /* value_gsm_system_info_v2_cid */ number | null, /* value_gsm_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_gsm_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_gsm_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_gsm_system_info_v2_network_id_valid */ boolean | null, /* value_gsm_system_info_v2_mcc */ string | null, /* value_gsm_system_info_v2_mnc */ string | null, /* value_gsm_system_info_v2_egprs_support_valid */ boolean | null, /* value_gsm_system_info_v2_egprs_support */ boolean | null, /* value_gsm_system_info_v2_dtm_support_valid */ boolean | null, /* value_gsm_system_info_v2_dtm_support */ boolean | null ]
    /**
     * Get the 'HDR Service Status' field from `self`.
     */
    get_hdr_service_status(): [ /* returnType */ boolean, /* value_hdr_service_status_service_status */ NasServiceStatus | null, /* value_hdr_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'HDR System Info' field from `self`.
     */
    get_hdr_system_info(): [ /* returnType */ boolean, /* value_hdr_system_info_domain_valid */ boolean | null, /* value_hdr_system_info_domain */ NasNetworkServiceDomain | null, /* value_hdr_system_info_service_capability_valid */ boolean | null, /* value_hdr_system_info_service_capability */ NasNetworkServiceDomain | null, /* value_hdr_system_info_roaming_status_valid */ boolean | null, /* value_hdr_system_info_roaming_status */ NasRoamingStatus | null, /* value_hdr_system_info_forbidden_valid */ boolean | null, /* value_hdr_system_info_forbidden */ boolean | null, /* value_hdr_system_info_prl_match_valid */ boolean | null, /* value_hdr_system_info_prl_match */ boolean | null, /* value_hdr_system_info_personality_valid */ boolean | null, /* value_hdr_system_info_personality */ NasHdrPersonality | null, /* value_hdr_system_info_protocol_revision_valid */ boolean | null, /* value_hdr_system_info_protocol_revision */ NasHdrProtocolRevision | null, /* value_hdr_system_info_is_856_system_id_valid */ boolean | null, /* value_hdr_system_info_is_856_system_id */ string | null ]
    /**
     * Get the 'LTE eMBMS Coverage Info Support' field from `self`.
     */
    get_lte_embms_coverage_info_support(): [ /* returnType */ boolean, /* value_lte_embms_coverage_info_support */ boolean | null ]
    /**
     * Get the 'LTE Service Status' field from `self`.
     */
    get_lte_service_status(): [ /* returnType */ boolean, /* value_lte_service_status_service_status */ NasServiceStatus | null, /* value_lte_service_status_true_service_status */ NasServiceStatus | null, /* value_lte_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'LTE System Info v2' field from `self`.
     */
    get_lte_system_info_v2(): [ /* returnType */ boolean, /* value_lte_system_info_v2_domain_valid */ boolean | null, /* value_lte_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_lte_system_info_v2_service_capability_valid */ boolean | null, /* value_lte_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_lte_system_info_v2_roaming_status_valid */ boolean | null, /* value_lte_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_lte_system_info_v2_forbidden_valid */ boolean | null, /* value_lte_system_info_v2_forbidden */ boolean | null, /* value_lte_system_info_v2_lac_valid */ boolean | null, /* value_lte_system_info_v2_lac */ number | null, /* value_lte_system_info_v2_cid_valid */ boolean | null, /* value_lte_system_info_v2_cid */ number | null, /* value_lte_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_lte_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_lte_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_lte_system_info_v2_network_id_valid */ boolean | null, /* value_lte_system_info_v2_mcc */ string | null, /* value_lte_system_info_v2_mnc */ string | null, /* value_lte_system_info_v2_tac_valid */ boolean | null, /* value_lte_system_info_v2_tac */ number | null ]
    /**
     * Get the 'LTE Voice Support' field from `self`.
     */
    get_lte_voice_support(): [ /* returnType */ boolean, /* value_lte_voice_support */ boolean | null ]
    /**
     * Get the 'NR5G Service Status Info' field from `self`.
     */
    get_nr5g_service_status_info(): [ /* returnType */ boolean, /* value_nr5g_service_status_info_service_status */ NasServiceStatus | null, /* value_nr5g_service_status_info_true_service_status */ NasServiceStatus | null, /* value_nr5g_service_status_info_preferred_data_path */ boolean | null ]
    /**
     * Get the 'NR5G System Info' field from `self`.
     */
    get_nr5g_system_info(): [ /* returnType */ boolean, /* value_nr5g_system_info_domain_valid */ boolean | null, /* value_nr5g_system_info_domain */ NasNetworkServiceDomain | null, /* value_nr5g_system_info_service_capability_valid */ boolean | null, /* value_nr5g_system_info_service_capability */ NasNetworkServiceDomain | null, /* value_nr5g_system_info_roaming_status_valid */ boolean | null, /* value_nr5g_system_info_roaming_status */ NasRoamingStatus | null, /* value_nr5g_system_info_forbidden_valid */ boolean | null, /* value_nr5g_system_info_forbidden */ boolean | null, /* value_nr5g_system_info_lac_valid */ boolean | null, /* value_nr5g_system_info_lac */ number | null, /* value_nr5g_system_info_cid_valid */ boolean | null, /* value_nr5g_system_info_cid */ number | null, /* value_nr5g_system_info_registration_reject_info_valid */ boolean | null, /* value_nr5g_system_info_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_nr5g_system_info_registration_reject_cause */ number | null, /* value_nr5g_system_info_network_id_valid */ boolean | null, /* value_nr5g_system_info_mcc */ string | null, /* value_nr5g_system_info_mnc */ string | null, /* value_nr5g_system_info_tac_valid */ boolean | null, /* value_nr5g_system_info_tac */ number | null ]
    /**
     * Get the 'NR5G Tracking Area Code' field from `self`.
     */
    get_nr5g_tracking_area_code(): [ /* returnType */ boolean, /* value_nr5g_tracking_area_code */ Uint8Array | null ]
    /**
     * Get the 'PLMN Not Changed Indication' field from `self`.
     */
    get_plmn_not_changed_indication(): [ /* returnType */ boolean, /* value_plmn_not_changed_indication */ boolean | null ]
    /**
     * Get the 'SIM Reject Info' field from `self`.
     */
    get_sim_reject_info(): [ /* returnType */ boolean, /* value_sim_reject_info */ NasSimRejectState | null ]
    /**
     * Get the 'TD SCDMA Service Status' field from `self`.
     */
    get_td_scdma_service_status(): [ /* returnType */ boolean, /* value_td_scdma_service_status_service_status */ NasServiceStatus | null, /* value_td_scdma_service_status_true_service_status */ NasServiceStatus | null, /* value_td_scdma_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'TD SCMA System Info v2' field from `self`.
     */
    get_td_scma_system_info_v2(): [ /* returnType */ boolean, /* value_td_scma_system_info_v2_domain_valid */ boolean | null, /* value_td_scma_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_td_scma_system_info_v2_service_capability_valid */ boolean | null, /* value_td_scma_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_td_scma_system_info_v2_roaming_status_valid */ boolean | null, /* value_td_scma_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_td_scma_system_info_v2_forbidden_valid */ boolean | null, /* value_td_scma_system_info_v2_forbidden */ boolean | null, /* value_td_scma_system_info_v2_lac_valid */ boolean | null, /* value_td_scma_system_info_v2_lac */ number | null, /* value_td_scma_system_info_v2_cid_valid */ boolean | null, /* value_td_scma_system_info_v2_cid */ number | null, /* value_td_scma_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_td_scma_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_td_scma_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_td_scma_system_info_v2_network_id_valid */ boolean | null, /* value_td_scma_system_info_v2_mcc */ string | null, /* value_td_scma_system_info_v2_mnc */ string | null, /* value_td_scma_system_info_v2_hs_call_status_valid */ boolean | null, /* value_td_scma_system_info_v2_hs_call_status */ NasWcdmaHsService | null, /* value_td_scma_system_info_v2_hs_service_valid */ boolean | null, /* value_td_scma_system_info_v2_hs_service */ NasWcdmaHsService | null, /* value_td_scma_system_info_v2_cell_parameter_id_valid */ boolean | null, /* value_td_scma_system_info_v2_cell_parameter_id */ number | null, /* value_td_scma_system_info_v2_cell_broadcast_support_valid */ boolean | null, /* value_td_scma_system_info_v2_cell_broadcast_support */ NasCellBroadcastCapability | null, /* value_td_scma_system_info_v2_cs_call_barring_status_valid */ boolean | null, /* value_td_scma_system_info_v2_cs_call_barring_status */ NasCallBarringStatus | null, /* value_td_scma_system_info_v2_ps_call_barring_status_valid */ boolean | null, /* value_td_scma_system_info_v2_ps_call_barring_status */ NasCallBarringStatus | null, /* value_td_scma_system_info_v2_cipher_domain_valid */ boolean | null, /* value_td_scma_system_info_v2_cipher_domain */ NasNetworkServiceDomain | null ]
    /**
     * Get the 'WCDMA Call Barring Status' field from `self`.
     */
    get_wcdma_call_barring_status(): [ /* returnType */ boolean, /* value_wcdma_call_barring_status_cs_status */ NasCallBarringStatus | null, /* value_wcdma_call_barring_status_ps_status */ NasCallBarringStatus | null ]
    /**
     * Get the 'WCDMA Cipher Domain' field from `self`.
     */
    get_wcdma_cipher_domain(): [ /* returnType */ boolean, /* value_wcdma_cipher_domain */ NasNetworkServiceDomain | null ]
    /**
     * Get the 'WCDMA Service Status' field from `self`.
     */
    get_wcdma_service_status(): [ /* returnType */ boolean, /* value_wcdma_service_status_service_status */ NasServiceStatus | null, /* value_wcdma_service_status_true_service_status */ NasServiceStatus | null, /* value_wcdma_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'WCDMA System Info v2' field from `self`.
     */
    get_wcdma_system_info_v2(): [ /* returnType */ boolean, /* value_wcdma_system_info_v2_domain_valid */ boolean | null, /* value_wcdma_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_wcdma_system_info_v2_service_capability_valid */ boolean | null, /* value_wcdma_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_wcdma_system_info_v2_roaming_status_valid */ boolean | null, /* value_wcdma_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_wcdma_system_info_v2_forbidden_valid */ boolean | null, /* value_wcdma_system_info_v2_forbidden */ boolean | null, /* value_wcdma_system_info_v2_lac_valid */ boolean | null, /* value_wcdma_system_info_v2_lac */ number | null, /* value_wcdma_system_info_v2_cid_valid */ boolean | null, /* value_wcdma_system_info_v2_cid */ number | null, /* value_wcdma_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_wcdma_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_wcdma_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_wcdma_system_info_v2_network_id_valid */ boolean | null, /* value_wcdma_system_info_v2_mcc */ string | null, /* value_wcdma_system_info_v2_mnc */ string | null, /* value_wcdma_system_info_v2_hs_call_status_valid */ boolean | null, /* value_wcdma_system_info_v2_hs_call_status */ NasWcdmaHsService | null, /* value_wcdma_system_info_v2_hs_service_valid */ boolean | null, /* value_wcdma_system_info_v2_hs_service */ NasWcdmaHsService | null, /* value_wcdma_system_info_v2_primary_scrambling_code_valid */ boolean | null, /* value_wcdma_system_info_v2_primary_scrambling_code */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationNasSystemInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationOmaEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationOmaEventReportOutput */
    /**
     * Get the 'Network Initiated Alert' field from `self`.
     */
    get_network_initiated_alert(): [ /* returnType */ boolean, /* value_network_initiated_alert_session_type */ OmaSessionType | null, /* value_network_initiated_alert_session_id */ number | null ]
    /**
     * Get the 'Session Fail Reason' field from `self`.
     */
    get_session_fail_reason(): [ /* returnType */ boolean, /* value_session_fail_reason */ OmaSessionFailedReason | null ]
    /**
     * Get the 'Session State' field from `self`.
     */
    get_session_state(): [ /* returnType */ boolean, /* value_session_state */ OmaSessionState | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationOmaEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcActivateConfigOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcActivateConfigOutput */
    /**
     * Get the 'Indication Result' field from `self`.
     */
    get_indication_result(): [ /* returnType */ boolean, /* value_indication_result */ number | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcActivateConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcDeactivateConfigOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcDeactivateConfigOutput */
    /**
     * Get the 'Indication Result' field from `self`.
     */
    get_indication_result(): [ /* returnType */ boolean, /* value_indication_result */ number | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcDeactivateConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcGetConfigInfoOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcGetConfigInfoOutput */
    /**
     * Get the 'Description' field from `self`.
     */
    get_description(): [ /* returnType */ boolean, /* value_description */ string | null ]
    /**
     * Get the 'Indication Result' field from `self`.
     */
    get_indication_result(): [ /* returnType */ boolean, /* value_indication_result */ number | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Get the 'Total Size' field from `self`.
     */
    get_total_size(): [ /* returnType */ boolean, /* value_total_size */ number | null ]
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcGetConfigInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcGetSelectedConfigOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcGetSelectedConfigOutput */
    /**
     * Get the 'Active Id' field from `self`.
     */
    get_active_id(): [ /* returnType */ boolean, /* value_active_id */ Uint8Array | null ]
    /**
     * Get the 'Indication Result' field from `self`.
     */
    get_indication_result(): [ /* returnType */ boolean, /* value_indication_result */ number | null ]
    /**
     * Get the 'Pending Id' field from `self`.
     */
    get_pending_id(): [ /* returnType */ boolean, /* value_pending_id */ Uint8Array | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcGetSelectedConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcListConfigsOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcListConfigsOutput */
    /**
     * Get the 'Configs' field from `self`.
     * 
     * Version of qmi_indication_pdc_list_configs_output_get_configs() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_configs(): [ /* returnType */ boolean, /* value_configs_ptr */ IndicationPdcListConfigsOutputConfigsElement[] | null ]
    /**
     * Get the 'Indication Result' field from `self`.
     */
    get_indication_result(): [ /* returnType */ boolean, /* value_indication_result */ number | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcListConfigsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcListConfigsOutputConfigsElement {
    /* Fields of Qmi-1.0.Qmi.IndicationPdcListConfigsOutputConfigsElement */
    /**
     * a #QmiPdcConfigurationType.
     */
    config_type: PdcConfigurationType
    /**
     * a #GArray of #guint8 elements.
     */
    id: object[]
    static name: string
}
class IndicationPdcLoadConfigOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcLoadConfigOutput */
    /**
     * Get the 'Frame Reset' field from `self`.
     */
    get_frame_reset(): [ /* returnType */ boolean, /* value_frame_reset */ boolean | null ]
    /**
     * Get the 'Indication Result' field from `self`.
     */
    get_indication_result(): [ /* returnType */ boolean, /* value_indication_result */ number | null ]
    /**
     * Get the 'Received' field from `self`.
     */
    get_received(): [ /* returnType */ boolean, /* value_received */ number | null ]
    /**
     * Get the 'Remaining Size' field from `self`.
     */
    get_remaining_size(): [ /* returnType */ boolean, /* value_remaining_size */ number | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcLoadConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcRefreshOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcRefreshOutput */
    /**
     * Get the 'Refresh Event' field from `self`.
     */
    get_refresh_event(): [ /* returnType */ boolean, /* value_refresh_event */ PdcRefreshEventType | null ]
    /**
     * Get the 'Slot ID' field from `self`.
     */
    get_slot_id(): [ /* returnType */ boolean, /* value_slot_id */ number | null ]
    /**
     * Get the 'Subscription ID' field from `self`.
     */
    get_subscription_id(): [ /* returnType */ boolean, /* value_subscription_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcRefreshOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdcSetSelectedConfigOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdcSetSelectedConfigOutput */
    /**
     * Get the 'Indication Result' field from `self`.
     */
    get_indication_result(): [ /* returnType */ boolean, /* value_indication_result */ number | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdcSetSelectedConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationPdsEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationPdsEventReportOutput */
    /**
     * Get the 'Extended NMEA Position' field from `self`.
     */
    get_extended_nmea_position(): [ /* returnType */ boolean, /* value_extended_nmea_position_operation_mode */ PdsOperationMode | null, /* value_extended_nmea_position_nmea */ string | null ]
    /**
     * Get the 'NMEA Position' field from `self`.
     */
    get_nmea_position(): [ /* returnType */ boolean, /* value_nmea_position */ string | null ]
    /**
     * Get the 'Position Session Status' field from `self`.
     */
    get_position_session_status(): [ /* returnType */ boolean, /* value_position_session_status */ PdsPositionSessionStatus | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationPdsEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationQosFlowStatusOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationQosFlowStatusOutput */
    /**
     * Get the 'Value' field from `self`.
     */
    get_value(): [ /* returnType */ boolean, /* value_value_qos_id */ number | null, /* value_value_status */ QosStatus | null, /* value_value_event */ QosEvent | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationQosFlowStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationQosNetworkStatusOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationQosNetworkStatusOutput */
    /**
     * Get the 'QoS Supported' field from `self`.
     */
    get_qos_supported(): [ /* returnType */ boolean, /* value_qos_supported */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationQosNetworkStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationUimCardStatusOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationUimCardStatusOutput */
    /**
     * Get the 'Card Status' field from `self`.
     * 
     * Version of qmi_indication_uim_card_status_output_get_card_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_card_status(): [ /* returnType */ boolean, /* value_card_status_index_gw_primary */ number | null, /* value_card_status_index_1x_primary */ number | null, /* value_card_status_index_gw_secondary */ number | null, /* value_card_status_index_1x_secondary */ number | null, /* value_card_status_cards_ptr */ IndicationUimCardStatusOutputCardStatusCardsElementGir[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationUimCardStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationUimCardStatusOutputCardStatusCardsElement {
    /* Fields of Qmi-1.0.Qmi.IndicationUimCardStatusOutputCardStatusCardsElement */
    /**
     * a #QmiUimCardState.
     */
    card_state: UimCardState
    /**
     * a #QmiUimPinState.
     */
    upin_state: UimPinState
    /**
     * a #guint8.
     */
    upin_retries: number
    /**
     * a #guint8.
     */
    upuk_retries: number
    /**
     * a #QmiUimCardError.
     */
    error_code: UimCardError
    /**
     * a #GArray of #QmiIndicationUimCardStatusOutputCardStatusCardsElementApplicationsElement elements.
     */
    applications: object[]
    static name: string
}
class IndicationUimCardStatusOutputCardStatusCardsElementApplicationsElement {
    /* Fields of Qmi-1.0.Qmi.IndicationUimCardStatusOutputCardStatusCardsElementApplicationsElement */
    /**
     * a #QmiUimCardApplicationType.
     */
    type: UimCardApplicationType
    /**
     * a #QmiUimCardApplicationState.
     */
    state: UimCardApplicationState
    /**
     * a #QmiUimCardApplicationPersonalizationState.
     */
    personalization_state: UimCardApplicationPersonalizationState
    /**
     * a #QmiUimCardApplicationPersonalizationFeature.
     */
    personalization_feature: UimCardApplicationPersonalizationFeature
    /**
     * a #guint8.
     */
    personalization_retries: number
    /**
     * a #guint8.
     */
    personalization_unblock_retries: number
    /**
     * a #GArray of #guint8 elements.
     */
    application_identifier_value: object[]
    /**
     * a #gboolean.
     */
    upin_replaces_pin1: boolean
    /**
     * a #QmiUimPinState.
     */
    pin1_state: UimPinState
    /**
     * a #guint8.
     */
    pin1_retries: number
    /**
     * a #guint8.
     */
    puk1_retries: number
    /**
     * a #QmiUimPinState.
     */
    pin2_state: UimPinState
    /**
     * a #guint8.
     */
    pin2_retries: number
    /**
     * a #guint8.
     */
    puk2_retries: number
    static name: string
}
class IndicationUimCardStatusOutputCardStatusCardsElementGir {
    /* Fields of Qmi-1.0.Qmi.IndicationUimCardStatusOutputCardStatusCardsElementGir */
    /**
     * a #QmiUimCardState.
     */
    card_state: UimCardState
    /**
     * a #QmiUimPinState.
     */
    upin_state: UimPinState
    /**
     * a #guint8.
     */
    upin_retries: number
    /**
     * a #guint8.
     */
    upuk_retries: number
    /**
     * a #QmiUimCardError.
     */
    error_code: UimCardError
    /**
     * an array of #QmiIndicationUimCardStatusOutputCardStatusCardsElementApplicationsElement elements.
     */
    applications: IndicationUimCardStatusOutputCardStatusCardsElementApplicationsElement[]
    static name: string
}
class IndicationUimRefreshOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationUimRefreshOutput */
    /**
     * Get the 'Event' field from `self`.
     * 
     * Version of qmi_indication_uim_refresh_output_get_event() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_event(): [ /* returnType */ boolean, /* value_event_stage */ UimRefreshStage | null, /* value_event_mode */ UimRefreshMode | null, /* value_event_session_type */ UimSessionType | null, /* value_event_application_identifier */ Uint8Array | null, /* value_event_files_ptr */ IndicationUimRefreshOutputEventFilesElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationUimRefreshOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationUimRefreshOutputEventFilesElement {
    /* Fields of Qmi-1.0.Qmi.IndicationUimRefreshOutputEventFilesElement */
    /**
     * a #guint16.
     */
    file_id: number
    /**
     * a #GArray of #guint8 elements.
     */
    path: object[]
    static name: string
}
class IndicationUimSlotStatusOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationUimSlotStatusOutput */
    get_compat_context(): object | null
    /**
     * Get the 'Physical Slot Information' field from `self`.
     * 
     * Version of qmi_indication_uim_slot_status_output_get_physical_slot_information() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_physical_slot_information(): [ /* returnType */ boolean, /* value_physical_slot_information_ptr */ PhysicalSlotInformationSlot[] | null ]
    /**
     * Get the 'Physical Slot Status' field from `self`.
     * 
     * Version of qmi_indication_uim_slot_status_output_get_physical_slot_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_physical_slot_status(): [ /* returnType */ boolean, /* value_physical_slot_status_ptr */ PhysicalSlotStatusSlot[] | null ]
    /**
     * Get the 'Slot EID' field from `self`.
     * 
     * Version of qmi_indication_uim_slot_status_output_get_slot_eid() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_slot_eid(): [ /* returnType */ boolean, /* value_slot_eid_ptr */ SlotEidElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationUimSlotStatusOutput
    set_compat_context(compat_context: object | null, compat_context_free: GLib.DestroyNotify): void
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationVoiceAllCallStatusOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationVoiceAllCallStatusOutput */
    /**
     * Get the 'Call Information' field from `self`.
     * 
     * Version of qmi_indication_voice_all_call_status_output_get_call_information() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_call_information(): [ /* returnType */ boolean, /* value_call_information_ptr */ IndicationVoiceAllCallStatusOutputCallInformationCall[] | null ]
    /**
     * Get the 'Remote Party Number' field from `self`.
     * 
     * Version of qmi_indication_voice_all_call_status_output_get_remote_party_number() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_remote_party_number(): [ /* returnType */ boolean, /* value_remote_party_number_ptr */ IndicationVoiceAllCallStatusOutputRemotePartyNumberCall[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationVoiceAllCallStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationVoiceAllCallStatusOutputCallInformationCall {
    /* Fields of Qmi-1.0.Qmi.IndicationVoiceAllCallStatusOutputCallInformationCall */
    /**
     * a #guint8.
     */
    id: number
    /**
     * a #QmiVoiceCallState.
     */
    state: VoiceCallState
    /**
     * a #QmiVoiceCallType.
     */
    type: VoiceCallType
    /**
     * a #QmiVoiceCallDirection.
     */
    direction: VoiceCallDirection
    /**
     * a #QmiVoiceCallMode.
     */
    mode: VoiceCallMode
    /**
     * a #gboolean.
     */
    multipart_indicator: boolean
    /**
     * a #QmiVoiceAls.
     */
    als: VoiceAls
    static name: string
}
class IndicationVoiceAllCallStatusOutputRemotePartyNumberCall {
    /* Fields of Qmi-1.0.Qmi.IndicationVoiceAllCallStatusOutputRemotePartyNumberCall */
    /**
     * a #guint8.
     */
    id: number
    /**
     * a #QmiVoicePresentation.
     */
    presentation_indicator: VoicePresentation
    /**
     * a string.
     */
    type: string
    static name: string
}
class IndicationVoiceOriginateUssdNoWaitOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationVoiceOriginateUssdNoWaitOutput */
    /**
     * Get the 'Alpha Identifier' field from `self`.
     */
    get_alpha_identifier(): [ /* returnType */ boolean, /* value_alpha_identifier_data_coding_scheme */ VoiceAlphaDataCodingScheme | null, /* value_alpha_identifier_alpha */ Uint8Array | null ]
    /**
     * Get the 'Error Code' field from `self`.
     */
    get_error_code(): [ /* returnType */ boolean, /* value_error_code */ number | null ]
    /**
     * Get the 'Failure Cause' field from `self`.
     */
    get_failure_cause(): [ /* returnType */ boolean, /* value_failure_cause */ VoiceCallEndReason | null ]
    /**
     * Get the 'USS Data' field from `self`.
     */
    get_uss_data(): [ /* returnType */ boolean, /* value_uss_data_data_coding_scheme */ VoiceUssDataCodingScheme | null, /* value_uss_data_data */ Uint8Array | null ]
    /**
     * Get the 'USS Data UTF16' field from `self`.
     */
    get_uss_data_utf16(): [ /* returnType */ boolean, /* value_uss_data_utf16 */ number[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationVoiceOriginateUssdNoWaitOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationVoiceSupplementaryServiceOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationVoiceSupplementaryServiceOutput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_call_id */ number | null, /* value_info_notification_type */ VoiceSupplementaryServiceNotificationType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationVoiceSupplementaryServiceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationVoiceUssdOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationVoiceUssdOutput */
    /**
     * Get the 'User Action' field from `self`.
     */
    get_user_action(): [ /* returnType */ boolean, /* value_user_action */ VoiceUserAction | null ]
    /**
     * Get the 'USS Data' field from `self`.
     */
    get_uss_data(): [ /* returnType */ boolean, /* value_uss_data_data_coding_scheme */ VoiceUssDataCodingScheme | null, /* value_uss_data_data */ Uint8Array | null ]
    /**
     * Get the 'USS Data UTF16' field from `self`.
     */
    get_uss_data_utf16(): [ /* returnType */ boolean, /* value_uss_data_utf16 */ number[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationVoiceUssdOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationWdsEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationWdsEventReportOutput */
    /**
     * Get the 'Channel Rates' field from `self`.
     */
    get_channel_rates(): [ /* returnType */ boolean, /* value_channel_rates_tx_rate_bps */ number | null, /* value_channel_rates_rx_rate_bps */ number | null ]
    /**
     * Get the 'Current Data Bearer Technology' field from `self`.
     */
    get_current_data_bearer_technology(): [ /* returnType */ boolean, /* value_current_data_bearer_technology_network_type */ WdsNetworkType | null, /* value_current_data_bearer_technology_rat_mask */ number | null, /* value_current_data_bearer_technology_so_mask */ number | null ]
    /**
     * Get the 'Data Bearer Technology' field from `self`.
     */
    get_data_bearer_technology(): [ /* returnType */ boolean, /* value_data_bearer_technology */ WdsDataBearerTechnology | null ]
    /**
     * Get the 'Data Call Address Family' field from `self`.
     */
    get_data_call_address_family(): [ /* returnType */ boolean, /* value_data_call_address_family */ WdsIpFamily | null ]
    /**
     * Get the 'Data Call Status' field from `self`.
     */
    get_data_call_status(): [ /* returnType */ boolean, /* value_data_call_status */ WdsDataCallStatus | null ]
    /**
     * Get the 'Data Call Type' field from `self`.
     */
    get_data_call_type(): [ /* returnType */ boolean, /* value_data_call_type_data_call_type */ WdsDataCallType | null, /* value_data_call_type_tethered_call_type */ WdsTetheredCallType | null ]
    /**
     * Get the 'Data Systems' field from `self`.
     * 
     * Version of qmi_indication_wds_event_report_output_get_data_systems() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_data_systems(): [ /* returnType */ boolean, /* value_data_systems_preferred_network_type */ WdsDataSystemNetworkType | null, /* value_data_systems_networks_ptr */ IndicationWdsEventReportOutputDataSystemsNetworksNetwork[] | null ]
    /**
     * Get the 'Dormancy Status' field from `self`.
     */
    get_dormancy_status(): [ /* returnType */ boolean, /* value_dormancy_status */ WdsDormancyStatus | null ]
    /**
     * Get the 'EVDO Page Monitor Period Change' field from `self`.
     */
    get_evdo_page_monitor_period_change(): [ /* returnType */ boolean, /* value_evdo_page_monitor_period_change_period_change */ number | null, /* value_evdo_page_monitor_period_change_force_long_sleep */ boolean | null ]
    /**
     * Get the 'Extended Data Bearer Technology' field from `self`.
     */
    get_extended_data_bearer_technology(): [ /* returnType */ boolean, /* value_extended_data_bearer_technology_data_bearer_technology */ WdsDataSystemNetworkType | null, /* value_extended_data_bearer_technology_radio_access_technology */ WdsRadioAccessTechnology | null, /* value_extended_data_bearer_technology_extended_data_bearer_technology_3gpp */ WdsExtendedDataBearerTechnology3gpp | null, /* value_extended_data_bearer_technology_extended_data_bearer_technology_3gpp2 */ WdsExtendedDataBearerTechnology3gpp2 | null ]
    /**
     * Get the 'MIP Status' field from `self`.
     */
    get_mip_status(): [ /* returnType */ boolean, /* value_mip_status */ boolean | null ]
    /**
     * Get the 'PDN Filters Removed' field from `self`.
     */
    get_pdn_filters_removed(): [ /* returnType */ boolean, /* value_pdn_filters_removed_pdn_filter_handler */ number[] | null ]
    /**
     * Get the 'Preferred Data System' field from `self`.
     */
    get_preferred_data_system(): [ /* returnType */ boolean, /* value_preferred_data_system */ WdsDataSystem | null ]
    /**
     * Get the 'Rx Bytes Ok' field from `self`.
     */
    get_rx_bytes_ok(): [ /* returnType */ boolean, /* value_rx_bytes_ok */ number | null ]
    /**
     * Get the 'Rx Overflows' field from `self`.
     */
    get_rx_overflows(): [ /* returnType */ boolean, /* value_rx_overflows */ number | null ]
    /**
     * Get the 'Rx Packets Dropped' field from `self`.
     */
    get_rx_packets_dropped(): [ /* returnType */ boolean, /* value_rx_packets_dropped */ number | null ]
    /**
     * Get the 'Rx Packets Error' field from `self`.
     */
    get_rx_packets_error(): [ /* returnType */ boolean, /* value_rx_packets_error */ number | null ]
    /**
     * Get the 'Rx Packets Ok' field from `self`.
     */
    get_rx_packets_ok(): [ /* returnType */ boolean, /* value_rx_packets_ok */ number | null ]
    /**
     * Get the 'Tx Bytes Ok' field from `self`.
     */
    get_tx_bytes_ok(): [ /* returnType */ boolean, /* value_tx_bytes_ok */ number | null ]
    /**
     * Get the 'Tx Overflows' field from `self`.
     */
    get_tx_overflows(): [ /* returnType */ boolean, /* value_tx_overflows */ number | null ]
    /**
     * Get the 'Tx Packets Dropped' field from `self`.
     */
    get_tx_packets_dropped(): [ /* returnType */ boolean, /* value_tx_packets_dropped */ number | null ]
    /**
     * Get the 'Tx Packets Error' field from `self`.
     */
    get_tx_packets_error(): [ /* returnType */ boolean, /* value_tx_packets_error */ number | null ]
    /**
     * Get the 'Tx Packets Ok' field from `self`.
     */
    get_tx_packets_ok(): [ /* returnType */ boolean, /* value_tx_packets_ok */ number | null ]
    /**
     * Get the 'Uplink Flow Control Enabled' field from `self`.
     */
    get_uplink_flow_control_enabled(): [ /* returnType */ boolean, /* value_uplink_flow_control_enabled */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationWdsEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationWdsEventReportOutputDataSystemsNetworksNetwork {
    /* Fields of Qmi-1.0.Qmi.IndicationWdsEventReportOutputDataSystemsNetworksNetwork */
    /**
     * a #QmiWdsDataSystemNetworkType.
     */
    network_type: WdsDataSystemNetworkType
    /**
     * a #guint32.
     */
    rat_mask: number
    /**
     * a #guint32.
     */
    so_mask: number
    static name: string
}
class IndicationWdsPacketServiceStatusOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationWdsPacketServiceStatusOutput */
    /**
     * Get the 'Call End Reason' field from `self`.
     */
    get_call_end_reason(): [ /* returnType */ boolean, /* value_call_end_reason */ WdsCallEndReason | null ]
    /**
     * Get the 'Connection Status' field from `self`.
     */
    get_connection_status(): [ /* returnType */ boolean, /* value_connection_status_status */ WdsConnectionStatus | null, /* value_connection_status_reconfiguration_required */ boolean | null ]
    /**
     * Get the 'Extended Technology Preference' field from `self`.
     */
    get_extended_technology_preference(): [ /* returnType */ boolean, /* value_extended_technology_preference */ WdsExtendedTechnologyPreference | null ]
    /**
     * Get the 'IP Family' field from `self`.
     */
    get_ip_family(): [ /* returnType */ boolean, /* value_ip_family */ WdsIpFamily | null ]
    /**
     * Get the 'Verbose Call End Reason' field from `self`.
     */
    get_verbose_call_end_reason(): [ /* returnType */ boolean, /* value_verbose_call_end_reason_type */ WdsVerboseCallEndReasonType | null, /* value_verbose_call_end_reason_reason */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationWdsPacketServiceStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationWdsSetLteAttachPdnListOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationWdsSetLteAttachPdnListOutput */
    /**
     * Get the 'Action Result' field from `self`.
     */
    get_action_result(): [ /* returnType */ boolean, /* value_action_result */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationWdsSetLteAttachPdnListOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationWmsEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationWmsEventReportOutput */
    /**
     * Get the 'ETWS Message' field from `self`.
     */
    get_etws_message(): [ /* returnType */ boolean, /* value_etws_message_notification_type */ WmsNotificationType | null, /* value_etws_message_raw_data */ Uint8Array | null ]
    /**
     * Get the 'ETWS PLMN Information' field from `self`.
     */
    get_etws_plmn_information(): [ /* returnType */ boolean, /* value_etws_plmn_information_mcc */ number | null, /* value_etws_plmn_information_mnc */ number | null ]
    /**
     * Get the 'Message Mode' field from `self`.
     */
    get_message_mode(): [ /* returnType */ boolean, /* value_message_mode */ WmsMessageMode | null ]
    /**
     * Get the 'MT Message' field from `self`.
     */
    get_mt_message(): [ /* returnType */ boolean, /* value_mt_message_storage_type */ WmsStorageType | null, /* value_mt_message_memory_index */ number | null ]
    /**
     * Get the 'SMS on IMS' field from `self`.
     */
    get_sms_on_ims(): [ /* returnType */ boolean, /* value_sms_on_ims */ boolean | null ]
    /**
     * Get the 'SMSC Address' field from `self`.
     */
    get_smsc_address(): [ /* returnType */ boolean, /* value_smsc_address */ string | null ]
    /**
     * Get the 'Transfer Route MT Message' field from `self`.
     */
    get_transfer_route_mt_message(): [ /* returnType */ boolean, /* value_transfer_route_mt_message_ack_indicator */ WmsAckIndicator | null, /* value_transfer_route_mt_message_transaction_id */ number | null, /* value_transfer_route_mt_message_format */ WmsMessageFormat | null, /* value_transfer_route_mt_message_raw_data */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationWmsEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class IndicationWmsSmscAddressOutput {
    /* Methods of Qmi-1.0.Qmi.IndicationWmsSmscAddressOutput */
    /**
     * Get the 'Address' field from `self`.
     */
    get_address(): [ /* returnType */ boolean, /* value_address_type */ string | null, /* value_address_digits */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): IndicationWmsSmscAddressOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageContext {
    /* Methods of Qmi-1.0.Qmi.MessageContext */
    /**
     * Gets the vendor ID associated to the message.
     */
    get_vendor_id(): number
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageContext
    /**
     * Sets the vendor ID associated to the message.
     * @param vendor_id the vendor ID.
     */
    set_vendor_id(vendor_id: number): void
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageContext
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageContext
}
class MessageDmsActivateAutomaticInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsActivateAutomaticInput */
    /**
     * Get the 'Activation Code' field from `self`.
     */
    get_activation_code(): [ /* returnType */ boolean, /* value_activation_code */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsActivateAutomaticInput
    /**
     * Set the 'Activation Code' field in the message.
     * @param value_activation_code a constant string.
     */
    set_activation_code(value_activation_code: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsActivateAutomaticInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsActivateAutomaticInput
}
class MessageDmsActivateAutomaticOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsActivateAutomaticOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsActivateAutomaticOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsActivateManualInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsActivateManualInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_service_programming_code */ string | null, /* value_info_system_identification_number */ number | null, /* value_info_mobile_directory_number */ string | null, /* value_info_mobile_identification_number */ string | null ]
    /**
     * Get the 'MN AAA key' field from `self`.
     */
    get_mn_aaa_key(): [ /* returnType */ boolean, /* value_mn_aaa_key */ string | null ]
    /**
     * Get the 'MN HA key' field from `self`.
     */
    get_mn_ha_key(): [ /* returnType */ boolean, /* value_mn_ha_key */ string | null ]
    /**
     * Get the 'PRL' field from `self`.
     */
    get_prl(): [ /* returnType */ boolean, /* value_prl_prl_total_length */ number | null, /* value_prl_prl_segment_sequence */ number | null, /* value_prl_prl_segment */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsActivateManualInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_service_programming_code a constant string of exactly 6 characters.
     * @param value_info_system_identification_number a #guint16.
     * @param value_info_mobile_directory_number a constant string with a maximum length of 15 characters.
     * @param value_info_mobile_identification_number a constant string with a maximum length of 15 characters.
     */
    set_info(value_info_service_programming_code: string, value_info_system_identification_number: number, value_info_mobile_directory_number: string, value_info_mobile_identification_number: string): boolean
    /**
     * Set the 'MN AAA key' field in the message.
     * @param value_mn_aaa_key a constant string with a maximum length of 16 characters.
     */
    set_mn_aaa_key(value_mn_aaa_key: string): boolean
    /**
     * Set the 'MN HA key' field in the message.
     * @param value_mn_ha_key a constant string with a maximum length of 16 characters.
     */
    set_mn_ha_key(value_mn_ha_key: string): boolean
    /**
     * Set the 'PRL' field in the message.
     * @param value_prl_prl_total_length a #guint16.
     * @param value_prl_prl_segment_sequence the sequence number.
     * @param value_prl_prl_segment a #GArray of #guint8 elements. A new reference to `value_prl_prl_segment` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_prl(value_prl_prl_total_length: number, value_prl_prl_segment_sequence: number, value_prl_prl_segment: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsActivateManualInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsActivateManualInput
}
class MessageDmsActivateManualOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsActivateManualOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsActivateManualOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsDeleteStoredImageInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsDeleteStoredImageInput */
    /**
     * Get the 'Image Details' field from `self`.
     */
    get_image_details(): [ /* returnType */ boolean, /* value_image_details_type */ DmsFirmwareImageType | null, /* value_image_details_unique_id */ Uint8Array | null, /* value_image_details_build_id */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsDeleteStoredImageInput
    /**
     * Set the 'Image Details' field in the message.
     * @param value_image_details_type a #QmiDmsFirmwareImageType.
     * @param value_image_details_unique_id a #GArray of #guint8 elements. A new reference to `value_image_details_unique_id` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     * @param value_image_details_build_id a constant string.
     */
    set_image_details(value_image_details_type: DmsFirmwareImageType, value_image_details_unique_id: Uint8Array, value_image_details_build_id: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsDeleteStoredImageInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsDeleteStoredImageInput
}
class MessageDmsDeleteStoredImageOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsDeleteStoredImageOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsDeleteStoredImageOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsFoxconnChangeDeviceModeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsFoxconnChangeDeviceModeInput */
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ DmsFoxconnDeviceMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsFoxconnChangeDeviceModeInput
    /**
     * Set the 'Mode' field in the message.
     * @param value_mode a #QmiDmsFoxconnDeviceMode.
     */
    set_mode(value_mode: DmsFoxconnDeviceMode): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsFoxconnChangeDeviceModeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsFoxconnChangeDeviceModeInput
}
class MessageDmsFoxconnChangeDeviceModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsFoxconnChangeDeviceModeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsFoxconnChangeDeviceModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsFoxconnGetFirmwareVersionInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsFoxconnGetFirmwareVersionInput */
    /**
     * Get the 'Version Type' field from `self`.
     */
    get_version_type(): [ /* returnType */ boolean, /* value_version_type */ DmsFoxconnFirmwareVersionType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsFoxconnGetFirmwareVersionInput
    /**
     * Set the 'Version Type' field in the message.
     * @param value_version_type a #QmiDmsFoxconnFirmwareVersionType.
     */
    set_version_type(value_version_type: DmsFoxconnFirmwareVersionType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsFoxconnGetFirmwareVersionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsFoxconnGetFirmwareVersionInput
}
class MessageDmsFoxconnGetFirmwareVersionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsFoxconnGetFirmwareVersionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsFoxconnGetFirmwareVersionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsFoxconnSetFccAuthenticationInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsFoxconnSetFccAuthenticationInput */
    /**
     * Get the 'Value' field from `self`.
     */
    get_value(): [ /* returnType */ boolean, /* value_value */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsFoxconnSetFccAuthenticationInput
    /**
     * Set the 'Value' field in the message.
     * @param value_value a #guint8.
     */
    set_value(value_value: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsFoxconnSetFccAuthenticationInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsFoxconnSetFccAuthenticationInput
}
class MessageDmsFoxconnSetFccAuthenticationOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsFoxconnSetFccAuthenticationOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsFoxconnSetFccAuthenticationOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetActivationStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetActivationStateOutput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info */ DmsActivationState | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetActivationStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetAltNetConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetAltNetConfigOutput */
    /**
     * Get the 'Config' field from `self`.
     */
    get_config(): [ /* returnType */ boolean, /* value_config */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetAltNetConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetBandCapabilitiesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetBandCapabilitiesOutput */
    /**
     * Get the 'Band Capability' field from `self`.
     */
    get_band_capability(): [ /* returnType */ boolean, /* value_band_capability */ DmsBandCapability | null ]
    /**
     * Get the 'Extended LTE Band Capability' field from `self`.
     */
    get_extended_lte_band_capability(): [ /* returnType */ boolean, /* value_extended_lte_band_capability */ number[] | null ]
    /**
     * Get the 'LTE Band Capability' field from `self`.
     */
    get_lte_band_capability(): [ /* returnType */ boolean, /* value_lte_band_capability */ DmsLteBandCapability | null ]
    /**
     * Get the 'NR5G Band Capability' field from `self`.
     */
    get_nr5g_band_capability(): [ /* returnType */ boolean, /* value_nr5g_band_capability */ number[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetBandCapabilitiesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetBootImageDownloadModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetBootImageDownloadModeOutput */
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ DmsBootImageDownloadMode | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetBootImageDownloadModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetCapabilitiesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetCapabilitiesOutput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_max_tx_channel_rate */ number | null, /* value_info_max_rx_channel_rate */ number | null, /* value_info_data_service_capability */ DmsDataServiceCapability | null, /* value_info_sim_capability */ DmsSimCapability | null, /* value_info_radio_interface_list */ DmsRadioInterface[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetCapabilitiesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetFactorySkuOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetFactorySkuOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'SKU' field from `self`.
     */
    get_sku(): [ /* returnType */ boolean, /* value_sku */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetFactorySkuOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetFirmwarePreferenceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetFirmwarePreferenceOutput */
    /**
     * Get the 'List' field from `self`.
     * 
     * Version of qmi_message_dms_get_firmware_preference_output_get_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_list(): [ /* returnType */ boolean, /* value_list_ptr */ MessageDmsGetFirmwarePreferenceOutputListImage[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetFirmwarePreferenceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetFirmwarePreferenceOutputListImage {
    /* Fields of Qmi-1.0.Qmi.MessageDmsGetFirmwarePreferenceOutputListImage */
    /**
     * a #QmiDmsFirmwareImageType.
     */
    type: DmsFirmwareImageType
    /**
     * a #GArray of #guint8 elements.
     */
    unique_id: object[]
    /**
     * a string.
     */
    build_id: string
    static name: string
}
class MessageDmsGetHardwareRevisionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetHardwareRevisionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Revision' field from `self`.
     */
    get_revision(): [ /* returnType */ boolean, /* value_revision */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetHardwareRevisionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetIdsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetIdsOutput */
    /**
     * Get the 'Esn' field from `self`.
     */
    get_esn(): [ /* returnType */ boolean, /* value_esn */ string | null ]
    /**
     * Get the 'Imei' field from `self`.
     */
    get_imei(): [ /* returnType */ boolean, /* value_imei */ string | null ]
    /**
     * Get the 'Imei Software Version' field from `self`.
     */
    get_imei_software_version(): [ /* returnType */ boolean, /* value_imei_software_version */ string | null ]
    /**
     * Get the 'Meid' field from `self`.
     */
    get_meid(): [ /* returnType */ boolean, /* value_meid */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetIdsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetMacAddressInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetMacAddressInput */
    /**
     * Get the 'Device' field from `self`.
     */
    get_device(): [ /* returnType */ boolean, /* value_device */ DmsMacType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetMacAddressInput
    /**
     * Set the 'Device' field in the message.
     * @param value_device a #QmiDmsMacType.
     */
    set_device(value_device: DmsMacType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsGetMacAddressInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsGetMacAddressInput
}
class MessageDmsGetMacAddressOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetMacAddressOutput */
    /**
     * Get the 'MAC Address' field from `self`.
     */
    get_mac_address(): [ /* returnType */ boolean, /* value_mac_address */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetMacAddressOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetManufacturerOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetManufacturerOutput */
    /**
     * Get the 'Manufacturer' field from `self`.
     */
    get_manufacturer(): [ /* returnType */ boolean, /* value_manufacturer */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetManufacturerOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetModelOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetModelOutput */
    /**
     * Get the 'Model' field from `self`.
     */
    get_model(): [ /* returnType */ boolean, /* value_model */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetModelOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetMsisdnOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetMsisdnOutput */
    /**
     * Get the 'MSISDN' field from `self`.
     */
    get_msisdn(): [ /* returnType */ boolean, /* value_msisdn */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetMsisdnOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetOperatingModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetOperatingModeOutput */
    /**
     * Get the 'Hardware Restricted Mode' field from `self`.
     */
    get_hardware_restricted_mode(): [ /* returnType */ boolean, /* value_hardware_restricted_mode */ boolean | null ]
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ DmsOperatingMode | null ]
    /**
     * Get the 'Offline Reason' field from `self`.
     */
    get_offline_reason(): [ /* returnType */ boolean, /* value_offline_reason */ DmsOfflineReason | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetOperatingModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetPowerStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetPowerStateOutput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_power_state_flags */ number | null, /* value_info_battery_level */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetPowerStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetPrlVersionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetPrlVersionOutput */
    /**
     * Get the 'PRL Only Preference' field from `self`.
     */
    get_prl_only_preference(): [ /* returnType */ boolean, /* value_prl_only_preference */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetPrlVersionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetRevisionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetRevisionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Revision' field from `self`.
     */
    get_revision(): [ /* returnType */ boolean, /* value_revision */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetRevisionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetSoftwareVersionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetSoftwareVersionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetSoftwareVersionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetStoredImageInfoInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetStoredImageInfoInput */
    /**
     * Get the 'Image Details' field from `self`.
     */
    get_image_details(): [ /* returnType */ boolean, /* value_image_details_type */ DmsFirmwareImageType | null, /* value_image_details_unique_id */ Uint8Array | null, /* value_image_details_build_id */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetStoredImageInfoInput
    /**
     * Set the 'Image Details' field in the message.
     * @param value_image_details_type a #QmiDmsFirmwareImageType.
     * @param value_image_details_unique_id a #GArray of #guint8 elements. A new reference to `value_image_details_unique_id` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     * @param value_image_details_build_id a constant string.
     */
    set_image_details(value_image_details_type: DmsFirmwareImageType, value_image_details_unique_id: Uint8Array, value_image_details_build_id: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsGetStoredImageInfoInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsGetStoredImageInfoInput
}
class MessageDmsGetStoredImageInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetStoredImageInfoOutput */
    /**
     * Get the 'Boot Version' field from `self`.
     */
    get_boot_version(): [ /* returnType */ boolean, /* value_boot_version_major_version */ number | null, /* value_boot_version_minor_version */ number | null ]
    /**
     * Get the 'OEM Lock ID' field from `self`.
     */
    get_oem_lock_id(): [ /* returnType */ boolean, /* value_oem_lock_id */ number | null ]
    /**
     * Get the 'PRI Version' field from `self`.
     */
    get_pri_version(): [ /* returnType */ boolean, /* value_pri_version_pri_version */ number | null, /* value_pri_version_pri_info */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetStoredImageInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetSupportedMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetSupportedMessagesOutput */
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetSupportedMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetTimeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetTimeOutput */
    /**
     * Get the 'Device Time' field from `self`.
     */
    get_device_time(): [ /* returnType */ boolean, /* value_device_time_time_count */ number | null, /* value_device_time_time_source */ DmsTimeSource | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'System Time' field from `self`.
     */
    get_system_time(): [ /* returnType */ boolean, /* value_system_time */ number | null ]
    /**
     * Get the 'User Time' field from `self`.
     */
    get_user_time(): [ /* returnType */ boolean, /* value_user_time */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetTimeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsGetUserLockStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsGetUserLockStateOutput */
    /**
     * Get the 'Enabled' field from `self`.
     */
    get_enabled(): [ /* returnType */ boolean, /* value_enabled */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsGetUserLockStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsHpChangeDeviceModeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsHpChangeDeviceModeInput */
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ DmsHpDeviceMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsHpChangeDeviceModeInput
    /**
     * Set the 'Mode' field in the message.
     * @param value_mode a #QmiDmsHpDeviceMode.
     */
    set_mode(value_mode: DmsHpDeviceMode): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsHpChangeDeviceModeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsHpChangeDeviceModeInput
}
class MessageDmsHpChangeDeviceModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsHpChangeDeviceModeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsHpChangeDeviceModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsListStoredImagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsListStoredImagesOutput */
    /**
     * Get the 'List' field from `self`.
     * 
     * Version of qmi_message_dms_list_stored_images_output_get_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_list(): [ /* returnType */ boolean, /* value_list_ptr */ MessageDmsListStoredImagesOutputListImageGir[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsListStoredImagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsListStoredImagesOutputListImage {
    /* Fields of Qmi-1.0.Qmi.MessageDmsListStoredImagesOutputListImage */
    /**
     * a #QmiDmsFirmwareImageType.
     */
    type: DmsFirmwareImageType
    /**
     * a #guint8.
     */
    maximum_images: number
    /**
     * a #guint8.
     */
    index_of_running_image: number
    /**
     * a #GArray of #QmiMessageDmsListStoredImagesOutputListImageSublistSublistElement elements.
     */
    sublist: object[]
    static name: string
}
class MessageDmsListStoredImagesOutputListImageGir {
    /* Fields of Qmi-1.0.Qmi.MessageDmsListStoredImagesOutputListImageGir */
    /**
     * a #QmiDmsFirmwareImageType.
     */
    type: DmsFirmwareImageType
    /**
     * a #guint8.
     */
    maximum_images: number
    /**
     * a #guint8.
     */
    index_of_running_image: number
    /**
     * an array of #QmiMessageDmsListStoredImagesOutputListImageSublistSublistElement elements.
     */
    sublist: MessageDmsListStoredImagesOutputListImageSublistSublistElement[]
    static name: string
}
class MessageDmsListStoredImagesOutputListImageSublistSublistElement {
    /* Fields of Qmi-1.0.Qmi.MessageDmsListStoredImagesOutputListImageSublistSublistElement */
    /**
     * a #guint8.
     */
    storage_index: number
    /**
     * a #guint8.
     */
    failure_count: number
    /**
     * a #GArray of #guint8 elements.
     */
    unique_id: object[]
    /**
     * a string.
     */
    build_id: string
    static name: string
}
class MessageDmsReadEriFileOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsReadEriFileOutput */
    /**
     * Get the 'ERI File' field from `self`.
     */
    get_eri_file(): [ /* returnType */ boolean, /* value_eri_file */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsReadEriFileOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsReadUserDataOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsReadUserDataOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'User Data' field from `self`.
     */
    get_user_data(): [ /* returnType */ boolean, /* value_user_data */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsReadUserDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsRestoreFactoryDefaultsInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsRestoreFactoryDefaultsInput */
    /**
     * Get the 'Service Programming Code' field from `self`.
     */
    get_service_programming_code(): [ /* returnType */ boolean, /* value_service_programming_code */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsRestoreFactoryDefaultsInput
    /**
     * Set the 'Service Programming Code' field in the message.
     * @param value_service_programming_code a constant string of exactly 6 characters.
     */
    set_service_programming_code(value_service_programming_code: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsRestoreFactoryDefaultsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsRestoreFactoryDefaultsInput
}
class MessageDmsRestoreFactoryDefaultsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsRestoreFactoryDefaultsOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsRestoreFactoryDefaultsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetAltNetConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetAltNetConfigInput */
    /**
     * Get the 'Config' field from `self`.
     */
    get_config(): [ /* returnType */ boolean, /* value_config */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetAltNetConfigInput
    /**
     * Set the 'Config' field in the message.
     * @param value_config a #gboolean.
     */
    set_config(value_config: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetAltNetConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetAltNetConfigInput
}
class MessageDmsSetAltNetConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetAltNetConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetAltNetConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetBootImageDownloadModeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetBootImageDownloadModeInput */
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ DmsBootImageDownloadMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetBootImageDownloadModeInput
    /**
     * Set the 'Mode' field in the message.
     * @param value_mode a #QmiDmsBootImageDownloadMode.
     */
    set_mode(value_mode: DmsBootImageDownloadMode): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetBootImageDownloadModeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetBootImageDownloadModeInput
}
class MessageDmsSetBootImageDownloadModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetBootImageDownloadModeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetBootImageDownloadModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetEventReportInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetEventReportInput */
    /**
     * Get the 'Activation State Reporting' field from `self`.
     */
    get_activation_state_reporting(): [ /* returnType */ boolean, /* value_activation_state_reporting */ boolean | null ]
    /**
     * Get the 'Battery Level Report Limits' field from `self`.
     */
    get_battery_level_report_limits(): [ /* returnType */ boolean, /* value_battery_level_report_limits_lower_limit */ number | null, /* value_battery_level_report_limits_upper_limit */ number | null ]
    /**
     * Get the 'Operating Mode Reporting' field from `self`.
     */
    get_operating_mode_reporting(): [ /* returnType */ boolean, /* value_operating_mode_reporting */ boolean | null ]
    /**
     * Get the 'PIN State Reporting' field from `self`.
     */
    get_pin_state_reporting(): [ /* returnType */ boolean, /* value_pin_state_reporting */ boolean | null ]
    /**
     * Get the 'Power State Reporting' field from `self`.
     */
    get_power_state_reporting(): [ /* returnType */ boolean, /* value_power_state_reporting */ boolean | null ]
    /**
     * Get the 'PRL Init Reporting' field from `self`.
     */
    get_prl_init_reporting(): [ /* returnType */ boolean, /* value_prl_init_reporting */ boolean | null ]
    /**
     * Get the 'UIM State Reporting' field from `self`.
     */
    get_uim_state_reporting(): [ /* returnType */ boolean, /* value_uim_state_reporting */ boolean | null ]
    /**
     * Get the 'Wireless Disable State Reporting' field from `self`.
     */
    get_wireless_disable_state_reporting(): [ /* returnType */ boolean, /* value_wireless_disable_state_reporting */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetEventReportInput
    /**
     * Set the 'Activation State Reporting' field in the message.
     * @param value_activation_state_reporting a #gboolean.
     */
    set_activation_state_reporting(value_activation_state_reporting: boolean): boolean
    /**
     * Set the 'Battery Level Report Limits' field in the message.
     * @param value_battery_level_report_limits_lower_limit a #guint8.
     * @param value_battery_level_report_limits_upper_limit a #guint8.
     */
    set_battery_level_report_limits(value_battery_level_report_limits_lower_limit: number, value_battery_level_report_limits_upper_limit: number): boolean
    /**
     * Set the 'Operating Mode Reporting' field in the message.
     * @param value_operating_mode_reporting a #gboolean.
     */
    set_operating_mode_reporting(value_operating_mode_reporting: boolean): boolean
    /**
     * Set the 'PIN State Reporting' field in the message.
     * @param value_pin_state_reporting a #gboolean.
     */
    set_pin_state_reporting(value_pin_state_reporting: boolean): boolean
    /**
     * Set the 'Power State Reporting' field in the message.
     * @param value_power_state_reporting a #gboolean.
     */
    set_power_state_reporting(value_power_state_reporting: boolean): boolean
    /**
     * Set the 'PRL Init Reporting' field in the message.
     * @param value_prl_init_reporting a #gboolean.
     */
    set_prl_init_reporting(value_prl_init_reporting: boolean): boolean
    /**
     * Set the 'UIM State Reporting' field in the message.
     * @param value_uim_state_reporting a #gboolean.
     */
    set_uim_state_reporting(value_uim_state_reporting: boolean): boolean
    /**
     * Set the 'Wireless Disable State Reporting' field in the message.
     * @param value_wireless_disable_state_reporting a #gboolean.
     */
    set_wireless_disable_state_reporting(value_wireless_disable_state_reporting: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetEventReportInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetEventReportInput
}
class MessageDmsSetEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetEventReportOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetFccAuthenticationOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetFccAuthenticationOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetFccAuthenticationOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetFirmwareIdOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetFirmwareIdOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetFirmwareIdOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetFirmwarePreferenceInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetFirmwarePreferenceInput */
    /**
     * Get the 'Download Override' field from `self`.
     */
    get_download_override(): [ /* returnType */ boolean, /* value_download_override */ boolean | null ]
    /**
     * Get the 'List' field from `self`.
     * 
     * Version of qmi_message_dms_set_firmware_preference_input_get_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_list(): [ /* returnType */ boolean, /* value_list_ptr */ MessageDmsSetFirmwarePreferenceInputListImage[] | null ]
    /**
     * Get the 'Modem Storage Index' field from `self`.
     */
    get_modem_storage_index(): [ /* returnType */ boolean, /* value_modem_storage_index */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetFirmwarePreferenceInput
    /**
     * Set the 'Download Override' field in the message.
     * @param value_download_override a #gboolean.
     */
    set_download_override(value_download_override: boolean): boolean
    /**
     * Set the 'List' field in the message.
     * @param value_list_ptr array of #QmiMessageDmsSetFirmwarePreferenceInputListImage elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_list(value_list_ptr: MessageDmsSetFirmwarePreferenceInputListImage[]): boolean
    /**
     * Set the 'Modem Storage Index' field in the message.
     * @param value_modem_storage_index a #guint8.
     */
    set_modem_storage_index(value_modem_storage_index: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetFirmwarePreferenceInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetFirmwarePreferenceInput
}
class MessageDmsSetFirmwarePreferenceInputListImage {
    /* Fields of Qmi-1.0.Qmi.MessageDmsSetFirmwarePreferenceInputListImage */
    /**
     * a #QmiDmsFirmwareImageType.
     */
    type: DmsFirmwareImageType
    /**
     * a #GArray of #guint8 elements.
     */
    unique_id: object[]
    /**
     * a string.
     */
    build_id: string
    static name: string
}
class MessageDmsSetFirmwarePreferenceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetFirmwarePreferenceOutput */
    /**
     * Get the 'Image Download List' field from `self`.
     */
    get_image_download_list(): [ /* returnType */ boolean, /* value_image_download_list */ DmsFirmwareImageType[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetFirmwarePreferenceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetOperatingModeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetOperatingModeInput */
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ DmsOperatingMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetOperatingModeInput
    /**
     * Set the 'Mode' field in the message.
     * @param value_mode a #QmiDmsOperatingMode.
     */
    set_mode(value_mode: DmsOperatingMode): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetOperatingModeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetOperatingModeInput
}
class MessageDmsSetOperatingModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetOperatingModeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetOperatingModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetServiceProgrammingCodeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetServiceProgrammingCodeInput */
    /**
     * Get the 'Current Code' field from `self`.
     */
    get_current_code(): [ /* returnType */ boolean, /* value_current_code */ string | null ]
    /**
     * Get the 'New Code' field from `self`.
     */
    get_new_code(): [ /* returnType */ boolean, /* value_new_code */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetServiceProgrammingCodeInput
    /**
     * Set the 'Current Code' field in the message.
     * @param value_current_code a constant string of exactly 6 characters.
     */
    set_current_code(value_current_code: string): boolean
    /**
     * Set the 'New Code' field in the message.
     * @param value_new_code a constant string of exactly 6 characters.
     */
    set_new_code(value_new_code: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetServiceProgrammingCodeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetServiceProgrammingCodeInput
}
class MessageDmsSetServiceProgrammingCodeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetServiceProgrammingCodeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetServiceProgrammingCodeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetTimeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetTimeInput */
    /**
     * Get the 'Time Reference Type' field from `self`.
     */
    get_time_reference_type(): [ /* returnType */ boolean, /* value_time_reference_type */ DmsTimeReferenceType | null ]
    /**
     * Get the 'Time Value' field from `self`.
     */
    get_time_value(): [ /* returnType */ boolean, /* value_time_value */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetTimeInput
    /**
     * Set the 'Time Reference Type' field in the message.
     * @param value_time_reference_type a #QmiDmsTimeReferenceType.
     */
    set_time_reference_type(value_time_reference_type: DmsTimeReferenceType): boolean
    /**
     * Set the 'Time Value' field in the message.
     * @param value_time_value a #guint64.
     */
    set_time_value(value_time_value: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetTimeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetTimeInput
}
class MessageDmsSetTimeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetTimeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetTimeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetUserLockCodeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetUserLockCodeInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_old_code */ string | null, /* value_info_new_code */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetUserLockCodeInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_old_code a constant string of exactly 4 characters.
     * @param value_info_new_code a constant string of exactly 4 characters.
     */
    set_info(value_info_old_code: string, value_info_new_code: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetUserLockCodeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetUserLockCodeInput
}
class MessageDmsSetUserLockCodeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetUserLockCodeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetUserLockCodeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSetUserLockStateInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetUserLockStateInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_enabled */ boolean | null, /* value_info_lock_code */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetUserLockStateInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_enabled a #gboolean.
     * @param value_info_lock_code a constant string of exactly 4 characters.
     */
    set_info(value_info_enabled: boolean, value_info_lock_code: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSetUserLockStateInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSetUserLockStateInput
}
class MessageDmsSetUserLockStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSetUserLockStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSetUserLockStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSwiGetCurrentFirmwareOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSwiGetCurrentFirmwareOutput */
    /**
     * Get the 'AMSS version' field from `self`.
     */
    get_amss_version(): [ /* returnType */ boolean, /* value_amss_version */ string | null ]
    /**
     * Get the 'Boot version' field from `self`.
     */
    get_boot_version(): [ /* returnType */ boolean, /* value_boot_version */ string | null ]
    /**
     * Get the 'Carrier' field from `self`.
     */
    get_carrier(): [ /* returnType */ boolean, /* value_carrier */ string | null ]
    /**
     * Get the 'Carrier ID' field from `self`.
     */
    get_carrier_id(): [ /* returnType */ boolean, /* value_carrier_id */ string | null ]
    /**
     * Get the 'Config version' field from `self`.
     */
    get_config_version(): [ /* returnType */ boolean, /* value_config_version */ string | null ]
    /**
     * Get the 'Model' field from `self`.
     */
    get_model(): [ /* returnType */ boolean, /* value_model */ string | null ]
    /**
     * Get the 'Package ID' field from `self`.
     */
    get_package_id(): [ /* returnType */ boolean, /* value_package_id */ string | null ]
    /**
     * Get the 'PRI version' field from `self`.
     */
    get_pri_version(): [ /* returnType */ boolean, /* value_pri_version */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'SKU ID' field from `self`.
     */
    get_sku_id(): [ /* returnType */ boolean, /* value_sku_id */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSwiGetCurrentFirmwareOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSwiGetUsbCompositionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSwiGetUsbCompositionOutput */
    /**
     * Get the 'Current' field from `self`.
     */
    get_current(): [ /* returnType */ boolean, /* value_current */ DmsSwiUsbComposition | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Supported' field from `self`.
     */
    get_supported(): [ /* returnType */ boolean, /* value_supported */ DmsSwiUsbComposition[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSwiGetUsbCompositionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsSwiSetUsbCompositionInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSwiSetUsbCompositionInput */
    /**
     * Get the 'Current' field from `self`.
     */
    get_current(): [ /* returnType */ boolean, /* value_current */ DmsSwiUsbComposition | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSwiSetUsbCompositionInput
    /**
     * Set the 'Current' field in the message.
     * @param value_current a #QmiDmsSwiUsbComposition.
     */
    set_current(value_current: DmsSwiUsbComposition): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsSwiSetUsbCompositionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsSwiSetUsbCompositionInput
}
class MessageDmsSwiSetUsbCompositionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsSwiSetUsbCompositionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsSwiSetUsbCompositionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimChangePinInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimChangePinInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ DmsUimPinId | null, /* value_info_old_pin */ string | null, /* value_info_new_pin */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimChangePinInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiDmsUimPinId.
     * @param value_info_old_pin a constant string.
     * @param value_info_new_pin a constant string.
     */
    set_info(value_info_pin_id: DmsUimPinId, value_info_old_pin: string, value_info_new_pin: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsUimChangePinInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsUimChangePinInput
}
class MessageDmsUimChangePinOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimChangePinOutput */
    /**
     * Get the 'Pin Retries Status' field from `self`.
     */
    get_pin_retries_status(): [ /* returnType */ boolean, /* value_pin_retries_status_verify_retries_left */ number | null, /* value_pin_retries_status_unblock_retries_left */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimChangePinOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimGetCkStatusInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimGetCkStatusInput */
    /**
     * Get the 'Facility' field from `self`.
     */
    get_facility(): [ /* returnType */ boolean, /* value_facility */ DmsUimFacility | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimGetCkStatusInput
    /**
     * Set the 'Facility' field in the message.
     * @param value_facility a #QmiDmsUimFacility.
     */
    set_facility(value_facility: DmsUimFacility): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsUimGetCkStatusInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsUimGetCkStatusInput
}
class MessageDmsUimGetCkStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimGetCkStatusOutput */
    /**
     * Get the 'CK Status' field from `self`.
     */
    get_ck_status(): [ /* returnType */ boolean, /* value_ck_status_facility_state */ DmsUimFacilityState | null, /* value_ck_status_verify_retries_left */ number | null, /* value_ck_status_unblock_retries_left */ number | null ]
    /**
     * Get the 'Operation Blocking Facility' field from `self`.
     */
    get_operation_blocking_facility(): [ /* returnType */ boolean, /* value_operation_blocking_facility */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimGetCkStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimGetIccidOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimGetIccidOutput */
    /**
     * Get the 'ICCID' field from `self`.
     */
    get_iccid(): [ /* returnType */ boolean, /* value_iccid */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimGetIccidOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimGetImsiOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimGetImsiOutput */
    /**
     * Get the 'IMSI' field from `self`.
     */
    get_imsi(): [ /* returnType */ boolean, /* value_imsi */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimGetImsiOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimGetPinStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimGetPinStatusOutput */
    /**
     * Get the 'PIN1 Status' field from `self`.
     */
    get_pin1_status(): [ /* returnType */ boolean, /* value_pin1_status_current_status */ DmsUimPinStatus | null, /* value_pin1_status_verify_retries_left */ number | null, /* value_pin1_status_unblock_retries_left */ number | null ]
    /**
     * Get the 'PIN2 Status' field from `self`.
     */
    get_pin2_status(): [ /* returnType */ boolean, /* value_pin2_status_current_status */ DmsUimPinStatus | null, /* value_pin2_status_verify_retries_left */ number | null, /* value_pin2_status_unblock_retries_left */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimGetPinStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimGetStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimGetStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'State' field from `self`.
     */
    get_state(): [ /* returnType */ boolean, /* value_state */ DmsUimState | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimGetStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimSetCkProtectionInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimSetCkProtectionInput */
    /**
     * Get the 'Facility' field from `self`.
     */
    get_facility(): [ /* returnType */ boolean, /* value_facility_facility */ DmsUimFacility | null, /* value_facility_facility_state */ DmsUimFacilityState | null, /* value_facility_facility_depersonalization_control_key */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimSetCkProtectionInput
    /**
     * Set the 'Facility' field in the message.
     * @param value_facility_facility a #QmiDmsUimFacility.
     * @param value_facility_facility_state a #QmiDmsUimFacilityState.
     * @param value_facility_facility_depersonalization_control_key a constant string.
     */
    set_facility(value_facility_facility: DmsUimFacility, value_facility_facility_state: DmsUimFacilityState, value_facility_facility_depersonalization_control_key: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsUimSetCkProtectionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsUimSetCkProtectionInput
}
class MessageDmsUimSetCkProtectionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimSetCkProtectionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Verify Retries Left' field from `self`.
     */
    get_verify_retries_left(): [ /* returnType */ boolean, /* value_verify_retries_left */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimSetCkProtectionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimSetPinProtectionInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimSetPinProtectionInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ DmsUimPinId | null, /* value_info_protection_enabled */ boolean | null, /* value_info_pin */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimSetPinProtectionInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiDmsUimPinId.
     * @param value_info_protection_enabled a #gboolean.
     * @param value_info_pin a constant string.
     */
    set_info(value_info_pin_id: DmsUimPinId, value_info_protection_enabled: boolean, value_info_pin: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsUimSetPinProtectionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsUimSetPinProtectionInput
}
class MessageDmsUimSetPinProtectionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimSetPinProtectionOutput */
    /**
     * Get the 'Pin Retries Status' field from `self`.
     */
    get_pin_retries_status(): [ /* returnType */ boolean, /* value_pin_retries_status_verify_retries_left */ number | null, /* value_pin_retries_status_unblock_retries_left */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimSetPinProtectionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimUnblockCkInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimUnblockCkInput */
    /**
     * Get the 'Facility' field from `self`.
     */
    get_facility(): [ /* returnType */ boolean, /* value_facility_facility */ DmsUimFacility | null, /* value_facility_facility_control_key */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimUnblockCkInput
    /**
     * Set the 'Facility' field in the message.
     * @param value_facility_facility a #QmiDmsUimFacility.
     * @param value_facility_facility_control_key a constant string.
     */
    set_facility(value_facility_facility: DmsUimFacility, value_facility_facility_control_key: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsUimUnblockCkInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsUimUnblockCkInput
}
class MessageDmsUimUnblockCkOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimUnblockCkOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Unblock Retries Left' field from `self`.
     */
    get_unblock_retries_left(): [ /* returnType */ boolean, /* value_unblock_retries_left */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimUnblockCkOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimUnblockPinInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimUnblockPinInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ DmsUimPinId | null, /* value_info_puk */ string | null, /* value_info_new_pin */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimUnblockPinInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiDmsUimPinId.
     * @param value_info_puk a constant string.
     * @param value_info_new_pin a constant string.
     */
    set_info(value_info_pin_id: DmsUimPinId, value_info_puk: string, value_info_new_pin: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsUimUnblockPinInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsUimUnblockPinInput
}
class MessageDmsUimUnblockPinOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimUnblockPinOutput */
    /**
     * Get the 'Pin Retries Status' field from `self`.
     */
    get_pin_retries_status(): [ /* returnType */ boolean, /* value_pin_retries_status_verify_retries_left */ number | null, /* value_pin_retries_status_unblock_retries_left */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimUnblockPinOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsUimVerifyPinInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimVerifyPinInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ DmsUimPinId | null, /* value_info_pin */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimVerifyPinInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiDmsUimPinId.
     * @param value_info_pin a constant string.
     */
    set_info(value_info_pin_id: DmsUimPinId, value_info_pin: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsUimVerifyPinInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsUimVerifyPinInput
}
class MessageDmsUimVerifyPinOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsUimVerifyPinOutput */
    /**
     * Get the 'Pin Retries Status' field from `self`.
     */
    get_pin_retries_status(): [ /* returnType */ boolean, /* value_pin_retries_status_verify_retries_left */ number | null, /* value_pin_retries_status_unblock_retries_left */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsUimVerifyPinOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsValidateServiceProgrammingCodeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsValidateServiceProgrammingCodeInput */
    /**
     * Get the 'Service Programming Code' field from `self`.
     */
    get_service_programming_code(): [ /* returnType */ boolean, /* value_service_programming_code */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsValidateServiceProgrammingCodeInput
    /**
     * Set the 'Service Programming Code' field in the message.
     * @param value_service_programming_code a constant string of exactly 6 characters.
     */
    set_service_programming_code(value_service_programming_code: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsValidateServiceProgrammingCodeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsValidateServiceProgrammingCodeInput
}
class MessageDmsValidateServiceProgrammingCodeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsValidateServiceProgrammingCodeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsValidateServiceProgrammingCodeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDmsWriteUserDataInput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsWriteUserDataInput */
    /**
     * Get the 'User Data' field from `self`.
     */
    get_user_data(): [ /* returnType */ boolean, /* value_user_data */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsWriteUserDataInput
    /**
     * Set the 'User Data' field in the message.
     * @param value_user_data a #GArray of #guint8 elements. A new reference to `value_user_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_user_data(value_user_data: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDmsWriteUserDataInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDmsWriteUserDataInput
}
class MessageDmsWriteUserDataOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDmsWriteUserDataOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDmsWriteUserDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDpmClosePortOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDpmClosePortOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDpmClosePortOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDpmOpenPortInput {
    /* Methods of Qmi-1.0.Qmi.MessageDpmOpenPortInput */
    /**
     * Get the 'Control Ports' field from `self`.
     * 
     * Version of qmi_message_dpm_open_port_input_get_control_ports() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_control_ports(): [ /* returnType */ boolean, /* value_control_ports_ptr */ MessageDpmOpenPortInputControlPortsElement[] | null ]
    /**
     * Get the 'Hardware Data Ports' field from `self`.
     * 
     * Version of qmi_message_dpm_open_port_input_get_hardware_data_ports() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_hardware_data_ports(): [ /* returnType */ boolean, /* value_hardware_data_ports_ptr */ MessageDpmOpenPortInputHardwareDataPortsElement[] | null ]
    /**
     * Get the 'Software Data Ports' field from `self`.
     * 
     * Version of qmi_message_dpm_open_port_input_get_software_data_ports() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_software_data_ports(): [ /* returnType */ boolean, /* value_software_data_ports_ptr */ MessageDpmOpenPortInputSoftwareDataPortsElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDpmOpenPortInput
    /**
     * Set the 'Control Ports' field in the message.
     * @param value_control_ports_ptr array of #QmiMessageDpmOpenPortInputControlPortsElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_control_ports(value_control_ports_ptr: MessageDpmOpenPortInputControlPortsElement[]): boolean
    /**
     * Set the 'Hardware Data Ports' field in the message.
     * @param value_hardware_data_ports_ptr array of #QmiMessageDpmOpenPortInputHardwareDataPortsElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_hardware_data_ports(value_hardware_data_ports_ptr: MessageDpmOpenPortInputHardwareDataPortsElement[]): boolean
    /**
     * Set the 'Software Data Ports' field in the message.
     * @param value_software_data_ports_ptr array of #QmiMessageDpmOpenPortInputSoftwareDataPortsElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_software_data_ports(value_software_data_ports_ptr: MessageDpmOpenPortInputSoftwareDataPortsElement[]): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDpmOpenPortInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDpmOpenPortInput
}
class MessageDpmOpenPortInputControlPortsElement {
    /* Fields of Qmi-1.0.Qmi.MessageDpmOpenPortInputControlPortsElement */
    /**
     * a string.
     */
    port_name: string
    /**
     * a #QmiDataEndpointType.
     */
    endpoint_type: DataEndpointType
    /**
     * a #guint32.
     */
    interface_number: number
    static name: string
}
class MessageDpmOpenPortInputHardwareDataPortsElement {
    /* Fields of Qmi-1.0.Qmi.MessageDpmOpenPortInputHardwareDataPortsElement */
    /**
     * a #QmiDataEndpointType.
     */
    endpoint_type: DataEndpointType
    /**
     * a #guint32.
     */
    interface_number: number
    /**
     * a #guint32.
     */
    rx_endpoint_number: number
    /**
     * a #guint32.
     */
    tx_endpoint_number: number
    static name: string
}
class MessageDpmOpenPortInputSoftwareDataPortsElement {
    /* Fields of Qmi-1.0.Qmi.MessageDpmOpenPortInputSoftwareDataPortsElement */
    /**
     * a #QmiDataEndpointType.
     */
    endpoint_type: DataEndpointType
    /**
     * a #guint32.
     */
    interface_number: number
    /**
     * a string.
     */
    port_name: string
    static name: string
}
class MessageDpmOpenPortOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDpmOpenPortOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDpmOpenPortOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDsdGetApnInfoInput {
    /* Methods of Qmi-1.0.Qmi.MessageDsdGetApnInfoInput */
    /**
     * Get the 'APN Type' field from `self`.
     */
    get_apn_type(): [ /* returnType */ boolean, /* value_apn_type */ DsdApnType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDsdGetApnInfoInput
    /**
     * Set the 'APN Type' field in the message.
     * @param value_apn_type a #QmiDsdApnType.
     */
    set_apn_type(value_apn_type: DsdApnType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDsdGetApnInfoInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDsdGetApnInfoInput
}
class MessageDsdGetApnInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDsdGetApnInfoOutput */
    /**
     * Get the 'APN Name' field from `self`.
     */
    get_apn_name(): [ /* returnType */ boolean, /* value_apn_name */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDsdGetApnInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageDsdSetApnTypeInput {
    /* Methods of Qmi-1.0.Qmi.MessageDsdSetApnTypeInput */
    /**
     * Get the 'APN Type' field from `self`.
     */
    get_apn_type(): [ /* returnType */ boolean, /* value_apn_type_name */ string | null, /* value_apn_type_type */ DsdApnTypePreference | null ]
    /**
     * Get the 'APN Type Preference Mask' field from `self`.
     */
    get_apn_type_preference_mask(): [ /* returnType */ boolean, /* value_apn_type_preference_mask */ DsdApnTypePreference | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDsdSetApnTypeInput
    /**
     * Set the 'APN Type' field in the message.
     * @param value_apn_type_name a constant string.
     * @param value_apn_type_type a #QmiDsdApnTypePreference.
     */
    set_apn_type(value_apn_type_name: string, value_apn_type_type: DsdApnTypePreference): boolean
    /**
     * Set the 'APN Type Preference Mask' field in the message.
     * @param value_apn_type_preference_mask a #QmiDsdApnTypePreference.
     */
    set_apn_type_preference_mask(value_apn_type_preference_mask: DsdApnTypePreference): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageDsdSetApnTypeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageDsdSetApnTypeInput
}
class MessageDsdSetApnTypeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageDsdSetApnTypeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageDsdSetApnTypeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageFoxGetFirmwareVersionInput {
    /* Methods of Qmi-1.0.Qmi.MessageFoxGetFirmwareVersionInput */
    /**
     * Get the 'Version Type' field from `self`.
     */
    get_version_type(): [ /* returnType */ boolean, /* value_version_type */ FoxFirmwareVersionType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageFoxGetFirmwareVersionInput
    /**
     * Set the 'Version Type' field in the message.
     * @param value_version_type a #QmiFoxFirmwareVersionType.
     */
    set_version_type(value_version_type: FoxFirmwareVersionType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageFoxGetFirmwareVersionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageFoxGetFirmwareVersionInput
}
class MessageFoxGetFirmwareVersionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageFoxGetFirmwareVersionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageFoxGetFirmwareVersionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageGasDmsGetFirmwareListInput {
    /* Methods of Qmi-1.0.Qmi.MessageGasDmsGetFirmwareListInput */
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ GasFirmwareListingMode | null ]
    /**
     * Get the 'Name' field from `self`.
     */
    get_name(): [ /* returnType */ boolean, /* value_name */ string | null ]
    /**
     * Get the 'Slot Index' field from `self`.
     */
    get_slot_index(): [ /* returnType */ boolean, /* value_slot_index */ number | null ]
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGasDmsGetFirmwareListInput
    /**
     * Set the 'Mode' field in the message.
     * @param value_mode a #QmiGasFirmwareListingMode.
     */
    set_mode(value_mode: GasFirmwareListingMode): boolean
    /**
     * Set the 'Name' field in the message.
     * @param value_name a constant string.
     */
    set_name(value_name: string): boolean
    /**
     * Set the 'Slot Index' field in the message.
     * @param value_slot_index a #guint8.
     */
    set_slot_index(value_slot_index: number): boolean
    /**
     * Set the 'Version' field in the message.
     * @param value_version a constant string.
     */
    set_version(value_version: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageGasDmsGetFirmwareListInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageGasDmsGetFirmwareListInput
}
class MessageGasDmsGetFirmwareListOutput {
    /* Methods of Qmi-1.0.Qmi.MessageGasDmsGetFirmwareListOutput */
    /**
     * Get the 'Mode' field from `self`.
     */
    get_mode(): [ /* returnType */ boolean, /* value_mode */ GasFirmwareListingMode | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Stored Firmware 1' field from `self`.
     */
    get_stored_firmware_1(): [ /* returnType */ boolean, /* value_stored_firmware_1_index */ number | null, /* value_stored_firmware_1_name */ string | null, /* value_stored_firmware_1_version */ string | null, /* value_stored_firmware_1_pri_revision */ string | null ]
    /**
     * Get the 'Stored Firmware 2' field from `self`.
     */
    get_stored_firmware_2(): [ /* returnType */ boolean, /* value_stored_firmware_2_index */ number | null, /* value_stored_firmware_2_name */ string | null, /* value_stored_firmware_2_version */ string | null, /* value_stored_firmware_2_pri_revision */ string | null ]
    /**
     * Get the 'Stored Firmware 3' field from `self`.
     */
    get_stored_firmware_3(): [ /* returnType */ boolean, /* value_stored_firmware_3_index */ number | null, /* value_stored_firmware_3_name */ string | null, /* value_stored_firmware_3_version */ string | null, /* value_stored_firmware_3_pri_revision */ string | null ]
    /**
     * Get the 'Stored Firmware 4' field from `self`.
     */
    get_stored_firmware_4(): [ /* returnType */ boolean, /* value_stored_firmware_4_index */ number | null, /* value_stored_firmware_4_name */ string | null, /* value_stored_firmware_4_version */ string | null, /* value_stored_firmware_4_pri_revision */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGasDmsGetFirmwareListOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageGasDmsGetUsbCompositionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageGasDmsGetUsbCompositionOutput */
    /**
     * Get the 'Composition Persistence' field from `self`.
     */
    get_composition_persistence(): [ /* returnType */ boolean, /* value_composition_persistence */ boolean | null ]
    /**
     * Get the 'Endpoint Type' field from `self`.
     */
    get_endpoint_type(): [ /* returnType */ boolean, /* value_endpoint_type */ GasUsbCompositionEndpointType | null ]
    /**
     * Get the 'Immediate Setting' field from `self`.
     */
    get_immediate_setting(): [ /* returnType */ boolean, /* value_immediate_setting */ boolean | null ]
    /**
     * Get the 'Reboot After Setting' field from `self`.
     */
    get_reboot_after_setting(): [ /* returnType */ boolean, /* value_reboot_after_setting */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'USB Composition' field from `self`.
     */
    get_usb_composition(): [ /* returnType */ boolean, /* value_usb_composition */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGasDmsGetUsbCompositionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageGasDmsSetActiveFirmwareInput {
    /* Methods of Qmi-1.0.Qmi.MessageGasDmsSetActiveFirmwareInput */
    /**
     * Get the 'Carrier Name' field from `self`.
     */
    get_carrier_name(): [ /* returnType */ boolean, /* value_carrier_name */ string | null ]
    /**
     * Get the 'Slot Index' field from `self`.
     */
    get_slot_index(): [ /* returnType */ boolean, /* value_slot_index */ number | null ]
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGasDmsSetActiveFirmwareInput
    /**
     * Set the 'Carrier Name' field in the message.
     * @param value_carrier_name a constant string.
     */
    set_carrier_name(value_carrier_name: string): boolean
    /**
     * Set the 'Slot Index' field in the message.
     * @param value_slot_index a #guint8.
     */
    set_slot_index(value_slot_index: number): boolean
    /**
     * Set the 'Version' field in the message.
     * @param value_version a constant string.
     */
    set_version(value_version: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageGasDmsSetActiveFirmwareInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageGasDmsSetActiveFirmwareInput
}
class MessageGasDmsSetActiveFirmwareOutput {
    /* Methods of Qmi-1.0.Qmi.MessageGasDmsSetActiveFirmwareOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGasDmsSetActiveFirmwareOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageGasDmsSetUsbCompositionInput {
    /* Methods of Qmi-1.0.Qmi.MessageGasDmsSetUsbCompositionInput */
    /**
     * Get the 'Composition Persistence' field from `self`.
     */
    get_composition_persistence(): [ /* returnType */ boolean, /* value_composition_persistence */ boolean | null ]
    /**
     * Get the 'Endpoint Type' field from `self`.
     */
    get_endpoint_type(): [ /* returnType */ boolean, /* value_endpoint_type */ GasUsbCompositionEndpointType | null ]
    /**
     * Get the 'Immediate Setting' field from `self`.
     */
    get_immediate_setting(): [ /* returnType */ boolean, /* value_immediate_setting */ boolean | null ]
    /**
     * Get the 'Reboot After Setting' field from `self`.
     */
    get_reboot_after_setting(): [ /* returnType */ boolean, /* value_reboot_after_setting */ boolean | null ]
    /**
     * Get the 'USB Composition' field from `self`.
     */
    get_usb_composition(): [ /* returnType */ boolean, /* value_usb_composition */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGasDmsSetUsbCompositionInput
    /**
     * Set the 'Composition Persistence' field in the message.
     * @param value_composition_persistence a #gboolean.
     */
    set_composition_persistence(value_composition_persistence: boolean): boolean
    /**
     * Set the 'Endpoint Type' field in the message.
     * @param value_endpoint_type a #QmiGasUsbCompositionEndpointType.
     */
    set_endpoint_type(value_endpoint_type: GasUsbCompositionEndpointType): boolean
    /**
     * Set the 'Immediate Setting' field in the message.
     * @param value_immediate_setting a #gboolean.
     */
    set_immediate_setting(value_immediate_setting: boolean): boolean
    /**
     * Set the 'Reboot After Setting' field in the message.
     * @param value_reboot_after_setting a #gboolean.
     */
    set_reboot_after_setting(value_reboot_after_setting: boolean): boolean
    /**
     * Set the 'USB Composition' field in the message.
     * @param value_usb_composition a #guint32.
     */
    set_usb_composition(value_usb_composition: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageGasDmsSetUsbCompositionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageGasDmsSetUsbCompositionInput
}
class MessageGasDmsSetUsbCompositionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageGasDmsSetUsbCompositionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGasDmsSetUsbCompositionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageGmsTestGetValueOutput {
    /* Methods of Qmi-1.0.Qmi.MessageGmsTestGetValueOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Test Mandatory Value' field from `self`.
     */
    get_test_mandatory_value(): [ /* returnType */ boolean, /* value_test_mandatory_value */ number | null ]
    /**
     * Get the 'Test Optional Value' field from `self`.
     */
    get_test_optional_value(): [ /* returnType */ boolean, /* value_test_optional_value */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGmsTestGetValueOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageGmsTestSetValueInput {
    /* Methods of Qmi-1.0.Qmi.MessageGmsTestSetValueInput */
    /**
     * Get the 'Test Mandatory Value' field from `self`.
     */
    get_test_mandatory_value(): [ /* returnType */ boolean, /* value_test_mandatory_value */ number | null ]
    /**
     * Get the 'Test Optional Value' field from `self`.
     */
    get_test_optional_value(): [ /* returnType */ boolean, /* value_test_optional_value */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGmsTestSetValueInput
    /**
     * Set the 'Test Mandatory Value' field in the message.
     * @param value_test_mandatory_value a #guint8.
     */
    set_test_mandatory_value(value_test_mandatory_value: number): boolean
    /**
     * Set the 'Test Optional Value' field in the message.
     * @param value_test_optional_value a #guint8.
     */
    set_test_optional_value(value_test_optional_value: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageGmsTestSetValueInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageGmsTestSetValueInput
}
class MessageGmsTestSetValueOutput {
    /* Methods of Qmi-1.0.Qmi.MessageGmsTestSetValueOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageGmsTestSetValueOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocDeleteAssistanceDataInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocDeleteAssistanceDataInput */
    /**
     * Get the 'Delete All' field from `self`.
     */
    get_delete_all(): [ /* returnType */ boolean, /* value_delete_all */ boolean | null ]
    /**
     * Get the 'Delete Cell Database Mask' field from `self`.
     */
    get_delete_cell_database_mask(): [ /* returnType */ boolean, /* value_delete_cell_database_mask */ LocDeleteCellDatabase | null ]
    /**
     * Get the 'Delete Clock Info Mask' field from `self`.
     */
    get_delete_clock_info_mask(): [ /* returnType */ boolean, /* value_delete_clock_info_mask */ LocDeleteClockInfo | null ]
    /**
     * Get the 'Delete GNSS Data Mask' field from `self`.
     */
    get_delete_gnss_data_mask(): [ /* returnType */ boolean, /* value_delete_gnss_data_mask */ LocDeleteGnssData | null ]
    /**
     * Get the 'Delete SV Info' field from `self`.
     * 
     * Version of qmi_message_loc_delete_assistance_data_input_get_delete_sv_info() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_delete_sv_info(): [ /* returnType */ boolean, /* value_delete_sv_info_ptr */ MessageLocDeleteAssistanceDataInputDeleteSvInfoElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocDeleteAssistanceDataInput
    /**
     * Set the 'Delete All' field in the message.
     * @param value_delete_all a #gboolean.
     */
    set_delete_all(value_delete_all: boolean): boolean
    /**
     * Set the 'Delete Cell Database Mask' field in the message.
     * @param value_delete_cell_database_mask a #QmiLocDeleteCellDatabase.
     */
    set_delete_cell_database_mask(value_delete_cell_database_mask: LocDeleteCellDatabase): boolean
    /**
     * Set the 'Delete Clock Info Mask' field in the message.
     * @param value_delete_clock_info_mask a #QmiLocDeleteClockInfo.
     */
    set_delete_clock_info_mask(value_delete_clock_info_mask: LocDeleteClockInfo): boolean
    /**
     * Set the 'Delete GNSS Data Mask' field in the message.
     * @param value_delete_gnss_data_mask a #QmiLocDeleteGnssData.
     */
    set_delete_gnss_data_mask(value_delete_gnss_data_mask: LocDeleteGnssData): boolean
    /**
     * Set the 'Delete SV Info' field in the message.
     * @param value_delete_sv_info_ptr array of #QmiMessageLocDeleteAssistanceDataInputDeleteSvInfoElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_delete_sv_info(value_delete_sv_info_ptr: MessageLocDeleteAssistanceDataInputDeleteSvInfoElement[]): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocDeleteAssistanceDataInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocDeleteAssistanceDataInput
}
class MessageLocDeleteAssistanceDataInputDeleteSvInfoElement {
    /* Fields of Qmi-1.0.Qmi.MessageLocDeleteAssistanceDataInputDeleteSvInfoElement */
    /**
     * a #guint16.
     */
    gnss_sv_id: number
    /**
     * a #QmiLocSystem.
     */
    system: LocSystem
    /**
     * a #QmiLocDeleteSvInfo.
     */
    delete_sv_info_mask: LocDeleteSvInfo
    static name: string
}
class MessageLocDeleteAssistanceDataOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocDeleteAssistanceDataOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocDeleteAssistanceDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocGetEngineLockOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocGetEngineLockOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocGetEngineLockOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocGetNmeaTypesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocGetNmeaTypesOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocGetNmeaTypesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocGetOperationModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocGetOperationModeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocGetOperationModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocGetPredictedOrbitsDataSourceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocGetPredictedOrbitsDataSourceOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocGetPredictedOrbitsDataSourceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocGetServerInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocGetServerInput */
    /**
     * Get the 'Server Address Type' field from `self`.
     */
    get_server_address_type(): [ /* returnType */ boolean, /* value_server_address_type */ LocServerAddressType | null ]
    /**
     * Get the 'Server Type' field from `self`.
     */
    get_server_type(): [ /* returnType */ boolean, /* value_server_type */ LocServerType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocGetServerInput
    /**
     * Set the 'Server Address Type' field in the message.
     * @param value_server_address_type a #QmiLocServerAddressType.
     */
    set_server_address_type(value_server_address_type: LocServerAddressType): boolean
    /**
     * Set the 'Server Type' field in the message.
     * @param value_server_type a #QmiLocServerType.
     */
    set_server_type(value_server_type: LocServerType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocGetServerInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocGetServerInput
}
class MessageLocGetServerOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocGetServerOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocGetServerOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocInjectPredictedOrbitsDataInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocInjectPredictedOrbitsDataInput */
    /**
     * Get the 'Format Type' field from `self`.
     */
    get_format_type(): [ /* returnType */ boolean, /* value_format_type */ LocPredictedOrbitsDataFormat | null ]
    /**
     * Get the 'Part Data' field from `self`.
     */
    get_part_data(): [ /* returnType */ boolean, /* value_part_data */ Uint8Array | null ]
    /**
     * Get the 'Part Number' field from `self`.
     */
    get_part_number(): [ /* returnType */ boolean, /* value_part_number */ number | null ]
    /**
     * Get the 'Total Parts' field from `self`.
     */
    get_total_parts(): [ /* returnType */ boolean, /* value_total_parts */ number | null ]
    /**
     * Get the 'Total Size' field from `self`.
     */
    get_total_size(): [ /* returnType */ boolean, /* value_total_size */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocInjectPredictedOrbitsDataInput
    /**
     * Set the 'Format Type' field in the message.
     * @param value_format_type a #QmiLocPredictedOrbitsDataFormat.
     */
    set_format_type(value_format_type: LocPredictedOrbitsDataFormat): boolean
    /**
     * Set the 'Part Data' field in the message.
     * @param value_part_data a #GArray of #guint8 elements. A new reference to `value_part_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_part_data(value_part_data: Uint8Array): boolean
    /**
     * Set the 'Part Number' field in the message.
     * @param value_part_number a #guint16.
     */
    set_part_number(value_part_number: number): boolean
    /**
     * Set the 'Total Parts' field in the message.
     * @param value_total_parts a #guint16.
     */
    set_total_parts(value_total_parts: number): boolean
    /**
     * Set the 'Total Size' field in the message.
     * @param value_total_size a #guint32.
     */
    set_total_size(value_total_size: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocInjectPredictedOrbitsDataInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocInjectPredictedOrbitsDataInput
}
class MessageLocInjectPredictedOrbitsDataOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocInjectPredictedOrbitsDataOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocInjectPredictedOrbitsDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocInjectXtraDataInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocInjectXtraDataInput */
    /**
     * Get the 'Part Data' field from `self`.
     */
    get_part_data(): [ /* returnType */ boolean, /* value_part_data */ Uint8Array | null ]
    /**
     * Get the 'Part Number' field from `self`.
     */
    get_part_number(): [ /* returnType */ boolean, /* value_part_number */ number | null ]
    /**
     * Get the 'Total Parts' field from `self`.
     */
    get_total_parts(): [ /* returnType */ boolean, /* value_total_parts */ number | null ]
    /**
     * Get the 'Total Size' field from `self`.
     */
    get_total_size(): [ /* returnType */ boolean, /* value_total_size */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocInjectXtraDataInput
    /**
     * Set the 'Part Data' field in the message.
     * @param value_part_data a #GArray of #guint8 elements. A new reference to `value_part_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_part_data(value_part_data: Uint8Array): boolean
    /**
     * Set the 'Part Number' field in the message.
     * @param value_part_number a #guint16.
     */
    set_part_number(value_part_number: number): boolean
    /**
     * Set the 'Total Parts' field in the message.
     * @param value_total_parts a #guint16.
     */
    set_total_parts(value_total_parts: number): boolean
    /**
     * Set the 'Total Size' field in the message.
     * @param value_total_size a #guint32.
     */
    set_total_size(value_total_size: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocInjectXtraDataInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocInjectXtraDataInput
}
class MessageLocInjectXtraDataOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocInjectXtraDataOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocInjectXtraDataOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocRegisterEventsInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocRegisterEventsInput */
    /**
     * Get the 'Event Registration Mask' field from `self`.
     */
    get_event_registration_mask(): [ /* returnType */ boolean, /* value_event_registration_mask */ LocEventRegistrationFlag | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocRegisterEventsInput
    /**
     * Set the 'Event Registration Mask' field in the message.
     * @param value_event_registration_mask a #QmiLocEventRegistrationFlag.
     */
    set_event_registration_mask(value_event_registration_mask: LocEventRegistrationFlag): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocRegisterEventsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocRegisterEventsInput
}
class MessageLocRegisterEventsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocRegisterEventsOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocRegisterEventsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocSetEngineLockInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetEngineLockInput */
    /**
     * Get the 'Lock Type' field from `self`.
     */
    get_lock_type(): [ /* returnType */ boolean, /* value_lock_type */ LocLockType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetEngineLockInput
    /**
     * Set the 'Lock Type' field in the message.
     * @param value_lock_type a #QmiLocLockType.
     */
    set_lock_type(value_lock_type: LocLockType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocSetEngineLockInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocSetEngineLockInput
}
class MessageLocSetEngineLockOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetEngineLockOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetEngineLockOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocSetNmeaTypesInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetNmeaTypesInput */
    /**
     * Get the 'NMEA Types' field from `self`.
     */
    get_nmea_types(): [ /* returnType */ boolean, /* value_nmea_types */ LocNmeaType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetNmeaTypesInput
    /**
     * Set the 'NMEA Types' field in the message.
     * @param value_nmea_types a #QmiLocNmeaType.
     */
    set_nmea_types(value_nmea_types: LocNmeaType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocSetNmeaTypesInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocSetNmeaTypesInput
}
class MessageLocSetNmeaTypesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetNmeaTypesOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetNmeaTypesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocSetOperationModeInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetOperationModeInput */
    /**
     * Get the 'Operation Mode' field from `self`.
     */
    get_operation_mode(): [ /* returnType */ boolean, /* value_operation_mode */ LocOperationMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetOperationModeInput
    /**
     * Set the 'Operation Mode' field in the message.
     * @param value_operation_mode a #QmiLocOperationMode.
     */
    set_operation_mode(value_operation_mode: LocOperationMode): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocSetOperationModeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocSetOperationModeInput
}
class MessageLocSetOperationModeOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetOperationModeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetOperationModeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocSetServerInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetServerInput */
    /**
     * Get the 'IPv4' field from `self`.
     */
    get_ipv4(): [ /* returnType */ boolean, /* value_ipv4_ipv4_address */ number | null, /* value_ipv4_ipv4_port */ number | null ]
    /**
     * Get the 'IPv6' field from `self`.
     */
    get_ipv6(): [ /* returnType */ boolean, /* value_ipv6_ipv6_address */ number[] | null, /* value_ipv6_ipv6_port */ number | null ]
    /**
     * Get the 'Server Type' field from `self`.
     */
    get_server_type(): [ /* returnType */ boolean, /* value_server_type */ LocServerType | null ]
    /**
     * Get the 'URL' field from `self`.
     */
    get_url(): [ /* returnType */ boolean, /* value_url */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetServerInput
    /**
     * Set the 'IPv4' field in the message.
     * @param value_ipv4_ipv4_address a #guint32.
     * @param value_ipv4_ipv4_port a #guint16.
     */
    set_ipv4(value_ipv4_ipv4_address: number, value_ipv4_ipv4_port: number): boolean
    /**
     * Set the 'IPv6' field in the message.
     * @param value_ipv6_ipv6_address a #GArray of #guint16 elements. A new reference to `value_ipv6`_ipv6_address will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     * @param value_ipv6_ipv6_port a #guint32.
     */
    set_ipv6(value_ipv6_ipv6_address: number[], value_ipv6_ipv6_port: number): boolean
    /**
     * Set the 'Server Type' field in the message.
     * @param value_server_type a #QmiLocServerType.
     */
    set_server_type(value_server_type: LocServerType): boolean
    /**
     * Set the 'URL' field in the message.
     * @param value_url a constant string with a maximum length of 256 characters.
     */
    set_url(value_url: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocSetServerInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocSetServerInput
}
class MessageLocSetServerOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocSetServerOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocSetServerOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocStartInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocStartInput */
    /**
     * Get the 'Fix Recurrence Type' field from `self`.
     */
    get_fix_recurrence_type(): [ /* returnType */ boolean, /* value_fix_recurrence_type */ LocFixRecurrenceType | null ]
    /**
     * Get the 'Intermediate Report State' field from `self`.
     */
    get_intermediate_report_state(): [ /* returnType */ boolean, /* value_intermediate_report_state */ LocIntermediateReportState | null ]
    /**
     * Get the 'Minimum Interval between Position Reports' field from `self`.
     */
    get_minimum_interval_between_position_reports(): [ /* returnType */ boolean, /* value_minimum_interval_between_position_reports */ number | null ]
    /**
     * Get the 'Session ID' field from `self`.
     */
    get_session_id(): [ /* returnType */ boolean, /* value_session_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocStartInput
    /**
     * Set the 'Fix Recurrence Type' field in the message.
     * @param value_fix_recurrence_type a #QmiLocFixRecurrenceType.
     */
    set_fix_recurrence_type(value_fix_recurrence_type: LocFixRecurrenceType): boolean
    /**
     * Set the 'Intermediate Report State' field in the message.
     * @param value_intermediate_report_state a #QmiLocIntermediateReportState.
     */
    set_intermediate_report_state(value_intermediate_report_state: LocIntermediateReportState): boolean
    /**
     * Set the 'Minimum Interval between Position Reports' field in the message.
     * @param value_minimum_interval_between_position_reports a #guint32.
     */
    set_minimum_interval_between_position_reports(value_minimum_interval_between_position_reports: number): boolean
    /**
     * Set the 'Session ID' field in the message.
     * @param value_session_id a #guint8.
     */
    set_session_id(value_session_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocStartInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocStartInput
}
class MessageLocStartOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocStartOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocStartOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageLocStopInput {
    /* Methods of Qmi-1.0.Qmi.MessageLocStopInput */
    /**
     * Get the 'Session ID' field from `self`.
     */
    get_session_id(): [ /* returnType */ boolean, /* value_session_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocStopInput
    /**
     * Set the 'Session ID' field in the message.
     * @param value_session_id a #guint8.
     */
    set_session_id(value_session_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageLocStopInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageLocStopInput
}
class MessageLocStopOutput {
    /* Methods of Qmi-1.0.Qmi.MessageLocStopOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageLocStopOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasAttachDetachInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasAttachDetachInput */
    /**
     * Get the 'Action' field from `self`.
     */
    get_action(): [ /* returnType */ boolean, /* value_action */ NasPsAttachAction | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasAttachDetachInput
    /**
     * Set the 'Action' field in the message.
     * @param value_action a #QmiNasPsAttachAction.
     */
    set_action(value_action: NasPsAttachAction): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasAttachDetachInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasAttachDetachInput
}
class MessageNasAttachDetachOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasAttachDetachOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasAttachDetachOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasConfigSignalInfoInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasConfigSignalInfoInput */
    /**
     * Get the 'ECIO Threshold' field from `self`.
     */
    get_ecio_threshold(): [ /* returnType */ boolean, /* value_ecio_threshold */ number[] | null ]
    /**
     * Get the 'IO Threshold' field from `self`.
     */
    get_io_threshold(): [ /* returnType */ boolean, /* value_io_threshold */ number[] | null ]
    /**
     * Get the 'LTE Report' field from `self`.
     */
    get_lte_report(): [ /* returnType */ boolean, /* value_lte_report_rate */ number | null, /* value_lte_report_average_period */ number | null ]
    /**
     * Get the 'LTE SNR Threshold' field from `self`.
     */
    get_lte_snr_threshold(): [ /* returnType */ boolean, /* value_lte_snr_threshold */ number[] | null ]
    /**
     * Get the 'RSCP Threshold' field from `self`.
     */
    get_rscp_threshold(): [ /* returnType */ boolean, /* value_rscp_threshold */ Uint8Array | null ]
    /**
     * Get the 'RSRP Threshold' field from `self`.
     */
    get_rsrp_threshold(): [ /* returnType */ boolean, /* value_rsrp_threshold */ number[] | null ]
    /**
     * Get the 'RSRQ Threshold' field from `self`.
     */
    get_rsrq_threshold(): [ /* returnType */ boolean, /* value_rsrq_threshold */ Uint8Array | null ]
    /**
     * Get the 'RSSI Threshold' field from `self`.
     */
    get_rssi_threshold(): [ /* returnType */ boolean, /* value_rssi_threshold */ Uint8Array | null ]
    /**
     * Get the 'SINR Threshold' field from `self`.
     */
    get_sinr_threshold(): [ /* returnType */ boolean, /* value_sinr_threshold */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasConfigSignalInfoInput
    /**
     * Set the 'ECIO Threshold' field in the message.
     * @param value_ecio_threshold a #GArray of #gint16 elements. A new reference to `value_ecio_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ecio_threshold(value_ecio_threshold: number[]): boolean
    /**
     * Set the 'IO Threshold' field in the message.
     * @param value_io_threshold a #GArray of #gint32 elements. A new reference to `value_io_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_io_threshold(value_io_threshold: number[]): boolean
    /**
     * Set the 'LTE Report' field in the message.
     * @param value_lte_report_rate a #guint8.
     * @param value_lte_report_average_period a #guint8.
     */
    set_lte_report(value_lte_report_rate: number, value_lte_report_average_period: number): boolean
    /**
     * Set the 'LTE SNR Threshold' field in the message.
     * @param value_lte_snr_threshold a #GArray of #gint16 elements. A new reference to `value_lte_snr_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_lte_snr_threshold(value_lte_snr_threshold: number[]): boolean
    /**
     * Set the 'RSCP Threshold' field in the message.
     * @param value_rscp_threshold a #GArray of #gint8 elements. A new reference to `value_rscp_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_rscp_threshold(value_rscp_threshold: Uint8Array): boolean
    /**
     * Set the 'RSRP Threshold' field in the message.
     * @param value_rsrp_threshold a #GArray of #gint16 elements. A new reference to `value_rsrp_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_rsrp_threshold(value_rsrp_threshold: number[]): boolean
    /**
     * Set the 'RSRQ Threshold' field in the message.
     * @param value_rsrq_threshold a #GArray of #gint8 elements. A new reference to `value_rsrq_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_rsrq_threshold(value_rsrq_threshold: Uint8Array): boolean
    /**
     * Set the 'RSSI Threshold' field in the message.
     * @param value_rssi_threshold a #GArray of #gint8 elements. A new reference to `value_rssi_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_rssi_threshold(value_rssi_threshold: Uint8Array): boolean
    /**
     * Set the 'SINR Threshold' field in the message.
     * @param value_sinr_threshold a #GArray of #guint8 elements. A new reference to `value_sinr_threshold` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_sinr_threshold(value_sinr_threshold: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasConfigSignalInfoInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasConfigSignalInfoInput
}
class MessageNasConfigSignalInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasConfigSignalInfoOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasConfigSignalInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasForceNetworkSearchOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasForceNetworkSearchOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasForceNetworkSearchOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetCdmaPositionInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetCdmaPositionInfoOutput */
    /**
     * Get the 'CDMA Position Info' field from `self`.
     * 
     * Version of qmi_message_nas_get_cdma_position_info_output_get_cdma_position_info() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_cdma_position_info(): [ /* returnType */ boolean, /* value_cdma_position_info_ui_in_idle_mode */ number | null, /* value_cdma_position_info_basestations_ptr */ MessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetCdmaPositionInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation */
    /**
     * a #QmiNasCdmaPilotType.
     */
    pilot_type: NasCdmaPilotType
    /**
     * a #guint16.
     */
    system_id: number
    /**
     * a #guint16.
     */
    network_id: number
    /**
     * a #guint16.
     */
    base_station_id: number
    /**
     * a #guint16.
     */
    pilot_pn: number
    /**
     * a #guint16.
     */
    pilot_strength: number
    /**
     * a #gint32.
     */
    latitude: number
    /**
     * a #gint32.
     */
    longitude: number
    /**
     * a #guint64.
     */
    gps_time_in_milliseconds: number
    static name: string
}
class MessageNasGetCellLocationInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutput */
    /**
     * Get the 'CDMA Info' field from `self`.
     */
    get_cdma_info(): [ /* returnType */ boolean, /* value_cdma_info_system_id */ number | null, /* value_cdma_info_network_id */ number | null, /* value_cdma_info_base_station_id */ number | null, /* value_cdma_info_reference_pn */ number | null, /* value_cdma_info_latitude */ number | null, /* value_cdma_info_longitude */ number | null ]
    get_compat_context(): object | null
    /**
     * Get the 'GERAN Info v2' field from `self`.
     * 
     * Version of qmi_message_nas_get_cell_location_info_output_get_geran_info_v2() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_geran_info_v2(): [ /* returnType */ boolean, /* value_geran_info_v2_cell_id */ number | null, /* value_geran_info_v2_plmn */ Uint8Array | null, /* value_geran_info_v2_lac */ number | null, /* value_geran_info_v2_geran_absolute_rf_channel_number */ number | null, /* value_geran_info_v2_base_station_identity_code */ number | null, /* value_geran_info_v2_timing_advance */ number | null, /* value_geran_info_v2_rx_level */ number | null, /* value_geran_info_v2_cell_ptr */ MessageNasGetCellLocationInfoOutputGeranInfoV2CellElement[] | null ]
    /**
     * Get the 'Interfrequency LTE Info' field from `self`.
     * 
     * Version of qmi_message_nas_get_cell_location_info_output_get_interfrequency_lte_info() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_interfrequency_lte_info(): [ /* returnType */ boolean, /* value_interfrequency_lte_info_ue_in_idle */ boolean | null, /* value_interfrequency_lte_info_frequency_ptr */ MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementGir[] | null ]
    /**
     * Get the 'Intrafrequency LTE Info v2' field from `self`.
     * 
     * Version of qmi_message_nas_get_cell_location_info_output_get_intrafrequency_lte_info_v2() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_intrafrequency_lte_info_v2(): [ /* returnType */ boolean, /* value_intrafrequency_lte_info_v2_ue_in_idle */ boolean | null, /* value_intrafrequency_lte_info_v2_plmn */ Uint8Array | null, /* value_intrafrequency_lte_info_v2_tracking_area_code */ number | null, /* value_intrafrequency_lte_info_v2_global_cell_id */ number | null, /* value_intrafrequency_lte_info_v2_eutra_absolute_rf_channel_number */ number | null, /* value_intrafrequency_lte_info_v2_serving_cell_id */ number | null, /* value_intrafrequency_lte_info_v2_cell_reselection_priority */ number | null, /* value_intrafrequency_lte_info_v2_s_non_intra_search_threshold */ number | null, /* value_intrafrequency_lte_info_v2_serving_cell_low_threshold */ number | null, /* value_intrafrequency_lte_info_v2_s_intra_search_threshold */ number | null, /* value_intrafrequency_lte_info_v2_cell_ptr */ MessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement[] | null ]
    /**
     * Get the 'LTE Info Neighboring GSM' field from `self`.
     * 
     * Version of qmi_message_nas_get_cell_location_info_output_get_lte_info_neighboring_gsm() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_lte_info_neighboring_gsm(): [ /* returnType */ boolean, /* value_lte_info_neighboring_gsm_ue_in_idle */ boolean | null, /* value_lte_info_neighboring_gsm_frequency_ptr */ MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementGir[] | null ]
    /**
     * Get the 'LTE Info Neighboring WCDMA' field from `self`.
     * 
     * Version of qmi_message_nas_get_cell_location_info_output_get_lte_info_neighboring_wcdma() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_lte_info_neighboring_wcdma(): [ /* returnType */ boolean, /* value_lte_info_neighboring_wcdma_ue_in_idle */ boolean | null, /* value_lte_info_neighboring_wcdma_frequency_ptr */ MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementGir[] | null ]
    /**
     * Get the 'LTE Info Timing Advance' field from `self`.
     */
    get_lte_info_timing_advance(): [ /* returnType */ boolean, /* value_lte_info_timing_advance */ number | null ]
    /**
     * Get the 'NR5G ARFCN' field from `self`.
     */
    get_nr5g_arfcn(): [ /* returnType */ boolean, /* value_nr5g_arfcn */ number | null ]
    /**
     * Get the 'NR5G Cell Information' field from `self`.
     */
    get_nr5g_cell_information(): [ /* returnType */ boolean, /* value_nr5g_cell_information_plmn */ Uint8Array | null, /* value_nr5g_cell_information_tracking_area_code */ Uint8Array | null, /* value_nr5g_cell_information_global_cell_id */ number | null, /* value_nr5g_cell_information_physical_cell_id */ number | null, /* value_nr5g_cell_information_rsrq */ number | null, /* value_nr5g_cell_information_rsrp */ number | null, /* value_nr5g_cell_information_snr */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'UMTS Cell ID' field from `self`.
     */
    get_umts_cell_id(): [ /* returnType */ boolean, /* value_umts_cell_id */ number | null ]
    /**
     * Get the 'UMTS Info Neighboring LTE' field from `self`.
     * 
     * Version of qmi_message_nas_get_cell_location_info_output_get_umts_info_neighboring_lte() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_umts_info_neighboring_lte(): [ /* returnType */ boolean, /* value_umts_info_neighboring_lte_rrc_state */ NasWcdmaRrcState | null, /* value_umts_info_neighboring_lte_frequency_ptr */ MessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement[] | null ]
    /**
     * Get the 'UMTS Info v2' field from `self`.
     * 
     * Version of qmi_message_nas_get_cell_location_info_output_get_umts_info_v2() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_umts_info_v2(): [ /* returnType */ boolean, /* value_umts_info_v2_cell_id */ number | null, /* value_umts_info_v2_plmn */ Uint8Array | null, /* value_umts_info_v2_lac */ number | null, /* value_umts_info_v2_utra_absolute_rf_channel_number */ number | null, /* value_umts_info_v2_primary_scrambling_code */ number | null, /* value_umts_info_v2_rscp */ number | null, /* value_umts_info_v2_ecio */ number | null, /* value_umts_info_v2_cell_ptr */ MessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement[] | null, /* value_umts_info_v2_neighboring_geran_ptr */ MessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetCellLocationInfoOutput
    set_compat_context(compat_context: object | null, compat_context_free: GLib.DestroyNotify): void
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetCellLocationInfoOutputGeranInfoV2CellElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputGeranInfoV2CellElement */
    /**
     * a #guint32.
     */
    cell_id: number
    /**
     * a #GArray of #guint8 elements.
     */
    plmn: object[]
    /**
     * a #guint16.
     */
    lac: number
    /**
     * a #guint16.
     */
    geran_absolute_rf_channel_number: number
    /**
     * a #guint8.
     */
    base_station_identity_code: number
    /**
     * a #guint16.
     */
    rx_level: number
    static name: string
}
class MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElement */
    /**
     * a #guint16.
     */
    eutra_absolute_rf_channel_number: number
    /**
     * a #guint8.
     */
    cell_selection_rx_level_low_threshold: number
    /**
     * a #guint8.
     */
    cell_selection_rx_level_high_threshold: number
    /**
     * a #guint8.
     */
    cell_reselection_priority: number
    /**
     * a #GArray of #QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement elements.
     */
    cell: object[]
    static name: string
}
class MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement */
    /**
     * a #guint16.
     */
    physical_cell_id: number
    /**
     * a #gint16.
     */
    rsrq: number
    /**
     * a #gint16.
     */
    rsrp: number
    /**
     * a #gint16.
     */
    rssi: number
    /**
     * a #gint16.
     */
    cell_selection_rx_level: number
    static name: string
}
class MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementGir {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementGir */
    /**
     * a #guint16.
     */
    eutra_absolute_rf_channel_number: number
    /**
     * a #guint8.
     */
    cell_selection_rx_level_low_threshold: number
    /**
     * a #guint8.
     */
    cell_selection_rx_level_high_threshold: number
    /**
     * a #guint8.
     */
    cell_reselection_priority: number
    /**
     * an array of #QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement elements.
     */
    cell: MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement[]
    static name: string
}
class MessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement */
    /**
     * a #guint16.
     */
    physical_cell_id: number
    /**
     * a #gint16.
     */
    rsrq: number
    /**
     * a #gint16.
     */
    rsrp: number
    /**
     * a #gint16.
     */
    rssi: number
    /**
     * a #gint16.
     */
    cell_selection_rx_level: number
    static name: string
}
class MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElement */
    /**
     * a #guint8.
     */
    cell_reselection_priority: number
    /**
     * a #guint8.
     */
    cell_reselection_high_threshold: number
    /**
     * a #guint8.
     */
    cell_reselection_low_threshold: number
    /**
     * a #guint8.
     */
    ncc_permitted: number
    /**
     * a #GArray of #QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement elements.
     */
    cell: object[]
    static name: string
}
class MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement */
    /**
     * a #guint16.
     */
    geran_absolute_rf_channel_number: number
    /**
     * a #gboolean.
     */
    band_is_1900: boolean
    /**
     * a #gboolean.
     */
    cell_id_valid: boolean
    /**
     * a #guint8.
     */
    base_station_identity_code: number
    /**
     * a #gint16.
     */
    rssi: number
    /**
     * a #gint16.
     */
    cell_selection_rx_level: number
    static name: string
}
class MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementGir {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementGir */
    /**
     * a #guint8.
     */
    cell_reselection_priority: number
    /**
     * a #guint8.
     */
    cell_reselection_high_threshold: number
    /**
     * a #guint8.
     */
    cell_reselection_low_threshold: number
    /**
     * a #guint8.
     */
    ncc_permitted: number
    /**
     * an array of #QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement elements.
     */
    cell: MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement[]
    static name: string
}
class MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElement */
    /**
     * a #guint16.
     */
    utra_absolute_rf_channel_number: number
    /**
     * a #guint8.
     */
    cell_reselection_priority: number
    /**
     * a #guint16.
     */
    cell_reselection_high_threshold: number
    /**
     * a #guint16.
     */
    cell_reselection_low_threshold: number
    /**
     * a #GArray of #QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement elements.
     */
    cell: object[]
    static name: string
}
class MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement */
    /**
     * a #guint16.
     */
    primary_scrambling_code: number
    /**
     * a #gint16.
     */
    cpich_rscp: number
    /**
     * a #gint16.
     */
    cpich_ecno: number
    /**
     * a #gint16.
     */
    cell_selection_rx_level: number
    static name: string
}
class MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementGir {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementGir */
    /**
     * a #guint16.
     */
    utra_absolute_rf_channel_number: number
    /**
     * a #guint8.
     */
    cell_reselection_priority: number
    /**
     * a #guint16.
     */
    cell_reselection_high_threshold: number
    /**
     * a #guint16.
     */
    cell_reselection_low_threshold: number
    /**
     * an array of #QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement elements.
     */
    cell: MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement[]
    static name: string
}
class MessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement */
    /**
     * a #guint16.
     */
    eutra_absolute_rf_channel_number: number
    /**
     * a #guint16.
     */
    physical_cell_id: number
    /**
     * a #gfloat.
     */
    rsrp: number
    /**
     * a #gfloat.
     */
    rsrq: number
    /**
     * a #gint16.
     */
    cell_selection_rx_level: number
    /**
     * a #gboolean.
     */
    is_tdd: boolean
    static name: string
}
class MessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement */
    /**
     * a #guint16.
     */
    utra_absolute_rf_channel_number: number
    /**
     * a #guint16.
     */
    primary_scrambling_code: number
    /**
     * a #gint16.
     */
    rscp: number
    /**
     * a #gint16.
     */
    ecio: number
    static name: string
}
class MessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement */
    /**
     * a #guint16.
     */
    geran_absolute_rf_channel_number: number
    /**
     * a #guint8.
     */
    network_color_code: number
    /**
     * a #guint8.
     */
    base_station_color_code: number
    /**
     * a #gint16.
     */
    rssi: number
    static name: string
}
class MessageNasGetDrxOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetDrxOutput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info */ NasDrx | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetDrxOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetHomeNetworkOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetHomeNetworkOutput */
    /**
     * Get the 'Home Network' field from `self`.
     */
    get_home_network(): [ /* returnType */ boolean, /* value_home_network_mcc */ number | null, /* value_home_network_mnc */ number | null, /* value_home_network_description */ string | null ]
    /**
     * Get the 'Home Network 3GPP2 Ext' field from `self`.
     */
    get_home_network_3gpp2_ext(): [ /* returnType */ boolean, /* value_home_network_3gpp2_ext_mcc */ number | null, /* value_home_network_3gpp2_ext_mnc */ number | null, /* value_home_network_3gpp2_ext_display_description */ NasNetworkDescriptionDisplay | null, /* value_home_network_3gpp2_ext_description_encoding */ NasNetworkDescriptionEncoding | null, /* value_home_network_3gpp2_ext_description */ Uint8Array | null ]
    /**
     * Get the 'Home Network 3GPP MNC' field from `self`.
     */
    get_home_network_3gpp_mnc(): [ /* returnType */ boolean, /* value_home_network_3gpp_mnc_is_3gpp */ boolean | null, /* value_home_network_3gpp_mnc_includes_pcs_digit */ boolean | null ]
    /**
     * Get the 'Home System ID' field from `self`.
     */
    get_home_system_id(): [ /* returnType */ boolean, /* value_home_system_id_sid */ number | null, /* value_home_system_id_nid */ number | null ]
    /**
     * Get the 'Network Name Source' field from `self`.
     */
    get_network_name_source(): [ /* returnType */ boolean, /* value_network_name_source */ NasNetworkNameSource | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetHomeNetworkOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetLteCphyCaInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetLteCphyCaInfoOutput */
    /**
     * Get the 'DL Bandwidth' field from `self`.
     */
    get_dl_bandwidth(): [ /* returnType */ boolean, /* value_dl_bandwidth */ NasDLBandwidth | null ]
    /**
     * Get the 'Phy CA Agg PCell Info' field from `self`.
     */
    get_phy_ca_agg_pcell_info(): [ /* returnType */ boolean, /* value_phy_ca_agg_pcell_info_physical_cell_id */ number | null, /* value_phy_ca_agg_pcell_info_rx_channel */ number | null, /* value_phy_ca_agg_pcell_info_dl_bandwidth */ NasDLBandwidth | null, /* value_phy_ca_agg_pcell_info_lte_band */ NasActiveBand | null ]
    /**
     * Get the 'Phy CA Agg SCell Info' field from `self`.
     */
    get_phy_ca_agg_scell_info(): [ /* returnType */ boolean, /* value_phy_ca_agg_scell_info_physical_cell_id */ number | null, /* value_phy_ca_agg_scell_info_rx_channel */ number | null, /* value_phy_ca_agg_scell_info_dl_bandwidth */ NasDLBandwidth | null, /* value_phy_ca_agg_scell_info_lte_band */ NasActiveBand | null, /* value_phy_ca_agg_scell_info_state */ NasScellState | null ]
    /**
     * Get the 'Phy CA Agg Secondary Cells' field from `self`.
     * 
     * Version of qmi_message_nas_get_lte_cphy_ca_info_output_get_phy_ca_agg_secondary_cells() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_phy_ca_agg_secondary_cells(): [ /* returnType */ boolean, /* value_phy_ca_agg_secondary_cells_ptr */ MessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'SCell index' field from `self`.
     */
    get_scell_index(): [ /* returnType */ boolean, /* value_scell_index */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetLteCphyCaInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc */
    /**
     * a #guint16.
     */
    physical_cell_id: number
    /**
     * a #guint16.
     */
    rx_channel: number
    /**
     * a #QmiNasDLBandwidth.
     */
    dl_bandwidth: NasDLBandwidth
    /**
     * a #QmiNasActiveBand.
     */
    lte_band: NasActiveBand
    /**
     * a #QmiNasScellState.
     */
    state: NasScellState
    /**
     * a #guint8.
     */
    cell_index: number
    static name: string
}
class MessageNasGetOperatorNameOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetOperatorNameOutput */
    /**
     * Get the 'NITZ Information' field from `self`.
     */
    get_nitz_information(): [ /* returnType */ boolean, /* value_nitz_information_name_encoding */ NasPlmnEncodingScheme | null, /* value_nitz_information_short_country_initials */ NasPlmnNameCountryInitials | null, /* value_nitz_information_long_name_spare_bits */ NasPlmnNameSpareBits | null, /* value_nitz_information_short_name_spare_bits */ NasPlmnNameSpareBits | null, /* value_nitz_information_long_name */ Uint8Array | null, /* value_nitz_information_short_name */ Uint8Array | null ]
    /**
     * Get the 'Operator PLMN List' field from `self`.
     * 
     * Version of qmi_message_nas_get_operator_name_output_get_operator_plmn_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_operator_plmn_list(): [ /* returnType */ boolean, /* value_operator_plmn_list_ptr */ MessageNasGetOperatorNameOutputOperatorPlmnListElement[] | null ]
    /**
     * Get the 'Operator PLMN Name' field from `self`.
     * 
     * Version of qmi_message_nas_get_operator_name_output_get_operator_plmn_name() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_operator_plmn_name(): [ /* returnType */ boolean, /* value_operator_plmn_name_ptr */ MessageNasGetOperatorNameOutputOperatorPlmnNameElement[] | null ]
    /**
     * Get the 'Operator String Name' field from `self`.
     */
    get_operator_string_name(): [ /* returnType */ boolean, /* value_operator_string_name */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Service Provider Name' field from `self`.
     */
    get_service_provider_name(): [ /* returnType */ boolean, /* value_service_provider_name_name_display_condition */ NasNetworkNameDisplayCondition | null, /* value_service_provider_name_name */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetOperatorNameOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetOperatorNameOutputOperatorPlmnListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetOperatorNameOutputOperatorPlmnListElement */
    /**
     * a string of exactly 3 characters.
     */
    mcc: string
    /**
     * a string of exactly 3 characters.
     */
    mnc: string
    /**
     * a #guint16.
     */
    lac1: number
    /**
     * a #guint16.
     */
    lac2: number
    /**
     * a #guint8.
     */
    plmn_name_record_identifier: number
    static name: string
}
class MessageNasGetOperatorNameOutputOperatorPlmnNameElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetOperatorNameOutputOperatorPlmnNameElement */
    /**
     * a #QmiNasPlmnEncodingScheme.
     */
    name_encoding: NasPlmnEncodingScheme
    /**
     * a #QmiNasPlmnNameCountryInitials.
     */
    short_country_initials: NasPlmnNameCountryInitials
    /**
     * a #QmiNasPlmnNameSpareBits.
     */
    long_name_spare_bits: NasPlmnNameSpareBits
    /**
     * a #QmiNasPlmnNameSpareBits.
     */
    short_name_spare_bits: NasPlmnNameSpareBits
    /**
     * a #GArray of #guint8 elements.
     */
    long_name: object[]
    /**
     * a #GArray of #guint8 elements.
     */
    short_name: object[]
    static name: string
}
class MessageNasGetPlmnNameInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetPlmnNameInput */
    /**
     * Get the 'Always Send PLMN Name' field from `self`.
     */
    get_always_send_plmn_name(): [ /* returnType */ boolean, /* value_always_send_plmn_name */ boolean | null ]
    /**
     * Get the 'CSG ID' field from `self`.
     */
    get_csg_id(): [ /* returnType */ boolean, /* value_csg_id */ number | null ]
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status */ boolean | null ]
    /**
     * Get the 'PLMN' field from `self`.
     */
    get_plmn(): [ /* returnType */ boolean, /* value_plmn_mcc */ number | null, /* value_plmn_mnc */ number | null ]
    /**
     * Get the 'Radio Access Technology' field from `self`.
     */
    get_radio_access_technology(): [ /* returnType */ boolean, /* value_radio_access_technology */ NasRadioInterface | null ]
    /**
     * Get the 'Send All Information' field from `self`.
     */
    get_send_all_information(): [ /* returnType */ boolean, /* value_send_all_information */ boolean | null ]
    /**
     * Get the 'Suppress SIM Error' field from `self`.
     */
    get_suppress_sim_error(): [ /* returnType */ boolean, /* value_suppress_sim_error */ boolean | null ]
    /**
     * Get the 'Use Static Table Only' field from `self`.
     */
    get_use_static_table_only(): [ /* returnType */ boolean, /* value_use_static_table_only */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetPlmnNameInput
    /**
     * Set the 'Always Send PLMN Name' field in the message.
     * @param value_always_send_plmn_name a #gboolean.
     */
    set_always_send_plmn_name(value_always_send_plmn_name: boolean): boolean
    /**
     * Set the 'CSG ID' field in the message.
     * @param value_csg_id a #guint32.
     */
    set_csg_id(value_csg_id: number): boolean
    /**
     * Set the 'MNC PCS Digit Include Status' field in the message.
     * @param value_mnc_pcs_digit_include_status a #gboolean.
     */
    set_mnc_pcs_digit_include_status(value_mnc_pcs_digit_include_status: boolean): boolean
    /**
     * Set the 'PLMN' field in the message.
     * @param value_plmn_mcc a #guint16.
     * @param value_plmn_mnc a #guint16.
     */
    set_plmn(value_plmn_mcc: number, value_plmn_mnc: number): boolean
    /**
     * Set the 'Radio Access Technology' field in the message.
     * @param value_radio_access_technology a #QmiNasRadioInterface.
     */
    set_radio_access_technology(value_radio_access_technology: NasRadioInterface): boolean
    /**
     * Set the 'Send All Information' field in the message.
     * @param value_send_all_information a #gboolean.
     */
    set_send_all_information(value_send_all_information: boolean): boolean
    /**
     * Set the 'Suppress SIM Error' field in the message.
     * @param value_suppress_sim_error a #gboolean.
     */
    set_suppress_sim_error(value_suppress_sim_error: boolean): boolean
    /**
     * Set the 'Use Static Table Only' field in the message.
     * @param value_use_static_table_only a #gboolean.
     */
    set_use_static_table_only(value_use_static_table_only: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasGetPlmnNameInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasGetPlmnNameInput
}
class MessageNasGetPlmnNameOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetPlmnNameOutput */
    /**
     * Get the '3GPP EONS PLMN Name' field from `self`.
     */
    get_3gpp_eons_plmn_name(): [ /* returnType */ boolean, /* value_3gpp_eons_plmn_name_service_provider_name_encoding */ NasNetworkDescriptionEncoding | null, /* value_3gpp_eons_plmn_name_service_provider_name */ Uint8Array | null, /* value_3gpp_eons_plmn_name_short_name_encoding */ NasNetworkDescriptionEncoding | null, /* value_3gpp_eons_plmn_name_short_name_country_initials */ NasPlmnNameCountryInitials | null, /* value_3gpp_eons_plmn_name_short_name_spare_bits */ NasPlmnNameSpareBits | null, /* value_3gpp_eons_plmn_name_short_name */ Uint8Array | null, /* value_3gpp_eons_plmn_name_long_name_encoding */ NasNetworkDescriptionEncoding | null, /* value_3gpp_eons_plmn_name_long_name_country_initials */ NasPlmnNameCountryInitials | null, /* value_3gpp_eons_plmn_name_long_name_spare_bits */ NasPlmnNameSpareBits | null, /* value_3gpp_eons_plmn_name_long_name */ Uint8Array | null ]
    /**
     * Get the 'Additional Information' field from `self`.
     */
    get_additional_information(): [ /* returnType */ boolean, /* value_additional_information */ number[] | null ]
    /**
     * Get the 'Display Bit Information' field from `self`.
     */
    get_display_bit_information(): [ /* returnType */ boolean, /* value_display_bit_information_service_provider_name_set */ NasBoolean | null, /* value_display_bit_information_plmn_name_set */ NasBoolean | null ]
    /**
     * Get the 'Network Information' field from `self`.
     */
    get_network_information(): [ /* returnType */ boolean, /* value_network_information */ NasBoolean | null ]
    /**
     * Get the 'Network Name Source' field from `self`.
     */
    get_network_name_source(): [ /* returnType */ boolean, /* value_network_name_source */ NasNetworkNameSource | null ]
    /**
     * Get the 'PLMN Name With Language Id' field from `self`.
     * 
     * Version of qmi_message_nas_get_plmn_name_output_get_plmn_name_with_language_id() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_plmn_name_with_language_id(): [ /* returnType */ boolean, /* value_plmn_name_with_language_id_ptr */ MessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetPlmnNameOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement */
    /**
     * a #GArray of #guint16 elements.
     */
    long_name: object[]
    /**
     * a #GArray of #guint16 elements.
     */
    short_name: object[]
    /**
     * a #QmiNasPlmnLanguageId.
     */
    language_id: NasPlmnLanguageId
    static name: string
}
class MessageNasGetPreferredNetworksOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetPreferredNetworksOutput */
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     * 
     * Version of qmi_message_nas_get_preferred_networks_output_get_mnc_pcs_digit_include_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status_ptr */ MessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement[] | null ]
    /**
     * Get the 'Preferred Networks' field from `self`.
     * 
     * Version of qmi_message_nas_get_preferred_networks_output_get_preferred_networks() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_preferred_networks(): [ /* returnType */ boolean, /* value_preferred_networks_ptr */ MessageNasGetPreferredNetworksOutputPreferredNetworksElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetPreferredNetworksOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement */
    /**
     * a #guint16.
     */
    mcc: number
    /**
     * a #guint16.
     */
    mnc: number
    /**
     * a #gboolean.
     */
    includes_pcs_digit: boolean
    static name: string
}
class MessageNasGetPreferredNetworksOutputPreferredNetworksElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetPreferredNetworksOutputPreferredNetworksElement */
    /**
     * a #guint16.
     */
    mcc: number
    /**
     * a #guint16.
     */
    mnc: number
    /**
     * a #QmiNasPlmnAccessTechnologyIdentifier.
     */
    radio_access_technology: NasPlmnAccessTechnologyIdentifier
    static name: string
}
class MessageNasGetRfBandInformationOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetRfBandInformationOutput */
    /**
     * Get the 'Bandwidth List' field from `self`.
     * 
     * Version of qmi_message_nas_get_rf_band_information_output_get_bandwidth_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_bandwidth_list(): [ /* returnType */ boolean, /* value_bandwidth_list_ptr */ MessageNasGetRfBandInformationOutputBandwidthListElement[] | null ]
    /**
     * Get the 'Extended List' field from `self`.
     * 
     * Version of qmi_message_nas_get_rf_band_information_output_get_extended_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_extended_list(): [ /* returnType */ boolean, /* value_extended_list_ptr */ MessageNasGetRfBandInformationOutputExtendedListElement[] | null ]
    /**
     * Get the 'List' field from `self`.
     * 
     * Version of qmi_message_nas_get_rf_band_information_output_get_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_list(): [ /* returnType */ boolean, /* value_list_ptr */ MessageNasGetRfBandInformationOutputListElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetRfBandInformationOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetRfBandInformationOutputBandwidthListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetRfBandInformationOutputBandwidthListElement */
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    /**
     * a #QmiNasDLBandwidth.
     */
    bandwidth: NasDLBandwidth
    static name: string
}
class MessageNasGetRfBandInformationOutputExtendedListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetRfBandInformationOutputExtendedListElement */
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    /**
     * a #QmiNasActiveBand.
     */
    active_band_class: NasActiveBand
    /**
     * a #guint32.
     */
    active_channel: number
    static name: string
}
class MessageNasGetRfBandInformationOutputListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetRfBandInformationOutputListElement */
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    /**
     * a #QmiNasActiveBand.
     */
    active_band_class: NasActiveBand
    /**
     * a #guint16.
     */
    active_channel: number
    static name: string
}
class MessageNasGetServingSystemOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetServingSystemOutput */
    /**
     * Get the 'Call Barring Status' field from `self`.
     */
    get_call_barring_status(): [ /* returnType */ boolean, /* value_call_barring_status_cs_status */ NasCallBarringStatus | null, /* value_call_barring_status_ps_status */ NasCallBarringStatus | null ]
    /**
     * Get the 'CDMA Base Station Info' field from `self`.
     */
    get_cdma_base_station_info(): [ /* returnType */ boolean, /* value_cdma_base_station_info_base_station_id */ number | null, /* value_cdma_base_station_info_base_station_latitude */ number | null, /* value_cdma_base_station_info_base_station_longitude */ number | null ]
    /**
     * Get the 'CDMA P Rev' field from `self`.
     */
    get_cdma_p_rev(): [ /* returnType */ boolean, /* value_cdma_p_rev */ number | null ]
    /**
     * Get the 'CDMA System ID' field from `self`.
     */
    get_cdma_system_id(): [ /* returnType */ boolean, /* value_cdma_system_id_sid */ number | null, /* value_cdma_system_id_nid */ number | null ]
    /**
     * Get the 'CDMA System Info' field from `self`.
     */
    get_cdma_system_info(): [ /* returnType */ boolean, /* value_cdma_system_info_mcc */ number | null, /* value_cdma_system_info_imsi_11_12 */ number | null ]
    /**
     * Get the 'CID 3GPP' field from `self`.
     */
    get_cid_3gpp(): [ /* returnType */ boolean, /* value_cid_3gpp */ number | null ]
    /**
     * Get the 'Concurrent Service Info 3GPP2' field from `self`.
     */
    get_concurrent_service_info_3gpp2(): [ /* returnType */ boolean, /* value_concurrent_service_info_3gpp2 */ boolean | null ]
    /**
     * Get the 'Current PLMN' field from `self`.
     */
    get_current_plmn(): [ /* returnType */ boolean, /* value_current_plmn_mcc */ number | null, /* value_current_plmn_mnc */ number | null, /* value_current_plmn_description */ string | null ]
    /**
     * Get the 'Data Service Capability' field from `self`.
     */
    get_data_service_capability(): [ /* returnType */ boolean, /* value_data_service_capability */ NasDataCapability[] | null ]
    /**
     * Get the 'Daylight Saving Time Adjustment 3GPP' field from `self`.
     */
    get_daylight_saving_time_adjustment_3gpp(): [ /* returnType */ boolean, /* value_daylight_saving_time_adjustment_3gpp */ number | null ]
    /**
     * Get the 'Default Roaming Indicator' field from `self`.
     */
    get_default_roaming_indicator(): [ /* returnType */ boolean, /* value_default_roaming_indicator */ NasRoamingIndicatorStatus | null ]
    /**
     * Get the 'Detailed Service Status' field from `self`.
     */
    get_detailed_service_status(): [ /* returnType */ boolean, /* value_detailed_service_status_status */ NasServiceStatus | null, /* value_detailed_service_status_capability */ NasNetworkServiceDomain | null, /* value_detailed_service_status_hdr_status */ NasServiceStatus | null, /* value_detailed_service_status_hdr_hybrid */ boolean | null, /* value_detailed_service_status_forbidden */ boolean | null ]
    /**
     * Get the 'DTM Support' field from `self`.
     */
    get_dtm_support(): [ /* returnType */ boolean, /* value_dtm_support */ boolean | null ]
    /**
     * Get the 'HDR Personality' field from `self`.
     */
    get_hdr_personality(): [ /* returnType */ boolean, /* value_hdr_personality */ NasHdrPersonality | null ]
    /**
     * Get the 'LAC 3GPP' field from `self`.
     */
    get_lac_3gpp(): [ /* returnType */ boolean, /* value_lac_3gpp */ number | null ]
    /**
     * Get the 'LTE TAC' field from `self`.
     */
    get_lte_tac(): [ /* returnType */ boolean, /* value_lte_tac */ number | null ]
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status_mcc */ number | null, /* value_mnc_pcs_digit_include_status_mnc */ number | null, /* value_mnc_pcs_digit_include_status_includes_pcs_digit */ boolean | null ]
    /**
     * Get the 'Network Name Source' field from `self`.
     */
    get_network_name_source(): [ /* returnType */ boolean, /* value_network_name_source */ NasNetworkNameSource | null ]
    /**
     * Get the 'PRL Indicator 3GPP2' field from `self`.
     */
    get_prl_indicator_3gpp2(): [ /* returnType */ boolean, /* value_prl_indicator_3gpp2 */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Roaming Indicator' field from `self`.
     */
    get_roaming_indicator(): [ /* returnType */ boolean, /* value_roaming_indicator */ NasRoamingIndicatorStatus | null ]
    /**
     * Get the 'Roaming Indicator List' field from `self`.
     * 
     * Version of qmi_message_nas_get_serving_system_output_get_roaming_indicator_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_roaming_indicator_list(): [ /* returnType */ boolean, /* value_roaming_indicator_list_ptr */ MessageNasGetServingSystemOutputRoamingIndicatorListElement[] | null ]
    /**
     * Get the 'Serving System' field from `self`.
     */
    get_serving_system(): [ /* returnType */ boolean, /* value_serving_system_registration_state */ NasRegistrationState | null, /* value_serving_system_cs_attach_state */ NasAttachState | null, /* value_serving_system_ps_attach_state */ NasAttachState | null, /* value_serving_system_selected_network */ NasNetworkType | null, /* value_serving_system_radio_interfaces */ NasRadioInterface[] | null ]
    /**
     * Get the 'Time Zone 3GPP' field from `self`.
     */
    get_time_zone_3gpp(): [ /* returnType */ boolean, /* value_time_zone_3gpp */ number | null ]
    /**
     * Get the 'Time Zone 3GPP2' field from `self`.
     */
    get_time_zone_3gpp2(): [ /* returnType */ boolean, /* value_time_zone_3gpp2_leap_seconds */ number | null, /* value_time_zone_3gpp2_local_time_offset */ number | null, /* value_time_zone_3gpp2_daylight_saving_time */ boolean | null ]
    /**
     * Get the 'UMTS Primary Scrambling Code' field from `self`.
     */
    get_umts_primary_scrambling_code(): [ /* returnType */ boolean, /* value_umts_primary_scrambling_code */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetServingSystemOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetServingSystemOutputRoamingIndicatorListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetServingSystemOutputRoamingIndicatorListElement */
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    /**
     * a #QmiNasRoamingIndicatorStatus.
     */
    roaming_indicator: NasRoamingIndicatorStatus
    static name: string
}
class MessageNasGetSignalInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetSignalInfoOutput */
    /**
     * Get the '5G Signal Strength' field from `self`.
     */
    get_5g_signal_strength(): [ /* returnType */ boolean, /* value_5g_signal_strength_rsrp */ number | null, /* value_5g_signal_strength_snr */ number | null ]
    /**
     * Get the '5G Signal Strength Extended' field from `self`.
     */
    get_5g_signal_strength_extended(): [ /* returnType */ boolean, /* value_5g_signal_strength_extended */ number | null ]
    /**
     * Get the 'CDMA Signal Strength' field from `self`.
     */
    get_cdma_signal_strength(): [ /* returnType */ boolean, /* value_cdma_signal_strength_rssi */ number | null, /* value_cdma_signal_strength_ecio */ number | null ]
    /**
     * Get the 'GSM Signal Strength' field from `self`.
     */
    get_gsm_signal_strength(): [ /* returnType */ boolean, /* value_gsm_signal_strength */ number | null ]
    /**
     * Get the 'HDR Signal Strength' field from `self`.
     */
    get_hdr_signal_strength(): [ /* returnType */ boolean, /* value_hdr_signal_strength_rssi */ number | null, /* value_hdr_signal_strength_ecio */ number | null, /* value_hdr_signal_strength_sinr */ NasEvdoSinrLevel | null, /* value_hdr_signal_strength_io */ number | null ]
    /**
     * Get the 'LTE Signal Strength' field from `self`.
     */
    get_lte_signal_strength(): [ /* returnType */ boolean, /* value_lte_signal_strength_rssi */ number | null, /* value_lte_signal_strength_rsrq */ number | null, /* value_lte_signal_strength_rsrp */ number | null, /* value_lte_signal_strength_snr */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'TDMA Signal Strength' field from `self`.
     */
    get_tdma_signal_strength(): [ /* returnType */ boolean, /* value_tdma_signal_strength */ number | null ]
    /**
     * Get the 'TDMA Signal Strength Extended' field from `self`.
     */
    get_tdma_signal_strength_extended(): [ /* returnType */ boolean, /* value_tdma_signal_strength_extended_rssi */ number | null, /* value_tdma_signal_strength_extended_rscp */ number | null, /* value_tdma_signal_strength_extended_ecio */ number | null, /* value_tdma_signal_strength_extended_sinr */ number | null ]
    /**
     * Get the 'WCDMA Signal Strength' field from `self`.
     */
    get_wcdma_signal_strength(): [ /* returnType */ boolean, /* value_wcdma_signal_strength_rssi */ number | null, /* value_wcdma_signal_strength_ecio */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetSignalInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetSignalStrengthInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetSignalStrengthInput */
    /**
     * Get the 'Request Mask' field from `self`.
     */
    get_request_mask(): [ /* returnType */ boolean, /* value_request_mask */ NasSignalStrengthRequest | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetSignalStrengthInput
    /**
     * Set the 'Request Mask' field in the message.
     * @param value_request_mask a #QmiNasSignalStrengthRequest.
     */
    set_request_mask(value_request_mask: NasSignalStrengthRequest): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasGetSignalStrengthInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasGetSignalStrengthInput
}
class MessageNasGetSignalStrengthOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetSignalStrengthOutput */
    /**
     * Get the 'ECIO List' field from `self`.
     * 
     * Version of qmi_message_nas_get_signal_strength_output_get_ecio_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_ecio_list(): [ /* returnType */ boolean, /* value_ecio_list_ptr */ MessageNasGetSignalStrengthOutputEcioListElement[] | null ]
    /**
     * Get the 'Error Rate List' field from `self`.
     * 
     * Version of qmi_message_nas_get_signal_strength_output_get_error_rate_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_error_rate_list(): [ /* returnType */ boolean, /* value_error_rate_list_ptr */ MessageNasGetSignalStrengthOutputErrorRateListElement[] | null ]
    /**
     * Get the 'IO' field from `self`.
     */
    get_io(): [ /* returnType */ boolean, /* value_io */ number | null ]
    /**
     * Get the 'LTE RSRP' field from `self`.
     */
    get_lte_rsrp(): [ /* returnType */ boolean, /* value_lte_rsrp */ number | null ]
    /**
     * Get the 'LTE SNR' field from `self`.
     */
    get_lte_snr(): [ /* returnType */ boolean, /* value_lte_snr */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'RSRQ' field from `self`.
     */
    get_rsrq(): [ /* returnType */ boolean, /* value_rsrq_rsrq */ number | null, /* value_rsrq_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'RSSI List' field from `self`.
     * 
     * Version of qmi_message_nas_get_signal_strength_output_get_rssi_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_rssi_list(): [ /* returnType */ boolean, /* value_rssi_list_ptr */ MessageNasGetSignalStrengthOutputRssiListElement[] | null ]
    /**
     * Get the 'Signal Strength' field from `self`.
     */
    get_signal_strength(): [ /* returnType */ boolean, /* value_signal_strength_strength */ number | null, /* value_signal_strength_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'SINR' field from `self`.
     */
    get_sinr(): [ /* returnType */ boolean, /* value_sinr */ NasEvdoSinrLevel | null ]
    /**
     * Get the 'Strength List' field from `self`.
     * 
     * Version of qmi_message_nas_get_signal_strength_output_get_strength_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_strength_list(): [ /* returnType */ boolean, /* value_strength_list_ptr */ MessageNasGetSignalStrengthOutputStrengthListElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetSignalStrengthOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetSignalStrengthOutputEcioListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetSignalStrengthOutputEcioListElement */
    /**
     * a #guint8.
     */
    ecio: number
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    static name: string
}
class MessageNasGetSignalStrengthOutputErrorRateListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetSignalStrengthOutputErrorRateListElement */
    /**
     * a #guint16.
     */
    rate: number
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    static name: string
}
class MessageNasGetSignalStrengthOutputRssiListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetSignalStrengthOutputRssiListElement */
    /**
     * a #guint8.
     */
    rssi: number
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    static name: string
}
class MessageNasGetSignalStrengthOutputStrengthListElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasGetSignalStrengthOutputStrengthListElement */
    /**
     * a #gint8.
     */
    strength: number
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    static name: string
}
class MessageNasGetSupportedMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetSupportedMessagesOutput */
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetSupportedMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetSystemInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetSystemInfoOutput */
    /**
     * Get the 'Additional CDMA System Info' field from `self`.
     */
    get_additional_cdma_system_info(): [ /* returnType */ boolean, /* value_additional_cdma_system_info_geo_system_index */ number | null, /* value_additional_cdma_system_info_registration_period */ number | null ]
    /**
     * Get the 'Additional GSM System Info' field from `self`.
     */
    get_additional_gsm_system_info(): [ /* returnType */ boolean, /* value_additional_gsm_system_info_geo_system_index */ number | null, /* value_additional_gsm_system_info_cell_broadcast_support */ NasCellBroadcastCapability | null ]
    /**
     * Get the 'Additional HDR System Info' field from `self`.
     */
    get_additional_hdr_system_info(): [ /* returnType */ boolean, /* value_additional_hdr_system_info_geo_system_index */ number | null ]
    /**
     * Get the 'Additional LTE System Info' field from `self`.
     */
    get_additional_lte_system_info(): [ /* returnType */ boolean, /* value_additional_lte_system_info_geo_system_index */ number | null ]
    /**
     * Get the 'Additional WCDMA System Info' field from `self`.
     */
    get_additional_wcdma_system_info(): [ /* returnType */ boolean, /* value_additional_wcdma_system_info_geo_system_index */ number | null, /* value_additional_wcdma_system_info_cell_broadcast_support */ NasCellBroadcastCapability | null ]
    /**
     * Get the 'CDMA Registration Zone ID' field from `self`.
     */
    get_cdma_registration_zone_id(): [ /* returnType */ boolean, /* value_cdma_registration_zone_id */ number | null ]
    /**
     * Get the 'CDMA Resolved MCC' field from `self`.
     */
    get_cdma_resolved_mcc(): [ /* returnType */ boolean, /* value_cdma_resolved_mcc */ number | null ]
    /**
     * Get the 'CDMA Service Status' field from `self`.
     */
    get_cdma_service_status(): [ /* returnType */ boolean, /* value_cdma_service_status_service_status */ NasServiceStatus | null, /* value_cdma_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'CDMA System Info' field from `self`.
     */
    get_cdma_system_info(): [ /* returnType */ boolean, /* value_cdma_system_info_domain_valid */ boolean | null, /* value_cdma_system_info_domain */ NasNetworkServiceDomain | null, /* value_cdma_system_info_service_capability_valid */ boolean | null, /* value_cdma_system_info_service_capability */ NasNetworkServiceDomain | null, /* value_cdma_system_info_roaming_status_valid */ boolean | null, /* value_cdma_system_info_roaming_status */ NasRoamingStatus | null, /* value_cdma_system_info_forbidden_valid */ boolean | null, /* value_cdma_system_info_forbidden */ boolean | null, /* value_cdma_system_info_prl_match_valid */ boolean | null, /* value_cdma_system_info_prl_match */ boolean | null, /* value_cdma_system_info_p_rev_valid */ boolean | null, /* value_cdma_system_info_p_rev */ number | null, /* value_cdma_system_info_base_station_p_rev_valid */ boolean | null, /* value_cdma_system_info_base_station_p_rev */ number | null, /* value_cdma_system_info_concurrent_service_support_valid */ boolean | null, /* value_cdma_system_info_concurrent_service_support */ boolean | null, /* value_cdma_system_info_cdma_system_id_valid */ boolean | null, /* value_cdma_system_info_sid */ number | null, /* value_cdma_system_info_nid */ number | null, /* value_cdma_system_info_base_station_info_valid */ boolean | null, /* value_cdma_system_info_base_station_id */ number | null, /* value_cdma_system_info_base_station_latitude */ number | null, /* value_cdma_system_info_base_station_longitude */ number | null, /* value_cdma_system_info_packet_zone_valid */ boolean | null, /* value_cdma_system_info_packet_zone */ number | null, /* value_cdma_system_info_network_id_valid */ boolean | null, /* value_cdma_system_info_mcc */ string | null, /* value_cdma_system_info_mnc */ string | null ]
    /**
     * Get the 'DCNR restriction Info' field from `self`.
     */
    get_dcnr_restriction_info(): [ /* returnType */ boolean, /* value_dcnr_restriction_info */ boolean | null ]
    /**
     * Get the 'EUTRA with NR5G availability' field from `self`.
     */
    get_eutra_with_nr5g_availability(): [ /* returnType */ boolean, /* value_eutra_with_nr5g_availability */ boolean | null ]
    /**
     * Get the 'GSM Call Barring Status' field from `self`.
     */
    get_gsm_call_barring_status(): [ /* returnType */ boolean, /* value_gsm_call_barring_status_cs_status */ NasCallBarringStatus | null, /* value_gsm_call_barring_status_ps_status */ NasCallBarringStatus | null ]
    /**
     * Get the 'GSM Cipher Domain' field from `self`.
     */
    get_gsm_cipher_domain(): [ /* returnType */ boolean, /* value_gsm_cipher_domain */ NasNetworkServiceDomain | null ]
    /**
     * Get the 'GSM Routing Area Code' field from `self`.
     */
    get_gsm_routing_area_code(): [ /* returnType */ boolean, /* value_gsm_routing_area_code */ number | null ]
    /**
     * Get the 'GSM Service Status' field from `self`.
     */
    get_gsm_service_status(): [ /* returnType */ boolean, /* value_gsm_service_status_service_status */ NasServiceStatus | null, /* value_gsm_service_status_true_service_status */ NasServiceStatus | null, /* value_gsm_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'GSM System Info v2' field from `self`.
     */
    get_gsm_system_info_v2(): [ /* returnType */ boolean, /* value_gsm_system_info_v2_domain_valid */ boolean | null, /* value_gsm_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_gsm_system_info_v2_service_capability_valid */ boolean | null, /* value_gsm_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_gsm_system_info_v2_roaming_status_valid */ boolean | null, /* value_gsm_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_gsm_system_info_v2_forbidden_valid */ boolean | null, /* value_gsm_system_info_v2_forbidden */ boolean | null, /* value_gsm_system_info_v2_lac_valid */ boolean | null, /* value_gsm_system_info_v2_lac */ number | null, /* value_gsm_system_info_v2_cid_valid */ boolean | null, /* value_gsm_system_info_v2_cid */ number | null, /* value_gsm_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_gsm_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_gsm_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_gsm_system_info_v2_network_id_valid */ boolean | null, /* value_gsm_system_info_v2_mcc */ string | null, /* value_gsm_system_info_v2_mnc */ string | null, /* value_gsm_system_info_v2_egprs_support_valid */ boolean | null, /* value_gsm_system_info_v2_egprs_support */ boolean | null, /* value_gsm_system_info_v2_dtm_support_valid */ boolean | null, /* value_gsm_system_info_v2_dtm_support */ boolean | null ]
    /**
     * Get the 'HDR Service Status' field from `self`.
     */
    get_hdr_service_status(): [ /* returnType */ boolean, /* value_hdr_service_status_service_status */ NasServiceStatus | null, /* value_hdr_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'HDR System Info' field from `self`.
     */
    get_hdr_system_info(): [ /* returnType */ boolean, /* value_hdr_system_info_domain_valid */ boolean | null, /* value_hdr_system_info_domain */ NasNetworkServiceDomain | null, /* value_hdr_system_info_service_capability_valid */ boolean | null, /* value_hdr_system_info_service_capability */ NasNetworkServiceDomain | null, /* value_hdr_system_info_roaming_status_valid */ boolean | null, /* value_hdr_system_info_roaming_status */ NasRoamingStatus | null, /* value_hdr_system_info_forbidden_valid */ boolean | null, /* value_hdr_system_info_forbidden */ boolean | null, /* value_hdr_system_info_prl_match_valid */ boolean | null, /* value_hdr_system_info_prl_match */ boolean | null, /* value_hdr_system_info_personality_valid */ boolean | null, /* value_hdr_system_info_personality */ NasHdrPersonality | null, /* value_hdr_system_info_protocol_revision_valid */ boolean | null, /* value_hdr_system_info_protocol_revision */ NasHdrProtocolRevision | null, /* value_hdr_system_info_is_856_system_id_valid */ boolean | null, /* value_hdr_system_info_is_856_system_id */ string | null ]
    /**
     * Get the 'IMS Voice Support' field from `self`.
     */
    get_ims_voice_support(): [ /* returnType */ boolean, /* value_ims_voice_support */ boolean | null ]
    /**
     * Get the 'LTE Cell Access Status' field from `self`.
     */
    get_lte_cell_access_status(): [ /* returnType */ boolean, /* value_lte_cell_access_status */ NasLteCellAccessStatus | null ]
    /**
     * Get the 'LTE eMBMS Coverage Info Support' field from `self`.
     */
    get_lte_embms_coverage_info_support(): [ /* returnType */ boolean, /* value_lte_embms_coverage_info_support */ boolean | null ]
    /**
     * Get the 'LTE eMBMS Coverage Info Trace ID' field from `self`.
     */
    get_lte_embms_coverage_info_trace_id(): [ /* returnType */ boolean, /* value_lte_embms_coverage_info_trace_id */ number | null ]
    /**
     * Get the 'LTE Registration Domain' field from `self`.
     */
    get_lte_registration_domain(): [ /* returnType */ boolean, /* value_lte_registration_domain */ NasLteRegistrationDomain | null ]
    /**
     * Get the 'LTE Service Status' field from `self`.
     */
    get_lte_service_status(): [ /* returnType */ boolean, /* value_lte_service_status_service_status */ NasServiceStatus | null, /* value_lte_service_status_true_service_status */ NasServiceStatus | null, /* value_lte_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'LTE System Info v2' field from `self`.
     */
    get_lte_system_info_v2(): [ /* returnType */ boolean, /* value_lte_system_info_v2_domain_valid */ boolean | null, /* value_lte_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_lte_system_info_v2_service_capability_valid */ boolean | null, /* value_lte_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_lte_system_info_v2_roaming_status_valid */ boolean | null, /* value_lte_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_lte_system_info_v2_forbidden_valid */ boolean | null, /* value_lte_system_info_v2_forbidden */ boolean | null, /* value_lte_system_info_v2_lac_valid */ boolean | null, /* value_lte_system_info_v2_lac */ number | null, /* value_lte_system_info_v2_cid_valid */ boolean | null, /* value_lte_system_info_v2_cid */ number | null, /* value_lte_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_lte_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_lte_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_lte_system_info_v2_network_id_valid */ boolean | null, /* value_lte_system_info_v2_mcc */ string | null, /* value_lte_system_info_v2_mnc */ string | null, /* value_lte_system_info_v2_tac_valid */ boolean | null, /* value_lte_system_info_v2_tac */ number | null ]
    /**
     * Get the 'LTE Voice Domain' field from `self`.
     */
    get_lte_voice_domain(): [ /* returnType */ boolean, /* value_lte_voice_domain */ NasLteVoiceDomain | null ]
    /**
     * Get the 'LTE Voice Support' field from `self`.
     */
    get_lte_voice_support(): [ /* returnType */ boolean, /* value_lte_voice_support */ boolean | null ]
    /**
     * Get the 'Network Selection Registration Restriction' field from `self`.
     */
    get_network_selection_registration_restriction(): [ /* returnType */ boolean, /* value_network_selection_registration_restriction */ NasNetworkSelectionRegistrationRestriction | null ]
    /**
     * Get the 'NR5G Service Status Info' field from `self`.
     */
    get_nr5g_service_status_info(): [ /* returnType */ boolean, /* value_nr5g_service_status_info_service_status */ NasServiceStatus | null, /* value_nr5g_service_status_info_true_service_status */ NasServiceStatus | null, /* value_nr5g_service_status_info_preferred_data_path */ boolean | null ]
    /**
     * Get the 'NR5G System Info' field from `self`.
     */
    get_nr5g_system_info(): [ /* returnType */ boolean, /* value_nr5g_system_info_domain_valid */ boolean | null, /* value_nr5g_system_info_domain */ NasNetworkServiceDomain | null, /* value_nr5g_system_info_service_capability_valid */ boolean | null, /* value_nr5g_system_info_service_capability */ NasNetworkServiceDomain | null, /* value_nr5g_system_info_roaming_status_valid */ boolean | null, /* value_nr5g_system_info_roaming_status */ NasRoamingStatus | null, /* value_nr5g_system_info_forbidden_valid */ boolean | null, /* value_nr5g_system_info_forbidden */ boolean | null, /* value_nr5g_system_info_lac_valid */ boolean | null, /* value_nr5g_system_info_lac */ number | null, /* value_nr5g_system_info_cid_valid */ boolean | null, /* value_nr5g_system_info_cid */ number | null, /* value_nr5g_system_info_registration_reject_info_valid */ boolean | null, /* value_nr5g_system_info_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_nr5g_system_info_registration_reject_cause */ number | null, /* value_nr5g_system_info_network_id_valid */ boolean | null, /* value_nr5g_system_info_mcc */ string | null, /* value_nr5g_system_info_mnc */ string | null, /* value_nr5g_system_info_tac_valid */ boolean | null, /* value_nr5g_system_info_tac */ number | null ]
    /**
     * Get the 'NR5G Tracking Area Code' field from `self`.
     */
    get_nr5g_tracking_area_code(): [ /* returnType */ boolean, /* value_nr5g_tracking_area_code */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'SIM Reject Info' field from `self`.
     */
    get_sim_reject_info(): [ /* returnType */ boolean, /* value_sim_reject_info */ NasSimRejectState | null ]
    /**
     * Get the 'TD SCDMA Service Status' field from `self`.
     */
    get_td_scdma_service_status(): [ /* returnType */ boolean, /* value_td_scdma_service_status_service_status */ NasServiceStatus | null, /* value_td_scdma_service_status_true_service_status */ NasServiceStatus | null, /* value_td_scdma_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'TD SCDMA System Info v2' field from `self`.
     */
    get_td_scdma_system_info_v2(): [ /* returnType */ boolean, /* value_td_scdma_system_info_v2_domain_valid */ boolean | null, /* value_td_scdma_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_td_scdma_system_info_v2_service_capability_valid */ boolean | null, /* value_td_scdma_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_td_scdma_system_info_v2_roaming_status_valid */ boolean | null, /* value_td_scdma_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_td_scdma_system_info_v2_forbidden_valid */ boolean | null, /* value_td_scdma_system_info_v2_forbidden */ boolean | null, /* value_td_scdma_system_info_v2_lac_valid */ boolean | null, /* value_td_scdma_system_info_v2_lac */ number | null, /* value_td_scdma_system_info_v2_cid_valid */ boolean | null, /* value_td_scdma_system_info_v2_cid */ number | null, /* value_td_scdma_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_td_scdma_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_td_scdma_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_td_scdma_system_info_v2_network_id_valid */ boolean | null, /* value_td_scdma_system_info_v2_mcc */ string | null, /* value_td_scdma_system_info_v2_mnc */ string | null, /* value_td_scdma_system_info_v2_hs_call_status_valid */ boolean | null, /* value_td_scdma_system_info_v2_hs_call_status */ NasWcdmaHsService | null, /* value_td_scdma_system_info_v2_hs_service_valid */ boolean | null, /* value_td_scdma_system_info_v2_hs_service */ NasWcdmaHsService | null, /* value_td_scdma_system_info_v2_cell_parameter_id_valid */ boolean | null, /* value_td_scdma_system_info_v2_cell_parameter_id */ number | null, /* value_td_scdma_system_info_v2_cell_broadcast_support_valid */ boolean | null, /* value_td_scdma_system_info_v2_cell_broadcast_support */ NasCellBroadcastCapability | null, /* value_td_scdma_system_info_v2_cs_call_barring_status_valid */ boolean | null, /* value_td_scdma_system_info_v2_cs_call_barring_status */ NasCallBarringStatus | null, /* value_td_scdma_system_info_v2_ps_call_barring_status_valid */ boolean | null, /* value_td_scdma_system_info_v2_ps_call_barring_status */ NasCallBarringStatus | null, /* value_td_scdma_system_info_v2_cipher_domain_valid */ boolean | null, /* value_td_scdma_system_info_v2_cipher_domain */ NasNetworkServiceDomain | null ]
    /**
     * Get the 'WCDMA Call Barring Status' field from `self`.
     */
    get_wcdma_call_barring_status(): [ /* returnType */ boolean, /* value_wcdma_call_barring_status_cs_status */ NasCallBarringStatus | null, /* value_wcdma_call_barring_status_ps_status */ NasCallBarringStatus | null ]
    /**
     * Get the 'WCDMA Cipher Domain' field from `self`.
     */
    get_wcdma_cipher_domain(): [ /* returnType */ boolean, /* value_wcdma_cipher_domain */ NasNetworkServiceDomain | null ]
    /**
     * Get the 'WCDMA Routing Area Code' field from `self`.
     */
    get_wcdma_routing_area_code(): [ /* returnType */ boolean, /* value_wcdma_routing_area_code */ number | null ]
    /**
     * Get the 'WCDMA Service Status' field from `self`.
     */
    get_wcdma_service_status(): [ /* returnType */ boolean, /* value_wcdma_service_status_service_status */ NasServiceStatus | null, /* value_wcdma_service_status_true_service_status */ NasServiceStatus | null, /* value_wcdma_service_status_preferred_data_path */ boolean | null ]
    /**
     * Get the 'WCDMA System Info v2' field from `self`.
     */
    get_wcdma_system_info_v2(): [ /* returnType */ boolean, /* value_wcdma_system_info_v2_domain_valid */ boolean | null, /* value_wcdma_system_info_v2_domain */ NasNetworkServiceDomain | null, /* value_wcdma_system_info_v2_service_capability_valid */ boolean | null, /* value_wcdma_system_info_v2_service_capability */ NasNetworkServiceDomain | null, /* value_wcdma_system_info_v2_roaming_status_valid */ boolean | null, /* value_wcdma_system_info_v2_roaming_status */ NasRoamingStatus | null, /* value_wcdma_system_info_v2_forbidden_valid */ boolean | null, /* value_wcdma_system_info_v2_forbidden */ boolean | null, /* value_wcdma_system_info_v2_lac_valid */ boolean | null, /* value_wcdma_system_info_v2_lac */ number | null, /* value_wcdma_system_info_v2_cid_valid */ boolean | null, /* value_wcdma_system_info_v2_cid */ number | null, /* value_wcdma_system_info_v2_registration_reject_info_valid */ boolean | null, /* value_wcdma_system_info_v2_registration_reject_domain */ NasNetworkServiceDomain | null, /* value_wcdma_system_info_v2_registration_reject_cause */ NasRejectCause | null, /* value_wcdma_system_info_v2_network_id_valid */ boolean | null, /* value_wcdma_system_info_v2_mcc */ string | null, /* value_wcdma_system_info_v2_mnc */ string | null, /* value_wcdma_system_info_v2_hs_call_status_valid */ boolean | null, /* value_wcdma_system_info_v2_hs_call_status */ NasWcdmaHsService | null, /* value_wcdma_system_info_v2_hs_service_valid */ boolean | null, /* value_wcdma_system_info_v2_hs_service */ NasWcdmaHsService | null, /* value_wcdma_system_info_v2_primary_scrambling_code_valid */ boolean | null, /* value_wcdma_system_info_v2_primary_scrambling_code */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetSystemInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetSystemSelectionPreferenceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetSystemSelectionPreferenceOutput */
    /**
     * Get the 'Acquisition Order Preference' field from `self`.
     */
    get_acquisition_order_preference(): [ /* returnType */ boolean, /* value_acquisition_order_preference */ NasRadioInterface[] | null ]
    /**
     * Get the 'Band Preference' field from `self`.
     */
    get_band_preference(): [ /* returnType */ boolean, /* value_band_preference */ NasBandPreference | null ]
    /**
     * Get the 'CDMA PRL Preference' field from `self`.
     */
    get_cdma_prl_preference(): [ /* returnType */ boolean, /* value_cdma_prl_preference */ NasCdmaPrlPreference | null ]
    /**
     * Get the 'Disabled Modes' field from `self`.
     */
    get_disabled_modes(): [ /* returnType */ boolean, /* value_disabled_modes */ NasRatModePreference | null ]
    /**
     * Get the 'Emergency mode' field from `self`.
     */
    get_emergency_mode(): [ /* returnType */ boolean, /* value_emergency_mode */ boolean | null ]
    /**
     * Get the 'Extended LTE Band Preference' field from `self`.
     */
    get_extended_lte_band_preference(): [ /* returnType */ boolean, /* value_extended_lte_band_preference_mask_low */ number | null, /* value_extended_lte_band_preference_mask_mid_low */ number | null, /* value_extended_lte_band_preference_mask_mid_high */ number | null, /* value_extended_lte_band_preference_mask_high */ number | null ]
    /**
     * Get the 'GSM WCDMA Acquisition Order Preference' field from `self`.
     */
    get_gsm_wcdma_acquisition_order_preference(): [ /* returnType */ boolean, /* value_gsm_wcdma_acquisition_order_preference */ NasGsmWcdmaAcquisitionOrderPreference | null ]
    /**
     * Get the 'LTE Band Preference' field from `self`.
     */
    get_lte_band_preference(): [ /* returnType */ boolean, /* value_lte_band_preference */ NasLteBandPreference | null ]
    /**
     * Get the 'Manual Network Selection' field from `self`.
     */
    get_manual_network_selection(): [ /* returnType */ boolean, /* value_manual_network_selection_mcc */ number | null, /* value_manual_network_selection_mnc */ number | null, /* value_manual_network_selection_includes_pcs_digit */ boolean | null ]
    /**
     * Get the 'Mode Preference' field from `self`.
     */
    get_mode_preference(): [ /* returnType */ boolean, /* value_mode_preference */ NasRatModePreference | null ]
    /**
     * Get the 'Network Selection Preference' field from `self`.
     */
    get_network_selection_preference(): [ /* returnType */ boolean, /* value_network_selection_preference */ NasNetworkSelectionPreference | null ]
    /**
     * Get the 'Network Selection Registration Restriction' field from `self`.
     */
    get_network_selection_registration_restriction(): [ /* returnType */ boolean, /* value_network_selection_registration_restriction */ NasNetworkSelectionRegistrationRestriction | null ]
    /**
     * Get the 'NR5G NSA Band Preference' field from `self`.
     */
    get_nr5g_nsa_band_preference(): [ /* returnType */ boolean, /* value_nr5g_nsa_band_preference_mask_0 */ number | null, /* value_nr5g_nsa_band_preference_mask_1 */ number | null, /* value_nr5g_nsa_band_preference_mask_2 */ number | null, /* value_nr5g_nsa_band_preference_mask_3 */ number | null, /* value_nr5g_nsa_band_preference_mask_4 */ number | null, /* value_nr5g_nsa_band_preference_mask_5 */ number | null, /* value_nr5g_nsa_band_preference_mask_6 */ number | null, /* value_nr5g_nsa_band_preference_mask_7 */ number | null ]
    /**
     * Get the 'NR5G SA Band Preference' field from `self`.
     */
    get_nr5g_sa_band_preference(): [ /* returnType */ boolean, /* value_nr5g_sa_band_preference_mask_0 */ number | null, /* value_nr5g_sa_band_preference_mask_1 */ number | null, /* value_nr5g_sa_band_preference_mask_2 */ number | null, /* value_nr5g_sa_band_preference_mask_3 */ number | null, /* value_nr5g_sa_band_preference_mask_4 */ number | null, /* value_nr5g_sa_band_preference_mask_5 */ number | null, /* value_nr5g_sa_band_preference_mask_6 */ number | null, /* value_nr5g_sa_band_preference_mask_7 */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Roaming Preference' field from `self`.
     */
    get_roaming_preference(): [ /* returnType */ boolean, /* value_roaming_preference */ NasRoamingPreference | null ]
    /**
     * Get the 'Service Domain Preference' field from `self`.
     */
    get_service_domain_preference(): [ /* returnType */ boolean, /* value_service_domain_preference */ NasServiceDomainPreference | null ]
    /**
     * Get the 'TD SCDMA Band Preference' field from `self`.
     */
    get_td_scdma_band_preference(): [ /* returnType */ boolean, /* value_td_scdma_band_preference */ NasTdScdmaBandPreference | null ]
    /**
     * Get the 'Usage Preference' field from `self`.
     */
    get_usage_preference(): [ /* returnType */ boolean, /* value_usage_preference */ NasUsagePreference | null ]
    /**
     * Get the 'Voice Domain Preference' field from `self`.
     */
    get_voice_domain_preference(): [ /* returnType */ boolean, /* value_voice_domain_preference */ NasVoiceDomainPreference | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetSystemSelectionPreferenceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetTechnologyPreferenceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetTechnologyPreferenceOutput */
    /**
     * Get the 'Active' field from `self`.
     */
    get_active(): [ /* returnType */ boolean, /* value_active_technology_preference */ NasRadioTechnologyPreference | null, /* value_active_technology_preference_duration */ NasPreferenceDuration | null ]
    /**
     * Get the 'Persistent' field from `self`.
     */
    get_persistent(): [ /* returnType */ boolean, /* value_persistent */ NasRadioTechnologyPreference | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetTechnologyPreferenceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasGetTxRxInfoInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetTxRxInfoInput */
    /**
     * Get the 'Radio Interface' field from `self`.
     */
    get_radio_interface(): [ /* returnType */ boolean, /* value_radio_interface */ NasRadioInterface | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetTxRxInfoInput
    /**
     * Set the 'Radio Interface' field in the message.
     * @param value_radio_interface a #QmiNasRadioInterface.
     */
    set_radio_interface(value_radio_interface: NasRadioInterface): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasGetTxRxInfoInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasGetTxRxInfoInput
}
class MessageNasGetTxRxInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasGetTxRxInfoOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Rx Chain 0 Info' field from `self`.
     */
    get_rx_chain_0_info(): [ /* returnType */ boolean, /* value_rx_chain_0_info_is_radio_tuned */ boolean | null, /* value_rx_chain_0_info_rx_power */ number | null, /* value_rx_chain_0_info_ecio */ number | null, /* value_rx_chain_0_info_rscp */ number | null, /* value_rx_chain_0_info_rsrp */ number | null, /* value_rx_chain_0_info_phase */ number | null ]
    /**
     * Get the 'Rx Chain 1 Info' field from `self`.
     */
    get_rx_chain_1_info(): [ /* returnType */ boolean, /* value_rx_chain_1_info_is_radio_tuned */ boolean | null, /* value_rx_chain_1_info_rx_power */ number | null, /* value_rx_chain_1_info_ecio */ number | null, /* value_rx_chain_1_info_rscp */ number | null, /* value_rx_chain_1_info_rsrp */ number | null, /* value_rx_chain_1_info_phase */ number | null ]
    /**
     * Get the 'Rx Chain 2 Info' field from `self`.
     */
    get_rx_chain_2_info(): [ /* returnType */ boolean, /* value_rx_chain_2_info_is_radio_tuned */ boolean | null, /* value_rx_chain_2_info_rx_power */ number | null, /* value_rx_chain_2_info_ecio */ number | null, /* value_rx_chain_2_info_rscp */ number | null, /* value_rx_chain_2_info_rsrp */ number | null, /* value_rx_chain_2_info_phase */ number | null ]
    /**
     * Get the 'Rx Chain 3 Info' field from `self`.
     */
    get_rx_chain_3_info(): [ /* returnType */ boolean, /* value_rx_chain_3_info_is_radio_tuned */ boolean | null, /* value_rx_chain_3_info_rx_power */ number | null, /* value_rx_chain_3_info_ecio */ number | null, /* value_rx_chain_3_info_rscp */ number | null, /* value_rx_chain_3_info_rsrp */ number | null, /* value_rx_chain_3_info_phase */ number | null ]
    /**
     * Get the 'Tx Info' field from `self`.
     */
    get_tx_info(): [ /* returnType */ boolean, /* value_tx_info_is_in_traffic */ boolean | null, /* value_tx_info_tx_power */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasGetTxRxInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasInitiateNetworkRegisterInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasInitiateNetworkRegisterInput */
    /**
     * Get the 'Action' field from `self`.
     */
    get_action(): [ /* returnType */ boolean, /* value_action */ NasNetworkRegisterType | null ]
    /**
     * Get the 'Change Duration' field from `self`.
     */
    get_change_duration(): [ /* returnType */ boolean, /* value_change_duration */ NasChangeDuration | null ]
    /**
     * Get the 'Manual Registration Info 3GPP' field from `self`.
     */
    get_manual_registration_info_3gpp(): [ /* returnType */ boolean, /* value_manual_registration_info_3gpp_mcc */ number | null, /* value_manual_registration_info_3gpp_mnc */ number | null, /* value_manual_registration_info_3gpp_radio_interface */ NasRadioInterface | null ]
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasInitiateNetworkRegisterInput
    /**
     * Set the 'Action' field in the message.
     * @param value_action a #QmiNasNetworkRegisterType.
     */
    set_action(value_action: NasNetworkRegisterType): boolean
    /**
     * Set the 'Change Duration' field in the message.
     * @param value_change_duration a #QmiNasChangeDuration.
     */
    set_change_duration(value_change_duration: NasChangeDuration): boolean
    /**
     * Set the 'Manual Registration Info 3GPP' field in the message.
     * @param value_manual_registration_info_3gpp_mcc a #guint16.
     * @param value_manual_registration_info_3gpp_mnc a #guint16.
     * @param value_manual_registration_info_3gpp_radio_interface a #QmiNasRadioInterface.
     */
    set_manual_registration_info_3gpp(value_manual_registration_info_3gpp_mcc: number, value_manual_registration_info_3gpp_mnc: number, value_manual_registration_info_3gpp_radio_interface: NasRadioInterface): boolean
    /**
     * Set the 'MNC PCS Digit Include Status' field in the message.
     * @param value_mnc_pcs_digit_include_status a #gboolean.
     */
    set_mnc_pcs_digit_include_status(value_mnc_pcs_digit_include_status: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasInitiateNetworkRegisterInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasInitiateNetworkRegisterInput
}
class MessageNasInitiateNetworkRegisterOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasInitiateNetworkRegisterOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasInitiateNetworkRegisterOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasNetworkScanInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasNetworkScanInput */
    /**
     * Get the 'Network Type' field from `self`.
     */
    get_network_type(): [ /* returnType */ boolean, /* value_network_type */ NasNetworkScanType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasNetworkScanInput
    /**
     * Set the 'Network Type' field in the message.
     * @param value_network_type a #QmiNasNetworkScanType.
     */
    set_network_type(value_network_type: NasNetworkScanType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasNetworkScanInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasNetworkScanInput
}
class MessageNasNetworkScanOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasNetworkScanOutput */
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     * 
     * Version of qmi_message_nas_network_scan_output_get_mnc_pcs_digit_include_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status_ptr */ MessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement[] | null ]
    /**
     * Get the 'Network Information' field from `self`.
     * 
     * Version of qmi_message_nas_network_scan_output_get_network_information() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_network_information(): [ /* returnType */ boolean, /* value_network_information_ptr */ MessageNasNetworkScanOutputNetworkInformationElement[] | null ]
    /**
     * Get the 'Network Scan Result' field from `self`.
     */
    get_network_scan_result(): [ /* returnType */ boolean, /* value_network_scan_result */ NasNetworkScanResult | null ]
    /**
     * Get the 'Radio Access Technology' field from `self`.
     * 
     * Version of qmi_message_nas_network_scan_output_get_radio_access_technology() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_radio_access_technology(): [ /* returnType */ boolean, /* value_radio_access_technology_ptr */ MessageNasNetworkScanOutputRadioAccessTechnologyElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasNetworkScanOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement */
    /**
     * a #guint16.
     */
    mcc: number
    /**
     * a #guint16.
     */
    mnc: number
    /**
     * a #gboolean.
     */
    includes_pcs_digit: boolean
    static name: string
}
class MessageNasNetworkScanOutputNetworkInformationElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasNetworkScanOutputNetworkInformationElement */
    /**
     * a #guint16.
     */
    mcc: number
    /**
     * a #guint16.
     */
    mnc: number
    /**
     * a #QmiNasNetworkStatus.
     */
    network_status: NasNetworkStatus
    /**
     * a string.
     */
    description: string
    static name: string
}
class MessageNasNetworkScanOutputRadioAccessTechnologyElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasNetworkScanOutputRadioAccessTechnologyElement */
    /**
     * a #guint16.
     */
    mcc: number
    /**
     * a #guint16.
     */
    mnc: number
    /**
     * a #QmiNasRadioInterface.
     */
    radio_interface: NasRadioInterface
    static name: string
}
class MessageNasRegisterIndicationsInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasRegisterIndicationsInput */
    /**
     * Get the 'Current PLMN Name' field from `self`.
     */
    get_current_plmn_name(): [ /* returnType */ boolean, /* value_current_plmn_name */ boolean | null ]
    /**
     * Get the 'DDTM Events' field from `self`.
     */
    get_ddtm_events(): [ /* returnType */ boolean, /* value_ddtm_events */ boolean | null ]
    /**
     * Get the 'Dual Standby Preference' field from `self`.
     */
    get_dual_standby_preference(): [ /* returnType */ boolean, /* value_dual_standby_preference */ boolean | null ]
    /**
     * Get the 'eMBMS Status' field from `self`.
     */
    get_embms_status(): [ /* returnType */ boolean, /* value_embms_status */ boolean | null ]
    /**
     * Get the 'Error Rate' field from `self`.
     */
    get_error_rate(): [ /* returnType */ boolean, /* value_error_rate */ boolean | null ]
    /**
     * Get the 'HDR New UATI Assigned' field from `self`.
     */
    get_hdr_new_uati_assigned(): [ /* returnType */ boolean, /* value_hdr_new_uati_assigned */ boolean | null ]
    /**
     * Get the 'HDR Session Closed' field from `self`.
     */
    get_hdr_session_closed(): [ /* returnType */ boolean, /* value_hdr_session_closed */ boolean | null ]
    /**
     * Get the 'Managed Roaming' field from `self`.
     */
    get_managed_roaming(): [ /* returnType */ boolean, /* value_managed_roaming */ boolean | null ]
    /**
     * Get the 'Network Reject Information' field from `self`.
     */
    get_network_reject_information(): [ /* returnType */ boolean, /* value_network_reject_information_enable_network_reject_indications */ boolean | null, /* value_network_reject_information_supress_system_info_indications */ boolean | null ]
    /**
     * Get the 'Network Time' field from `self`.
     */
    get_network_time(): [ /* returnType */ boolean, /* value_network_time */ boolean | null ]
    /**
     * Get the 'RF Band Information' field from `self`.
     */
    get_rf_band_information(): [ /* returnType */ boolean, /* value_rf_band_information */ boolean | null ]
    /**
     * Get the 'Serving System Events' field from `self`.
     */
    get_serving_system_events(): [ /* returnType */ boolean, /* value_serving_system_events */ boolean | null ]
    /**
     * Get the 'Signal Info' field from `self`.
     */
    get_signal_info(): [ /* returnType */ boolean, /* value_signal_info */ boolean | null ]
    /**
     * Get the 'Subscription Info' field from `self`.
     */
    get_subscription_info(): [ /* returnType */ boolean, /* value_subscription_info */ boolean | null ]
    /**
     * Get the 'System Info' field from `self`.
     */
    get_system_info(): [ /* returnType */ boolean, /* value_system_info */ boolean | null ]
    /**
     * Get the 'System Selection Preference' field from `self`.
     */
    get_system_selection_preference(): [ /* returnType */ boolean, /* value_system_selection_preference */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasRegisterIndicationsInput
    /**
     * Set the 'Current PLMN Name' field in the message.
     * @param value_current_plmn_name a #gboolean.
     */
    set_current_plmn_name(value_current_plmn_name: boolean): boolean
    /**
     * Set the 'DDTM Events' field in the message.
     * @param value_ddtm_events a #gboolean.
     */
    set_ddtm_events(value_ddtm_events: boolean): boolean
    /**
     * Set the 'Dual Standby Preference' field in the message.
     * @param value_dual_standby_preference a #gboolean.
     */
    set_dual_standby_preference(value_dual_standby_preference: boolean): boolean
    /**
     * Set the 'eMBMS Status' field in the message.
     * @param value_embms_status a #gboolean.
     */
    set_embms_status(value_embms_status: boolean): boolean
    /**
     * Set the 'Error Rate' field in the message.
     * @param value_error_rate a #gboolean.
     */
    set_error_rate(value_error_rate: boolean): boolean
    /**
     * Set the 'HDR New UATI Assigned' field in the message.
     * @param value_hdr_new_uati_assigned a #gboolean.
     */
    set_hdr_new_uati_assigned(value_hdr_new_uati_assigned: boolean): boolean
    /**
     * Set the 'HDR Session Closed' field in the message.
     * @param value_hdr_session_closed a #gboolean.
     */
    set_hdr_session_closed(value_hdr_session_closed: boolean): boolean
    /**
     * Set the 'Managed Roaming' field in the message.
     * @param value_managed_roaming a #gboolean.
     */
    set_managed_roaming(value_managed_roaming: boolean): boolean
    /**
     * Set the 'Network Reject Information' field in the message.
     * @param value_network_reject_information_enable_network_reject_indications a #gboolean.
     * @param value_network_reject_information_supress_system_info_indications a #gboolean.
     */
    set_network_reject_information(value_network_reject_information_enable_network_reject_indications: boolean, value_network_reject_information_supress_system_info_indications: boolean): boolean
    /**
     * Set the 'Network Time' field in the message.
     * @param value_network_time a #gboolean.
     */
    set_network_time(value_network_time: boolean): boolean
    /**
     * Set the 'RF Band Information' field in the message.
     * @param value_rf_band_information a #gboolean.
     */
    set_rf_band_information(value_rf_band_information: boolean): boolean
    /**
     * Set the 'Serving System Events' field in the message.
     * @param value_serving_system_events a #gboolean.
     */
    set_serving_system_events(value_serving_system_events: boolean): boolean
    /**
     * Set the 'Signal Info' field in the message.
     * @param value_signal_info a #gboolean.
     */
    set_signal_info(value_signal_info: boolean): boolean
    /**
     * Set the 'Subscription Info' field in the message.
     * @param value_subscription_info a #gboolean.
     */
    set_subscription_info(value_subscription_info: boolean): boolean
    /**
     * Set the 'System Info' field in the message.
     * @param value_system_info a #gboolean.
     */
    set_system_info(value_system_info: boolean): boolean
    /**
     * Set the 'System Selection Preference' field in the message.
     * @param value_system_selection_preference a #gboolean.
     */
    set_system_selection_preference(value_system_selection_preference: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasRegisterIndicationsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasRegisterIndicationsInput
}
class MessageNasRegisterIndicationsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasRegisterIndicationsOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasRegisterIndicationsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasSetEventReportInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetEventReportInput */
    /**
     * Get the 'ECIO Indicator' field from `self`.
     */
    get_ecio_indicator(): [ /* returnType */ boolean, /* value_ecio_indicator_report */ boolean | null, /* value_ecio_indicator_ecio_delta */ number | null ]
    /**
     * Get the 'ECIO Threshold' field from `self`.
     */
    get_ecio_threshold(): [ /* returnType */ boolean, /* value_ecio_threshold_report */ boolean | null, /* value_ecio_threshold_thresholds */ number[] | null ]
    /**
     * Get the 'Error Rate Indicator' field from `self`.
     */
    get_error_rate_indicator(): [ /* returnType */ boolean, /* value_error_rate_indicator */ boolean | null ]
    /**
     * Get the 'IO Indicator' field from `self`.
     */
    get_io_indicator(): [ /* returnType */ boolean, /* value_io_indicator_report */ boolean | null, /* value_io_indicator_io_delta */ number | null ]
    /**
     * Get the 'LTE RSRP Delta' field from `self`.
     */
    get_lte_rsrp_delta(): [ /* returnType */ boolean, /* value_lte_rsrp_delta_report */ boolean | null, /* value_lte_rsrp_delta_rsrp_delta */ number | null ]
    /**
     * Get the 'LTE SNR Delta' field from `self`.
     */
    get_lte_snr_delta(): [ /* returnType */ boolean, /* value_lte_snr_delta_report */ boolean | null, /* value_lte_snr_delta_snr_delta */ number | null ]
    /**
     * Get the 'Registration Reject Reason' field from `self`.
     */
    get_registration_reject_reason(): [ /* returnType */ boolean, /* value_registration_reject_reason */ boolean | null ]
    /**
     * Get the 'RF Band Information' field from `self`.
     */
    get_rf_band_information(): [ /* returnType */ boolean, /* value_rf_band_information */ boolean | null ]
    /**
     * Get the 'RSSI Indicator' field from `self`.
     */
    get_rssi_indicator(): [ /* returnType */ boolean, /* value_rssi_indicator_report */ boolean | null, /* value_rssi_indicator_rssi_delta */ number | null ]
    /**
     * Get the 'Signal Strength Indicator' field from `self`.
     */
    get_signal_strength_indicator(): [ /* returnType */ boolean, /* value_signal_strength_indicator_report */ boolean | null, /* value_signal_strength_indicator_thresholds */ Uint8Array | null ]
    /**
     * Get the 'SINR Indicator' field from `self`.
     */
    get_sinr_indicator(): [ /* returnType */ boolean, /* value_sinr_indicator_report */ boolean | null, /* value_sinr_indicator_sinr_delta */ number | null ]
    /**
     * Get the 'SINR Threshold' field from `self`.
     */
    get_sinr_threshold(): [ /* returnType */ boolean, /* value_sinr_threshold_report */ boolean | null, /* value_sinr_threshold_thresholds */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetEventReportInput
    /**
     * Set the 'ECIO Indicator' field in the message.
     * @param value_ecio_indicator_report a #gboolean.
     * @param value_ecio_indicator_ecio_delta a #guint8.
     */
    set_ecio_indicator(value_ecio_indicator_report: boolean, value_ecio_indicator_ecio_delta: number): boolean
    /**
     * Set the 'ECIO Threshold' field in the message.
     * @param value_ecio_threshold_report a #gboolean.
     * @param value_ecio_threshold_thresholds a #GArray of #gint16 elements. A new reference to `value_ecio_threshold_thresholds` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ecio_threshold(value_ecio_threshold_report: boolean, value_ecio_threshold_thresholds: number[]): boolean
    /**
     * Set the 'Error Rate Indicator' field in the message.
     * @param value_error_rate_indicator a #gboolean.
     */
    set_error_rate_indicator(value_error_rate_indicator: boolean): boolean
    /**
     * Set the 'IO Indicator' field in the message.
     * @param value_io_indicator_report a #gboolean.
     * @param value_io_indicator_io_delta a #guint8.
     */
    set_io_indicator(value_io_indicator_report: boolean, value_io_indicator_io_delta: number): boolean
    /**
     * Set the 'LTE RSRP Delta' field in the message.
     * @param value_lte_rsrp_delta_report a #gboolean.
     * @param value_lte_rsrp_delta_rsrp_delta a #guint8.
     */
    set_lte_rsrp_delta(value_lte_rsrp_delta_report: boolean, value_lte_rsrp_delta_rsrp_delta: number): boolean
    /**
     * Set the 'LTE SNR Delta' field in the message.
     * @param value_lte_snr_delta_report a #gboolean.
     * @param value_lte_snr_delta_snr_delta a #guint8.
     */
    set_lte_snr_delta(value_lte_snr_delta_report: boolean, value_lte_snr_delta_snr_delta: number): boolean
    /**
     * Set the 'Registration Reject Reason' field in the message.
     * @param value_registration_reject_reason a #gboolean.
     */
    set_registration_reject_reason(value_registration_reject_reason: boolean): boolean
    /**
     * Set the 'RF Band Information' field in the message.
     * @param value_rf_band_information a #gboolean.
     */
    set_rf_band_information(value_rf_band_information: boolean): boolean
    /**
     * Set the 'RSSI Indicator' field in the message.
     * @param value_rssi_indicator_report a #gboolean.
     * @param value_rssi_indicator_rssi_delta a #guint8.
     */
    set_rssi_indicator(value_rssi_indicator_report: boolean, value_rssi_indicator_rssi_delta: number): boolean
    /**
     * Set the 'Signal Strength Indicator' field in the message.
     * @param value_signal_strength_indicator_report a #gboolean.
     * @param value_signal_strength_indicator_thresholds a #GArray of #gint8 elements. A new reference to `value_signal_strength_indicator_thresholds` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_signal_strength_indicator(value_signal_strength_indicator_report: boolean, value_signal_strength_indicator_thresholds: Uint8Array): boolean
    /**
     * Set the 'SINR Indicator' field in the message.
     * @param value_sinr_indicator_report a #gboolean.
     * @param value_sinr_indicator_sinr_delta a #guint8.
     */
    set_sinr_indicator(value_sinr_indicator_report: boolean, value_sinr_indicator_sinr_delta: number): boolean
    /**
     * Set the 'SINR Threshold' field in the message.
     * @param value_sinr_threshold_report a #gboolean.
     * @param value_sinr_threshold_thresholds a #GArray of #guint8 elements. A new reference to `value_sinr_threshold_thresholds` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_sinr_threshold(value_sinr_threshold_report: boolean, value_sinr_threshold_thresholds: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasSetEventReportInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasSetEventReportInput
}
class MessageNasSetEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetEventReportOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasSetPreferredNetworksInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetPreferredNetworksInput */
    /**
     * Get the 'Clear Previous Preferred Networks' field from `self`.
     */
    get_clear_previous_preferred_networks(): [ /* returnType */ boolean, /* value_clear_previous_preferred_networks */ boolean | null ]
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     * 
     * Version of qmi_message_nas_set_preferred_networks_input_get_mnc_pcs_digit_include_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status_ptr */ MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement[] | null ]
    /**
     * Get the 'Preferred Networks' field from `self`.
     * 
     * Version of qmi_message_nas_set_preferred_networks_input_get_preferred_networks() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_preferred_networks(): [ /* returnType */ boolean, /* value_preferred_networks_ptr */ MessageNasSetPreferredNetworksInputPreferredNetworksElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetPreferredNetworksInput
    /**
     * Set the 'Clear Previous Preferred Networks' field in the message.
     * @param value_clear_previous_preferred_networks a #gboolean.
     */
    set_clear_previous_preferred_networks(value_clear_previous_preferred_networks: boolean): boolean
    /**
     * Set the 'MNC PCS Digit Include Status' field in the message.
     * @param value_mnc_pcs_digit_include_status_ptr array of #QmiMessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_mnc_pcs_digit_include_status(value_mnc_pcs_digit_include_status_ptr: MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement[]): boolean
    /**
     * Set the 'Preferred Networks' field in the message.
     * @param value_preferred_networks_ptr array of #QmiMessageNasSetPreferredNetworksInputPreferredNetworksElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_preferred_networks(value_preferred_networks_ptr: MessageNasSetPreferredNetworksInputPreferredNetworksElement[]): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasSetPreferredNetworksInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasSetPreferredNetworksInput
}
class MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement */
    /**
     * a #guint16.
     */
    mcc: number
    /**
     * a #guint16.
     */
    mnc: number
    /**
     * a #gboolean.
     */
    includes_pcs_digit: boolean
    static name: string
}
class MessageNasSetPreferredNetworksInputPreferredNetworksElement {
    /* Fields of Qmi-1.0.Qmi.MessageNasSetPreferredNetworksInputPreferredNetworksElement */
    /**
     * a #guint16.
     */
    mcc: number
    /**
     * a #guint16.
     */
    mnc: number
    /**
     * a #QmiNasPlmnAccessTechnologyIdentifier.
     */
    radio_access_technology: NasPlmnAccessTechnologyIdentifier
    static name: string
}
class MessageNasSetPreferredNetworksOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetPreferredNetworksOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetPreferredNetworksOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasSetSystemSelectionPreferenceInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetSystemSelectionPreferenceInput */
    /**
     * Get the 'Acquisition Order Preference' field from `self`.
     */
    get_acquisition_order_preference(): [ /* returnType */ boolean, /* value_acquisition_order_preference */ NasRadioInterface[] | null ]
    /**
     * Get the 'Band Preference' field from `self`.
     */
    get_band_preference(): [ /* returnType */ boolean, /* value_band_preference */ NasBandPreference | null ]
    /**
     * Get the 'CDMA PRL Preference' field from `self`.
     */
    get_cdma_prl_preference(): [ /* returnType */ boolean, /* value_cdma_prl_preference */ NasCdmaPrlPreference | null ]
    /**
     * Get the 'Change Duration' field from `self`.
     */
    get_change_duration(): [ /* returnType */ boolean, /* value_change_duration */ NasChangeDuration | null ]
    /**
     * Get the 'Emergency mode' field from `self`.
     */
    get_emergency_mode(): [ /* returnType */ boolean, /* value_emergency_mode */ boolean | null ]
    /**
     * Get the 'Extended LTE Band Preference' field from `self`.
     */
    get_extended_lte_band_preference(): [ /* returnType */ boolean, /* value_extended_lte_band_preference_mask_low */ number | null, /* value_extended_lte_band_preference_mask_mid_low */ number | null, /* value_extended_lte_band_preference_mask_mid_high */ number | null, /* value_extended_lte_band_preference_mask_high */ number | null ]
    /**
     * Get the 'GSM WCDMA Acquisition Order Preference' field from `self`.
     */
    get_gsm_wcdma_acquisition_order_preference(): [ /* returnType */ boolean, /* value_gsm_wcdma_acquisition_order_preference */ NasGsmWcdmaAcquisitionOrderPreference | null ]
    /**
     * Get the 'LTE Band Preference' field from `self`.
     */
    get_lte_band_preference(): [ /* returnType */ boolean, /* value_lte_band_preference */ NasLteBandPreference | null ]
    /**
     * Get the 'MNC PCS Digit Include Status' field from `self`.
     */
    get_mnc_pcs_digit_include_status(): [ /* returnType */ boolean, /* value_mnc_pcs_digit_include_status */ boolean | null ]
    /**
     * Get the 'Mode Preference' field from `self`.
     */
    get_mode_preference(): [ /* returnType */ boolean, /* value_mode_preference */ NasRatModePreference | null ]
    /**
     * Get the 'Network Selection Preference' field from `self`.
     */
    get_network_selection_preference(): [ /* returnType */ boolean, /* value_network_selection_preference_mode */ NasNetworkSelectionPreference | null, /* value_network_selection_preference_mcc */ number | null, /* value_network_selection_preference_mnc */ number | null ]
    /**
     * Get the 'Network Selection Registration Restriction' field from `self`.
     */
    get_network_selection_registration_restriction(): [ /* returnType */ boolean, /* value_network_selection_registration_restriction */ NasNetworkSelectionRegistrationRestriction | null ]
    /**
     * Get the 'NR5G NSA Band Preference' field from `self`.
     */
    get_nr5g_nsa_band_preference(): [ /* returnType */ boolean, /* value_nr5g_nsa_band_preference_mask_0 */ number | null, /* value_nr5g_nsa_band_preference_mask_1 */ number | null, /* value_nr5g_nsa_band_preference_mask_2 */ number | null, /* value_nr5g_nsa_band_preference_mask_3 */ number | null, /* value_nr5g_nsa_band_preference_mask_4 */ number | null, /* value_nr5g_nsa_band_preference_mask_5 */ number | null, /* value_nr5g_nsa_band_preference_mask_6 */ number | null, /* value_nr5g_nsa_band_preference_mask_7 */ number | null ]
    /**
     * Get the 'NR5G SA Band Preference' field from `self`.
     */
    get_nr5g_sa_band_preference(): [ /* returnType */ boolean, /* value_nr5g_sa_band_preference_mask_0 */ number | null, /* value_nr5g_sa_band_preference_mask_1 */ number | null, /* value_nr5g_sa_band_preference_mask_2 */ number | null, /* value_nr5g_sa_band_preference_mask_3 */ number | null, /* value_nr5g_sa_band_preference_mask_4 */ number | null, /* value_nr5g_sa_band_preference_mask_5 */ number | null, /* value_nr5g_sa_band_preference_mask_6 */ number | null, /* value_nr5g_sa_band_preference_mask_7 */ number | null ]
    /**
     * Get the 'Roaming Preference' field from `self`.
     */
    get_roaming_preference(): [ /* returnType */ boolean, /* value_roaming_preference */ NasRoamingPreference | null ]
    /**
     * Get the 'Service Domain Preference' field from `self`.
     */
    get_service_domain_preference(): [ /* returnType */ boolean, /* value_service_domain_preference */ NasServiceDomainPreference | null ]
    /**
     * Get the 'TD SCDMA Band Preference' field from `self`.
     */
    get_td_scdma_band_preference(): [ /* returnType */ boolean, /* value_td_scdma_band_preference */ NasTdScdmaBandPreference | null ]
    /**
     * Get the 'Usage Preference' field from `self`.
     */
    get_usage_preference(): [ /* returnType */ boolean, /* value_usage_preference */ NasUsagePreference | null ]
    /**
     * Get the 'Voice Domain Preference' field from `self`.
     */
    get_voice_domain_preference(): [ /* returnType */ boolean, /* value_voice_domain_preference */ NasVoiceDomainPreference | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetSystemSelectionPreferenceInput
    /**
     * Set the 'Acquisition Order Preference' field in the message.
     * @param value_acquisition_order_preference a #GArray of #QmiNasRadioInterface elements. A new reference to `value_acquisition_order_preference` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_acquisition_order_preference(value_acquisition_order_preference: NasRadioInterface[]): boolean
    /**
     * Set the 'Band Preference' field in the message.
     * @param value_band_preference a #QmiNasBandPreference.
     */
    set_band_preference(value_band_preference: NasBandPreference): boolean
    /**
     * Set the 'CDMA PRL Preference' field in the message.
     * @param value_cdma_prl_preference a #QmiNasCdmaPrlPreference.
     */
    set_cdma_prl_preference(value_cdma_prl_preference: NasCdmaPrlPreference): boolean
    /**
     * Set the 'Change Duration' field in the message.
     * @param value_change_duration a #QmiNasChangeDuration.
     */
    set_change_duration(value_change_duration: NasChangeDuration): boolean
    /**
     * Set the 'Emergency mode' field in the message.
     * @param value_emergency_mode a #gboolean.
     */
    set_emergency_mode(value_emergency_mode: boolean): boolean
    /**
     * Set the 'Extended LTE Band Preference' field in the message.
     * @param value_extended_lte_band_preference_mask_low a #guint64.
     * @param value_extended_lte_band_preference_mask_mid_low a #guint64.
     * @param value_extended_lte_band_preference_mask_mid_high a #guint64.
     * @param value_extended_lte_band_preference_mask_high a #guint64.
     */
    set_extended_lte_band_preference(value_extended_lte_band_preference_mask_low: number, value_extended_lte_band_preference_mask_mid_low: number, value_extended_lte_band_preference_mask_mid_high: number, value_extended_lte_band_preference_mask_high: number): boolean
    /**
     * Set the 'GSM WCDMA Acquisition Order Preference' field in the message.
     * @param value_gsm_wcdma_acquisition_order_preference a #QmiNasGsmWcdmaAcquisitionOrderPreference.
     */
    set_gsm_wcdma_acquisition_order_preference(value_gsm_wcdma_acquisition_order_preference: NasGsmWcdmaAcquisitionOrderPreference): boolean
    /**
     * Set the 'LTE Band Preference' field in the message.
     * @param value_lte_band_preference a #QmiNasLteBandPreference.
     */
    set_lte_band_preference(value_lte_band_preference: NasLteBandPreference): boolean
    /**
     * Set the 'MNC PCS Digit Include Status' field in the message.
     * @param value_mnc_pcs_digit_include_status a #gboolean.
     */
    set_mnc_pcs_digit_include_status(value_mnc_pcs_digit_include_status: boolean): boolean
    /**
     * Set the 'Mode Preference' field in the message.
     * @param value_mode_preference a #QmiNasRatModePreference.
     */
    set_mode_preference(value_mode_preference: NasRatModePreference): boolean
    /**
     * Set the 'Network Selection Preference' field in the message.
     * @param value_network_selection_preference_mode a #QmiNasNetworkSelectionPreference.
     * @param value_network_selection_preference_mcc a #guint16.
     * @param value_network_selection_preference_mnc a #guint16.
     */
    set_network_selection_preference(value_network_selection_preference_mode: NasNetworkSelectionPreference, value_network_selection_preference_mcc: number, value_network_selection_preference_mnc: number): boolean
    /**
     * Set the 'Network Selection Registration Restriction' field in the message.
     * @param value_network_selection_registration_restriction a #QmiNasNetworkSelectionRegistrationRestriction.
     */
    set_network_selection_registration_restriction(value_network_selection_registration_restriction: NasNetworkSelectionRegistrationRestriction): boolean
    /**
     * Set the 'NR5G NSA Band Preference' field in the message.
     * @param value_nr5g_nsa_band_preference_mask_0 a #guint64.
     * @param value_nr5g_nsa_band_preference_mask_1 a #guint64.
     * @param value_nr5g_nsa_band_preference_mask_2 a #guint64.
     * @param value_nr5g_nsa_band_preference_mask_3 a #guint64.
     * @param value_nr5g_nsa_band_preference_mask_4 a #guint64.
     * @param value_nr5g_nsa_band_preference_mask_5 a #guint64.
     * @param value_nr5g_nsa_band_preference_mask_6 a #guint64.
     * @param value_nr5g_nsa_band_preference_mask_7 a #guint64.
     */
    set_nr5g_nsa_band_preference(value_nr5g_nsa_band_preference_mask_0: number, value_nr5g_nsa_band_preference_mask_1: number, value_nr5g_nsa_band_preference_mask_2: number, value_nr5g_nsa_band_preference_mask_3: number, value_nr5g_nsa_band_preference_mask_4: number, value_nr5g_nsa_band_preference_mask_5: number, value_nr5g_nsa_band_preference_mask_6: number, value_nr5g_nsa_band_preference_mask_7: number): boolean
    /**
     * Set the 'NR5G SA Band Preference' field in the message.
     * @param value_nr5g_sa_band_preference_mask_0 a #guint64.
     * @param value_nr5g_sa_band_preference_mask_1 a #guint64.
     * @param value_nr5g_sa_band_preference_mask_2 a #guint64.
     * @param value_nr5g_sa_band_preference_mask_3 a #guint64.
     * @param value_nr5g_sa_band_preference_mask_4 a #guint64.
     * @param value_nr5g_sa_band_preference_mask_5 a #guint64.
     * @param value_nr5g_sa_band_preference_mask_6 a #guint64.
     * @param value_nr5g_sa_band_preference_mask_7 a #guint64.
     */
    set_nr5g_sa_band_preference(value_nr5g_sa_band_preference_mask_0: number, value_nr5g_sa_band_preference_mask_1: number, value_nr5g_sa_band_preference_mask_2: number, value_nr5g_sa_band_preference_mask_3: number, value_nr5g_sa_band_preference_mask_4: number, value_nr5g_sa_band_preference_mask_5: number, value_nr5g_sa_band_preference_mask_6: number, value_nr5g_sa_band_preference_mask_7: number): boolean
    /**
     * Set the 'Roaming Preference' field in the message.
     * @param value_roaming_preference a #QmiNasRoamingPreference.
     */
    set_roaming_preference(value_roaming_preference: NasRoamingPreference): boolean
    /**
     * Set the 'Service Domain Preference' field in the message.
     * @param value_service_domain_preference a #QmiNasServiceDomainPreference.
     */
    set_service_domain_preference(value_service_domain_preference: NasServiceDomainPreference): boolean
    /**
     * Set the 'TD SCDMA Band Preference' field in the message.
     * @param value_td_scdma_band_preference a #QmiNasTdScdmaBandPreference.
     */
    set_td_scdma_band_preference(value_td_scdma_band_preference: NasTdScdmaBandPreference): boolean
    /**
     * Set the 'Usage Preference' field in the message.
     * @param value_usage_preference a #QmiNasUsagePreference.
     */
    set_usage_preference(value_usage_preference: NasUsagePreference): boolean
    /**
     * Set the 'Voice Domain Preference' field in the message.
     * @param value_voice_domain_preference a #QmiNasVoiceDomainPreference.
     */
    set_voice_domain_preference(value_voice_domain_preference: NasVoiceDomainPreference): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasSetSystemSelectionPreferenceInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasSetSystemSelectionPreferenceInput
}
class MessageNasSetSystemSelectionPreferenceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetSystemSelectionPreferenceOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetSystemSelectionPreferenceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasSetTechnologyPreferenceInput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetTechnologyPreferenceInput */
    /**
     * Get the 'Current' field from `self`.
     */
    get_current(): [ /* returnType */ boolean, /* value_current_technology_preference */ NasRadioTechnologyPreference | null, /* value_current_technology_preference_duration */ NasPreferenceDuration | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetTechnologyPreferenceInput
    /**
     * Set the 'Current' field in the message.
     * @param value_current_technology_preference a #QmiNasRadioTechnologyPreference.
     * @param value_current_technology_preference_duration a #QmiNasPreferenceDuration.
     */
    set_current(value_current_technology_preference: NasRadioTechnologyPreference, value_current_technology_preference_duration: NasPreferenceDuration): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageNasSetTechnologyPreferenceInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageNasSetTechnologyPreferenceInput
}
class MessageNasSetTechnologyPreferenceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSetTechnologyPreferenceOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSetTechnologyPreferenceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageNasSwiGetStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageNasSwiGetStatusOutput */
    /**
     * Get the 'Common Info v2' field from `self`.
     */
    get_common_info_v2(): [ /* returnType */ boolean, /* value_common_info_v2_temperature */ number | null, /* value_common_info_v2_modem_mode */ NasSwiModemMode | null, /* value_common_info_v2_system_mode */ NasSwiSystemMode | null, /* value_common_info_v2_ims_registration_state */ NasSwiImsRegState | null, /* value_common_info_v2_packet_service_state */ NasSwiPsState | null ]
    /**
     * Get the 'LTE Info' field from `self`.
     */
    get_lte_info(): [ /* returnType */ boolean, /* value_lte_info_band */ NasActiveBand | null, /* value_lte_info_bandwidth */ NasDLBandwidth | null, /* value_lte_info_rx_channel */ number | null, /* value_lte_info_tx_channel */ number | null, /* value_lte_info_emm_state */ NasSwiEmmState | null, /* value_lte_info_emm_sub_state */ number | null, /* value_lte_info_emm_connection_state */ NasSwiEmmConnectionState | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageNasSwiGetStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaCancelSessionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaCancelSessionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaCancelSessionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaGetFeatureSettingOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaGetFeatureSettingOutput */
    /**
     * Get the 'Device Provisioning Service Update Config' field from `self`.
     */
    get_device_provisioning_service_update_config(): [ /* returnType */ boolean, /* value_device_provisioning_service_update_config */ boolean | null ]
    /**
     * Get the 'HFA Feature Config' field from `self`.
     */
    get_hfa_feature_config(): [ /* returnType */ boolean, /* value_hfa_feature_config */ boolean | null ]
    /**
     * Get the 'HFA Feature Done State' field from `self`.
     */
    get_hfa_feature_done_state(): [ /* returnType */ boolean, /* value_hfa_feature_done_state */ OmaHfaFeatureDoneState | null ]
    /**
     * Get the 'PRL Update Service Config' field from `self`.
     */
    get_prl_update_service_config(): [ /* returnType */ boolean, /* value_prl_update_service_config */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaGetFeatureSettingOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaGetSessionInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaGetSessionInfoOutput */
    /**
     * Get the 'Network Initiated Alert' field from `self`.
     */
    get_network_initiated_alert(): [ /* returnType */ boolean, /* value_network_initiated_alert_session_type */ OmaSessionType | null, /* value_network_initiated_alert_session_id */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Retry Info' field from `self`.
     */
    get_retry_info(): [ /* returnType */ boolean, /* value_retry_info_retry_count */ number | null, /* value_retry_info_retry_pause_timer */ number | null, /* value_retry_info_retry_pause_timer_remaining */ number | null ]
    /**
     * Get the 'Session Failed Reason' field from `self`.
     */
    get_session_failed_reason(): [ /* returnType */ boolean, /* value_session_failed_reason */ OmaSessionFailedReason | null ]
    /**
     * Get the 'Session Info' field from `self`.
     */
    get_session_info(): [ /* returnType */ boolean, /* value_session_info_session_state */ OmaSessionState | null, /* value_session_info_session_type */ OmaSessionType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaGetSessionInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaSendSelectionInput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaSendSelectionInput */
    /**
     * Get the 'Network Initiated Alert Selection' field from `self`.
     */
    get_network_initiated_alert_selection(): [ /* returnType */ boolean, /* value_network_initiated_alert_selection_control_point_selection_accept */ boolean | null, /* value_network_initiated_alert_selection_session_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaSendSelectionInput
    /**
     * Set the 'Network Initiated Alert Selection' field in the message.
     * @param value_network_initiated_alert_selection_control_point_selection_accept a #gboolean.
     * @param value_network_initiated_alert_selection_session_id a #guint16.
     */
    set_network_initiated_alert_selection(value_network_initiated_alert_selection_control_point_selection_accept: boolean, value_network_initiated_alert_selection_session_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageOmaSendSelectionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageOmaSendSelectionInput
}
class MessageOmaSendSelectionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaSendSelectionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaSendSelectionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaSetEventReportInput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaSetEventReportInput */
    /**
     * Get the 'Network Initiated Alert Reporting' field from `self`.
     */
    get_network_initiated_alert_reporting(): [ /* returnType */ boolean, /* value_network_initiated_alert_reporting */ boolean | null ]
    /**
     * Get the 'Session State Reporting' field from `self`.
     */
    get_session_state_reporting(): [ /* returnType */ boolean, /* value_session_state_reporting */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaSetEventReportInput
    /**
     * Set the 'Network Initiated Alert Reporting' field in the message.
     * @param value_network_initiated_alert_reporting a #gboolean.
     */
    set_network_initiated_alert_reporting(value_network_initiated_alert_reporting: boolean): boolean
    /**
     * Set the 'Session State Reporting' field in the message.
     * @param value_session_state_reporting a #gboolean.
     */
    set_session_state_reporting(value_session_state_reporting: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageOmaSetEventReportInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageOmaSetEventReportInput
}
class MessageOmaSetEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaSetEventReportOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaSetEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaSetFeatureSettingInput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaSetFeatureSettingInput */
    /**
     * Get the 'Device Provisioning Service Update Config' field from `self`.
     */
    get_device_provisioning_service_update_config(): [ /* returnType */ boolean, /* value_device_provisioning_service_update_config */ boolean | null ]
    /**
     * Get the 'HFA Feature Config' field from `self`.
     */
    get_hfa_feature_config(): [ /* returnType */ boolean, /* value_hfa_feature_config */ boolean | null ]
    /**
     * Get the 'PRL Update Service Config' field from `self`.
     */
    get_prl_update_service_config(): [ /* returnType */ boolean, /* value_prl_update_service_config */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaSetFeatureSettingInput
    /**
     * Set the 'Device Provisioning Service Update Config' field in the message.
     * @param value_device_provisioning_service_update_config a #gboolean.
     */
    set_device_provisioning_service_update_config(value_device_provisioning_service_update_config: boolean): boolean
    /**
     * Set the 'HFA Feature Config' field in the message.
     * @param value_hfa_feature_config a #gboolean.
     */
    set_hfa_feature_config(value_hfa_feature_config: boolean): boolean
    /**
     * Set the 'PRL Update Service Config' field in the message.
     * @param value_prl_update_service_config a #gboolean.
     */
    set_prl_update_service_config(value_prl_update_service_config: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageOmaSetFeatureSettingInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageOmaSetFeatureSettingInput
}
class MessageOmaSetFeatureSettingOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaSetFeatureSettingOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaSetFeatureSettingOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageOmaStartSessionInput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaStartSessionInput */
    /**
     * Get the 'Session Type' field from `self`.
     */
    get_session_type(): [ /* returnType */ boolean, /* value_session_type */ OmaSessionType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaStartSessionInput
    /**
     * Set the 'Session Type' field in the message.
     * @param value_session_type a #QmiOmaSessionType.
     */
    set_session_type(value_session_type: OmaSessionType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageOmaStartSessionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageOmaStartSessionInput
}
class MessageOmaStartSessionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageOmaStartSessionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageOmaStartSessionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePbmGetAllCapabilitiesOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutput */
    /**
     * Get the 'Additional Number Alpha String Capability' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_additional_number_alpha_string_capability() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_additional_number_alpha_string_capability(): [ /* returnType */ boolean, /* value_additional_number_alpha_string_capability_ptr */ MessagePbmGetAllCapabilitiesOutputAdditionalNumberAlphaStringCapabilityElement[] | null ]
    /**
     * Get the 'Additional Number Capability' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_additional_number_capability() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_additional_number_capability(): [ /* returnType */ boolean, /* value_additional_number_capability_ptr */ MessagePbmGetAllCapabilitiesOutputAdditionalNumberCapabilityElement[] | null ]
    /**
     * Get the 'Capability Basic Information' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_capability_basic_information() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_capability_basic_information(): [ /* returnType */ boolean, /* value_capability_basic_information_ptr */ MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementGir[] | null ]
    /**
     * Get the 'Email Capability' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_email_capability() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_email_capability(): [ /* returnType */ boolean, /* value_email_capability_ptr */ MessagePbmGetAllCapabilitiesOutputEmailCapabilityElement[] | null ]
    /**
     * Get the 'Group Capability' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_group_capability() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_group_capability(): [ /* returnType */ boolean, /* value_group_capability_ptr */ MessagePbmGetAllCapabilitiesOutputGroupCapabilityElement[] | null ]
    /**
     * Get the 'Grouping Information Alpha String Capability' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_grouping_information_alpha_string_capability() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_grouping_information_alpha_string_capability(): [ /* returnType */ boolean, /* value_grouping_information_alpha_string_capability_ptr */ MessagePbmGetAllCapabilitiesOutputGroupingInformationAlphaStringCapabilityElement[] | null ]
    /**
     * Get the 'Hidden Records Capability' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_hidden_records_capability() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_hidden_records_capability(): [ /* returnType */ boolean, /* value_hidden_records_capability_ptr */ MessagePbmGetAllCapabilitiesOutputHiddenRecordsCapabilityElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Second Name Capability' field from `self`.
     * 
     * Version of qmi_message_pbm_get_all_capabilities_output_get_second_name_capability() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_second_name_capability(): [ /* returnType */ boolean, /* value_second_name_capability_ptr */ MessagePbmGetAllCapabilitiesOutputSecondNameCapabilityElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePbmGetAllCapabilitiesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputAdditionalNumberAlphaStringCapabilityElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputAdditionalNumberAlphaStringCapabilityElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #guint8.
     */
    maximum_records: number
    /**
     * a #guint8.
     */
    used_records: number
    /**
     * a #guint8.
     */
    maximum_string_length: number
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputAdditionalNumberCapabilityElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputAdditionalNumberCapabilityElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #guint8.
     */
    maximum_additional_numbers: number
    /**
     * a #guint8.
     */
    maximum_additional_number_length: number
    /**
     * a #guint8.
     */
    maximum_additional_number_tag_length: number
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #GArray of #QmiMessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement elements.
     */
    phonebooks: object[]
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementGir {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementGir */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * an array of #QmiMessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement elements.
     */
    phonebooks: MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement[]
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement */
    /**
     * a #QmiPbmPhonebookType.
     */
    phonebook_type: PbmPhonebookType
    /**
     * a #guint16.
     */
    used_records: number
    /**
     * a #guint16.
     */
    maximum_records: number
    /**
     * a #guint8.
     */
    maximum_number_length: number
    /**
     * a #guint8.
     */
    maximum_name_length: number
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputEmailCapabilityElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputEmailCapabilityElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #guint8.
     */
    maximum_emails: number
    /**
     * a #guint8.
     */
    maximum_email_address_length: number
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputGroupCapabilityElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputGroupCapabilityElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #guint8.
     */
    maximum_groups: number
    /**
     * a #guint8.
     */
    maximum_group_tag_length: number
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputGroupingInformationAlphaStringCapabilityElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputGroupingInformationAlphaStringCapabilityElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #guint8.
     */
    maximum_records: number
    /**
     * a #guint8.
     */
    used_records: number
    /**
     * a #guint8.
     */
    maximum_string_length: number
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputHiddenRecordsCapabilityElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputHiddenRecordsCapabilityElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #gboolean.
     */
    supported: boolean
    static name: string
}
class MessagePbmGetAllCapabilitiesOutputSecondNameCapabilityElement {
    /* Fields of Qmi-1.0.Qmi.MessagePbmGetAllCapabilitiesOutputSecondNameCapabilityElement */
    /**
     * a #QmiPbmSessionType.
     */
    session_type: PbmSessionType
    /**
     * a #guint8.
     */
    maximum_second_name_length: number
    static name: string
}
class MessagePbmGetCapabilitiesInput {
    /* Methods of Qmi-1.0.Qmi.MessagePbmGetCapabilitiesInput */
    /**
     * Get the 'Phonebook Information' field from `self`.
     */
    get_phonebook_information(): [ /* returnType */ boolean, /* value_phonebook_information_session_type */ PbmSessionType | null, /* value_phonebook_information_phonebook_type */ PbmPhonebookType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePbmGetCapabilitiesInput
    /**
     * Set the 'Phonebook Information' field in the message.
     * @param value_phonebook_information_session_type a #QmiPbmSessionType.
     * @param value_phonebook_information_phonebook_type a #QmiPbmPhonebookType.
     */
    set_phonebook_information(value_phonebook_information_session_type: PbmSessionType, value_phonebook_information_phonebook_type: PbmPhonebookType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePbmGetCapabilitiesInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePbmGetCapabilitiesInput
}
class MessagePbmGetCapabilitiesOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePbmGetCapabilitiesOutput */
    /**
     * Get the 'Additional Number Alpha String Capability' field from `self`.
     */
    get_additional_number_alpha_string_capability(): [ /* returnType */ boolean, /* value_additional_number_alpha_string_capability_maximum_records */ number | null, /* value_additional_number_alpha_string_capability_used_records */ number | null, /* value_additional_number_alpha_string_capability_maximum_string_length */ number | null ]
    /**
     * Get the 'Additional Number Capability' field from `self`.
     */
    get_additional_number_capability(): [ /* returnType */ boolean, /* value_additional_number_capability_maximum_additional_numbers */ number | null, /* value_additional_number_capability_maximum_additional_number_length */ number | null, /* value_additional_number_capability_maximum_additional_number_tag_length */ number | null ]
    /**
     * Get the 'Capability Basic Information' field from `self`.
     */
    get_capability_basic_information(): [ /* returnType */ boolean, /* value_capability_basic_information_session_type */ PbmSessionType | null, /* value_capability_basic_information_phonebook_type */ PbmPhonebookType | null, /* value_capability_basic_information_used_records */ number | null, /* value_capability_basic_information_maximum_records */ number | null, /* value_capability_basic_information_maximum_number_length */ number | null, /* value_capability_basic_information_maximum_name_length */ number | null ]
    /**
     * Get the 'Email Capability' field from `self`.
     */
    get_email_capability(): [ /* returnType */ boolean, /* value_email_capability_maximum_emails */ number | null, /* value_email_capability_maximum_email_address_length */ number | null ]
    /**
     * Get the 'Group Capability' field from `self`.
     */
    get_group_capability(): [ /* returnType */ boolean, /* value_group_capability_maximum_groups */ number | null, /* value_group_capability_maximum_group_tag_length */ number | null ]
    /**
     * Get the 'Grouping Information Alpha String Capability' field from `self`.
     */
    get_grouping_information_alpha_string_capability(): [ /* returnType */ boolean, /* value_grouping_information_alpha_string_capability_maximum_records */ number | null, /* value_grouping_information_alpha_string_capability_used_records */ number | null, /* value_grouping_information_alpha_string_capability_maximum_string_length */ number | null ]
    /**
     * Get the 'Hidden Records Capability' field from `self`.
     */
    get_hidden_records_capability(): [ /* returnType */ boolean, /* value_hidden_records_capability_supported */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Second Name Capability' field from `self`.
     */
    get_second_name_capability(): [ /* returnType */ boolean, /* value_second_name_capability_maximum_second_name_length */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePbmGetCapabilitiesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePbmIndicationRegisterInput {
    /* Methods of Qmi-1.0.Qmi.MessagePbmIndicationRegisterInput */
    /**
     * Get the 'Event Registration Mask' field from `self`.
     */
    get_event_registration_mask(): [ /* returnType */ boolean, /* value_event_registration_mask */ PbmEventRegistrationFlag | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePbmIndicationRegisterInput
    /**
     * Set the 'Event Registration Mask' field in the message.
     * @param value_event_registration_mask a #QmiPbmEventRegistrationFlag.
     */
    set_event_registration_mask(value_event_registration_mask: PbmEventRegistrationFlag): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePbmIndicationRegisterInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePbmIndicationRegisterInput
}
class MessagePbmIndicationRegisterOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePbmIndicationRegisterOutput */
    /**
     * Get the 'Event Registration Mask' field from `self`.
     */
    get_event_registration_mask(): [ /* returnType */ boolean, /* value_event_registration_mask */ PbmEventRegistrationFlag | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePbmIndicationRegisterOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcActivateConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcActivateConfigInput */
    /**
     * Get the 'Config Type' field from `self`.
     */
    get_config_type(): [ /* returnType */ boolean, /* value_config_type */ PdcConfigurationType | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcActivateConfigInput
    /**
     * Set the 'Config Type' field in the message.
     * @param value_config_type a #QmiPdcConfigurationType.
     */
    set_config_type(value_config_type: PdcConfigurationType): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcActivateConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcActivateConfigInput
}
class MessagePdcActivateConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcActivateConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcActivateConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcConfigChangeInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcConfigChangeInput */
    /**
     * Get the 'Type With Id v2' field from `self`.
     */
    get_type_with_id_v2(): [ /* returnType */ boolean, /* value_type_with_id_v2_config_type */ PdcConfigurationType | null, /* value_type_with_id_v2_id */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcConfigChangeInput
    /**
     * Set the 'Type With Id v2' field in the message.
     * @param value_type_with_id_v2_config_type a #QmiPdcConfigurationType.
     * @param value_type_with_id_v2_id a #GArray of #guint8 elements. A new reference to `value_type_with_id_v2`_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_type_with_id_v2(value_type_with_id_v2_config_type: PdcConfigurationType, value_type_with_id_v2_id: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcConfigChangeInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcConfigChangeInput
}
class MessagePdcConfigChangeOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcConfigChangeOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Type With Id v2' field from `self`.
     */
    get_type_with_id_v2(): [ /* returnType */ boolean, /* value_type_with_id_v2_config_type */ PdcConfigurationType | null, /* value_type_with_id_v2_id */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcConfigChangeOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcDeactivateConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcDeactivateConfigInput */
    /**
     * Get the 'Config Type' field from `self`.
     */
    get_config_type(): [ /* returnType */ boolean, /* value_config_type */ PdcConfigurationType | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcDeactivateConfigInput
    /**
     * Set the 'Config Type' field in the message.
     * @param value_config_type a #QmiPdcConfigurationType.
     */
    set_config_type(value_config_type: PdcConfigurationType): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcDeactivateConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcDeactivateConfigInput
}
class MessagePdcDeactivateConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcDeactivateConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcDeactivateConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcDeleteConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcDeleteConfigInput */
    /**
     * Get the 'Config Type' field from `self`.
     */
    get_config_type(): [ /* returnType */ boolean, /* value_config_type */ PdcConfigurationType | null ]
    /**
     * Get the 'Id' field from `self`.
     */
    get_id(): [ /* returnType */ boolean, /* value_id */ Uint8Array | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcDeleteConfigInput
    /**
     * Set the 'Config Type' field in the message.
     * @param value_config_type a #QmiPdcConfigurationType.
     */
    set_config_type(value_config_type: PdcConfigurationType): boolean
    /**
     * Set the 'Id' field in the message.
     * @param value_id a #GArray of #guint8 elements. A new reference to `value_id` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_id(value_id: Uint8Array): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcDeleteConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcDeleteConfigInput
}
class MessagePdcDeleteConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcDeleteConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcDeleteConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcGetConfigInfoInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetConfigInfoInput */
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Get the 'Type With Id v2' field from `self`.
     */
    get_type_with_id_v2(): [ /* returnType */ boolean, /* value_type_with_id_v2_config_type */ PdcConfigurationType | null, /* value_type_with_id_v2_id */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetConfigInfoInput
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Set the 'Type With Id v2' field in the message.
     * @param value_type_with_id_v2_config_type a #QmiPdcConfigurationType.
     * @param value_type_with_id_v2_id a #GArray of #guint8 elements. A new reference to `value_type_with_id_v2`_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_type_with_id_v2(value_type_with_id_v2_config_type: PdcConfigurationType, value_type_with_id_v2_id: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcGetConfigInfoInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcGetConfigInfoInput
}
class MessagePdcGetConfigInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetConfigInfoOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetConfigInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcGetConfigLimitsInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetConfigLimitsInput */
    /**
     * Get the 'Config Type' field from `self`.
     */
    get_config_type(): [ /* returnType */ boolean, /* value_config_type */ PdcConfigurationType | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetConfigLimitsInput
    /**
     * Set the 'Config Type' field in the message.
     * @param value_config_type a #QmiPdcConfigurationType.
     */
    set_config_type(value_config_type: PdcConfigurationType): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcGetConfigLimitsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcGetConfigLimitsInput
}
class MessagePdcGetConfigLimitsOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetConfigLimitsOutput */
    /**
     * Get the 'Current Size' field from `self`.
     */
    get_current_size(): [ /* returnType */ boolean, /* value_current_size */ number | null ]
    /**
     * Get the 'Maximum Size' field from `self`.
     */
    get_maximum_size(): [ /* returnType */ boolean, /* value_maximum_size */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetConfigLimitsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcGetDefaultConfigInfoInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetDefaultConfigInfoInput */
    /**
     * Get the 'Config Type' field from `self`.
     */
    get_config_type(): [ /* returnType */ boolean, /* value_config_type */ PdcConfigurationType | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetDefaultConfigInfoInput
    /**
     * Set the 'Config Type' field in the message.
     * @param value_config_type a #QmiPdcConfigurationType.
     */
    set_config_type(value_config_type: PdcConfigurationType): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcGetDefaultConfigInfoInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcGetDefaultConfigInfoInput
}
class MessagePdcGetDefaultConfigInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetDefaultConfigInfoOutput */
    /**
     * Get the 'Description' field from `self`.
     */
    get_description(): [ /* returnType */ boolean, /* value_description */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Get the 'Total Size' field from `self`.
     */
    get_total_size(): [ /* returnType */ boolean, /* value_total_size */ number | null ]
    /**
     * Get the 'Version' field from `self`.
     */
    get_version(): [ /* returnType */ boolean, /* value_version */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetDefaultConfigInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcGetSelectedConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetSelectedConfigInput */
    /**
     * Get the 'Config Type' field from `self`.
     */
    get_config_type(): [ /* returnType */ boolean, /* value_config_type */ PdcConfigurationType | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetSelectedConfigInput
    /**
     * Set the 'Config Type' field in the message.
     * @param value_config_type a #QmiPdcConfigurationType.
     */
    set_config_type(value_config_type: PdcConfigurationType): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcGetSelectedConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcGetSelectedConfigInput
}
class MessagePdcGetSelectedConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcGetSelectedConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcGetSelectedConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcListConfigsInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcListConfigsInput */
    /**
     * Get the 'Config Type' field from `self`.
     */
    get_config_type(): [ /* returnType */ boolean, /* value_config_type */ PdcConfigurationType | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcListConfigsInput
    /**
     * Set the 'Config Type' field in the message.
     * @param value_config_type a #QmiPdcConfigurationType.
     */
    set_config_type(value_config_type: PdcConfigurationType): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcListConfigsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcListConfigsInput
}
class MessagePdcListConfigsOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcListConfigsOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcListConfigsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcLoadConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcLoadConfigInput */
    /**
     * Get the 'Config Chunk' field from `self`.
     */
    get_config_chunk(): [ /* returnType */ boolean, /* value_config_chunk_type */ PdcConfigurationType | null, /* value_config_chunk_id */ Uint8Array | null, /* value_config_chunk_total_size */ number | null, /* value_config_chunk_chunk */ Uint8Array | null ]
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcLoadConfigInput
    /**
     * Set the 'Config Chunk' field in the message.
     * @param value_config_chunk_type a #QmiPdcConfigurationType.
     * @param value_config_chunk_id a #GArray of #guint8 elements. A new reference to `value_config_chunk_id` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     * @param value_config_chunk_total_size a #guint32.
     * @param value_config_chunk_chunk a #GArray of #guint8 elements. A new reference to `value_config_chunk_chunk` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_config_chunk(value_config_chunk_type: PdcConfigurationType, value_config_chunk_id: Uint8Array, value_config_chunk_total_size: number, value_config_chunk_chunk: Uint8Array): boolean
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcLoadConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcLoadConfigInput
}
class MessagePdcLoadConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcLoadConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcLoadConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcRegisterInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcRegisterInput */
    /**
     * Get the 'Enable Refresh' field from `self`.
     */
    get_enable_refresh(): [ /* returnType */ boolean, /* value_enable_refresh */ boolean | null ]
    /**
     * Get the 'Enable Reporting' field from `self`.
     */
    get_enable_reporting(): [ /* returnType */ boolean, /* value_enable_reporting */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcRegisterInput
    /**
     * Set the 'Enable Refresh' field in the message.
     * @param value_enable_refresh a #gboolean.
     */
    set_enable_refresh(value_enable_refresh: boolean): boolean
    /**
     * Set the 'Enable Reporting' field in the message.
     * @param value_enable_reporting a #gboolean.
     */
    set_enable_reporting(value_enable_reporting: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcRegisterInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcRegisterInput
}
class MessagePdcRegisterOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcRegisterOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcRegisterOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdcSetSelectedConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcSetSelectedConfigInput */
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Get the 'Type With Id v2' field from `self`.
     */
    get_type_with_id_v2(): [ /* returnType */ boolean, /* value_type_with_id_v2_config_type */ PdcConfigurationType | null, /* value_type_with_id_v2_id */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcSetSelectedConfigInput
    /**
     * Set the 'Token' field in the message.
     * @param value_token a #guint32.
     */
    set_token(value_token: number): boolean
    /**
     * Set the 'Type With Id v2' field in the message.
     * @param value_type_with_id_v2_config_type a #QmiPdcConfigurationType.
     * @param value_type_with_id_v2_id a #GArray of #guint8 elements. A new reference to `value_type_with_id_v2`_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_type_with_id_v2(value_type_with_id_v2_config_type: PdcConfigurationType, value_type_with_id_v2_id: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdcSetSelectedConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdcSetSelectedConfigInput
}
class MessagePdcSetSelectedConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdcSetSelectedConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Token' field from `self`.
     */
    get_token(): [ /* returnType */ boolean, /* value_token */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdcSetSelectedConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsGetAgpsConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsGetAgpsConfigInput */
    /**
     * Get the 'Network Mode' field from `self`.
     */
    get_network_mode(): [ /* returnType */ boolean, /* value_network_mode */ PdsNetworkMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsGetAgpsConfigInput
    /**
     * Set the 'Network Mode' field in the message.
     * @param value_network_mode a #QmiPdsNetworkMode.
     */
    set_network_mode(value_network_mode: PdsNetworkMode): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdsGetAgpsConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdsGetAgpsConfigInput
}
class MessagePdsGetAgpsConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsGetAgpsConfigOutput */
    /**
     * Get the 'Location Server Address' field from `self`.
     */
    get_location_server_address(): [ /* returnType */ boolean, /* value_location_server_address_ip */ number | null, /* value_location_server_address_port */ number | null ]
    /**
     * Get the 'Location Server URL' field from `self`.
     */
    get_location_server_url(): [ /* returnType */ boolean, /* value_location_server_url */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsGetAgpsConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsGetAutoTrackingStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsGetAutoTrackingStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'State' field from `self`.
     */
    get_state(): [ /* returnType */ boolean, /* value_state_auto_tracking_state */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsGetAutoTrackingStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsGetDefaultTrackingSessionOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsGetDefaultTrackingSessionOutput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_session_operation */ PdsOperatingMode | null, /* value_info_position_data_timeout */ number | null, /* value_info_interval */ number | null, /* value_info_accuracy_threshold */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsGetDefaultTrackingSessionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsGetGpsServiceStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsGetGpsServiceStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'State' field from `self`.
     */
    get_state(): [ /* returnType */ boolean, /* value_state_gps_service_state */ boolean | null, /* value_state_tracking_session_state */ PdsTrackingSessionState | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsGetGpsServiceStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsSetAgpsConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetAgpsConfigInput */
    /**
     * Get the 'Location Server Address' field from `self`.
     */
    get_location_server_address(): [ /* returnType */ boolean, /* value_location_server_address_ip */ number | null, /* value_location_server_address_port */ number | null ]
    /**
     * Get the 'Location Server URL' field from `self`.
     */
    get_location_server_url(): [ /* returnType */ boolean, /* value_location_server_url */ Uint8Array | null ]
    /**
     * Get the 'Network Mode' field from `self`.
     */
    get_network_mode(): [ /* returnType */ boolean, /* value_network_mode */ PdsNetworkMode | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetAgpsConfigInput
    /**
     * Set the 'Location Server Address' field in the message.
     * @param value_location_server_address_ip a #guint32.
     * @param value_location_server_address_port a #guint32.
     */
    set_location_server_address(value_location_server_address_ip: number, value_location_server_address_port: number): boolean
    /**
     * Set the 'Location Server URL' field in the message.
     * @param value_location_server_url a #GArray of #guint8 elements. A new reference to `value_location_server_url` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_location_server_url(value_location_server_url: Uint8Array): boolean
    /**
     * Set the 'Network Mode' field in the message.
     * @param value_network_mode a #QmiPdsNetworkMode.
     */
    set_network_mode(value_network_mode: PdsNetworkMode): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdsSetAgpsConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdsSetAgpsConfigInput
}
class MessagePdsSetAgpsConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetAgpsConfigOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetAgpsConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsSetAutoTrackingStateInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetAutoTrackingStateInput */
    /**
     * Get the 'State' field from `self`.
     */
    get_state(): [ /* returnType */ boolean, /* value_state_auto_tracking_state */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetAutoTrackingStateInput
    /**
     * Set the 'State' field in the message.
     * @param value_state_auto_tracking_state a #gboolean.
     */
    set_state(value_state_auto_tracking_state: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdsSetAutoTrackingStateInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdsSetAutoTrackingStateInput
}
class MessagePdsSetAutoTrackingStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetAutoTrackingStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetAutoTrackingStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsSetDefaultTrackingSessionInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetDefaultTrackingSessionInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_session_operation */ PdsOperatingMode | null, /* value_info_position_data_timeout */ number | null, /* value_info_interval */ number | null, /* value_info_accuracy_threshold */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetDefaultTrackingSessionInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_session_operation a #QmiPdsOperatingMode.
     * @param value_info_position_data_timeout a #guint8.
     * @param value_info_interval a #guint32.
     * @param value_info_accuracy_threshold a #guint32.
     */
    set_info(value_info_session_operation: PdsOperatingMode, value_info_position_data_timeout: number, value_info_interval: number, value_info_accuracy_threshold: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdsSetDefaultTrackingSessionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdsSetDefaultTrackingSessionInput
}
class MessagePdsSetDefaultTrackingSessionOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetDefaultTrackingSessionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetDefaultTrackingSessionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsSetEventReportInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetEventReportInput */
    /**
     * Get the 'Accelerometer Data Streaming Ready Reporting' field from `self`.
     */
    get_accelerometer_data_streaming_ready_reporting(): [ /* returnType */ boolean, /* value_accelerometer_data_streaming_ready_reporting */ boolean | null ]
    /**
     * Get the 'Extended External XTRA Data Request Reporting' field from `self`.
     */
    get_extended_external_xtra_data_request_reporting(): [ /* returnType */ boolean, /* value_extended_external_xtra_data_request_reporting */ boolean | null ]
    /**
     * Get the 'Extended NMEA Position Reporting' field from `self`.
     */
    get_extended_nmea_position_reporting(): [ /* returnType */ boolean, /* value_extended_nmea_position_reporting */ boolean | null ]
    /**
     * Get the 'External Time Injection Request Reporting' field from `self`.
     */
    get_external_time_injection_request_reporting(): [ /* returnType */ boolean, /* value_external_time_injection_request_reporting */ boolean | null ]
    /**
     * Get the 'External WIFI Position Request Reporting' field from `self`.
     */
    get_external_wifi_position_request_reporting(): [ /* returnType */ boolean, /* value_external_wifi_position_request_reporting */ boolean | null ]
    /**
     * Get the 'External XTRA Data Request Reporting' field from `self`.
     */
    get_external_xtra_data_request_reporting(): [ /* returnType */ boolean, /* value_external_xtra_data_request_reporting */ boolean | null ]
    /**
     * Get the 'Gyro Data Streaming Ready Reporting' field from `self`.
     */
    get_gyro_data_streaming_ready_reporting(): [ /* returnType */ boolean, /* value_gyro_data_streaming_ready_reporting */ boolean | null ]
    /**
     * Get the 'Heading Uncertainty Reporting' field from `self`.
     */
    get_heading_uncertainty_reporting(): [ /* returnType */ boolean, /* value_heading_uncertainty_reporting */ boolean | null ]
    /**
     * Get the 'NMEA Debug Strings Reporting' field from `self`.
     */
    get_nmea_debug_strings_reporting(): [ /* returnType */ boolean, /* value_nmea_debug_strings_reporting */ boolean | null ]
    /**
     * Get the 'NMEA Position Reporting' field from `self`.
     */
    get_nmea_position_reporting(): [ /* returnType */ boolean, /* value_nmea_position_reporting */ boolean | null ]
    /**
     * Get the 'Parsed Position Reporting' field from `self`.
     */
    get_parsed_position_reporting(): [ /* returnType */ boolean, /* value_parsed_position_reporting */ boolean | null ]
    /**
     * Get the 'PDS Comm Event Reporting' field from `self`.
     */
    get_pds_comm_event_reporting(): [ /* returnType */ boolean, /* value_pds_comm_event_reporting */ boolean | null ]
    /**
     * Get the 'Position Reliability Indicator Reporting' field from `self`.
     */
    get_position_reliability_indicator_reporting(): [ /* returnType */ boolean, /* value_position_reliability_indicator_reporting */ boolean | null ]
    /**
     * Get the 'Satellite Information Reporting' field from `self`.
     */
    get_satellite_information_reporting(): [ /* returnType */ boolean, /* value_satellite_information_reporting */ boolean | null ]
    /**
     * Get the 'Sensor Data Usage Indicator Reporting' field from `self`.
     */
    get_sensor_data_usage_indicator_reporting(): [ /* returnType */ boolean, /* value_sensor_data_usage_indicator_reporting */ boolean | null ]
    /**
     * Get the 'SUPL Network Initiated Prompt Reporting' field from `self`.
     */
    get_supl_network_initiated_prompt_reporting(): [ /* returnType */ boolean, /* value_supl_network_initiated_prompt_reporting */ boolean | null ]
    /**
     * Get the 'Time Source Information Reporting' field from `self`.
     */
    get_time_source_information_reporting(): [ /* returnType */ boolean, /* value_time_source_information_reporting */ boolean | null ]
    /**
     * Get the 'Time Sync Request Reporting' field from `self`.
     */
    get_time_sync_request_reporting(): [ /* returnType */ boolean, /* value_time_sync_request_reporting */ boolean | null ]
    /**
     * Get the 'UMTS CP Network Initiated Prompt Reporting' field from `self`.
     */
    get_umts_cp_network_initiated_prompt_reporting(): [ /* returnType */ boolean, /* value_umts_cp_network_initiated_prompt_reporting */ boolean | null ]
    /**
     * Get the 'VX Network Initiated Request Reporting' field from `self`.
     */
    get_vx_network_initiated_request_reporting(): [ /* returnType */ boolean, /* value_vx_network_initiated_request_reporting */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetEventReportInput
    /**
     * Set the 'Accelerometer Data Streaming Ready Reporting' field in the message.
     * @param value_accelerometer_data_streaming_ready_reporting a #gboolean.
     */
    set_accelerometer_data_streaming_ready_reporting(value_accelerometer_data_streaming_ready_reporting: boolean): boolean
    /**
     * Set the 'Extended External XTRA Data Request Reporting' field in the message.
     * @param value_extended_external_xtra_data_request_reporting a #gboolean.
     */
    set_extended_external_xtra_data_request_reporting(value_extended_external_xtra_data_request_reporting: boolean): boolean
    /**
     * Set the 'Extended NMEA Position Reporting' field in the message.
     * @param value_extended_nmea_position_reporting a #gboolean.
     */
    set_extended_nmea_position_reporting(value_extended_nmea_position_reporting: boolean): boolean
    /**
     * Set the 'External Time Injection Request Reporting' field in the message.
     * @param value_external_time_injection_request_reporting a #gboolean.
     */
    set_external_time_injection_request_reporting(value_external_time_injection_request_reporting: boolean): boolean
    /**
     * Set the 'External WIFI Position Request Reporting' field in the message.
     * @param value_external_wifi_position_request_reporting a #gboolean.
     */
    set_external_wifi_position_request_reporting(value_external_wifi_position_request_reporting: boolean): boolean
    /**
     * Set the 'External XTRA Data Request Reporting' field in the message.
     * @param value_external_xtra_data_request_reporting a #gboolean.
     */
    set_external_xtra_data_request_reporting(value_external_xtra_data_request_reporting: boolean): boolean
    /**
     * Set the 'Gyro Data Streaming Ready Reporting' field in the message.
     * @param value_gyro_data_streaming_ready_reporting a #gboolean.
     */
    set_gyro_data_streaming_ready_reporting(value_gyro_data_streaming_ready_reporting: boolean): boolean
    /**
     * Set the 'Heading Uncertainty Reporting' field in the message.
     * @param value_heading_uncertainty_reporting a #gboolean.
     */
    set_heading_uncertainty_reporting(value_heading_uncertainty_reporting: boolean): boolean
    /**
     * Set the 'NMEA Debug Strings Reporting' field in the message.
     * @param value_nmea_debug_strings_reporting a #gboolean.
     */
    set_nmea_debug_strings_reporting(value_nmea_debug_strings_reporting: boolean): boolean
    /**
     * Set the 'NMEA Position Reporting' field in the message.
     * @param value_nmea_position_reporting a #gboolean.
     */
    set_nmea_position_reporting(value_nmea_position_reporting: boolean): boolean
    /**
     * Set the 'Parsed Position Reporting' field in the message.
     * @param value_parsed_position_reporting a #gboolean.
     */
    set_parsed_position_reporting(value_parsed_position_reporting: boolean): boolean
    /**
     * Set the 'PDS Comm Event Reporting' field in the message.
     * @param value_pds_comm_event_reporting a #gboolean.
     */
    set_pds_comm_event_reporting(value_pds_comm_event_reporting: boolean): boolean
    /**
     * Set the 'Position Reliability Indicator Reporting' field in the message.
     * @param value_position_reliability_indicator_reporting a #gboolean.
     */
    set_position_reliability_indicator_reporting(value_position_reliability_indicator_reporting: boolean): boolean
    /**
     * Set the 'Satellite Information Reporting' field in the message.
     * @param value_satellite_information_reporting a #gboolean.
     */
    set_satellite_information_reporting(value_satellite_information_reporting: boolean): boolean
    /**
     * Set the 'Sensor Data Usage Indicator Reporting' field in the message.
     * @param value_sensor_data_usage_indicator_reporting a #gboolean.
     */
    set_sensor_data_usage_indicator_reporting(value_sensor_data_usage_indicator_reporting: boolean): boolean
    /**
     * Set the 'SUPL Network Initiated Prompt Reporting' field in the message.
     * @param value_supl_network_initiated_prompt_reporting a #gboolean.
     */
    set_supl_network_initiated_prompt_reporting(value_supl_network_initiated_prompt_reporting: boolean): boolean
    /**
     * Set the 'Time Source Information Reporting' field in the message.
     * @param value_time_source_information_reporting a #gboolean.
     */
    set_time_source_information_reporting(value_time_source_information_reporting: boolean): boolean
    /**
     * Set the 'Time Sync Request Reporting' field in the message.
     * @param value_time_sync_request_reporting a #gboolean.
     */
    set_time_sync_request_reporting(value_time_sync_request_reporting: boolean): boolean
    /**
     * Set the 'UMTS CP Network Initiated Prompt Reporting' field in the message.
     * @param value_umts_cp_network_initiated_prompt_reporting a #gboolean.
     */
    set_umts_cp_network_initiated_prompt_reporting(value_umts_cp_network_initiated_prompt_reporting: boolean): boolean
    /**
     * Set the 'VX Network Initiated Request Reporting' field in the message.
     * @param value_vx_network_initiated_request_reporting a #gboolean.
     */
    set_vx_network_initiated_request_reporting(value_vx_network_initiated_request_reporting: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdsSetEventReportInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdsSetEventReportInput
}
class MessagePdsSetEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetEventReportOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessagePdsSetGpsServiceStateInput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetGpsServiceStateInput */
    /**
     * Get the 'State' field from `self`.
     */
    get_state(): [ /* returnType */ boolean, /* value_state_gps_service_state */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetGpsServiceStateInput
    /**
     * Set the 'State' field in the message.
     * @param value_state_gps_service_state a #gboolean.
     */
    set_state(value_state_gps_service_state: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessagePdsSetGpsServiceStateInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessagePdsSetGpsServiceStateInput
}
class MessagePdsSetGpsServiceStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessagePdsSetGpsServiceStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessagePdsSetGpsServiceStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageQosGetFlowStatusInput {
    /* Methods of Qmi-1.0.Qmi.MessageQosGetFlowStatusInput */
    /**
     * Get the 'Qos Id' field from `self`.
     */
    get_qos_id(): [ /* returnType */ boolean, /* value_qos_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageQosGetFlowStatusInput
    /**
     * Set the 'Qos Id' field in the message.
     * @param value_qos_id a #guint32.
     */
    set_qos_id(value_qos_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageQosGetFlowStatusInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageQosGetFlowStatusInput
}
class MessageQosGetFlowStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageQosGetFlowStatusOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Value' field from `self`.
     */
    get_value(): [ /* returnType */ boolean, /* value_value */ QosStatus | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageQosGetFlowStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageQosGetNetworkStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageQosGetNetworkStatusOutput */
    /**
     * Get the 'QoS Supported' field from `self`.
     */
    get_qos_supported(): [ /* returnType */ boolean, /* value_qos_supported */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageQosGetNetworkStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageQosResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessageQosResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageQosResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageQosSwiReadDataStatsInput {
    /* Methods of Qmi-1.0.Qmi.MessageQosSwiReadDataStatsInput */
    /**
     * Get the 'Apn Id' field from `self`.
     */
    get_apn_id(): [ /* returnType */ boolean, /* value_apn_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageQosSwiReadDataStatsInput
    /**
     * Set the 'Apn Id' field in the message.
     * @param value_apn_id a #guint32.
     */
    set_apn_id(value_apn_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageQosSwiReadDataStatsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageQosSwiReadDataStatsInput
}
class MessageQosSwiReadDataStatsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageQosSwiReadDataStatsOutput */
    /**
     * Get the 'Apn' field from `self`.
     */
    get_apn(): [ /* returnType */ boolean, /* value_apn_apn_id */ number | null, /* value_apn_tx_packets */ number | null, /* value_apn_tx_packets_dropped */ number | null, /* value_apn_rx_packets */ number | null, /* value_apn_tx_bytes */ number | null, /* value_apn_tx_bytes_dropped */ number | null, /* value_apn_rx_bytes */ number | null ]
    /**
     * Get the 'Flow' field from `self`.
     * 
     * Version of qmi_message_qos_swi_read_data_stats_output_get_flow() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_flow(): [ /* returnType */ boolean, /* value_flow_ptr */ MessageQosSwiReadDataStatsOutputFlowElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageQosSwiReadDataStatsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageQosSwiReadDataStatsOutputFlowElement {
    /* Fields of Qmi-1.0.Qmi.MessageQosSwiReadDataStatsOutputFlowElement */
    /**
     * a #guint32.
     */
    bearer_id: number
    /**
     * a #guint32.
     */
    tx_packets: number
    /**
     * a #guint32.
     */
    tx_packets_dropped: number
    /**
     * a #guint64.
     */
    tx_bytes: number
    /**
     * a #guint64.
     */
    tx_bytes_dropped: number
    static name: string
}
class MessageSarRfGetStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessageSarRfGetStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'State' field from `self`.
     */
    get_state(): [ /* returnType */ boolean, /* value_state */ SarRfState | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageSarRfGetStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageSarRfSetStateInput {
    /* Methods of Qmi-1.0.Qmi.MessageSarRfSetStateInput */
    /**
     * Get the 'State' field from `self`.
     */
    get_state(): [ /* returnType */ boolean, /* value_state */ SarRfState | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageSarRfSetStateInput
    /**
     * Set the 'State' field in the message.
     * @param value_state a #QmiSarRfState.
     */
    set_state(value_state: SarRfState): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageSarRfSetStateInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageSarRfSetStateInput
}
class MessageSarRfSetStateOutput {
    /* Methods of Qmi-1.0.Qmi.MessageSarRfSetStateOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageSarRfSetStateOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimChangePinInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimChangePinInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ UimPinId | null, /* value_info_old_pin */ string | null, /* value_info_new_pin */ string | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimChangePinInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiUimPinId.
     * @param value_info_old_pin a constant string.
     * @param value_info_new_pin a constant string.
     */
    set_info(value_info_pin_id: UimPinId, value_info_old_pin: string, value_info_new_pin: string): boolean
    /**
     * Set the 'Response In Indication Token' field in the message.
     * @param value_response_in_indication_token a #guint32.
     */
    set_response_in_indication_token(value_response_in_indication_token: number): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimChangePinInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimChangePinInput
}
class MessageUimChangePinOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimChangePinOutput */
    /**
     * Get the 'Card Result' field from `self`.
     */
    get_card_result(): [ /* returnType */ boolean, /* value_card_result_sw1 */ number | null, /* value_card_result_sw2 */ number | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Retries Remaining' field from `self`.
     */
    get_retries_remaining(): [ /* returnType */ boolean, /* value_retries_remaining_verify_retries_left */ number | null, /* value_retries_remaining_unblock_retries_left */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimChangePinOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimChangeProvisioningSessionInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimChangeProvisioningSessionInput */
    /**
     * Get the 'Application Information' field from `self`.
     */
    get_application_information(): [ /* returnType */ boolean, /* value_application_information_slot */ number | null, /* value_application_information_application_identifier */ Uint8Array | null ]
    /**
     * Get the 'Session Change' field from `self`.
     */
    get_session_change(): [ /* returnType */ boolean, /* value_session_change_session_type */ UimSessionType | null, /* value_session_change_activate */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimChangeProvisioningSessionInput
    /**
     * Set the 'Application Information' field in the message.
     * @param value_application_information_slot a #guint8.
     * @param value_application_information_application_identifier a #GArray of #guint8 elements. A new reference to `value_application_information_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_application_information(value_application_information_slot: number, value_application_information_application_identifier: Uint8Array): boolean
    /**
     * Set the 'Session Change' field in the message.
     * @param value_session_change_session_type a #QmiUimSessionType.
     * @param value_session_change_activate a #gboolean.
     */
    set_session_change(value_session_change_session_type: UimSessionType, value_session_change_activate: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimChangeProvisioningSessionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimChangeProvisioningSessionInput
}
class MessageUimChangeProvisioningSessionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimChangeProvisioningSessionOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimChangeProvisioningSessionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimDepersonalizationInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimDepersonalizationInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_feature */ UimCardApplicationPersonalizationFeature | null, /* value_info_operation */ UimDepersonalizationOperation | null, /* value_info_control_key */ string | null ]
    /**
     * Get the 'Slot' field from `self`.
     */
    get_slot(): [ /* returnType */ boolean, /* value_slot */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimDepersonalizationInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_feature a #QmiUimCardApplicationPersonalizationFeature.
     * @param value_info_operation a #QmiUimDepersonalizationOperation.
     * @param value_info_control_key a constant string.
     */
    set_info(value_info_feature: UimCardApplicationPersonalizationFeature, value_info_operation: UimDepersonalizationOperation, value_info_control_key: string): boolean
    /**
     * Set the 'Slot' field in the message.
     * @param value_slot a #guint8.
     */
    set_slot(value_slot: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimDepersonalizationInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimDepersonalizationInput
}
class MessageUimDepersonalizationOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimDepersonalizationOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Retries Remaining' field from `self`.
     */
    get_retries_remaining(): [ /* returnType */ boolean, /* value_retries_remaining_verify_left */ number | null, /* value_retries_remaining_unblock_left */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimDepersonalizationOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimGetCardStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimGetCardStatusOutput */
    /**
     * Get the 'Card Status' field from `self`.
     * 
     * Version of qmi_message_uim_get_card_status_output_get_card_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_card_status(): [ /* returnType */ boolean, /* value_card_status_index_gw_primary */ number | null, /* value_card_status_index_1x_primary */ number | null, /* value_card_status_index_gw_secondary */ number | null, /* value_card_status_index_1x_secondary */ number | null, /* value_card_status_cards_ptr */ MessageUimGetCardStatusOutputCardStatusCardsElementGir[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimGetCardStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimGetCardStatusOutputCardStatusCardsElement {
    /* Fields of Qmi-1.0.Qmi.MessageUimGetCardStatusOutputCardStatusCardsElement */
    /**
     * a #QmiUimCardState.
     */
    card_state: UimCardState
    /**
     * a #QmiUimPinState.
     */
    upin_state: UimPinState
    /**
     * a #guint8.
     */
    upin_retries: number
    /**
     * a #guint8.
     */
    upuk_retries: number
    /**
     * a #QmiUimCardError.
     */
    error_code: UimCardError
    /**
     * a #GArray of #QmiMessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElement elements.
     */
    applications: object[]
    static name: string
}
class MessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElement {
    /* Fields of Qmi-1.0.Qmi.MessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElement */
    /**
     * a #QmiUimCardApplicationType.
     */
    type: UimCardApplicationType
    /**
     * a #QmiUimCardApplicationState.
     */
    state: UimCardApplicationState
    /**
     * a #QmiUimCardApplicationPersonalizationState.
     */
    personalization_state: UimCardApplicationPersonalizationState
    /**
     * a #QmiUimCardApplicationPersonalizationFeature.
     */
    personalization_feature: UimCardApplicationPersonalizationFeature
    /**
     * a #guint8.
     */
    personalization_retries: number
    /**
     * a #guint8.
     */
    personalization_unblock_retries: number
    /**
     * a #GArray of #guint8 elements.
     */
    application_identifier_value: object[]
    /**
     * a #gboolean.
     */
    upin_replaces_pin1: boolean
    /**
     * a #QmiUimPinState.
     */
    pin1_state: UimPinState
    /**
     * a #guint8.
     */
    pin1_retries: number
    /**
     * a #guint8.
     */
    puk1_retries: number
    /**
     * a #QmiUimPinState.
     */
    pin2_state: UimPinState
    /**
     * a #guint8.
     */
    pin2_retries: number
    /**
     * a #guint8.
     */
    puk2_retries: number
    static name: string
}
class MessageUimGetCardStatusOutputCardStatusCardsElementGir {
    /* Fields of Qmi-1.0.Qmi.MessageUimGetCardStatusOutputCardStatusCardsElementGir */
    /**
     * a #QmiUimCardState.
     */
    card_state: UimCardState
    /**
     * a #QmiUimPinState.
     */
    upin_state: UimPinState
    /**
     * a #guint8.
     */
    upin_retries: number
    /**
     * a #guint8.
     */
    upuk_retries: number
    /**
     * a #QmiUimCardError.
     */
    error_code: UimCardError
    /**
     * an array of #QmiMessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElement elements.
     */
    applications: MessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElement[]
    static name: string
}
class MessageUimGetConfigurationInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimGetConfigurationInput */
    /**
     * Get the 'Configuration Mask' field from `self`.
     */
    get_configuration_mask(): [ /* returnType */ boolean, /* value_configuration_mask */ UimConfiguration | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimGetConfigurationInput
    /**
     * Set the 'Configuration Mask' field in the message.
     * @param value_configuration_mask a #QmiUimConfiguration.
     */
    set_configuration_mask(value_configuration_mask: UimConfiguration): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimGetConfigurationInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimGetConfigurationInput
}
class MessageUimGetConfigurationOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimGetConfigurationOutput */
    /**
     * Get the 'Automatic Selection' field from `self`.
     */
    get_automatic_selection(): [ /* returnType */ boolean, /* value_automatic_selection */ boolean | null ]
    get_compat_context(): object | null
    /**
     * Get the 'Halt Subscription' field from `self`.
     */
    get_halt_subscription(): [ /* returnType */ boolean, /* value_halt_subscription */ boolean | null ]
    /**
     * Get the 'Personalization Status' field from `self`.
     * 
     * Version of qmi_message_uim_get_configuration_output_get_personalization_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_personalization_status(): [ /* returnType */ boolean, /* value_personalization_status_ptr */ MessageUimGetConfigurationOutputPersonalizationStatusElement[] | null ]
    /**
     * Get the 'Personalization Status Other' field from `self`.
     * 
     * Version of qmi_message_uim_get_configuration_output_get_personalization_status_other() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_personalization_status_other(): [ /* returnType */ boolean, /* value_personalization_status_other_ptr */ MessageUimGetConfigurationOutputPersonalizationStatusOtherElementGir[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimGetConfigurationOutput
    set_compat_context(compat_context: object | null, compat_context_free: GLib.DestroyNotify): void
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimGetConfigurationOutputPersonalizationStatusElement {
    /* Fields of Qmi-1.0.Qmi.MessageUimGetConfigurationOutputPersonalizationStatusElement */
    /**
     * a #QmiUimCardApplicationPersonalizationFeature.
     */
    feature: UimCardApplicationPersonalizationFeature
    /**
     * a #guint8.
     */
    verify_left: number
    /**
     * a #guint8.
     */
    unblock_left: number
    static name: string
}
class MessageUimGetConfigurationOutputPersonalizationStatusOtherElement {
    /* Fields of Qmi-1.0.Qmi.MessageUimGetConfigurationOutputPersonalizationStatusOtherElement */
    /**
     * a #GArray of #QmiMessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement elements.
     */
    slot: object[]
    static name: string
}
class MessageUimGetConfigurationOutputPersonalizationStatusOtherElementGir {
    /* Fields of Qmi-1.0.Qmi.MessageUimGetConfigurationOutputPersonalizationStatusOtherElementGir */
    /**
     * an array of #QmiMessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement elements.
     */
    slot: MessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement[]
    static name: string
}
class MessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement {
    /* Fields of Qmi-1.0.Qmi.MessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement */
    /**
     * a #QmiUimCardApplicationPersonalizationFeature.
     */
    feature: UimCardApplicationPersonalizationFeature
    /**
     * a #guint8.
     */
    verify_left: number
    /**
     * a #guint8.
     */
    unblock_left: number
    static name: string
}
class MessageUimGetFileAttributesInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimGetFileAttributesInput */
    /**
     * Get the 'File' field from `self`.
     */
    get_file(): [ /* returnType */ boolean, /* value_file_file_id */ number | null, /* value_file_file_path */ Uint8Array | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimGetFileAttributesInput
    /**
     * Set the 'File' field in the message.
     * @param value_file_file_id a #guint16.
     * @param value_file_file_path a #GArray of #guint8 elements. A new reference to `value_file_file_path` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_file(value_file_file_id: number, value_file_file_path: Uint8Array): boolean
    /**
     * Set the 'Response In Indication Token' field in the message.
     * @param value_response_in_indication_token a #guint32.
     */
    set_response_in_indication_token(value_response_in_indication_token: number): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimGetFileAttributesInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimGetFileAttributesInput
}
class MessageUimGetFileAttributesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimGetFileAttributesOutput */
    /**
     * Get the 'Card result' field from `self`.
     */
    get_card_result(): [ /* returnType */ boolean, /* value_card_result_sw1 */ number | null, /* value_card_result_sw2 */ number | null ]
    /**
     * Get the 'File Attributes' field from `self`.
     */
    get_file_attributes(): [ /* returnType */ boolean, /* value_file_attributes_file_size */ number | null, /* value_file_attributes_file_id */ number | null, /* value_file_attributes_file_type */ UimFileType | null, /* value_file_attributes_record_size */ number | null, /* value_file_attributes_record_count */ number | null, /* value_file_attributes_read_security_attributes_logic */ UimSecurityAttributeLogic | null, /* value_file_attributes_read_security_attributes */ UimSecurityAttribute | null, /* value_file_attributes_write_security_attributes_logic */ UimSecurityAttributeLogic | null, /* value_file_attributes_write_security_attributes */ UimSecurityAttribute | null, /* value_file_attributes_increase_security_attributes_logic */ UimSecurityAttributeLogic | null, /* value_file_attributes_increase_security_attributes */ UimSecurityAttribute | null, /* value_file_attributes_deactivate_security_attributes_logic */ UimSecurityAttributeLogic | null, /* value_file_attributes_deactivate_security_attributes */ UimSecurityAttribute | null, /* value_file_attributes_activate_security_attributes_logic */ UimSecurityAttributeLogic | null, /* value_file_attributes_activate_security_attributes */ UimSecurityAttribute | null, /* value_file_attributes_raw_data */ Uint8Array | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimGetFileAttributesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimGetSlotStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimGetSlotStatusOutput */
    get_compat_context(): object | null
    /**
     * Get the 'Physical Slot Information' field from `self`.
     * 
     * Version of qmi_message_uim_get_slot_status_output_get_physical_slot_information() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_physical_slot_information(): [ /* returnType */ boolean, /* value_physical_slot_information_ptr */ PhysicalSlotInformationSlot[] | null ]
    /**
     * Get the 'Physical Slot Status' field from `self`.
     * 
     * Version of qmi_message_uim_get_slot_status_output_get_physical_slot_status() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_physical_slot_status(): [ /* returnType */ boolean, /* value_physical_slot_status_ptr */ PhysicalSlotStatusSlot[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Slot EID' field from `self`.
     * 
     * Version of qmi_message_uim_get_slot_status_output_get_slot_eid() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_slot_eid(): [ /* returnType */ boolean, /* value_slot_eid_ptr */ SlotEidElement[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimGetSlotStatusOutput
    set_compat_context(compat_context: object | null, compat_context_free: GLib.DestroyNotify): void
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimGetSupportedMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimGetSupportedMessagesOutput */
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimGetSupportedMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimPowerOffSimInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimPowerOffSimInput */
    /**
     * Get the 'Slot' field from `self`.
     */
    get_slot(): [ /* returnType */ boolean, /* value_slot */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimPowerOffSimInput
    /**
     * Set the 'Slot' field in the message.
     * @param value_slot a #guint8.
     */
    set_slot(value_slot: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimPowerOffSimInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimPowerOffSimInput
}
class MessageUimPowerOffSimOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimPowerOffSimOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimPowerOffSimOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimPowerOnSimInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimPowerOnSimInput */
    /**
     * Get the 'Slot' field from `self`.
     */
    get_slot(): [ /* returnType */ boolean, /* value_slot */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimPowerOnSimInput
    /**
     * Set the 'Slot' field in the message.
     * @param value_slot a #guint8.
     */
    set_slot(value_slot: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimPowerOnSimInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimPowerOnSimInput
}
class MessageUimPowerOnSimOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimPowerOnSimOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimPowerOnSimOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimReadRecordInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimReadRecordInput */
    /**
     * Get the 'File' field from `self`.
     */
    get_file(): [ /* returnType */ boolean, /* value_file_file_id */ number | null, /* value_file_file_path */ Uint8Array | null ]
    /**
     * Get the 'Last Record' field from `self`.
     */
    get_last_record(): [ /* returnType */ boolean, /* value_last_record */ number | null ]
    /**
     * Get the 'Record' field from `self`.
     */
    get_record(): [ /* returnType */ boolean, /* value_record_record_number */ number | null, /* value_record_record_length */ number | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimReadRecordInput
    /**
     * Set the 'File' field in the message.
     * @param value_file_file_id a #guint16.
     * @param value_file_file_path a #GArray of #guint8 elements. A new reference to `value_file_file_path` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_file(value_file_file_id: number, value_file_file_path: Uint8Array): boolean
    /**
     * Set the 'Last Record' field in the message.
     * @param value_last_record a #guint16.
     */
    set_last_record(value_last_record: number): boolean
    /**
     * Set the 'Record' field in the message.
     * @param value_record_record_number a #guint16.
     * @param value_record_record_length a #guint16.
     */
    set_record(value_record_record_number: number, value_record_record_length: number): boolean
    /**
     * Set the 'Response In Indication Token' field in the message.
     * @param value_response_in_indication_token a #guint32.
     */
    set_response_in_indication_token(value_response_in_indication_token: number): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimReadRecordInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimReadRecordInput
}
class MessageUimReadRecordOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimReadRecordOutput */
    /**
     * Get the 'Additional Read Result' field from `self`.
     */
    get_additional_read_result(): [ /* returnType */ boolean, /* value_additional_read_result */ Uint8Array | null ]
    /**
     * Get the 'Card result' field from `self`.
     */
    get_card_result(): [ /* returnType */ boolean, /* value_card_result_sw1 */ number | null, /* value_card_result_sw2 */ number | null ]
    /**
     * Get the 'Read Result' field from `self`.
     */
    get_read_result(): [ /* returnType */ boolean, /* value_read_result */ Uint8Array | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimReadRecordOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimReadTransparentInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimReadTransparentInput */
    /**
     * Get the 'Encrypt Data' field from `self`.
     */
    get_encrypt_data(): [ /* returnType */ boolean, /* value_encrypt_data */ boolean | null ]
    /**
     * Get the 'File' field from `self`.
     */
    get_file(): [ /* returnType */ boolean, /* value_file_file_id */ number | null, /* value_file_file_path */ Uint8Array | null ]
    /**
     * Get the 'Read Information' field from `self`.
     */
    get_read_information(): [ /* returnType */ boolean, /* value_read_information_offset */ number | null, /* value_read_information_length */ number | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimReadTransparentInput
    /**
     * Set the 'Encrypt Data' field in the message.
     * @param value_encrypt_data a #gboolean.
     */
    set_encrypt_data(value_encrypt_data: boolean): boolean
    /**
     * Set the 'File' field in the message.
     * @param value_file_file_id a #guint16.
     * @param value_file_file_path a #GArray of #guint8 elements. A new reference to `value_file_file_path` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_file(value_file_file_id: number, value_file_file_path: Uint8Array): boolean
    /**
     * Set the 'Read Information' field in the message.
     * @param value_read_information_offset a #guint16.
     * @param value_read_information_length a #guint16.
     */
    set_read_information(value_read_information_offset: number, value_read_information_length: number): boolean
    /**
     * Set the 'Response In Indication Token' field in the message.
     * @param value_response_in_indication_token a #guint32.
     */
    set_response_in_indication_token(value_response_in_indication_token: number): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimReadTransparentInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimReadTransparentInput
}
class MessageUimReadTransparentOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimReadTransparentOutput */
    /**
     * Get the 'Card result' field from `self`.
     */
    get_card_result(): [ /* returnType */ boolean, /* value_card_result_sw1 */ number | null, /* value_card_result_sw2 */ number | null ]
    /**
     * Get the 'Encrypted Data' field from `self`.
     */
    get_encrypted_data(): [ /* returnType */ boolean, /* value_encrypted_data */ boolean | null ]
    /**
     * Get the 'Read result' field from `self`.
     */
    get_read_result(): [ /* returnType */ boolean, /* value_read_result */ Uint8Array | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimReadTransparentOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimRefreshCompleteInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRefreshCompleteInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_refresh_success */ boolean | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRefreshCompleteInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_refresh_success a #gboolean.
     */
    set_info(value_info_refresh_success: boolean): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimRefreshCompleteInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimRefreshCompleteInput
}
class MessageUimRefreshCompleteOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRefreshCompleteOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRefreshCompleteOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimRefreshRegisterAllInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRefreshRegisterAllInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_register_flag */ boolean | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRefreshRegisterAllInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_register_flag a #gboolean.
     */
    set_info(value_info_register_flag: boolean): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimRefreshRegisterAllInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimRefreshRegisterAllInput
}
class MessageUimRefreshRegisterAllOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRefreshRegisterAllOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRefreshRegisterAllOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimRefreshRegisterInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRefreshRegisterInput */
    /**
     * Get the 'Info' field from `self`.
     * 
     * Version of qmi_message_uim_refresh_register_input_get_info() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_register_flag */ boolean | null, /* value_info_vote_for_init */ boolean | null, /* value_info_files_ptr */ MessageUimRefreshRegisterInputInfoFilesElement[] | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRefreshRegisterInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_register_flag a #gboolean.
     * @param value_info_vote_for_init a #gboolean.
     * @param value_info_files_ptr array of #QmiMessageUimRefreshRegisterInputInfoFilesElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_info(value_info_register_flag: boolean, value_info_vote_for_init: boolean, value_info_files_ptr: MessageUimRefreshRegisterInputInfoFilesElement[]): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimRefreshRegisterInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimRefreshRegisterInput
}
class MessageUimRefreshRegisterInputInfoFilesElement {
    /* Fields of Qmi-1.0.Qmi.MessageUimRefreshRegisterInputInfoFilesElement */
    /**
     * a #guint16.
     */
    file_id: number
    /**
     * a #GArray of #guint8 elements.
     */
    path: object[]
    static name: string
}
class MessageUimRefreshRegisterOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRefreshRegisterOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRefreshRegisterOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimRegisterEventsInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRegisterEventsInput */
    /**
     * Get the 'Event Registration Mask' field from `self`.
     */
    get_event_registration_mask(): [ /* returnType */ boolean, /* value_event_registration_mask */ UimEventRegistrationFlag | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRegisterEventsInput
    /**
     * Set the 'Event Registration Mask' field in the message.
     * @param value_event_registration_mask a #QmiUimEventRegistrationFlag.
     */
    set_event_registration_mask(value_event_registration_mask: UimEventRegistrationFlag): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimRegisterEventsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimRegisterEventsInput
}
class MessageUimRegisterEventsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimRegisterEventsOutput */
    /**
     * Get the 'Event Registration Mask' field from `self`.
     */
    get_event_registration_mask(): [ /* returnType */ boolean, /* value_event_registration_mask */ UimEventRegistrationFlag | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimRegisterEventsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimSetPinProtectionInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimSetPinProtectionInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ UimPinId | null, /* value_info_pin_enabled */ boolean | null, /* value_info_pin_value */ string | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimSetPinProtectionInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiUimPinId.
     * @param value_info_pin_enabled a #gboolean.
     * @param value_info_pin_value a constant string.
     */
    set_info(value_info_pin_id: UimPinId, value_info_pin_enabled: boolean, value_info_pin_value: string): boolean
    /**
     * Set the 'Response In Indication Token' field in the message.
     * @param value_response_in_indication_token a #guint32.
     */
    set_response_in_indication_token(value_response_in_indication_token: number): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimSetPinProtectionInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimSetPinProtectionInput
}
class MessageUimSetPinProtectionOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimSetPinProtectionOutput */
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Retries Remaining' field from `self`.
     */
    get_retries_remaining(): [ /* returnType */ boolean, /* value_retries_remaining_verify_retries_left */ number | null, /* value_retries_remaining_unblock_retries_left */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimSetPinProtectionOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimSwitchSlotInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimSwitchSlotInput */
    /**
     * Get the 'Logical Slot' field from `self`.
     */
    get_logical_slot(): [ /* returnType */ boolean, /* value_logical_slot */ number | null ]
    /**
     * Get the 'Physical Slot' field from `self`.
     */
    get_physical_slot(): [ /* returnType */ boolean, /* value_physical_slot */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimSwitchSlotInput
    /**
     * Set the 'Logical Slot' field in the message.
     * @param value_logical_slot a #guint8.
     */
    set_logical_slot(value_logical_slot: number): boolean
    /**
     * Set the 'Physical Slot' field in the message.
     * @param value_physical_slot a #guint32.
     */
    set_physical_slot(value_physical_slot: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimSwitchSlotInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimSwitchSlotInput
}
class MessageUimSwitchSlotOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimSwitchSlotOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimSwitchSlotOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimUnblockPinInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimUnblockPinInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ UimPinId | null, /* value_info_puk */ string | null, /* value_info_new_pin */ string | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimUnblockPinInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiUimPinId.
     * @param value_info_puk a constant string.
     * @param value_info_new_pin a constant string.
     */
    set_info(value_info_pin_id: UimPinId, value_info_puk: string, value_info_new_pin: string): boolean
    /**
     * Set the 'Response In Indication Token' field in the message.
     * @param value_response_in_indication_token a #guint32.
     */
    set_response_in_indication_token(value_response_in_indication_token: number): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimUnblockPinInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimUnblockPinInput
}
class MessageUimUnblockPinOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimUnblockPinOutput */
    /**
     * Get the 'Card Result' field from `self`.
     */
    get_card_result(): [ /* returnType */ boolean, /* value_card_result_sw1 */ number | null, /* value_card_result_sw2 */ number | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Retries Remaining' field from `self`.
     */
    get_retries_remaining(): [ /* returnType */ boolean, /* value_retries_remaining_verify_retries_left */ number | null, /* value_retries_remaining_unblock_retries_left */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimUnblockPinOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageUimVerifyPinInput {
    /* Methods of Qmi-1.0.Qmi.MessageUimVerifyPinInput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_pin_id */ UimPinId | null, /* value_info_pin_value */ string | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the 'Session' field from `self`.
     */
    get_session(): [ /* returnType */ boolean, /* value_session_session_type */ UimSessionType | null, /* value_session_application_identifier */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimVerifyPinInput
    /**
     * Set the 'Info' field in the message.
     * @param value_info_pin_id a #QmiUimPinId.
     * @param value_info_pin_value a constant string.
     */
    set_info(value_info_pin_id: UimPinId, value_info_pin_value: string): boolean
    /**
     * Set the 'Response In Indication Token' field in the message.
     * @param value_response_in_indication_token a #guint32.
     */
    set_response_in_indication_token(value_response_in_indication_token: number): boolean
    /**
     * Set the 'Session' field in the message.
     * @param value_session_session_type a #QmiUimSessionType.
     * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to `value_session_application_identifier` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_session(value_session_session_type: UimSessionType, value_session_application_identifier: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageUimVerifyPinInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageUimVerifyPinInput
}
class MessageUimVerifyPinOutput {
    /* Methods of Qmi-1.0.Qmi.MessageUimVerifyPinOutput */
    /**
     * Get the 'Card Result' field from `self`.
     */
    get_card_result(): [ /* returnType */ boolean, /* value_card_result_sw1 */ number | null, /* value_card_result_sw2 */ number | null ]
    /**
     * Get the 'Response In Indication Token' field from `self`.
     */
    get_response_in_indication_token(): [ /* returnType */ boolean, /* value_response_in_indication_token */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Retries Remaining' field from `self`.
     */
    get_retries_remaining(): [ /* returnType */ boolean, /* value_retries_remaining_verify_retries_left */ number | null, /* value_retries_remaining_unblock_retries_left */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageUimVerifyPinOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceAnswerCallInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceAnswerCallInput */
    /**
     * Get the 'Call ID' field from `self`.
     */
    get_call_id(): [ /* returnType */ boolean, /* value_call_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceAnswerCallInput
    /**
     * Set the 'Call ID' field in the message.
     * @param value_call_id a #guint8.
     */
    set_call_id(value_call_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceAnswerCallInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceAnswerCallInput
}
class MessageVoiceAnswerCallOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceAnswerCallOutput */
    /**
     * Get the 'Call ID' field from `self`.
     */
    get_call_id(): [ /* returnType */ boolean, /* value_call_id */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceAnswerCallOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceAnswerUssdInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceAnswerUssdInput */
    /**
     * Get the 'USS Data' field from `self`.
     */
    get_uss_data(): [ /* returnType */ boolean, /* value_uss_data_data_coding_scheme */ VoiceUssDataCodingScheme | null, /* value_uss_data_data */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceAnswerUssdInput
    /**
     * Set the 'USS Data' field in the message.
     * @param value_uss_data_data_coding_scheme a #QmiVoiceUssDataCodingScheme.
     * @param value_uss_data_data a #GArray of #guint8 elements. A new reference to `value_uss_data_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_uss_data(value_uss_data_data_coding_scheme: VoiceUssDataCodingScheme, value_uss_data_data: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceAnswerUssdInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceAnswerUssdInput
}
class MessageVoiceAnswerUssdOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceAnswerUssdOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceAnswerUssdOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceCancelUssdOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceCancelUssdOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceCancelUssdOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceDialCallInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceDialCallInput */
    /**
     * Get the 'Calling Number' field from `self`.
     */
    get_calling_number(): [ /* returnType */ boolean, /* value_calling_number */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceDialCallInput
    /**
     * Set the 'Calling Number' field in the message.
     * @param value_calling_number a constant string.
     */
    set_calling_number(value_calling_number: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceDialCallInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceDialCallInput
}
class MessageVoiceDialCallOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceDialCallOutput */
    /**
     * Get the 'Call ID' field from `self`.
     */
    get_call_id(): [ /* returnType */ boolean, /* value_call_id */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceDialCallOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceEndCallInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceEndCallInput */
    /**
     * Get the 'Call ID' field from `self`.
     */
    get_call_id(): [ /* returnType */ boolean, /* value_call_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceEndCallInput
    /**
     * Set the 'Call ID' field in the message.
     * @param value_call_id a #guint8.
     */
    set_call_id(value_call_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceEndCallInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceEndCallInput
}
class MessageVoiceEndCallOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceEndCallOutput */
    /**
     * Get the 'Call ID' field from `self`.
     */
    get_call_id(): [ /* returnType */ boolean, /* value_call_id */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceEndCallOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceGetAllCallInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceGetAllCallInfoOutput */
    /**
     * Get the 'Call Information' field from `self`.
     * 
     * Version of qmi_message_voice_get_all_call_info_output_get_call_information() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_call_information(): [ /* returnType */ boolean, /* value_call_information_ptr */ MessageVoiceGetAllCallInfoOutputCallInformationCall[] | null ]
    /**
     * Get the 'Remote Party Number' field from `self`.
     * 
     * Version of qmi_message_voice_get_all_call_info_output_get_remote_party_number() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_remote_party_number(): [ /* returnType */ boolean, /* value_remote_party_number_ptr */ MessageVoiceGetAllCallInfoOutputRemotePartyNumberCall[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceGetAllCallInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceGetAllCallInfoOutputCallInformationCall {
    /* Fields of Qmi-1.0.Qmi.MessageVoiceGetAllCallInfoOutputCallInformationCall */
    /**
     * a #guint8.
     */
    id: number
    /**
     * a #QmiVoiceCallState.
     */
    state: VoiceCallState
    /**
     * a #QmiVoiceCallType.
     */
    type: VoiceCallType
    /**
     * a #QmiVoiceCallDirection.
     */
    direction: VoiceCallDirection
    /**
     * a #QmiVoiceCallMode.
     */
    mode: VoiceCallMode
    /**
     * a #gboolean.
     */
    multipart_indicator: boolean
    /**
     * a #QmiVoiceAls.
     */
    als: VoiceAls
    static name: string
}
class MessageVoiceGetAllCallInfoOutputRemotePartyNumberCall {
    /* Fields of Qmi-1.0.Qmi.MessageVoiceGetAllCallInfoOutputRemotePartyNumberCall */
    /**
     * a #guint8.
     */
    id: number
    /**
     * a #QmiVoicePresentation.
     */
    presentation_indicator: VoicePresentation
    /**
     * a string.
     */
    type: string
    static name: string
}
class MessageVoiceGetCallWaitingInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceGetCallWaitingInput */
    /**
     * Get the 'Service Class' field from `self`.
     */
    get_service_class(): [ /* returnType */ boolean, /* value_service_class */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceGetCallWaitingInput
    /**
     * Set the 'Service Class' field in the message.
     * @param value_service_class a #guint8.
     */
    set_service_class(value_service_class: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceGetCallWaitingInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceGetCallWaitingInput
}
class MessageVoiceGetCallWaitingOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceGetCallWaitingOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Service Class' field from `self`.
     */
    get_service_class(): [ /* returnType */ boolean, /* value_service_class */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceGetCallWaitingOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceGetConfigInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceGetConfigInput */
    /**
     * Get the 'Air Timer' field from `self`.
     */
    get_air_timer(): [ /* returnType */ boolean, /* value_air_timer */ boolean | null ]
    /**
     * Get the 'AMR Status' field from `self`.
     */
    get_amr_status(): [ /* returnType */ boolean, /* value_amr_status */ boolean | null ]
    /**
     * Get the 'Auto Answer' field from `self`.
     */
    get_auto_answer(): [ /* returnType */ boolean, /* value_auto_answer */ boolean | null ]
    /**
     * Get the 'NAM Index' field from `self`.
     */
    get_nam_index(): [ /* returnType */ boolean, /* value_nam_index */ boolean | null ]
    /**
     * Get the 'Preferred Voice Privacy' field from `self`.
     */
    get_preferred_voice_privacy(): [ /* returnType */ boolean, /* value_preferred_voice_privacy */ boolean | null ]
    /**
     * Get the 'Preferred Voice Service Option' field from `self`.
     */
    get_preferred_voice_service_option(): [ /* returnType */ boolean, /* value_preferred_voice_service_option */ boolean | null ]
    /**
     * Get the 'Roam Timer' field from `self`.
     */
    get_roam_timer(): [ /* returnType */ boolean, /* value_roam_timer */ boolean | null ]
    /**
     * Get the 'TTY Mode' field from `self`.
     */
    get_tty_mode(): [ /* returnType */ boolean, /* value_tty_mode */ boolean | null ]
    /**
     * Get the 'Voice Domain Preference' field from `self`.
     */
    get_voice_domain_preference(): [ /* returnType */ boolean, /* value_voice_domain_preference */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceGetConfigInput
    /**
     * Set the 'Air Timer' field in the message.
     * @param value_air_timer a #gboolean.
     */
    set_air_timer(value_air_timer: boolean): boolean
    /**
     * Set the 'AMR Status' field in the message.
     * @param value_amr_status a #gboolean.
     */
    set_amr_status(value_amr_status: boolean): boolean
    /**
     * Set the 'Auto Answer' field in the message.
     * @param value_auto_answer a #gboolean.
     */
    set_auto_answer(value_auto_answer: boolean): boolean
    /**
     * Set the 'NAM Index' field in the message.
     * @param value_nam_index a #gboolean.
     */
    set_nam_index(value_nam_index: boolean): boolean
    /**
     * Set the 'Preferred Voice Privacy' field in the message.
     * @param value_preferred_voice_privacy a #gboolean.
     */
    set_preferred_voice_privacy(value_preferred_voice_privacy: boolean): boolean
    /**
     * Set the 'Preferred Voice Service Option' field in the message.
     * @param value_preferred_voice_service_option a #gboolean.
     */
    set_preferred_voice_service_option(value_preferred_voice_service_option: boolean): boolean
    /**
     * Set the 'Roam Timer' field in the message.
     * @param value_roam_timer a #gboolean.
     */
    set_roam_timer(value_roam_timer: boolean): boolean
    /**
     * Set the 'TTY Mode' field in the message.
     * @param value_tty_mode a #gboolean.
     */
    set_tty_mode(value_tty_mode: boolean): boolean
    /**
     * Set the 'Voice Domain Preference' field in the message.
     * @param value_voice_domain_preference a #gboolean.
     */
    set_voice_domain_preference(value_voice_domain_preference: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceGetConfigInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceGetConfigInput
}
class MessageVoiceGetConfigOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceGetConfigOutput */
    /**
     * Get the 'Air Timer Count' field from `self`.
     */
    get_air_timer_count(): [ /* returnType */ boolean, /* value_air_timer_count_nam_id */ number | null, /* value_air_timer_count_air_timer */ number | null ]
    /**
     * Get the 'Auto Answer Status' field from `self`.
     */
    get_auto_answer_status(): [ /* returnType */ boolean, /* value_auto_answer_status */ boolean | null ]
    /**
     * Get the 'Current AMR Status' field from `self`.
     */
    get_current_amr_status(): [ /* returnType */ boolean, /* value_current_amr_status_gsm */ boolean | null, /* value_current_amr_status_wcdma */ VoiceWcdmaAmrStatus | null ]
    /**
     * Get the 'Current Preferred Voice SO' field from `self`.
     */
    get_current_preferred_voice_so(): [ /* returnType */ boolean, /* value_current_preferred_voice_so_nam_id */ number | null, /* value_current_preferred_voice_so_evrc_capability */ boolean | null, /* value_current_preferred_voice_so_home_page_voice_service_option */ VoiceServiceOption | null, /* value_current_preferred_voice_so_home_origination_voice_service_option */ VoiceServiceOption | null, /* value_current_preferred_voice_so_roaming_origination_voice_service_option */ VoiceServiceOption | null ]
    /**
     * Get the 'Current TTY Mode' field from `self`.
     */
    get_current_tty_mode(): [ /* returnType */ boolean, /* value_current_tty_mode */ VoiceTtyMode | null ]
    /**
     * Get the 'Current Voice Domain Preference' field from `self`.
     */
    get_current_voice_domain_preference(): [ /* returnType */ boolean, /* value_current_voice_domain_preference */ VoiceDomain | null ]
    /**
     * Get the 'Current Voice Privacy Preference' field from `self`.
     */
    get_current_voice_privacy_preference(): [ /* returnType */ boolean, /* value_current_voice_privacy_preference */ VoicePrivacy | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Roam Timer Count' field from `self`.
     */
    get_roam_timer_count(): [ /* returnType */ boolean, /* value_roam_timer_count_nam_id */ number | null, /* value_roam_timer_count_roam_timer */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceGetConfigOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceGetSupportedMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceGetSupportedMessagesOutput */
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceGetSupportedMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceIndicationRegisterInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceIndicationRegisterInput */
    /**
     * Get the 'AOC Events' field from `self`.
     */
    get_aoc_events(): [ /* returnType */ boolean, /* value_aoc_events */ boolean | null ]
    /**
     * Get the 'Call Notification Events' field from `self`.
     */
    get_call_notification_events(): [ /* returnType */ boolean, /* value_call_notification_events */ boolean | null ]
    /**
     * Get the 'Conference Events' field from `self`.
     */
    get_conference_events(): [ /* returnType */ boolean, /* value_conference_events */ boolean | null ]
    /**
     * Get the 'DTMF Events' field from `self`.
     */
    get_dtmf_events(): [ /* returnType */ boolean, /* value_dtmf_events */ boolean | null ]
    /**
     * Get the 'Extended Burst Type International Information Events' field from `self`.
     */
    get_extended_burst_type_international_information_events(): [ /* returnType */ boolean, /* value_extended_burst_type_international_information_events */ boolean | null ]
    /**
     * Get the 'Handover Events' field from `self`.
     */
    get_handover_events(): [ /* returnType */ boolean, /* value_handover_events */ boolean | null ]
    /**
     * Get the 'Modification Events' field from `self`.
     */
    get_modification_events(): [ /* returnType */ boolean, /* value_modification_events */ boolean | null ]
    /**
     * Get the 'MT Page Miss Information Events' field from `self`.
     */
    get_mt_page_miss_information_events(): [ /* returnType */ boolean, /* value_mt_page_miss_information_events */ boolean | null ]
    /**
     * Get the 'Speech Codec Events' field from `self`.
     */
    get_speech_codec_events(): [ /* returnType */ boolean, /* value_speech_codec_events */ boolean | null ]
    /**
     * Get the 'Supplementary Service Notification Events' field from `self`.
     */
    get_supplementary_service_notification_events(): [ /* returnType */ boolean, /* value_supplementary_service_notification_events */ boolean | null ]
    /**
     * Get the 'USSD Notification Events' field from `self`.
     */
    get_ussd_notification_events(): [ /* returnType */ boolean, /* value_ussd_notification_events */ boolean | null ]
    /**
     * Get the 'UUS Events' field from `self`.
     */
    get_uus_events(): [ /* returnType */ boolean, /* value_uus_events */ boolean | null ]
    /**
     * Get the 'Voice Privacy Events' field from `self`.
     */
    get_voice_privacy_events(): [ /* returnType */ boolean, /* value_voice_privacy_events */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceIndicationRegisterInput
    /**
     * Set the 'AOC Events' field in the message.
     * @param value_aoc_events a #gboolean.
     */
    set_aoc_events(value_aoc_events: boolean): boolean
    /**
     * Set the 'Call Notification Events' field in the message.
     * @param value_call_notification_events a #gboolean.
     */
    set_call_notification_events(value_call_notification_events: boolean): boolean
    /**
     * Set the 'Conference Events' field in the message.
     * @param value_conference_events a #gboolean.
     */
    set_conference_events(value_conference_events: boolean): boolean
    /**
     * Set the 'DTMF Events' field in the message.
     * @param value_dtmf_events a #gboolean.
     */
    set_dtmf_events(value_dtmf_events: boolean): boolean
    /**
     * Set the 'Extended Burst Type International Information Events' field in the message.
     * @param value_extended_burst_type_international_information_events a #gboolean.
     */
    set_extended_burst_type_international_information_events(value_extended_burst_type_international_information_events: boolean): boolean
    /**
     * Set the 'Handover Events' field in the message.
     * @param value_handover_events a #gboolean.
     */
    set_handover_events(value_handover_events: boolean): boolean
    /**
     * Set the 'Modification Events' field in the message.
     * @param value_modification_events a #gboolean.
     */
    set_modification_events(value_modification_events: boolean): boolean
    /**
     * Set the 'MT Page Miss Information Events' field in the message.
     * @param value_mt_page_miss_information_events a #gboolean.
     */
    set_mt_page_miss_information_events(value_mt_page_miss_information_events: boolean): boolean
    /**
     * Set the 'Speech Codec Events' field in the message.
     * @param value_speech_codec_events a #gboolean.
     */
    set_speech_codec_events(value_speech_codec_events: boolean): boolean
    /**
     * Set the 'Supplementary Service Notification Events' field in the message.
     * @param value_supplementary_service_notification_events a #gboolean.
     */
    set_supplementary_service_notification_events(value_supplementary_service_notification_events: boolean): boolean
    /**
     * Set the 'USSD Notification Events' field in the message.
     * @param value_ussd_notification_events a #gboolean.
     */
    set_ussd_notification_events(value_ussd_notification_events: boolean): boolean
    /**
     * Set the 'UUS Events' field in the message.
     * @param value_uus_events a #gboolean.
     */
    set_uus_events(value_uus_events: boolean): boolean
    /**
     * Set the 'Voice Privacy Events' field in the message.
     * @param value_voice_privacy_events a #gboolean.
     */
    set_voice_privacy_events(value_voice_privacy_events: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceIndicationRegisterInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceIndicationRegisterInput
}
class MessageVoiceIndicationRegisterOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceIndicationRegisterOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceIndicationRegisterOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceManageCallsInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceManageCallsInput */
    /**
     * Get the 'Call ID' field from `self`.
     */
    get_call_id(): [ /* returnType */ boolean, /* value_call_id */ number | null ]
    /**
     * Get the 'Service Type' field from `self`.
     */
    get_service_type(): [ /* returnType */ boolean, /* value_service_type */ VoiceSupplementaryServiceType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceManageCallsInput
    /**
     * Set the 'Call ID' field in the message.
     * @param value_call_id a #guint8.
     */
    set_call_id(value_call_id: number): boolean
    /**
     * Set the 'Service Type' field in the message.
     * @param value_service_type a #QmiVoiceSupplementaryServiceType.
     */
    set_service_type(value_service_type: VoiceSupplementaryServiceType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceManageCallsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceManageCallsInput
}
class MessageVoiceManageCallsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceManageCallsOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceManageCallsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceOriginateUssdInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceOriginateUssdInput */
    /**
     * Get the 'USS Data' field from `self`.
     */
    get_uss_data(): [ /* returnType */ boolean, /* value_uss_data_data_coding_scheme */ VoiceUssDataCodingScheme | null, /* value_uss_data_data */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceOriginateUssdInput
    /**
     * Set the 'USS Data' field in the message.
     * @param value_uss_data_data_coding_scheme a #QmiVoiceUssDataCodingScheme.
     * @param value_uss_data_data a #GArray of #guint8 elements. A new reference to `value_uss_data_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_uss_data(value_uss_data_data_coding_scheme: VoiceUssDataCodingScheme, value_uss_data_data: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceOriginateUssdInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceOriginateUssdInput
}
class MessageVoiceOriginateUssdNoWaitInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceOriginateUssdNoWaitInput */
    /**
     * Get the 'USS Data' field from `self`.
     */
    get_uss_data(): [ /* returnType */ boolean, /* value_uss_data_data_coding_scheme */ VoiceUssDataCodingScheme | null, /* value_uss_data_data */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceOriginateUssdNoWaitInput
    /**
     * Set the 'USS Data' field in the message.
     * @param value_uss_data_data_coding_scheme a #QmiVoiceUssDataCodingScheme.
     * @param value_uss_data_data a #GArray of #guint8 elements. A new reference to `value_uss_data_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_uss_data(value_uss_data_data_coding_scheme: VoiceUssDataCodingScheme, value_uss_data_data: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceOriginateUssdNoWaitInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceOriginateUssdNoWaitInput
}
class MessageVoiceOriginateUssdNoWaitOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceOriginateUssdNoWaitOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceOriginateUssdNoWaitOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceOriginateUssdOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceOriginateUssdOutput */
    /**
     * Get the 'Alpha Identifier' field from `self`.
     */
    get_alpha_identifier(): [ /* returnType */ boolean, /* value_alpha_identifier_data_coding_scheme */ VoiceAlphaDataCodingScheme | null, /* value_alpha_identifier_alpha */ Uint8Array | null ]
    /**
     * Get the 'Call Control Result Type' field from `self`.
     */
    get_call_control_result_type(): [ /* returnType */ boolean, /* value_call_control_result_type */ VoiceCallControlResultType | null ]
    /**
     * Get the 'Call Control Supplementary Service Type' field from `self`.
     */
    get_call_control_supplementary_service_type(): [ /* returnType */ boolean, /* value_call_control_supplementary_service_type */ VoiceCallControlSupplementaryServiceType | null ]
    /**
     * Get the 'Call ID' field from `self`.
     */
    get_call_id(): [ /* returnType */ boolean, /* value_call_id */ number | null ]
    /**
     * Get the 'Failure Cause' field from `self`.
     */
    get_failure_cause(): [ /* returnType */ boolean, /* value_failure_cause */ VoiceCallEndReason | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'USS Data' field from `self`.
     */
    get_uss_data(): [ /* returnType */ boolean, /* value_uss_data_data_coding_scheme */ VoiceUssDataCodingScheme | null, /* value_uss_data_data */ Uint8Array | null ]
    /**
     * Get the 'USS Data UTF16' field from `self`.
     */
    get_uss_data_utf16(): [ /* returnType */ boolean, /* value_uss_data_utf16 */ number[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceOriginateUssdOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageVoiceSetSupplementaryServiceInput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceSetSupplementaryServiceInput */
    /**
     * Get the 'Supplementary Service Information' field from `self`.
     */
    get_supplementary_service_information(): [ /* returnType */ boolean, /* value_supplementary_service_information_supplementary_service_action */ VoiceSupplementaryServiceAction | null, /* value_supplementary_service_information_supplementary_service_reason */ VoiceSupplementaryServiceReason | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceSetSupplementaryServiceInput
    /**
     * Set the 'Supplementary Service Information' field in the message.
     * @param value_supplementary_service_information_supplementary_service_action a #QmiVoiceSupplementaryServiceAction.
     * @param value_supplementary_service_information_supplementary_service_reason a #QmiVoiceSupplementaryServiceReason.
     */
    set_supplementary_service_information(value_supplementary_service_information_supplementary_service_action: VoiceSupplementaryServiceAction, value_supplementary_service_information_supplementary_service_reason: VoiceSupplementaryServiceReason): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageVoiceSetSupplementaryServiceInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageVoiceSetSupplementaryServiceInput
}
class MessageVoiceSetSupplementaryServiceOutput {
    /* Methods of Qmi-1.0.Qmi.MessageVoiceSetSupplementaryServiceOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Service Status' field from `self`.
     */
    get_service_status(): [ /* returnType */ boolean, /* value_service_status_active */ boolean | null, /* value_service_status_provisioned */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageVoiceSetSupplementaryServiceOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdaGetDataFormatInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdaGetDataFormatInput */
    /**
     * Get the 'Endpoint Info' field from `self`.
     */
    get_endpoint_info(): [ /* returnType */ boolean, /* value_endpoint_info_endpoint_type */ DataEndpointType | null, /* value_endpoint_info_interface_number */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdaGetDataFormatInput
    /**
     * Set the 'Endpoint Info' field in the message.
     * @param value_endpoint_info_endpoint_type a #QmiDataEndpointType.
     * @param value_endpoint_info_interface_number a #guint32.
     */
    set_endpoint_info(value_endpoint_info_endpoint_type: DataEndpointType, value_endpoint_info_interface_number: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdaGetDataFormatInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdaGetDataFormatInput
}
class MessageWdaGetDataFormatOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdaGetDataFormatOutput */
    /**
     * Get the 'Downlink Data Aggregation Max Datagrams' field from `self`.
     */
    get_downlink_data_aggregation_max_datagrams(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_max_datagrams */ number | null ]
    /**
     * Get the 'Downlink Data Aggregation Max Size' field from `self`.
     */
    get_downlink_data_aggregation_max_size(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_max_size */ number | null ]
    /**
     * Get the 'Downlink Data Aggregation Protocol' field from `self`.
     */
    get_downlink_data_aggregation_protocol(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_protocol */ WdaDataAggregationProtocol | null ]
    /**
     * Get the 'Download Minimum Padding' field from `self`.
     */
    get_download_minimum_padding(): [ /* returnType */ boolean, /* value_download_minimum_padding */ number | null ]
    /**
     * Get the 'Flow Control' field from `self`.
     */
    get_flow_control(): [ /* returnType */ boolean, /* value_flow_control */ number | null ]
    /**
     * Get the 'Link Layer Protocol' field from `self`.
     */
    get_link_layer_protocol(): [ /* returnType */ boolean, /* value_link_layer_protocol */ WdaLinkLayerProtocol | null ]
    /**
     * Get the 'NDP Signature' field from `self`.
     */
    get_ndp_signature(): [ /* returnType */ boolean, /* value_ndp_signature */ number | null ]
    /**
     * Get the 'QoS Format' field from `self`.
     */
    get_qos_format(): [ /* returnType */ boolean, /* value_qos_format */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Uplink Data Aggregation Max Datagrams' field from `self`.
     */
    get_uplink_data_aggregation_max_datagrams(): [ /* returnType */ boolean, /* value_uplink_data_aggregation_max_datagrams */ number | null ]
    /**
     * Get the 'Uplink Data Aggregation Max Size' field from `self`.
     */
    get_uplink_data_aggregation_max_size(): [ /* returnType */ boolean, /* value_uplink_data_aggregation_max_size */ number | null ]
    /**
     * Get the 'Uplink Data Aggregation Protocol' field from `self`.
     */
    get_uplink_data_aggregation_protocol(): [ /* returnType */ boolean, /* value_uplink_data_aggregation_protocol */ WdaDataAggregationProtocol | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdaGetDataFormatOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdaGetSupportedMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdaGetSupportedMessagesOutput */
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdaGetSupportedMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdaSetDataFormatInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdaSetDataFormatInput */
    /**
     * Get the 'Downlink Data Aggregation Max Datagrams' field from `self`.
     */
    get_downlink_data_aggregation_max_datagrams(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_max_datagrams */ number | null ]
    /**
     * Get the 'Downlink Data Aggregation Max Size' field from `self`.
     */
    get_downlink_data_aggregation_max_size(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_max_size */ number | null ]
    /**
     * Get the 'Downlink Data Aggregation Protocol' field from `self`.
     */
    get_downlink_data_aggregation_protocol(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_protocol */ WdaDataAggregationProtocol | null ]
    /**
     * Get the 'Endpoint Info' field from `self`.
     */
    get_endpoint_info(): [ /* returnType */ boolean, /* value_endpoint_info_endpoint_type */ DataEndpointType | null, /* value_endpoint_info_interface_number */ number | null ]
    /**
     * Get the 'Link Layer Protocol' field from `self`.
     */
    get_link_layer_protocol(): [ /* returnType */ boolean, /* value_link_layer_protocol */ WdaLinkLayerProtocol | null ]
    /**
     * Get the 'NDP Signature' field from `self`.
     */
    get_ndp_signature(): [ /* returnType */ boolean, /* value_ndp_signature */ number | null ]
    /**
     * Get the 'QoS Format' field from `self`.
     */
    get_qos_format(): [ /* returnType */ boolean, /* value_qos_format */ boolean | null ]
    /**
     * Get the 'Uplink Data Aggregation Protocol' field from `self`.
     */
    get_uplink_data_aggregation_protocol(): [ /* returnType */ boolean, /* value_uplink_data_aggregation_protocol */ WdaDataAggregationProtocol | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdaSetDataFormatInput
    /**
     * Set the 'Downlink Data Aggregation Max Datagrams' field in the message.
     * @param value_downlink_data_aggregation_max_datagrams a #guint32.
     */
    set_downlink_data_aggregation_max_datagrams(value_downlink_data_aggregation_max_datagrams: number): boolean
    /**
     * Set the 'Downlink Data Aggregation Max Size' field in the message.
     * @param value_downlink_data_aggregation_max_size a #guint32.
     */
    set_downlink_data_aggregation_max_size(value_downlink_data_aggregation_max_size: number): boolean
    /**
     * Set the 'Downlink Data Aggregation Protocol' field in the message.
     * @param value_downlink_data_aggregation_protocol a #QmiWdaDataAggregationProtocol.
     */
    set_downlink_data_aggregation_protocol(value_downlink_data_aggregation_protocol: WdaDataAggregationProtocol): boolean
    /**
     * Set the 'Endpoint Info' field in the message.
     * @param value_endpoint_info_endpoint_type a #QmiDataEndpointType.
     * @param value_endpoint_info_interface_number a #guint32.
     */
    set_endpoint_info(value_endpoint_info_endpoint_type: DataEndpointType, value_endpoint_info_interface_number: number): boolean
    /**
     * Set the 'Link Layer Protocol' field in the message.
     * @param value_link_layer_protocol a #QmiWdaLinkLayerProtocol.
     */
    set_link_layer_protocol(value_link_layer_protocol: WdaLinkLayerProtocol): boolean
    /**
     * Set the 'NDP Signature' field in the message.
     * @param value_ndp_signature a #guint32.
     */
    set_ndp_signature(value_ndp_signature: number): boolean
    /**
     * Set the 'QoS Format' field in the message.
     * @param value_qos_format a #gboolean.
     */
    set_qos_format(value_qos_format: boolean): boolean
    /**
     * Set the 'Uplink Data Aggregation Protocol' field in the message.
     * @param value_uplink_data_aggregation_protocol a #QmiWdaDataAggregationProtocol.
     */
    set_uplink_data_aggregation_protocol(value_uplink_data_aggregation_protocol: WdaDataAggregationProtocol): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdaSetDataFormatInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdaSetDataFormatInput
}
class MessageWdaSetDataFormatOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdaSetDataFormatOutput */
    /**
     * Get the 'Downlink Data Aggregation Max Datagrams' field from `self`.
     */
    get_downlink_data_aggregation_max_datagrams(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_max_datagrams */ number | null ]
    /**
     * Get the 'Downlink Data Aggregation Max Size' field from `self`.
     */
    get_downlink_data_aggregation_max_size(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_max_size */ number | null ]
    /**
     * Get the 'Downlink Data Aggregation Protocol' field from `self`.
     */
    get_downlink_data_aggregation_protocol(): [ /* returnType */ boolean, /* value_downlink_data_aggregation_protocol */ WdaDataAggregationProtocol | null ]
    /**
     * Get the 'Download Minimum Padding' field from `self`.
     */
    get_download_minimum_padding(): [ /* returnType */ boolean, /* value_download_minimum_padding */ number | null ]
    /**
     * Get the 'Flow Control' field from `self`.
     */
    get_flow_control(): [ /* returnType */ boolean, /* value_flow_control */ number | null ]
    /**
     * Get the 'Link Layer Protocol' field from `self`.
     */
    get_link_layer_protocol(): [ /* returnType */ boolean, /* value_link_layer_protocol */ WdaLinkLayerProtocol | null ]
    /**
     * Get the 'NDP Signature' field from `self`.
     */
    get_ndp_signature(): [ /* returnType */ boolean, /* value_ndp_signature */ number | null ]
    /**
     * Get the 'QoS Format' field from `self`.
     */
    get_qos_format(): [ /* returnType */ boolean, /* value_qos_format */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Uplink Data Aggregation Max Datagrams' field from `self`.
     */
    get_uplink_data_aggregation_max_datagrams(): [ /* returnType */ boolean, /* value_uplink_data_aggregation_max_datagrams */ number | null ]
    /**
     * Get the 'Uplink Data Aggregation Max Size' field from `self`.
     */
    get_uplink_data_aggregation_max_size(): [ /* returnType */ boolean, /* value_uplink_data_aggregation_max_size */ number | null ]
    /**
     * Get the 'Uplink Data Aggregation Protocol' field from `self`.
     */
    get_uplink_data_aggregation_protocol(): [ /* returnType */ boolean, /* value_uplink_data_aggregation_protocol */ WdaDataAggregationProtocol | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdaSetDataFormatOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsBindDataPortInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsBindDataPortInput */
    /**
     * Get the 'Data Port' field from `self`.
     */
    get_data_port(): [ /* returnType */ boolean, /* value_data_port */ SioPort | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsBindDataPortInput
    /**
     * Set the 'Data Port' field in the message.
     * @param value_data_port a #QmiSioPort.
     */
    set_data_port(value_data_port: SioPort): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsBindDataPortInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsBindDataPortInput
}
class MessageWdsBindDataPortOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsBindDataPortOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsBindDataPortOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsBindMuxDataPortInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsBindMuxDataPortInput */
    /**
     * Get the 'Client Type' field from `self`.
     */
    get_client_type(): [ /* returnType */ boolean, /* value_client_type */ WdsClientType | null ]
    /**
     * Get the 'Endpoint Info' field from `self`.
     */
    get_endpoint_info(): [ /* returnType */ boolean, /* value_endpoint_info_endpoint_type */ DataEndpointType | null, /* value_endpoint_info_interface_number */ number | null ]
    /**
     * Get the 'Mux ID' field from `self`.
     */
    get_mux_id(): [ /* returnType */ boolean, /* value_mux_id */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsBindMuxDataPortInput
    /**
     * Set the 'Client Type' field in the message.
     * @param value_client_type a #QmiWdsClientType.
     */
    set_client_type(value_client_type: WdsClientType): boolean
    /**
     * Set the 'Endpoint Info' field in the message.
     * @param value_endpoint_info_endpoint_type a #QmiDataEndpointType.
     * @param value_endpoint_info_interface_number a #guint32.
     */
    set_endpoint_info(value_endpoint_info_endpoint_type: DataEndpointType, value_endpoint_info_interface_number: number): boolean
    /**
     * Set the 'Mux ID' field in the message.
     * @param value_mux_id a #guint8.
     */
    set_mux_id(value_mux_id: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsBindMuxDataPortInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsBindMuxDataPortInput
}
class MessageWdsBindMuxDataPortOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsBindMuxDataPortOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsBindMuxDataPortOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsCreateProfileInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsCreateProfileInput */
    /**
     * Get the 'APN Disabled Flag' field from `self`.
     */
    get_apn_disabled_flag(): [ /* returnType */ boolean, /* value_apn_disabled_flag */ boolean | null ]
    /**
     * Get the 'APN Name' field from `self`.
     */
    get_apn_name(): [ /* returnType */ boolean, /* value_apn_name */ string | null ]
    /**
     * Get the 'APN Type Mask' field from `self`.
     */
    get_apn_type_mask(): [ /* returnType */ boolean, /* value_apn_type_mask */ WdsApnTypeMask | null ]
    /**
     * Get the 'Authentication' field from `self`.
     */
    get_authentication(): [ /* returnType */ boolean, /* value_authentication */ WdsAuthentication | null ]
    /**
     * Get the 'GPRS Minimum QoS' field from `self`.
     */
    get_gprs_minimum_qos(): [ /* returnType */ boolean, /* value_gprs_minimum_qos_precedence_class */ number | null, /* value_gprs_minimum_qos_delay_class */ number | null, /* value_gprs_minimum_qos_reliability_class */ number | null, /* value_gprs_minimum_qos_peak_throughput_class */ number | null, /* value_gprs_minimum_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'GPRS Requested QoS' field from `self`.
     */
    get_gprs_requested_qos(): [ /* returnType */ boolean, /* value_gprs_requested_qos_precedence_class */ number | null, /* value_gprs_requested_qos_delay_class */ number | null, /* value_gprs_requested_qos_reliability_class */ number | null, /* value_gprs_requested_qos_peak_throughput_class */ number | null, /* value_gprs_requested_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'IMCN Flag' field from `self`.
     */
    get_imcn_flag(): [ /* returnType */ boolean, /* value_imcn_flag */ boolean | null ]
    /**
     * Get the 'IPv4 Address Preference' field from `self`.
     */
    get_ipv4_address_preference(): [ /* returnType */ boolean, /* value_ipv4_address_preference */ number | null ]
    /**
     * Get the 'IPv6 Address Preference' field from `self`.
     */
    get_ipv6_address_preference(): [ /* returnType */ boolean, /* value_ipv6_address_preference_address */ number[] | null ]
    /**
     * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
     */
    get_ipv6_primary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_primary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
     */
    get_ipv6_secondary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_secondary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'LTE QoS Parameters' field from `self`.
     */
    get_lte_qos_parameters(): [ /* returnType */ boolean, /* value_lte_qos_parameters_qos_class_identifier */ WdsQosClassIdentifier | null, /* value_lte_qos_parameters_guaranteed_downlink_bitrate */ number | null, /* value_lte_qos_parameters_max_downlink_bitrate */ number | null, /* value_lte_qos_parameters_guaranteed_uplink_bitrate */ number | null, /* value_lte_qos_parameters_max_uplink_bitrate */ number | null ]
    /**
     * Get the 'Password' field from `self`.
     */
    get_password(): [ /* returnType */ boolean, /* value_password */ string | null ]
    /**
     * Get the 'PCSCF Address Using DHCP' field from `self`.
     */
    get_pcscf_address_using_dhcp(): [ /* returnType */ boolean, /* value_pcscf_address_using_dhcp */ boolean | null ]
    /**
     * Get the 'PCSCF Address Using PCO' field from `self`.
     */
    get_pcscf_address_using_pco(): [ /* returnType */ boolean, /* value_pcscf_address_using_pco */ boolean | null ]
    /**
     * Get the 'PDP Context Number' field from `self`.
     */
    get_pdp_context_number(): [ /* returnType */ boolean, /* value_pdp_context_number */ number | null ]
    /**
     * Get the 'PDP Context Primary ID' field from `self`.
     */
    get_pdp_context_primary_id(): [ /* returnType */ boolean, /* value_pdp_context_primary_id */ number | null ]
    /**
     * Get the 'PDP Context Secondary Flag' field from `self`.
     */
    get_pdp_context_secondary_flag(): [ /* returnType */ boolean, /* value_pdp_context_secondary_flag */ boolean | null ]
    /**
     * Get the 'PDP Data Compression Type' field from `self`.
     */
    get_pdp_data_compression_type(): [ /* returnType */ boolean, /* value_pdp_data_compression_type */ WdsPdpDataCompressionType | null ]
    /**
     * Get the 'PDP Header Compression Type' field from `self`.
     */
    get_pdp_header_compression_type(): [ /* returnType */ boolean, /* value_pdp_header_compression_type */ WdsPdpHeaderCompressionType | null ]
    /**
     * Get the 'PDP Type' field from `self`.
     */
    get_pdp_type(): [ /* returnType */ boolean, /* value_pdp_type */ WdsPdpType | null ]
    /**
     * Get the 'Primary IPv4 DNS Address' field from `self`.
     */
    get_primary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_primary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'Profile Name' field from `self`.
     */
    get_profile_name(): [ /* returnType */ boolean, /* value_profile_name */ string | null ]
    /**
     * Get the 'Profile Type' field from `self`.
     */
    get_profile_type(): [ /* returnType */ boolean, /* value_profile_type */ WdsProfileType | null ]
    /**
     * Get the 'Roaming Disallowed Flag' field from `self`.
     */
    get_roaming_disallowed_flag(): [ /* returnType */ boolean, /* value_roaming_disallowed_flag */ boolean | null ]
    /**
     * Get the 'Secondary IPv4 DNS Address' field from `self`.
     */
    get_secondary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_secondary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS' field from `self`.
     */
    get_umts_minimum_qos(): [ /* returnType */ boolean, /* value_umts_minimum_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_transfer_delay */ number | null, /* value_umts_minimum_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_minimum_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'UMTS Requested QoS' field from `self`.
     */
    get_umts_requested_qos(): [ /* returnType */ boolean, /* value_umts_requested_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_maximum_sdu_size */ number | null, /* value_umts_requested_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_transfer_delay */ number | null, /* value_umts_requested_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_requested_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'Username' field from `self`.
     */
    get_username(): [ /* returnType */ boolean, /* value_username */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsCreateProfileInput
    /**
     * Set the 'APN Disabled Flag' field in the message.
     * @param value_apn_disabled_flag a #gboolean.
     */
    set_apn_disabled_flag(value_apn_disabled_flag: boolean): boolean
    /**
     * Set the 'APN Name' field in the message.
     * @param value_apn_name a constant string.
     */
    set_apn_name(value_apn_name: string): boolean
    /**
     * Set the 'APN Type Mask' field in the message.
     * @param value_apn_type_mask a #QmiWdsApnTypeMask.
     */
    set_apn_type_mask(value_apn_type_mask: WdsApnTypeMask): boolean
    /**
     * Set the 'Authentication' field in the message.
     * @param value_authentication a #QmiWdsAuthentication.
     */
    set_authentication(value_authentication: WdsAuthentication): boolean
    /**
     * Set the 'GPRS Minimum QoS' field in the message.
     * @param value_gprs_minimum_qos_precedence_class a #guint32.
     * @param value_gprs_minimum_qos_delay_class a #guint32.
     * @param value_gprs_minimum_qos_reliability_class a #guint32.
     * @param value_gprs_minimum_qos_peak_throughput_class a #guint32.
     * @param value_gprs_minimum_qos_mean_throughput_class a #guint32.
     */
    set_gprs_minimum_qos(value_gprs_minimum_qos_precedence_class: number, value_gprs_minimum_qos_delay_class: number, value_gprs_minimum_qos_reliability_class: number, value_gprs_minimum_qos_peak_throughput_class: number, value_gprs_minimum_qos_mean_throughput_class: number): boolean
    /**
     * Set the 'GPRS Requested QoS' field in the message.
     * @param value_gprs_requested_qos_precedence_class a #guint32.
     * @param value_gprs_requested_qos_delay_class a #guint32.
     * @param value_gprs_requested_qos_reliability_class a #guint32.
     * @param value_gprs_requested_qos_peak_throughput_class a #guint32.
     * @param value_gprs_requested_qos_mean_throughput_class a #guint32.
     */
    set_gprs_requested_qos(value_gprs_requested_qos_precedence_class: number, value_gprs_requested_qos_delay_class: number, value_gprs_requested_qos_reliability_class: number, value_gprs_requested_qos_peak_throughput_class: number, value_gprs_requested_qos_mean_throughput_class: number): boolean
    /**
     * Set the 'IMCN Flag' field in the message.
     * @param value_imcn_flag a #gboolean.
     */
    set_imcn_flag(value_imcn_flag: boolean): boolean
    /**
     * Set the 'IPv4 Address Preference' field in the message.
     * @param value_ipv4_address_preference a #guint32.
     */
    set_ipv4_address_preference(value_ipv4_address_preference: number): boolean
    /**
     * Set the 'IPv6 Address Preference' field in the message.
     * @param value_ipv6_address_preference_address a #GArray of #guint16 elements. A new reference to `value_ipv6`_address_preference_address will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ipv6_address_preference(value_ipv6_address_preference_address: number[]): boolean
    /**
     * Set the 'IPv6 Primary DNS Address Preference' field in the message.
     * @param value_ipv6_primary_dns_address_preference a #GArray of #guint16 elements. A new reference to `value_ipv6`_primary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ipv6_primary_dns_address_preference(value_ipv6_primary_dns_address_preference: number[]): boolean
    /**
     * Set the 'IPv6 Secondary DNS Address Preference' field in the message.
     * @param value_ipv6_secondary_dns_address_preference a #GArray of #guint16 elements. A new reference to `value_ipv6`_secondary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ipv6_secondary_dns_address_preference(value_ipv6_secondary_dns_address_preference: number[]): boolean
    /**
     * Set the 'LTE QoS Parameters' field in the message.
     * @param value_lte_qos_parameters_qos_class_identifier a #QmiWdsQosClassIdentifier.
     * @param value_lte_qos_parameters_guaranteed_downlink_bitrate a #guint32.
     * @param value_lte_qos_parameters_max_downlink_bitrate a #guint32.
     * @param value_lte_qos_parameters_guaranteed_uplink_bitrate a #guint32.
     * @param value_lte_qos_parameters_max_uplink_bitrate a #guint32.
     */
    set_lte_qos_parameters(value_lte_qos_parameters_qos_class_identifier: WdsQosClassIdentifier, value_lte_qos_parameters_guaranteed_downlink_bitrate: number, value_lte_qos_parameters_max_downlink_bitrate: number, value_lte_qos_parameters_guaranteed_uplink_bitrate: number, value_lte_qos_parameters_max_uplink_bitrate: number): boolean
    /**
     * Set the 'Password' field in the message.
     * @param value_password a constant string.
     */
    set_password(value_password: string): boolean
    /**
     * Set the 'PCSCF Address Using DHCP' field in the message.
     * @param value_pcscf_address_using_dhcp a #gboolean.
     */
    set_pcscf_address_using_dhcp(value_pcscf_address_using_dhcp: boolean): boolean
    /**
     * Set the 'PCSCF Address Using PCO' field in the message.
     * @param value_pcscf_address_using_pco a #gboolean.
     */
    set_pcscf_address_using_pco(value_pcscf_address_using_pco: boolean): boolean
    /**
     * Set the 'PDP Context Number' field in the message.
     * @param value_pdp_context_number a #guint8.
     */
    set_pdp_context_number(value_pdp_context_number: number): boolean
    /**
     * Set the 'PDP Context Primary ID' field in the message.
     * @param value_pdp_context_primary_id a #guint8.
     */
    set_pdp_context_primary_id(value_pdp_context_primary_id: number): boolean
    /**
     * Set the 'PDP Context Secondary Flag' field in the message.
     * @param value_pdp_context_secondary_flag a #gboolean.
     */
    set_pdp_context_secondary_flag(value_pdp_context_secondary_flag: boolean): boolean
    /**
     * Set the 'PDP Data Compression Type' field in the message.
     * @param value_pdp_data_compression_type a #QmiWdsPdpDataCompressionType.
     */
    set_pdp_data_compression_type(value_pdp_data_compression_type: WdsPdpDataCompressionType): boolean
    /**
     * Set the 'PDP Header Compression Type' field in the message.
     * @param value_pdp_header_compression_type a #QmiWdsPdpHeaderCompressionType.
     */
    set_pdp_header_compression_type(value_pdp_header_compression_type: WdsPdpHeaderCompressionType): boolean
    /**
     * Set the 'PDP Type' field in the message.
     * @param value_pdp_type a #QmiWdsPdpType.
     */
    set_pdp_type(value_pdp_type: WdsPdpType): boolean
    /**
     * Set the 'Primary IPv4 DNS Address' field in the message.
     * @param value_primary_ipv4_dns_address a #guint32.
     */
    set_primary_ipv4_dns_address(value_primary_ipv4_dns_address: number): boolean
    /**
     * Set the 'Profile Name' field in the message.
     * @param value_profile_name a constant string.
     */
    set_profile_name(value_profile_name: string): boolean
    /**
     * Set the 'Profile Type' field in the message.
     * @param value_profile_type a #QmiWdsProfileType.
     */
    set_profile_type(value_profile_type: WdsProfileType): boolean
    /**
     * Set the 'Roaming Disallowed Flag' field in the message.
     * @param value_roaming_disallowed_flag a #gboolean.
     */
    set_roaming_disallowed_flag(value_roaming_disallowed_flag: boolean): boolean
    /**
     * Set the 'Secondary IPv4 DNS Address' field in the message.
     * @param value_secondary_ipv4_dns_address a #guint32.
     */
    set_secondary_ipv4_dns_address(value_secondary_ipv4_dns_address: number): boolean
    /**
     * Set the 'UMTS Minimum QoS' field in the message.
     * @param value_umts_minimum_qos_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_minimum_qos_max_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_max_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_minimum_qos_maximum_sdu_size a #guint32.
     * @param value_umts_minimum_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_minimum_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_minimum_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_minimum_qos_transfer_delay a #guint32.
     * @param value_umts_minimum_qos_traffic_handling_priority a #guint32.
     */
    set_umts_minimum_qos(value_umts_minimum_qos_traffic_class: WdsTrafficClass, value_umts_minimum_qos_max_uplink_bitrate: number, value_umts_minimum_qos_max_downlink_bitrate: number, value_umts_minimum_qos_guaranteed_uplink_bitrate: number, value_umts_minimum_qos_guaranteed_downlink_bitrate: number, value_umts_minimum_qos_qos_delivery_order: WdsDeliveryOrder, value_umts_minimum_qos_maximum_sdu_size: number, value_umts_minimum_qos_sdu_error_ratio: WdsSduErrorRatio, value_umts_minimum_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_minimum_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_minimum_qos_transfer_delay: number, value_umts_minimum_qos_traffic_handling_priority: number): boolean
    /**
     * Set the 'UMTS Minimum QoS With Signaling Indication Flag' field in the message.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication a #gint8.
     */
    set_umts_minimum_qos_with_signaling_indication_flag(value_umts_minimum_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass, value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder, value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size: number, value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio, value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay: number, value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority: number, value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication: number): boolean
    /**
     * Set the 'UMTS Requested QoS' field in the message.
     * @param value_umts_requested_qos_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_requested_qos_max_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_max_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_requested_qos_maximum_sdu_size a #guint32.
     * @param value_umts_requested_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_requested_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_requested_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_requested_qos_transfer_delay a #guint32.
     * @param value_umts_requested_qos_traffic_handling_priority a #guint32.
     */
    set_umts_requested_qos(value_umts_requested_qos_traffic_class: WdsTrafficClass, value_umts_requested_qos_max_uplink_bitrate: number, value_umts_requested_qos_max_downlink_bitrate: number, value_umts_requested_qos_guaranteed_uplink_bitrate: number, value_umts_requested_qos_guaranteed_downlink_bitrate: number, value_umts_requested_qos_qos_delivery_order: WdsDeliveryOrder, value_umts_requested_qos_maximum_sdu_size: number, value_umts_requested_qos_sdu_error_ratio: WdsSduErrorRatio, value_umts_requested_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_requested_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_requested_qos_transfer_delay: number, value_umts_requested_qos_traffic_handling_priority: number): boolean
    /**
     * Set the 'UMTS Requested QoS With Signaling Indication Flag' field in the message.
     * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_requested_qos_with_signaling_indication_flag_transfer_delay a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_signaling_indication a #gint8.
     */
    set_umts_requested_qos_with_signaling_indication_flag(value_umts_requested_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass, value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder, value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size: number, value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio, value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_requested_qos_with_signaling_indication_flag_transfer_delay: number, value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority: number, value_umts_requested_qos_with_signaling_indication_flag_signaling_indication: number): boolean
    /**
     * Set the 'Username' field in the message.
     * @param value_username a constant string.
     */
    set_username(value_username: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsCreateProfileInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsCreateProfileInput
}
class MessageWdsCreateProfileOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsCreateProfileOutput */
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the 'Profile Identifier' field from `self`.
     */
    get_profile_identifier(): [ /* returnType */ boolean, /* value_profile_identifier_profile_type */ WdsProfileType | null, /* value_profile_identifier_profile_index */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsCreateProfileOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsDeleteProfileInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsDeleteProfileInput */
    /**
     * Get the 'Profile Identifier' field from `self`.
     */
    get_profile_identifier(): [ /* returnType */ boolean, /* value_profile_identifier_profile_type */ WdsProfileType | null, /* value_profile_identifier_profile_index */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsDeleteProfileInput
    /**
     * Set the 'Profile Identifier' field in the message.
     * @param value_profile_identifier_profile_type a #QmiWdsProfileType.
     * @param value_profile_identifier_profile_index a #guint8.
     */
    set_profile_identifier(value_profile_identifier_profile_type: WdsProfileType, value_profile_identifier_profile_index: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsDeleteProfileInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsDeleteProfileInput
}
class MessageWdsDeleteProfileOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsDeleteProfileOutput */
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsDeleteProfileOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetAutoconnectSettingsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetAutoconnectSettingsOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Roaming' field from `self`.
     */
    get_roaming(): [ /* returnType */ boolean, /* value_roaming */ WdsAutoconnectSettingRoaming | null ]
    /**
     * Get the 'Status' field from `self`.
     */
    get_status(): [ /* returnType */ boolean, /* value_status */ WdsAutoconnectSetting | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetAutoconnectSettingsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetChannelRatesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetChannelRatesOutput */
    /**
     * Get the 'Channel Rates' field from `self`.
     */
    get_channel_rates(): [ /* returnType */ boolean, /* value_channel_rates_channel_tx_rate_bps */ number | null, /* value_channel_rates_channel_rx_rate_bps */ number | null, /* value_channel_rates_max_channel_tx_rate_bps */ number | null, /* value_channel_rates_max_channel_rx_rate_bps */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetChannelRatesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetCurrentDataBearerTechnologyOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetCurrentDataBearerTechnologyOutput */
    /**
     * Get the 'Current' field from `self`.
     */
    get_current(): [ /* returnType */ boolean, /* value_current_network_type */ WdsNetworkType | null, /* value_current_rat_mask */ number | null, /* value_current_so_mask */ number | null ]
    /**
     * Get the 'Last' field from `self`.
     */
    get_last(): [ /* returnType */ boolean, /* value_last_network_type */ WdsNetworkType | null, /* value_last_rat_mask */ number | null, /* value_last_so_mask */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetCurrentDataBearerTechnologyOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetCurrentSettingsInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetCurrentSettingsInput */
    /**
     * Get the 'Requested Settings' field from `self`.
     */
    get_requested_settings(): [ /* returnType */ boolean, /* value_requested_settings */ WdsGetCurrentSettingsRequestedSettings | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetCurrentSettingsInput
    /**
     * Set the 'Requested Settings' field in the message.
     * @param value_requested_settings a #QmiWdsGetCurrentSettingsRequestedSettings.
     */
    set_requested_settings(value_requested_settings: WdsGetCurrentSettingsRequestedSettings): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsGetCurrentSettingsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsGetCurrentSettingsInput
}
class MessageWdsGetCurrentSettingsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetCurrentSettingsOutput */
    /**
     * Get the 'APN Name' field from `self`.
     */
    get_apn_name(): [ /* returnType */ boolean, /* value_apn_name */ string | null ]
    /**
     * Get the 'Authentication' field from `self`.
     */
    get_authentication(): [ /* returnType */ boolean, /* value_authentication */ WdsAuthentication | null ]
    /**
     * Get the 'Domain Name List' field from `self`.
     */
    get_domain_name_list(): [ /* returnType */ boolean, /* value_domain_name_list */ string[] | null ]
    /**
     * Get the 'Extended Technology Preference' field from `self`.
     */
    get_extended_technology_preference(): [ /* returnType */ boolean, /* value_extended_technology_preference */ WdsExtendedTechnologyPreference | null ]
    /**
     * Get the 'GPRS Granted QoS' field from `self`.
     */
    get_gprs_granted_qos(): [ /* returnType */ boolean, /* value_gprs_granted_qos_precedence_class */ number | null, /* value_gprs_granted_qos_delay_class */ number | null, /* value_gprs_granted_qos_reliability_class */ number | null, /* value_gprs_granted_qos_peak_throughput_class */ number | null, /* value_gprs_granted_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'IMCN Flag' field from `self`.
     */
    get_imcn_flag(): [ /* returnType */ boolean, /* value_imcn_flag */ number | null ]
    /**
     * Get the 'IP Family' field from `self`.
     */
    get_ip_family(): [ /* returnType */ boolean, /* value_ip_family */ WdsIpFamily | null ]
    /**
     * Get the 'IPv4 Address' field from `self`.
     */
    get_ipv4_address(): [ /* returnType */ boolean, /* value_ipv4_address */ number | null ]
    /**
     * Get the 'IPv4 Gateway Address' field from `self`.
     */
    get_ipv4_gateway_address(): [ /* returnType */ boolean, /* value_ipv4_gateway_address */ number | null ]
    /**
     * Get the 'IPv4 Gateway Subnet Mask' field from `self`.
     */
    get_ipv4_gateway_subnet_mask(): [ /* returnType */ boolean, /* value_ipv4_gateway_subnet_mask */ number | null ]
    /**
     * Get the 'IPv6 Address' field from `self`.
     */
    get_ipv6_address(): [ /* returnType */ boolean, /* value_ipv6_address_address */ number[] | null, /* value_ipv6_address_prefix_length */ number | null ]
    /**
     * Get the 'IPv6 Gateway Address' field from `self`.
     */
    get_ipv6_gateway_address(): [ /* returnType */ boolean, /* value_ipv6_gateway_address_address */ number[] | null, /* value_ipv6_gateway_address_prefix_length */ number | null ]
    /**
     * Get the 'IPv6 Primary DNS Address' field from `self`.
     */
    get_ipv6_primary_dns_address(): [ /* returnType */ boolean, /* value_ipv6_primary_dns_address */ number[] | null ]
    /**
     * Get the 'IPv6 Secondary DNS Address' field from `self`.
     */
    get_ipv6_secondary_dns_address(): [ /* returnType */ boolean, /* value_ipv6_secondary_dns_address */ number[] | null ]
    /**
     * Get the 'MTU' field from `self`.
     */
    get_mtu(): [ /* returnType */ boolean, /* value_mtu */ number | null ]
    /**
     * Get the 'PCSCF Address Using PCO' field from `self`.
     */
    get_pcscf_address_using_pco(): [ /* returnType */ boolean, /* value_pcscf_address_using_pco */ number | null ]
    /**
     * Get the 'PCSCF Domain Name List' field from `self`.
     */
    get_pcscf_domain_name_list(): [ /* returnType */ boolean, /* value_pcscf_domain_name_list */ string[] | null ]
    /**
     * Get the 'PCSCF Server Address List' field from `self`.
     */
    get_pcscf_server_address_list(): [ /* returnType */ boolean, /* value_pcscf_server_address_list */ number[] | null ]
    /**
     * Get the 'PDP Type' field from `self`.
     */
    get_pdp_type(): [ /* returnType */ boolean, /* value_pdp_type */ WdsPdpType | null ]
    /**
     * Get the 'Primary IPv4 DNS Address' field from `self`.
     */
    get_primary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_primary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'Profile ID' field from `self`.
     */
    get_profile_id(): [ /* returnType */ boolean, /* value_profile_id_profile_type */ WdsProfileType | null, /* value_profile_id_profile_index */ number | null ]
    /**
     * Get the 'Profile Name' field from `self`.
     */
    get_profile_name(): [ /* returnType */ boolean, /* value_profile_name */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Secondary IPv4 DNS Address' field from `self`.
     */
    get_secondary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_secondary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'UMTS Granted QoS' field from `self`.
     */
    get_umts_granted_qos(): [ /* returnType */ boolean, /* value_umts_granted_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_granted_qos_max_uplink_bitrate */ number | null, /* value_umts_granted_qos_max_downlink_bitrate */ number | null, /* value_umts_granted_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_granted_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_granted_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_granted_qos_maximum_sdu_size */ number | null, /* value_umts_granted_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_granted_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_granted_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_granted_qos_transfer_delay */ number | null, /* value_umts_granted_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'Username' field from `self`.
     */
    get_username(): [ /* returnType */ boolean, /* value_username */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetCurrentSettingsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetDataBearerTechnologyOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetDataBearerTechnologyOutput */
    /**
     * Get the 'Current' field from `self`.
     */
    get_current(): [ /* returnType */ boolean, /* value_current */ WdsDataBearerTechnology | null ]
    /**
     * Get the 'Last' field from `self`.
     */
    get_last(): [ /* returnType */ boolean, /* value_last */ WdsDataBearerTechnology | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetDataBearerTechnologyOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetDefaultProfileNumberInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetDefaultProfileNumberInput */
    /**
     * Get the 'Profile Type' field from `self`.
     */
    get_profile_type(): [ /* returnType */ boolean, /* value_profile_type_type */ WdsProfileType | null, /* value_profile_type_family */ WdsProfileFamily | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetDefaultProfileNumberInput
    /**
     * Set the 'Profile Type' field in the message.
     * @param value_profile_type_type a #QmiWdsProfileType.
     * @param value_profile_type_family a #QmiWdsProfileFamily.
     */
    set_profile_type(value_profile_type_type: WdsProfileType, value_profile_type_family: WdsProfileFamily): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsGetDefaultProfileNumberInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsGetDefaultProfileNumberInput
}
class MessageWdsGetDefaultProfileNumberOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetDefaultProfileNumberOutput */
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the 'Index' field from `self`.
     */
    get_index(): [ /* returnType */ boolean, /* value_index */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetDefaultProfileNumberOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetDefaultSettingsInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetDefaultSettingsInput */
    /**
     * Get the 'Profile Type' field from `self`.
     */
    get_profile_type(): [ /* returnType */ boolean, /* value_profile_type */ WdsProfileType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetDefaultSettingsInput
    /**
     * Set the 'Profile Type' field in the message.
     * @param value_profile_type a #QmiWdsProfileType.
     */
    set_profile_type(value_profile_type: WdsProfileType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsGetDefaultSettingsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsGetDefaultSettingsInput
}
class MessageWdsGetDefaultSettingsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetDefaultSettingsOutput */
    /**
     * Get the 'APN Name' field from `self`.
     */
    get_apn_name(): [ /* returnType */ boolean, /* value_apn_name */ string | null ]
    /**
     * Get the 'Authentication' field from `self`.
     */
    get_authentication(): [ /* returnType */ boolean, /* value_authentication */ WdsAuthentication | null ]
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the 'GPRS Minimum QoS' field from `self`.
     */
    get_gprs_minimum_qos(): [ /* returnType */ boolean, /* value_gprs_minimum_qos_precedence_class */ number | null, /* value_gprs_minimum_qos_delay_class */ number | null, /* value_gprs_minimum_qos_reliability_class */ number | null, /* value_gprs_minimum_qos_peak_throughput_class */ number | null, /* value_gprs_minimum_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'GPRS Requested QoS' field from `self`.
     */
    get_gprs_requested_qos(): [ /* returnType */ boolean, /* value_gprs_requested_qos_precedence_class */ number | null, /* value_gprs_requested_qos_delay_class */ number | null, /* value_gprs_requested_qos_reliability_class */ number | null, /* value_gprs_requested_qos_peak_throughput_class */ number | null, /* value_gprs_requested_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'IMCN Flag' field from `self`.
     */
    get_imcn_flag(): [ /* returnType */ boolean, /* value_imcn_flag */ boolean | null ]
    /**
     * Get the 'IPv4 Address Preference' field from `self`.
     */
    get_ipv4_address_preference(): [ /* returnType */ boolean, /* value_ipv4_address_preference */ number | null ]
    /**
     * Get the 'IPv6 Address Preference' field from `self`.
     */
    get_ipv6_address_preference(): [ /* returnType */ boolean, /* value_ipv6_address_preference_address */ number[] | null ]
    /**
     * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
     */
    get_ipv6_primary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_primary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
     */
    get_ipv6_secondary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_secondary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'LTE QoS Parameters' field from `self`.
     */
    get_lte_qos_parameters(): [ /* returnType */ boolean, /* value_lte_qos_parameters_qos_class_identifier */ WdsQosClassIdentifier | null, /* value_lte_qos_parameters_guaranteed_downlink_bitrate */ number | null, /* value_lte_qos_parameters_max_downlink_bitrate */ number | null, /* value_lte_qos_parameters_guaranteed_uplink_bitrate */ number | null, /* value_lte_qos_parameters_max_uplink_bitrate */ number | null ]
    /**
     * Get the 'Password' field from `self`.
     */
    get_password(): [ /* returnType */ boolean, /* value_password */ string | null ]
    /**
     * Get the 'PCSCF Address Using DHCP' field from `self`.
     */
    get_pcscf_address_using_dhcp(): [ /* returnType */ boolean, /* value_pcscf_address_using_dhcp */ boolean | null ]
    /**
     * Get the 'PCSCF Address Using PCO' field from `self`.
     */
    get_pcscf_address_using_pco(): [ /* returnType */ boolean, /* value_pcscf_address_using_pco */ boolean | null ]
    /**
     * Get the 'PDP Context Number' field from `self`.
     */
    get_pdp_context_number(): [ /* returnType */ boolean, /* value_pdp_context_number */ number | null ]
    /**
     * Get the 'PDP Context Primary ID' field from `self`.
     */
    get_pdp_context_primary_id(): [ /* returnType */ boolean, /* value_pdp_context_primary_id */ number | null ]
    /**
     * Get the 'PDP Context Secondary Flag' field from `self`.
     */
    get_pdp_context_secondary_flag(): [ /* returnType */ boolean, /* value_pdp_context_secondary_flag */ boolean | null ]
    /**
     * Get the 'PDP Data Compression Type' field from `self`.
     */
    get_pdp_data_compression_type(): [ /* returnType */ boolean, /* value_pdp_data_compression_type */ WdsPdpDataCompressionType | null ]
    /**
     * Get the 'PDP Header Compression Type' field from `self`.
     */
    get_pdp_header_compression_type(): [ /* returnType */ boolean, /* value_pdp_header_compression_type */ WdsPdpHeaderCompressionType | null ]
    /**
     * Get the 'PDP Type' field from `self`.
     */
    get_pdp_type(): [ /* returnType */ boolean, /* value_pdp_type */ WdsPdpType | null ]
    /**
     * Get the 'Primary IPv4 DNS Address' field from `self`.
     */
    get_primary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_primary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'Profile Name' field from `self`.
     */
    get_profile_name(): [ /* returnType */ boolean, /* value_profile_name */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Secondary IPv4 DNS Address' field from `self`.
     */
    get_secondary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_secondary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS' field from `self`.
     */
    get_umts_minimum_qos(): [ /* returnType */ boolean, /* value_umts_minimum_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_transfer_delay */ number | null, /* value_umts_minimum_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_minimum_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'UMTS Requested QoS' field from `self`.
     */
    get_umts_requested_qos(): [ /* returnType */ boolean, /* value_umts_requested_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_maximum_sdu_size */ number | null, /* value_umts_requested_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_transfer_delay */ number | null, /* value_umts_requested_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_requested_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'Username' field from `self`.
     */
    get_username(): [ /* returnType */ boolean, /* value_username */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetDefaultSettingsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetDormancyStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetDormancyStatusOutput */
    /**
     * Get the 'Dormancy Status' field from `self`.
     */
    get_dormancy_status(): [ /* returnType */ boolean, /* value_dormancy_status */ WdsDormancyStatus | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetDormancyStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetLteAttachParametersOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetLteAttachParametersOutput */
    /**
     * Get the 'APN' field from `self`.
     */
    get_apn(): [ /* returnType */ boolean, /* value_apn */ string | null ]
    /**
     * Get the 'IP Support Type' field from `self`.
     */
    get_ip_support_type(): [ /* returnType */ boolean, /* value_ip_support_type */ WdsIpSupportType | null ]
    /**
     * Get the 'OTA Attach Performed' field from `self`.
     */
    get_ota_attach_performed(): [ /* returnType */ boolean, /* value_ota_attach_performed */ boolean | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetLteAttachParametersOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetLteAttachPdnListOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetLteAttachPdnListOutput */
    /**
     * Get the 'Current List' field from `self`.
     */
    get_current_list(): [ /* returnType */ boolean, /* value_current_list */ number[] | null ]
    /**
     * Get the 'Pending List' field from `self`.
     */
    get_pending_list(): [ /* returnType */ boolean, /* value_pending_list */ number[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetLteAttachPdnListOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetMaxLteAttachPdnNumberOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetMaxLteAttachPdnNumberOutput */
    /**
     * Get the 'Info' field from `self`.
     */
    get_info(): [ /* returnType */ boolean, /* value_info */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetMaxLteAttachPdnNumberOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetPacketServiceStatusOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetPacketServiceStatusOutput */
    /**
     * Get the 'Connection Status' field from `self`.
     */
    get_connection_status(): [ /* returnType */ boolean, /* value_connection_status */ WdsConnectionStatus | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetPacketServiceStatusOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetPacketStatisticsInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetPacketStatisticsInput */
    /**
     * Get the 'Mask' field from `self`.
     */
    get_mask(): [ /* returnType */ boolean, /* value_mask */ WdsPacketStatisticsMaskFlag | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetPacketStatisticsInput
    /**
     * Set the 'Mask' field in the message.
     * @param value_mask a #QmiWdsPacketStatisticsMaskFlag.
     */
    set_mask(value_mask: WdsPacketStatisticsMaskFlag): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsGetPacketStatisticsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsGetPacketStatisticsInput
}
class MessageWdsGetPacketStatisticsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetPacketStatisticsOutput */
    /**
     * Get the 'Last Call Rx Bytes Ok' field from `self`.
     */
    get_last_call_rx_bytes_ok(): [ /* returnType */ boolean, /* value_last_call_rx_bytes_ok */ number | null ]
    /**
     * Get the 'Last Call Tx Bytes Ok' field from `self`.
     */
    get_last_call_tx_bytes_ok(): [ /* returnType */ boolean, /* value_last_call_tx_bytes_ok */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Rx Bytes Ok' field from `self`.
     */
    get_rx_bytes_ok(): [ /* returnType */ boolean, /* value_rx_bytes_ok */ number | null ]
    /**
     * Get the 'Rx Overflows' field from `self`.
     */
    get_rx_overflows(): [ /* returnType */ boolean, /* value_rx_overflows */ number | null ]
    /**
     * Get the 'Rx Packets Dropped' field from `self`.
     */
    get_rx_packets_dropped(): [ /* returnType */ boolean, /* value_rx_packets_dropped */ number | null ]
    /**
     * Get the 'Rx Packets Error' field from `self`.
     */
    get_rx_packets_error(): [ /* returnType */ boolean, /* value_rx_packets_error */ number | null ]
    /**
     * Get the 'Rx Packets Ok' field from `self`.
     */
    get_rx_packets_ok(): [ /* returnType */ boolean, /* value_rx_packets_ok */ number | null ]
    /**
     * Get the 'Tx Bytes Ok' field from `self`.
     */
    get_tx_bytes_ok(): [ /* returnType */ boolean, /* value_tx_bytes_ok */ number | null ]
    /**
     * Get the 'Tx Overflows' field from `self`.
     */
    get_tx_overflows(): [ /* returnType */ boolean, /* value_tx_overflows */ number | null ]
    /**
     * Get the 'Tx Packets Dropped' field from `self`.
     */
    get_tx_packets_dropped(): [ /* returnType */ boolean, /* value_tx_packets_dropped */ number | null ]
    /**
     * Get the 'Tx Packets Error' field from `self`.
     */
    get_tx_packets_error(): [ /* returnType */ boolean, /* value_tx_packets_error */ number | null ]
    /**
     * Get the 'Tx Packets Ok' field from `self`.
     */
    get_tx_packets_ok(): [ /* returnType */ boolean, /* value_tx_packets_ok */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetPacketStatisticsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetPdnThrottleInfoInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetPdnThrottleInfoInput */
    /**
     * Get the 'Network Type' field from `self`.
     */
    get_network_type(): [ /* returnType */ boolean, /* value_network_type */ WdsDataSystemNetworkType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetPdnThrottleInfoInput
    /**
     * Set the 'Network Type' field in the message.
     * @param value_network_type a #QmiWdsDataSystemNetworkType.
     */
    set_network_type(value_network_type: WdsDataSystemNetworkType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsGetPdnThrottleInfoInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsGetPdnThrottleInfoInput
}
class MessageWdsGetPdnThrottleInfoOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetPdnThrottleInfoOutput */
    /**
     * Get the 'Info' field from `self`.
     * 
     * Version of qmi_message_wds_get_pdn_throttle_info_output_get_info() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_info(): [ /* returnType */ boolean, /* value_info_ptr */ MessageWdsGetPdnThrottleInfoOutputInfoElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetPdnThrottleInfoOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetPdnThrottleInfoOutputInfoElement {
    /* Fields of Qmi-1.0.Qmi.MessageWdsGetPdnThrottleInfoOutputInfoElement */
    /**
     * a #gboolean.
     */
    ipv4_throttled: boolean
    /**
     * a #gboolean.
     */
    ipv6_throttled: boolean
    /**
     * a #guint32.
     */
    ipv4_throttle_time_left_ms: number
    /**
     * a #guint32.
     */
    ipv6_throttle_time_left_ms: number
    /**
     * a string.
     */
    apn: string
    static name: string
}
class MessageWdsGetProfileListInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetProfileListInput */
    /**
     * Get the 'Profile Type' field from `self`.
     */
    get_profile_type(): [ /* returnType */ boolean, /* value_profile_type */ WdsProfileType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetProfileListInput
    /**
     * Set the 'Profile Type' field in the message.
     * @param value_profile_type a #QmiWdsProfileType.
     */
    set_profile_type(value_profile_type: WdsProfileType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsGetProfileListInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsGetProfileListInput
}
class MessageWdsGetProfileListOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetProfileListOutput */
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the 'Profile List' field from `self`.
     * 
     * Version of qmi_message_wds_get_profile_list_output_get_profile_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_profile_list(): [ /* returnType */ boolean, /* value_profile_list_ptr */ MessageWdsGetProfileListOutputProfileListProfile[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetProfileListOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetProfileListOutputProfileListProfile {
    /* Fields of Qmi-1.0.Qmi.MessageWdsGetProfileListOutputProfileListProfile */
    /**
     * a #QmiWdsProfileType.
     */
    profile_type: WdsProfileType
    /**
     * a #guint8.
     */
    profile_index: number
    /**
     * a string.
     */
    profile_name: string
    static name: string
}
class MessageWdsGetProfileSettingsInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetProfileSettingsInput */
    /**
     * Get the 'Profile ID' field from `self`.
     */
    get_profile_id(): [ /* returnType */ boolean, /* value_profile_id_profile_type */ WdsProfileType | null, /* value_profile_id_profile_index */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetProfileSettingsInput
    /**
     * Set the 'Profile ID' field in the message.
     * @param value_profile_id_profile_type a #QmiWdsProfileType.
     * @param value_profile_id_profile_index a #guint8.
     */
    set_profile_id(value_profile_id_profile_type: WdsProfileType, value_profile_id_profile_index: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsGetProfileSettingsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsGetProfileSettingsInput
}
class MessageWdsGetProfileSettingsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetProfileSettingsOutput */
    /**
     * Get the 'APN Disabled Flag' field from `self`.
     */
    get_apn_disabled_flag(): [ /* returnType */ boolean, /* value_apn_disabled_flag */ boolean | null ]
    /**
     * Get the 'APN Name' field from `self`.
     */
    get_apn_name(): [ /* returnType */ boolean, /* value_apn_name */ string | null ]
    /**
     * Get the 'APN Type Mask' field from `self`.
     */
    get_apn_type_mask(): [ /* returnType */ boolean, /* value_apn_type_mask */ WdsApnTypeMask | null ]
    /**
     * Get the 'Authentication' field from `self`.
     */
    get_authentication(): [ /* returnType */ boolean, /* value_authentication */ WdsAuthentication | null ]
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the 'GPRS Minimum QoS' field from `self`.
     */
    get_gprs_minimum_qos(): [ /* returnType */ boolean, /* value_gprs_minimum_qos_precedence_class */ number | null, /* value_gprs_minimum_qos_delay_class */ number | null, /* value_gprs_minimum_qos_reliability_class */ number | null, /* value_gprs_minimum_qos_peak_throughput_class */ number | null, /* value_gprs_minimum_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'GPRS Requested QoS' field from `self`.
     */
    get_gprs_requested_qos(): [ /* returnType */ boolean, /* value_gprs_requested_qos_precedence_class */ number | null, /* value_gprs_requested_qos_delay_class */ number | null, /* value_gprs_requested_qos_reliability_class */ number | null, /* value_gprs_requested_qos_peak_throughput_class */ number | null, /* value_gprs_requested_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'IMCN Flag' field from `self`.
     */
    get_imcn_flag(): [ /* returnType */ boolean, /* value_imcn_flag */ boolean | null ]
    /**
     * Get the 'IPv4 Address Preference' field from `self`.
     */
    get_ipv4_address_preference(): [ /* returnType */ boolean, /* value_ipv4_address_preference */ number | null ]
    /**
     * Get the 'IPv6 Address Preference' field from `self`.
     */
    get_ipv6_address_preference(): [ /* returnType */ boolean, /* value_ipv6_address_preference_address */ number[] | null ]
    /**
     * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
     */
    get_ipv6_primary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_primary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
     */
    get_ipv6_secondary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_secondary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'LTE QoS Parameters' field from `self`.
     */
    get_lte_qos_parameters(): [ /* returnType */ boolean, /* value_lte_qos_parameters_qos_class_identifier */ WdsQosClassIdentifier | null, /* value_lte_qos_parameters_guaranteed_downlink_bitrate */ number | null, /* value_lte_qos_parameters_max_downlink_bitrate */ number | null, /* value_lte_qos_parameters_guaranteed_uplink_bitrate */ number | null, /* value_lte_qos_parameters_max_uplink_bitrate */ number | null ]
    /**
     * Get the 'Password' field from `self`.
     */
    get_password(): [ /* returnType */ boolean, /* value_password */ string | null ]
    /**
     * Get the 'PCSCF Address Using DHCP' field from `self`.
     */
    get_pcscf_address_using_dhcp(): [ /* returnType */ boolean, /* value_pcscf_address_using_dhcp */ boolean | null ]
    /**
     * Get the 'PCSCF Address Using PCO' field from `self`.
     */
    get_pcscf_address_using_pco(): [ /* returnType */ boolean, /* value_pcscf_address_using_pco */ boolean | null ]
    /**
     * Get the 'PDP Context Number' field from `self`.
     */
    get_pdp_context_number(): [ /* returnType */ boolean, /* value_pdp_context_number */ number | null ]
    /**
     * Get the 'PDP Context Primary ID' field from `self`.
     */
    get_pdp_context_primary_id(): [ /* returnType */ boolean, /* value_pdp_context_primary_id */ number | null ]
    /**
     * Get the 'PDP Context Secondary Flag' field from `self`.
     */
    get_pdp_context_secondary_flag(): [ /* returnType */ boolean, /* value_pdp_context_secondary_flag */ boolean | null ]
    /**
     * Get the 'PDP Data Compression Type' field from `self`.
     */
    get_pdp_data_compression_type(): [ /* returnType */ boolean, /* value_pdp_data_compression_type */ WdsPdpDataCompressionType | null ]
    /**
     * Get the 'PDP Header Compression Type' field from `self`.
     */
    get_pdp_header_compression_type(): [ /* returnType */ boolean, /* value_pdp_header_compression_type */ WdsPdpHeaderCompressionType | null ]
    /**
     * Get the 'PDP Type' field from `self`.
     */
    get_pdp_type(): [ /* returnType */ boolean, /* value_pdp_type */ WdsPdpType | null ]
    /**
     * Get the 'Primary IPv4 DNS Address' field from `self`.
     */
    get_primary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_primary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'Profile Name' field from `self`.
     */
    get_profile_name(): [ /* returnType */ boolean, /* value_profile_name */ string | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Roaming Disallowed Flag' field from `self`.
     */
    get_roaming_disallowed_flag(): [ /* returnType */ boolean, /* value_roaming_disallowed_flag */ boolean | null ]
    /**
     * Get the 'Secondary IPv4 DNS Address' field from `self`.
     */
    get_secondary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_secondary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS' field from `self`.
     */
    get_umts_minimum_qos(): [ /* returnType */ boolean, /* value_umts_minimum_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_transfer_delay */ number | null, /* value_umts_minimum_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_minimum_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'UMTS Requested QoS' field from `self`.
     */
    get_umts_requested_qos(): [ /* returnType */ boolean, /* value_umts_requested_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_maximum_sdu_size */ number | null, /* value_umts_requested_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_transfer_delay */ number | null, /* value_umts_requested_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_requested_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'Username' field from `self`.
     */
    get_username(): [ /* returnType */ boolean, /* value_username */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetProfileSettingsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGetSupportedMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGetSupportedMessagesOutput */
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGetSupportedMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGoActiveOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGoActiveOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGoActiveOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsGoDormantOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsGoDormantOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsGoDormantOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsModifyProfileInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsModifyProfileInput */
    /**
     * Get the 'APN Disabled Flag' field from `self`.
     */
    get_apn_disabled_flag(): [ /* returnType */ boolean, /* value_apn_disabled_flag */ boolean | null ]
    /**
     * Get the 'APN Name' field from `self`.
     */
    get_apn_name(): [ /* returnType */ boolean, /* value_apn_name */ string | null ]
    /**
     * Get the 'APN Type Mask' field from `self`.
     */
    get_apn_type_mask(): [ /* returnType */ boolean, /* value_apn_type_mask */ WdsApnTypeMask | null ]
    /**
     * Get the 'Authentication' field from `self`.
     */
    get_authentication(): [ /* returnType */ boolean, /* value_authentication */ WdsAuthentication | null ]
    /**
     * Get the 'GPRS Minimum QoS' field from `self`.
     */
    get_gprs_minimum_qos(): [ /* returnType */ boolean, /* value_gprs_minimum_qos_precedence_class */ number | null, /* value_gprs_minimum_qos_delay_class */ number | null, /* value_gprs_minimum_qos_reliability_class */ number | null, /* value_gprs_minimum_qos_peak_throughput_class */ number | null, /* value_gprs_minimum_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'GPRS Requested QoS' field from `self`.
     */
    get_gprs_requested_qos(): [ /* returnType */ boolean, /* value_gprs_requested_qos_precedence_class */ number | null, /* value_gprs_requested_qos_delay_class */ number | null, /* value_gprs_requested_qos_reliability_class */ number | null, /* value_gprs_requested_qos_peak_throughput_class */ number | null, /* value_gprs_requested_qos_mean_throughput_class */ number | null ]
    /**
     * Get the 'IMCN Flag' field from `self`.
     */
    get_imcn_flag(): [ /* returnType */ boolean, /* value_imcn_flag */ boolean | null ]
    /**
     * Get the 'IPv4 Address Preference' field from `self`.
     */
    get_ipv4_address_preference(): [ /* returnType */ boolean, /* value_ipv4_address_preference */ number | null ]
    /**
     * Get the 'IPv6 Address Preference' field from `self`.
     */
    get_ipv6_address_preference(): [ /* returnType */ boolean, /* value_ipv6_address_preference_address */ number[] | null ]
    /**
     * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
     */
    get_ipv6_primary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_primary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
     */
    get_ipv6_secondary_dns_address_preference(): [ /* returnType */ boolean, /* value_ipv6_secondary_dns_address_preference */ number[] | null ]
    /**
     * Get the 'LTE QoS Parameters' field from `self`.
     */
    get_lte_qos_parameters(): [ /* returnType */ boolean, /* value_lte_qos_parameters_qos_class_identifier */ WdsQosClassIdentifier | null, /* value_lte_qos_parameters_guaranteed_downlink_bitrate */ number | null, /* value_lte_qos_parameters_max_downlink_bitrate */ number | null, /* value_lte_qos_parameters_guaranteed_uplink_bitrate */ number | null, /* value_lte_qos_parameters_max_uplink_bitrate */ number | null ]
    /**
     * Get the 'Password' field from `self`.
     */
    get_password(): [ /* returnType */ boolean, /* value_password */ string | null ]
    /**
     * Get the 'PCSCF Address Using DHCP' field from `self`.
     */
    get_pcscf_address_using_dhcp(): [ /* returnType */ boolean, /* value_pcscf_address_using_dhcp */ boolean | null ]
    /**
     * Get the 'PCSCF Address Using PCO' field from `self`.
     */
    get_pcscf_address_using_pco(): [ /* returnType */ boolean, /* value_pcscf_address_using_pco */ boolean | null ]
    /**
     * Get the 'PDP Context Number' field from `self`.
     */
    get_pdp_context_number(): [ /* returnType */ boolean, /* value_pdp_context_number */ number | null ]
    /**
     * Get the 'PDP Context Primary ID' field from `self`.
     */
    get_pdp_context_primary_id(): [ /* returnType */ boolean, /* value_pdp_context_primary_id */ number | null ]
    /**
     * Get the 'PDP Context Secondary Flag' field from `self`.
     */
    get_pdp_context_secondary_flag(): [ /* returnType */ boolean, /* value_pdp_context_secondary_flag */ boolean | null ]
    /**
     * Get the 'PDP Data Compression Type' field from `self`.
     */
    get_pdp_data_compression_type(): [ /* returnType */ boolean, /* value_pdp_data_compression_type */ WdsPdpDataCompressionType | null ]
    /**
     * Get the 'PDP Header Compression Type' field from `self`.
     */
    get_pdp_header_compression_type(): [ /* returnType */ boolean, /* value_pdp_header_compression_type */ WdsPdpHeaderCompressionType | null ]
    /**
     * Get the 'PDP Type' field from `self`.
     */
    get_pdp_type(): [ /* returnType */ boolean, /* value_pdp_type */ WdsPdpType | null ]
    /**
     * Get the 'Primary IPv4 DNS Address' field from `self`.
     */
    get_primary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_primary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'Profile Identifier' field from `self`.
     */
    get_profile_identifier(): [ /* returnType */ boolean, /* value_profile_identifier_profile_type */ WdsProfileType | null, /* value_profile_identifier_profile_index */ number | null ]
    /**
     * Get the 'Profile Name' field from `self`.
     */
    get_profile_name(): [ /* returnType */ boolean, /* value_profile_name */ string | null ]
    /**
     * Get the 'Roaming Disallowed Flag' field from `self`.
     */
    get_roaming_disallowed_flag(): [ /* returnType */ boolean, /* value_roaming_disallowed_flag */ boolean | null ]
    /**
     * Get the 'Secondary IPv4 DNS Address' field from `self`.
     */
    get_secondary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_secondary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS' field from `self`.
     */
    get_umts_minimum_qos(): [ /* returnType */ boolean, /* value_umts_minimum_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_transfer_delay */ number | null, /* value_umts_minimum_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_minimum_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'UMTS Requested QoS' field from `self`.
     */
    get_umts_requested_qos(): [ /* returnType */ boolean, /* value_umts_requested_qos_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_maximum_sdu_size */ number | null, /* value_umts_requested_qos_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_transfer_delay */ number | null, /* value_umts_requested_qos_traffic_handling_priority */ number | null ]
    /**
     * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
     */
    get_umts_requested_qos_with_signaling_indication_flag(): [ /* returnType */ boolean, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_class */ WdsTrafficClass | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order */ WdsDeliveryOrder | null, /* value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio */ WdsSduErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio */ WdsSduResidualBitErrorRatio | null, /* value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu */ WdsSduErroneousDelivery | null, /* value_umts_requested_qos_with_signaling_indication_flag_transfer_delay */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority */ number | null, /* value_umts_requested_qos_with_signaling_indication_flag_signaling_indication */ number | null ]
    /**
     * Get the 'Username' field from `self`.
     */
    get_username(): [ /* returnType */ boolean, /* value_username */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsModifyProfileInput
    /**
     * Set the 'APN Disabled Flag' field in the message.
     * @param value_apn_disabled_flag a #gboolean.
     */
    set_apn_disabled_flag(value_apn_disabled_flag: boolean): boolean
    /**
     * Set the 'APN Name' field in the message.
     * @param value_apn_name a constant string.
     */
    set_apn_name(value_apn_name: string): boolean
    /**
     * Set the 'APN Type Mask' field in the message.
     * @param value_apn_type_mask a #QmiWdsApnTypeMask.
     */
    set_apn_type_mask(value_apn_type_mask: WdsApnTypeMask): boolean
    /**
     * Set the 'Authentication' field in the message.
     * @param value_authentication a #QmiWdsAuthentication.
     */
    set_authentication(value_authentication: WdsAuthentication): boolean
    /**
     * Set the 'GPRS Minimum QoS' field in the message.
     * @param value_gprs_minimum_qos_precedence_class a #guint32.
     * @param value_gprs_minimum_qos_delay_class a #guint32.
     * @param value_gprs_minimum_qos_reliability_class a #guint32.
     * @param value_gprs_minimum_qos_peak_throughput_class a #guint32.
     * @param value_gprs_minimum_qos_mean_throughput_class a #guint32.
     */
    set_gprs_minimum_qos(value_gprs_minimum_qos_precedence_class: number, value_gprs_minimum_qos_delay_class: number, value_gprs_minimum_qos_reliability_class: number, value_gprs_minimum_qos_peak_throughput_class: number, value_gprs_minimum_qos_mean_throughput_class: number): boolean
    /**
     * Set the 'GPRS Requested QoS' field in the message.
     * @param value_gprs_requested_qos_precedence_class a #guint32.
     * @param value_gprs_requested_qos_delay_class a #guint32.
     * @param value_gprs_requested_qos_reliability_class a #guint32.
     * @param value_gprs_requested_qos_peak_throughput_class a #guint32.
     * @param value_gprs_requested_qos_mean_throughput_class a #guint32.
     */
    set_gprs_requested_qos(value_gprs_requested_qos_precedence_class: number, value_gprs_requested_qos_delay_class: number, value_gprs_requested_qos_reliability_class: number, value_gprs_requested_qos_peak_throughput_class: number, value_gprs_requested_qos_mean_throughput_class: number): boolean
    /**
     * Set the 'IMCN Flag' field in the message.
     * @param value_imcn_flag a #gboolean.
     */
    set_imcn_flag(value_imcn_flag: boolean): boolean
    /**
     * Set the 'IPv4 Address Preference' field in the message.
     * @param value_ipv4_address_preference a #guint32.
     */
    set_ipv4_address_preference(value_ipv4_address_preference: number): boolean
    /**
     * Set the 'IPv6 Address Preference' field in the message.
     * @param value_ipv6_address_preference_address a #GArray of #guint16 elements. A new reference to `value_ipv6`_address_preference_address will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ipv6_address_preference(value_ipv6_address_preference_address: number[]): boolean
    /**
     * Set the 'IPv6 Primary DNS Address Preference' field in the message.
     * @param value_ipv6_primary_dns_address_preference a #GArray of #guint16 elements. A new reference to `value_ipv6`_primary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ipv6_primary_dns_address_preference(value_ipv6_primary_dns_address_preference: number[]): boolean
    /**
     * Set the 'IPv6 Secondary DNS Address Preference' field in the message.
     * @param value_ipv6_secondary_dns_address_preference a #GArray of #guint16 elements. A new reference to `value_ipv6`_secondary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_ipv6_secondary_dns_address_preference(value_ipv6_secondary_dns_address_preference: number[]): boolean
    /**
     * Set the 'LTE QoS Parameters' field in the message.
     * @param value_lte_qos_parameters_qos_class_identifier a #QmiWdsQosClassIdentifier.
     * @param value_lte_qos_parameters_guaranteed_downlink_bitrate a #guint32.
     * @param value_lte_qos_parameters_max_downlink_bitrate a #guint32.
     * @param value_lte_qos_parameters_guaranteed_uplink_bitrate a #guint32.
     * @param value_lte_qos_parameters_max_uplink_bitrate a #guint32.
     */
    set_lte_qos_parameters(value_lte_qos_parameters_qos_class_identifier: WdsQosClassIdentifier, value_lte_qos_parameters_guaranteed_downlink_bitrate: number, value_lte_qos_parameters_max_downlink_bitrate: number, value_lte_qos_parameters_guaranteed_uplink_bitrate: number, value_lte_qos_parameters_max_uplink_bitrate: number): boolean
    /**
     * Set the 'Password' field in the message.
     * @param value_password a constant string.
     */
    set_password(value_password: string): boolean
    /**
     * Set the 'PCSCF Address Using DHCP' field in the message.
     * @param value_pcscf_address_using_dhcp a #gboolean.
     */
    set_pcscf_address_using_dhcp(value_pcscf_address_using_dhcp: boolean): boolean
    /**
     * Set the 'PCSCF Address Using PCO' field in the message.
     * @param value_pcscf_address_using_pco a #gboolean.
     */
    set_pcscf_address_using_pco(value_pcscf_address_using_pco: boolean): boolean
    /**
     * Set the 'PDP Context Number' field in the message.
     * @param value_pdp_context_number a #guint8.
     */
    set_pdp_context_number(value_pdp_context_number: number): boolean
    /**
     * Set the 'PDP Context Primary ID' field in the message.
     * @param value_pdp_context_primary_id a #guint8.
     */
    set_pdp_context_primary_id(value_pdp_context_primary_id: number): boolean
    /**
     * Set the 'PDP Context Secondary Flag' field in the message.
     * @param value_pdp_context_secondary_flag a #gboolean.
     */
    set_pdp_context_secondary_flag(value_pdp_context_secondary_flag: boolean): boolean
    /**
     * Set the 'PDP Data Compression Type' field in the message.
     * @param value_pdp_data_compression_type a #QmiWdsPdpDataCompressionType.
     */
    set_pdp_data_compression_type(value_pdp_data_compression_type: WdsPdpDataCompressionType): boolean
    /**
     * Set the 'PDP Header Compression Type' field in the message.
     * @param value_pdp_header_compression_type a #QmiWdsPdpHeaderCompressionType.
     */
    set_pdp_header_compression_type(value_pdp_header_compression_type: WdsPdpHeaderCompressionType): boolean
    /**
     * Set the 'PDP Type' field in the message.
     * @param value_pdp_type a #QmiWdsPdpType.
     */
    set_pdp_type(value_pdp_type: WdsPdpType): boolean
    /**
     * Set the 'Primary IPv4 DNS Address' field in the message.
     * @param value_primary_ipv4_dns_address a #guint32.
     */
    set_primary_ipv4_dns_address(value_primary_ipv4_dns_address: number): boolean
    /**
     * Set the 'Profile Identifier' field in the message.
     * @param value_profile_identifier_profile_type a #QmiWdsProfileType.
     * @param value_profile_identifier_profile_index a #guint8.
     */
    set_profile_identifier(value_profile_identifier_profile_type: WdsProfileType, value_profile_identifier_profile_index: number): boolean
    /**
     * Set the 'Profile Name' field in the message.
     * @param value_profile_name a constant string.
     */
    set_profile_name(value_profile_name: string): boolean
    /**
     * Set the 'Roaming Disallowed Flag' field in the message.
     * @param value_roaming_disallowed_flag a #gboolean.
     */
    set_roaming_disallowed_flag(value_roaming_disallowed_flag: boolean): boolean
    /**
     * Set the 'Secondary IPv4 DNS Address' field in the message.
     * @param value_secondary_ipv4_dns_address a #guint32.
     */
    set_secondary_ipv4_dns_address(value_secondary_ipv4_dns_address: number): boolean
    /**
     * Set the 'UMTS Minimum QoS' field in the message.
     * @param value_umts_minimum_qos_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_minimum_qos_max_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_max_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_minimum_qos_maximum_sdu_size a #guint32.
     * @param value_umts_minimum_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_minimum_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_minimum_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_minimum_qos_transfer_delay a #guint32.
     * @param value_umts_minimum_qos_traffic_handling_priority a #guint32.
     */
    set_umts_minimum_qos(value_umts_minimum_qos_traffic_class: WdsTrafficClass, value_umts_minimum_qos_max_uplink_bitrate: number, value_umts_minimum_qos_max_downlink_bitrate: number, value_umts_minimum_qos_guaranteed_uplink_bitrate: number, value_umts_minimum_qos_guaranteed_downlink_bitrate: number, value_umts_minimum_qos_qos_delivery_order: WdsDeliveryOrder, value_umts_minimum_qos_maximum_sdu_size: number, value_umts_minimum_qos_sdu_error_ratio: WdsSduErrorRatio, value_umts_minimum_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_minimum_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_minimum_qos_transfer_delay: number, value_umts_minimum_qos_traffic_handling_priority: number): boolean
    /**
     * Set the 'UMTS Minimum QoS With Signaling Indication Flag' field in the message.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
     * @param value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication a #gint8.
     */
    set_umts_minimum_qos_with_signaling_indication_flag(value_umts_minimum_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass, value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number, value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder, value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size: number, value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio, value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay: number, value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority: number, value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication: number): boolean
    /**
     * Set the 'UMTS Requested QoS' field in the message.
     * @param value_umts_requested_qos_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_requested_qos_max_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_max_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_requested_qos_maximum_sdu_size a #guint32.
     * @param value_umts_requested_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_requested_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_requested_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_requested_qos_transfer_delay a #guint32.
     * @param value_umts_requested_qos_traffic_handling_priority a #guint32.
     */
    set_umts_requested_qos(value_umts_requested_qos_traffic_class: WdsTrafficClass, value_umts_requested_qos_max_uplink_bitrate: number, value_umts_requested_qos_max_downlink_bitrate: number, value_umts_requested_qos_guaranteed_uplink_bitrate: number, value_umts_requested_qos_guaranteed_downlink_bitrate: number, value_umts_requested_qos_qos_delivery_order: WdsDeliveryOrder, value_umts_requested_qos_maximum_sdu_size: number, value_umts_requested_qos_sdu_error_ratio: WdsSduErrorRatio, value_umts_requested_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_requested_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_requested_qos_transfer_delay: number, value_umts_requested_qos_traffic_handling_priority: number): boolean
    /**
     * Set the 'UMTS Requested QoS With Signaling Indication Flag' field in the message.
     * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
     * @param value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
     * @param value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
     * @param value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
     * @param value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
     * @param value_umts_requested_qos_with_signaling_indication_flag_transfer_delay a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
     * @param value_umts_requested_qos_with_signaling_indication_flag_signaling_indication a #gint8.
     */
    set_umts_requested_qos_with_signaling_indication_flag(value_umts_requested_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass, value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number, value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder, value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size: number, value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio, value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio, value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery, value_umts_requested_qos_with_signaling_indication_flag_transfer_delay: number, value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority: number, value_umts_requested_qos_with_signaling_indication_flag_signaling_indication: number): boolean
    /**
     * Set the 'Username' field in the message.
     * @param value_username a constant string.
     */
    set_username(value_username: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsModifyProfileInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsModifyProfileInput
}
class MessageWdsModifyProfileOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsModifyProfileOutput */
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsModifyProfileOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsSetAutoconnectSettingsInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetAutoconnectSettingsInput */
    /**
     * Get the 'Roaming' field from `self`.
     */
    get_roaming(): [ /* returnType */ boolean, /* value_roaming */ WdsAutoconnectSettingRoaming | null ]
    /**
     * Get the 'Status' field from `self`.
     */
    get_status(): [ /* returnType */ boolean, /* value_status */ WdsAutoconnectSetting | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetAutoconnectSettingsInput
    /**
     * Set the 'Roaming' field in the message.
     * @param value_roaming a #QmiWdsAutoconnectSettingRoaming.
     */
    set_roaming(value_roaming: WdsAutoconnectSettingRoaming): boolean
    /**
     * Set the 'Status' field in the message.
     * @param value_status a #QmiWdsAutoconnectSetting.
     */
    set_status(value_status: WdsAutoconnectSetting): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsSetAutoconnectSettingsInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsSetAutoconnectSettingsInput
}
class MessageWdsSetAutoconnectSettingsOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetAutoconnectSettingsOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetAutoconnectSettingsOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsSetDefaultProfileNumberInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetDefaultProfileNumberInput */
    /**
     * Get the 'Profile Identifier' field from `self`.
     */
    get_profile_identifier(): [ /* returnType */ boolean, /* value_profile_identifier_type */ WdsProfileType | null, /* value_profile_identifier_family */ WdsProfileFamily | null, /* value_profile_identifier_index */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetDefaultProfileNumberInput
    /**
     * Set the 'Profile Identifier' field in the message.
     * @param value_profile_identifier_type a #QmiWdsProfileType.
     * @param value_profile_identifier_family a #QmiWdsProfileFamily.
     * @param value_profile_identifier_index a #guint8.
     */
    set_profile_identifier(value_profile_identifier_type: WdsProfileType, value_profile_identifier_family: WdsProfileFamily, value_profile_identifier_index: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsSetDefaultProfileNumberInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsSetDefaultProfileNumberInput
}
class MessageWdsSetDefaultProfileNumberOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetDefaultProfileNumberOutput */
    /**
     * Get the 'Extended Error Code' field from `self`.
     */
    get_extended_error_code(): [ /* returnType */ boolean, /* value_extended_error_code */ WdsDsProfileError | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetDefaultProfileNumberOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsSetEventReportInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetEventReportInput */
    /**
     * Get the 'Channel Rate' field from `self`.
     */
    get_channel_rate(): [ /* returnType */ boolean, /* value_channel_rate */ boolean | null ]
    /**
     * Get the 'Current Data Bearer Technology' field from `self`.
     */
    get_current_data_bearer_technology(): [ /* returnType */ boolean, /* value_current_data_bearer_technology */ boolean | null ]
    /**
     * Get the 'Data Bearer Technology' field from `self`.
     */
    get_data_bearer_technology(): [ /* returnType */ boolean, /* value_data_bearer_technology */ boolean | null ]
    /**
     * Get the 'Data Call Status' field from `self`.
     */
    get_data_call_status(): [ /* returnType */ boolean, /* value_data_call_status */ boolean | null ]
    /**
     * Get the 'Data Systems' field from `self`.
     */
    get_data_systems(): [ /* returnType */ boolean, /* value_data_systems */ boolean | null ]
    /**
     * Get the 'Dormancy Status' field from `self`.
     */
    get_dormancy_status(): [ /* returnType */ boolean, /* value_dormancy_status */ boolean | null ]
    /**
     * Get the 'EVDO PM Change' field from `self`.
     */
    get_evdo_pm_change(): [ /* returnType */ boolean, /* value_evdo_pm_change */ boolean | null ]
    /**
     * Get the 'Extended Data Bearer Technology' field from `self`.
     */
    get_extended_data_bearer_technology(): [ /* returnType */ boolean, /* value_extended_data_bearer_technology */ boolean | null ]
    /**
     * Get the 'Limited Data System Status' field from `self`.
     */
    get_limited_data_system_status(): [ /* returnType */ boolean, /* value_limited_data_system_status */ boolean | null ]
    /**
     * Get the 'MIP Status' field from `self`.
     */
    get_mip_status(): [ /* returnType */ boolean, /* value_mip_status */ number | null ]
    /**
     * Get the 'PDN Filter Removals' field from `self`.
     */
    get_pdn_filter_removals(): [ /* returnType */ boolean, /* value_pdn_filter_removals */ boolean | null ]
    /**
     * Get the 'Preferred Data System' field from `self`.
     */
    get_preferred_data_system(): [ /* returnType */ boolean, /* value_preferred_data_system */ boolean | null ]
    /**
     * Get the 'Transfer Statistics' field from `self`.
     */
    get_transfer_statistics(): [ /* returnType */ boolean, /* value_transfer_statistics_interval_seconds */ number | null, /* value_transfer_statistics_indicators */ WdsSetEventReportTransferStatistics | null ]
    /**
     * Get the 'Uplink Flow Control' field from `self`.
     */
    get_uplink_flow_control(): [ /* returnType */ boolean, /* value_uplink_flow_control */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetEventReportInput
    /**
     * Set the 'Channel Rate' field in the message.
     * @param value_channel_rate a #gboolean.
     */
    set_channel_rate(value_channel_rate: boolean): boolean
    /**
     * Set the 'Current Data Bearer Technology' field in the message.
     * @param value_current_data_bearer_technology a #gboolean.
     */
    set_current_data_bearer_technology(value_current_data_bearer_technology: boolean): boolean
    /**
     * Set the 'Data Bearer Technology' field in the message.
     * @param value_data_bearer_technology a #gboolean.
     */
    set_data_bearer_technology(value_data_bearer_technology: boolean): boolean
    /**
     * Set the 'Data Call Status' field in the message.
     * @param value_data_call_status a #gboolean.
     */
    set_data_call_status(value_data_call_status: boolean): boolean
    /**
     * Set the 'Data Systems' field in the message.
     * @param value_data_systems a #gboolean.
     */
    set_data_systems(value_data_systems: boolean): boolean
    /**
     * Set the 'Dormancy Status' field in the message.
     * @param value_dormancy_status a #gboolean.
     */
    set_dormancy_status(value_dormancy_status: boolean): boolean
    /**
     * Set the 'EVDO PM Change' field in the message.
     * @param value_evdo_pm_change a #gboolean.
     */
    set_evdo_pm_change(value_evdo_pm_change: boolean): boolean
    /**
     * Set the 'Extended Data Bearer Technology' field in the message.
     * @param value_extended_data_bearer_technology a #gboolean.
     */
    set_extended_data_bearer_technology(value_extended_data_bearer_technology: boolean): boolean
    /**
     * Set the 'Limited Data System Status' field in the message.
     * @param value_limited_data_system_status a #gboolean.
     */
    set_limited_data_system_status(value_limited_data_system_status: boolean): boolean
    /**
     * Set the 'MIP Status' field in the message.
     * @param value_mip_status a #guint8.
     */
    set_mip_status(value_mip_status: number): boolean
    /**
     * Set the 'PDN Filter Removals' field in the message.
     * @param value_pdn_filter_removals a #gboolean.
     */
    set_pdn_filter_removals(value_pdn_filter_removals: boolean): boolean
    /**
     * Set the 'Preferred Data System' field in the message.
     * @param value_preferred_data_system a #gboolean.
     */
    set_preferred_data_system(value_preferred_data_system: boolean): boolean
    /**
     * Set the 'Transfer Statistics' field in the message.
     * @param value_transfer_statistics_interval_seconds a #guint8.
     * @param value_transfer_statistics_indicators a #QmiWdsSetEventReportTransferStatistics.
     */
    set_transfer_statistics(value_transfer_statistics_interval_seconds: number, value_transfer_statistics_indicators: WdsSetEventReportTransferStatistics): boolean
    /**
     * Set the 'Uplink Flow Control' field in the message.
     * @param value_uplink_flow_control a #gboolean.
     */
    set_uplink_flow_control(value_uplink_flow_control: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsSetEventReportInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsSetEventReportInput
}
class MessageWdsSetEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetEventReportOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsSetIpFamilyInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetIpFamilyInput */
    /**
     * Get the 'Preference' field from `self`.
     */
    get_preference(): [ /* returnType */ boolean, /* value_preference */ WdsIpFamily | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetIpFamilyInput
    /**
     * Set the 'Preference' field in the message.
     * @param value_preference a #QmiWdsIpFamily.
     */
    set_preference(value_preference: WdsIpFamily): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsSetIpFamilyInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsSetIpFamilyInput
}
class MessageWdsSetIpFamilyOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetIpFamilyOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetIpFamilyOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsSetLteAttachPdnListInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetLteAttachPdnListInput */
    /**
     * Get the 'Action' field from `self`.
     */
    get_action(): [ /* returnType */ boolean, /* value_action */ WdsAttachPdnListAction | null ]
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ number[] | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetLteAttachPdnListInput
    /**
     * Set the 'Action' field in the message.
     * @param value_action a #QmiWdsAttachPdnListAction.
     */
    set_action(value_action: WdsAttachPdnListAction): boolean
    /**
     * Set the 'List' field in the message.
     * @param value_list a #GArray of #guint16 elements. A new reference to `value_list` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_list(value_list: number[]): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsSetLteAttachPdnListInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsSetLteAttachPdnListInput
}
class MessageWdsSetLteAttachPdnListOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSetLteAttachPdnListOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSetLteAttachPdnListOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsStartNetworkInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsStartNetworkInput */
    /**
     * Get the 'APN' field from `self`.
     */
    get_apn(): [ /* returnType */ boolean, /* value_apn */ string | null ]
    /**
     * Get the 'Authentication Preference' field from `self`.
     */
    get_authentication_preference(): [ /* returnType */ boolean, /* value_authentication_preference */ WdsAuthentication | null ]
    /**
     * Get the 'Call Type' field from `self`.
     */
    get_call_type(): [ /* returnType */ boolean, /* value_call_type */ WdsCallType | null ]
    /**
     * Get the 'Enable Autoconnect' field from `self`.
     */
    get_enable_autoconnect(): [ /* returnType */ boolean, /* value_enable_autoconnect */ boolean | null ]
    /**
     * Get the 'Extended Technology Preference' field from `self`.
     */
    get_extended_technology_preference(): [ /* returnType */ boolean, /* value_extended_technology_preference */ WdsExtendedTechnologyPreference | null ]
    /**
     * Get the 'IP Family Preference' field from `self`.
     */
    get_ip_family_preference(): [ /* returnType */ boolean, /* value_ip_family_preference */ WdsIpFamily | null ]
    /**
     * Get the 'IPv4 Address Preference' field from `self`.
     */
    get_ipv4_address_preference(): [ /* returnType */ boolean, /* value_ipv4_address_preference */ number | null ]
    /**
     * Get the 'Password' field from `self`.
     */
    get_password(): [ /* returnType */ boolean, /* value_password */ string | null ]
    /**
     * Get the 'Primary DNS Address Preference' field from `self`.
     */
    get_primary_dns_address_preference(): [ /* returnType */ boolean, /* value_primary_dns_address_preference */ number | null ]
    /**
     * Get the 'Primary NBNS Address Preference' field from `self`.
     */
    get_primary_nbns_address_preference(): [ /* returnType */ boolean, /* value_primary_nbns_address_preference */ number | null ]
    /**
     * Get the 'Profile Index 3GPP' field from `self`.
     */
    get_profile_index_3gpp(): [ /* returnType */ boolean, /* value_profile_index_3gpp */ number | null ]
    /**
     * Get the 'Profile Index 3GPP2' field from `self`.
     */
    get_profile_index_3gpp2(): [ /* returnType */ boolean, /* value_profile_index_3gpp2 */ number | null ]
    /**
     * Get the 'Secondary DNS Address Preference' field from `self`.
     */
    get_secondary_dns_address_preference(): [ /* returnType */ boolean, /* value_secondary_dns_address_preference */ number | null ]
    /**
     * Get the 'Secondary NBNS Address Preference' field from `self`.
     */
    get_secondary_nbns_address_preference(): [ /* returnType */ boolean, /* value_secondary_nbns_address_preference */ number | null ]
    /**
     * Get the 'Technology Preference' field from `self`.
     */
    get_technology_preference(): [ /* returnType */ boolean, /* value_technology_preference */ WdsTechnologyPreference | null ]
    /**
     * Get the 'Username' field from `self`.
     */
    get_username(): [ /* returnType */ boolean, /* value_username */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsStartNetworkInput
    /**
     * Set the 'APN' field in the message.
     * @param value_apn a constant string.
     */
    set_apn(value_apn: string): boolean
    /**
     * Set the 'Authentication Preference' field in the message.
     * @param value_authentication_preference a #QmiWdsAuthentication.
     */
    set_authentication_preference(value_authentication_preference: WdsAuthentication): boolean
    /**
     * Set the 'Call Type' field in the message.
     * @param value_call_type a #QmiWdsCallType.
     */
    set_call_type(value_call_type: WdsCallType): boolean
    /**
     * Set the 'Enable Autoconnect' field in the message.
     * @param value_enable_autoconnect a #gboolean.
     */
    set_enable_autoconnect(value_enable_autoconnect: boolean): boolean
    /**
     * Set the 'Extended Technology Preference' field in the message.
     * @param value_extended_technology_preference a #QmiWdsExtendedTechnologyPreference.
     */
    set_extended_technology_preference(value_extended_technology_preference: WdsExtendedTechnologyPreference): boolean
    /**
     * Set the 'IP Family Preference' field in the message.
     * @param value_ip_family_preference a #QmiWdsIpFamily.
     */
    set_ip_family_preference(value_ip_family_preference: WdsIpFamily): boolean
    /**
     * Set the 'IPv4 Address Preference' field in the message.
     * @param value_ipv4_address_preference a #guint32.
     */
    set_ipv4_address_preference(value_ipv4_address_preference: number): boolean
    /**
     * Set the 'Password' field in the message.
     * @param value_password a constant string.
     */
    set_password(value_password: string): boolean
    /**
     * Set the 'Primary DNS Address Preference' field in the message.
     * @param value_primary_dns_address_preference a #guint32.
     */
    set_primary_dns_address_preference(value_primary_dns_address_preference: number): boolean
    /**
     * Set the 'Primary NBNS Address Preference' field in the message.
     * @param value_primary_nbns_address_preference a #guint32.
     */
    set_primary_nbns_address_preference(value_primary_nbns_address_preference: number): boolean
    /**
     * Set the 'Profile Index 3GPP' field in the message.
     * @param value_profile_index_3gpp a #guint8.
     */
    set_profile_index_3gpp(value_profile_index_3gpp: number): boolean
    /**
     * Set the 'Profile Index 3GPP2' field in the message.
     * @param value_profile_index_3gpp2 a #guint8.
     */
    set_profile_index_3gpp2(value_profile_index_3gpp2: number): boolean
    /**
     * Set the 'Secondary DNS Address Preference' field in the message.
     * @param value_secondary_dns_address_preference a #guint32.
     */
    set_secondary_dns_address_preference(value_secondary_dns_address_preference: number): boolean
    /**
     * Set the 'Secondary NBNS Address Preference' field in the message.
     * @param value_secondary_nbns_address_preference a #guint32.
     */
    set_secondary_nbns_address_preference(value_secondary_nbns_address_preference: number): boolean
    /**
     * Set the 'Technology Preference' field in the message.
     * @param value_technology_preference a #QmiWdsTechnologyPreference.
     */
    set_technology_preference(value_technology_preference: WdsTechnologyPreference): boolean
    /**
     * Set the 'Username' field in the message.
     * @param value_username a constant string.
     */
    set_username(value_username: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsStartNetworkInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsStartNetworkInput
}
class MessageWdsStartNetworkOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsStartNetworkOutput */
    /**
     * Get the 'Call End Reason' field from `self`.
     */
    get_call_end_reason(): [ /* returnType */ boolean, /* value_call_end_reason */ WdsCallEndReason | null ]
    /**
     * Get the 'Packet Data Handle' field from `self`.
     */
    get_packet_data_handle(): [ /* returnType */ boolean, /* value_packet_data_handle */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Verbose Call End Reason' field from `self`.
     */
    get_verbose_call_end_reason(): [ /* returnType */ boolean, /* value_verbose_call_end_reason_type */ WdsVerboseCallEndReasonType | null, /* value_verbose_call_end_reason_reason */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsStartNetworkOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsStopNetworkInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsStopNetworkInput */
    /**
     * Get the 'Disable Autoconnect' field from `self`.
     */
    get_disable_autoconnect(): [ /* returnType */ boolean, /* value_disable_autoconnect */ boolean | null ]
    /**
     * Get the 'Packet Data Handle' field from `self`.
     */
    get_packet_data_handle(): [ /* returnType */ boolean, /* value_packet_data_handle */ number | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsStopNetworkInput
    /**
     * Set the 'Disable Autoconnect' field in the message.
     * @param value_disable_autoconnect a #gboolean.
     */
    set_disable_autoconnect(value_disable_autoconnect: boolean): boolean
    /**
     * Set the 'Packet Data Handle' field in the message.
     * @param value_packet_data_handle a #guint32.
     */
    set_packet_data_handle(value_packet_data_handle: number): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsStopNetworkInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsStopNetworkInput
}
class MessageWdsStopNetworkOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsStopNetworkOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsStopNetworkOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWdsSwiCreateProfileIndexedInput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSwiCreateProfileIndexedInput */
    /**
     * Get the 'APN Disabled Flag' field from `self`.
     */
    get_apn_disabled_flag(): [ /* returnType */ boolean, /* value_apn_disabled_flag */ boolean | null ]
    /**
     * Get the 'APN Name' field from `self`.
     */
    get_apn_name(): [ /* returnType */ boolean, /* value_apn_name */ string | null ]
    /**
     * Get the 'Authentication' field from `self`.
     */
    get_authentication(): [ /* returnType */ boolean, /* value_authentication */ WdsAuthentication | null ]
    /**
     * Get the 'IPv4 Address Preference' field from `self`.
     */
    get_ipv4_address_preference(): [ /* returnType */ boolean, /* value_ipv4_address_preference */ number | null ]
    /**
     * Get the 'Password' field from `self`.
     */
    get_password(): [ /* returnType */ boolean, /* value_password */ string | null ]
    /**
     * Get the 'PDP Context Number' field from `self`.
     */
    get_pdp_context_number(): [ /* returnType */ boolean, /* value_pdp_context_number */ number | null ]
    /**
     * Get the 'PDP Type' field from `self`.
     */
    get_pdp_type(): [ /* returnType */ boolean, /* value_pdp_type */ WdsPdpType | null ]
    /**
     * Get the 'Primary IPv4 DNS Address' field from `self`.
     */
    get_primary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_primary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'Profile Identifier' field from `self`.
     */
    get_profile_identifier(): [ /* returnType */ boolean, /* value_profile_identifier_profile_type */ WdsProfileType | null, /* value_profile_identifier_profile_index */ number | null ]
    /**
     * Get the 'Profile Name' field from `self`.
     */
    get_profile_name(): [ /* returnType */ boolean, /* value_profile_name */ string | null ]
    /**
     * Get the 'Roaming Disallowed Flag' field from `self`.
     */
    get_roaming_disallowed_flag(): [ /* returnType */ boolean, /* value_roaming_disallowed_flag */ boolean | null ]
    /**
     * Get the 'Secondary IPv4 DNS Address' field from `self`.
     */
    get_secondary_ipv4_dns_address(): [ /* returnType */ boolean, /* value_secondary_ipv4_dns_address */ number | null ]
    /**
     * Get the 'Username' field from `self`.
     */
    get_username(): [ /* returnType */ boolean, /* value_username */ string | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSwiCreateProfileIndexedInput
    /**
     * Set the 'APN Disabled Flag' field in the message.
     * @param value_apn_disabled_flag a #gboolean.
     */
    set_apn_disabled_flag(value_apn_disabled_flag: boolean): boolean
    /**
     * Set the 'APN Name' field in the message.
     * @param value_apn_name a constant string.
     */
    set_apn_name(value_apn_name: string): boolean
    /**
     * Set the 'Authentication' field in the message.
     * @param value_authentication a #QmiWdsAuthentication.
     */
    set_authentication(value_authentication: WdsAuthentication): boolean
    /**
     * Set the 'IPv4 Address Preference' field in the message.
     * @param value_ipv4_address_preference a #guint32.
     */
    set_ipv4_address_preference(value_ipv4_address_preference: number): boolean
    /**
     * Set the 'Password' field in the message.
     * @param value_password a constant string.
     */
    set_password(value_password: string): boolean
    /**
     * Set the 'PDP Context Number' field in the message.
     * @param value_pdp_context_number a #guint8.
     */
    set_pdp_context_number(value_pdp_context_number: number): boolean
    /**
     * Set the 'PDP Type' field in the message.
     * @param value_pdp_type a #QmiWdsPdpType.
     */
    set_pdp_type(value_pdp_type: WdsPdpType): boolean
    /**
     * Set the 'Primary IPv4 DNS Address' field in the message.
     * @param value_primary_ipv4_dns_address a #guint32.
     */
    set_primary_ipv4_dns_address(value_primary_ipv4_dns_address: number): boolean
    /**
     * Set the 'Profile Identifier' field in the message.
     * @param value_profile_identifier_profile_type a #QmiWdsProfileType.
     * @param value_profile_identifier_profile_index a #guint8.
     */
    set_profile_identifier(value_profile_identifier_profile_type: WdsProfileType, value_profile_identifier_profile_index: number): boolean
    /**
     * Set the 'Profile Name' field in the message.
     * @param value_profile_name a constant string.
     */
    set_profile_name(value_profile_name: string): boolean
    /**
     * Set the 'Roaming Disallowed Flag' field in the message.
     * @param value_roaming_disallowed_flag a #gboolean.
     */
    set_roaming_disallowed_flag(value_roaming_disallowed_flag: boolean): boolean
    /**
     * Set the 'Secondary IPv4 DNS Address' field in the message.
     * @param value_secondary_ipv4_dns_address a #guint32.
     */
    set_secondary_ipv4_dns_address(value_secondary_ipv4_dns_address: number): boolean
    /**
     * Set the 'Username' field in the message.
     * @param value_username a constant string.
     */
    set_username(value_username: string): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWdsSwiCreateProfileIndexedInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWdsSwiCreateProfileIndexedInput
}
class MessageWdsSwiCreateProfileIndexedOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWdsSwiCreateProfileIndexedOutput */
    /**
     * Get the 'Profile Identifier' field from `self`.
     */
    get_profile_identifier(): [ /* returnType */ boolean, /* value_profile_identifier_profile_type */ WdsProfileType | null, /* value_profile_identifier_profile_index */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWdsSwiCreateProfileIndexedOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsDeleteInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsDeleteInput */
    /**
     * Get the 'Memory Index' field from `self`.
     */
    get_memory_index(): [ /* returnType */ boolean, /* value_memory_index */ number | null ]
    /**
     * Get the 'Memory Storage' field from `self`.
     */
    get_memory_storage(): [ /* returnType */ boolean, /* value_memory_storage */ WmsStorageType | null ]
    /**
     * Get the 'Message Mode' field from `self`.
     */
    get_message_mode(): [ /* returnType */ boolean, /* value_message_mode */ WmsMessageMode | null ]
    /**
     * Get the 'Message Tag' field from `self`.
     */
    get_message_tag(): [ /* returnType */ boolean, /* value_message_tag */ WmsMessageTagType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsDeleteInput
    /**
     * Set the 'Memory Index' field in the message.
     * @param value_memory_index a #guint32.
     */
    set_memory_index(value_memory_index: number): boolean
    /**
     * Set the 'Memory Storage' field in the message.
     * @param value_memory_storage a #QmiWmsStorageType.
     */
    set_memory_storage(value_memory_storage: WmsStorageType): boolean
    /**
     * Set the 'Message Mode' field in the message.
     * @param value_message_mode a #QmiWmsMessageMode.
     */
    set_message_mode(value_message_mode: WmsMessageMode): boolean
    /**
     * Set the 'Message Tag' field in the message.
     * @param value_message_tag a #QmiWmsMessageTagType.
     */
    set_message_tag(value_message_tag: WmsMessageTagType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsDeleteInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsDeleteInput
}
class MessageWmsDeleteOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsDeleteOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsDeleteOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsGetMessageProtocolOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsGetMessageProtocolOutput */
    /**
     * Get the 'Message Protocol' field from `self`.
     */
    get_message_protocol(): [ /* returnType */ boolean, /* value_message_protocol */ WmsMessageProtocol | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsGetMessageProtocolOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsGetRoutesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsGetRoutesOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Get the 'Route List' field from `self`.
     * 
     * Version of qmi_message_wms_get_routes_output_get_route_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_route_list(): [ /* returnType */ boolean, /* value_route_list_ptr */ MessageWmsGetRoutesOutputRouteListElement[] | null ]
    /**
     * Get the 'Transfer Status Report' field from `self`.
     */
    get_transfer_status_report(): [ /* returnType */ boolean, /* value_transfer_status_report */ WmsTransferIndication | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsGetRoutesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsGetRoutesOutputRouteListElement {
    /* Fields of Qmi-1.0.Qmi.MessageWmsGetRoutesOutputRouteListElement */
    /**
     * a #QmiWmsMessageType.
     */
    message_type: WmsMessageType
    /**
     * a #QmiWmsMessageClass.
     */
    message_class: WmsMessageClass
    /**
     * a #QmiWmsStorageType.
     */
    storage: WmsStorageType
    /**
     * a #QmiWmsReceiptAction.
     */
    receipt_action: WmsReceiptAction
    static name: string
}
class MessageWmsGetSupportedMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsGetSupportedMessagesOutput */
    /**
     * Get the 'List' field from `self`.
     */
    get_list(): [ /* returnType */ boolean, /* value_list */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsGetSupportedMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsListMessagesInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsListMessagesInput */
    /**
     * Get the 'Message Mode' field from `self`.
     */
    get_message_mode(): [ /* returnType */ boolean, /* value_message_mode */ WmsMessageMode | null ]
    /**
     * Get the 'Message Tag' field from `self`.
     */
    get_message_tag(): [ /* returnType */ boolean, /* value_message_tag */ WmsMessageTagType | null ]
    /**
     * Get the 'Storage Type' field from `self`.
     */
    get_storage_type(): [ /* returnType */ boolean, /* value_storage_type */ WmsStorageType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsListMessagesInput
    /**
     * Set the 'Message Mode' field in the message.
     * @param value_message_mode a #QmiWmsMessageMode.
     */
    set_message_mode(value_message_mode: WmsMessageMode): boolean
    /**
     * Set the 'Message Tag' field in the message.
     * @param value_message_tag a #QmiWmsMessageTagType.
     */
    set_message_tag(value_message_tag: WmsMessageTagType): boolean
    /**
     * Set the 'Storage Type' field in the message.
     * @param value_storage_type a #QmiWmsStorageType.
     */
    set_storage_type(value_storage_type: WmsStorageType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsListMessagesInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsListMessagesInput
}
class MessageWmsListMessagesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsListMessagesOutput */
    /**
     * Get the 'Message List' field from `self`.
     * 
     * Version of qmi_message_wms_list_messages_output_get_message_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_message_list(): [ /* returnType */ boolean, /* value_message_list_ptr */ MessageWmsListMessagesOutputMessageListElement[] | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsListMessagesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsListMessagesOutputMessageListElement {
    /* Fields of Qmi-1.0.Qmi.MessageWmsListMessagesOutputMessageListElement */
    /**
     * a #guint32.
     */
    memory_index: number
    /**
     * a #QmiWmsMessageTagType.
     */
    message_tag: WmsMessageTagType
    static name: string
}
class MessageWmsModifyTagInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsModifyTagInput */
    /**
     * Get the 'Message Mode' field from `self`.
     */
    get_message_mode(): [ /* returnType */ boolean, /* value_message_mode */ WmsMessageMode | null ]
    /**
     * Get the 'Message Tag' field from `self`.
     */
    get_message_tag(): [ /* returnType */ boolean, /* value_message_tag_storage_type */ WmsStorageType | null, /* value_message_tag_memory_index */ number | null, /* value_message_tag_message_tag */ WmsMessageTagType | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsModifyTagInput
    /**
     * Set the 'Message Mode' field in the message.
     * @param value_message_mode a #QmiWmsMessageMode.
     */
    set_message_mode(value_message_mode: WmsMessageMode): boolean
    /**
     * Set the 'Message Tag' field in the message.
     * @param value_message_tag_storage_type a #QmiWmsStorageType.
     * @param value_message_tag_memory_index a #guint32.
     * @param value_message_tag_message_tag a #QmiWmsMessageTagType.
     */
    set_message_tag(value_message_tag_storage_type: WmsStorageType, value_message_tag_memory_index: number, value_message_tag_message_tag: WmsMessageTagType): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsModifyTagInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsModifyTagInput
}
class MessageWmsModifyTagOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsModifyTagOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsModifyTagOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsRawReadInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsRawReadInput */
    /**
     * Get the 'Message Memory Storage ID' field from `self`.
     */
    get_message_memory_storage_id(): [ /* returnType */ boolean, /* value_message_memory_storage_id_storage_type */ WmsStorageType | null, /* value_message_memory_storage_id_memory_index */ number | null ]
    /**
     * Get the 'Message Mode' field from `self`.
     */
    get_message_mode(): [ /* returnType */ boolean, /* value_message_mode */ WmsMessageMode | null ]
    /**
     * Get the 'SMS on IMS' field from `self`.
     */
    get_sms_on_ims(): [ /* returnType */ boolean, /* value_sms_on_ims */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsRawReadInput
    /**
     * Set the 'Message Memory Storage ID' field in the message.
     * @param value_message_memory_storage_id_storage_type a #QmiWmsStorageType.
     * @param value_message_memory_storage_id_memory_index a #guint32.
     */
    set_message_memory_storage_id(value_message_memory_storage_id_storage_type: WmsStorageType, value_message_memory_storage_id_memory_index: number): boolean
    /**
     * Set the 'Message Mode' field in the message.
     * @param value_message_mode a #QmiWmsMessageMode.
     */
    set_message_mode(value_message_mode: WmsMessageMode): boolean
    /**
     * Set the 'SMS on IMS' field in the message.
     * @param value_sms_on_ims a #gboolean.
     */
    set_sms_on_ims(value_sms_on_ims: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsRawReadInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsRawReadInput
}
class MessageWmsRawReadOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsRawReadOutput */
    /**
     * Get the 'Raw Message Data' field from `self`.
     */
    get_raw_message_data(): [ /* returnType */ boolean, /* value_raw_message_data_message_tag */ WmsMessageTagType | null, /* value_raw_message_data_format */ WmsMessageFormat | null, /* value_raw_message_data_raw_data */ Uint8Array | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsRawReadOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsRawSendInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsRawSendInput */
    /**
     * Get the 'CDMA Follow On DC' field from `self`.
     */
    get_cdma_follow_on_dc(): [ /* returnType */ boolean, /* value_cdma_follow_on_dc_follow */ boolean | null ]
    /**
     * Get the 'CDMA Force On DC' field from `self`.
     */
    get_cdma_force_on_dc(): [ /* returnType */ boolean, /* value_cdma_force_on_dc_force */ boolean | null, /* value_cdma_force_on_dc_service_option */ WmsCdmaServiceOption | null ]
    /**
     * Get the 'GSM WCDMA Link Timer' field from `self`.
     */
    get_gsm_wcdma_link_timer(): [ /* returnType */ boolean, /* value_gsm_wcdma_link_timer */ number | null ]
    /**
     * Get the 'Raw Message Data' field from `self`.
     */
    get_raw_message_data(): [ /* returnType */ boolean, /* value_raw_message_data_format */ WmsMessageFormat | null, /* value_raw_message_data_raw_data */ Uint8Array | null ]
    /**
     * Get the 'SMS on IMS' field from `self`.
     */
    get_sms_on_ims(): [ /* returnType */ boolean, /* value_sms_on_ims */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsRawSendInput
    /**
     * Set the 'CDMA Follow On DC' field in the message.
     * @param value_cdma_follow_on_dc_follow a #gboolean.
     */
    set_cdma_follow_on_dc(value_cdma_follow_on_dc_follow: boolean): boolean
    /**
     * Set the 'CDMA Force On DC' field in the message.
     * @param value_cdma_force_on_dc_force a #gboolean.
     * @param value_cdma_force_on_dc_service_option a #QmiWmsCdmaServiceOption.
     */
    set_cdma_force_on_dc(value_cdma_force_on_dc_force: boolean, value_cdma_force_on_dc_service_option: WmsCdmaServiceOption): boolean
    /**
     * Set the 'GSM WCDMA Link Timer' field in the message.
     * @param value_gsm_wcdma_link_timer a #guint8.
     */
    set_gsm_wcdma_link_timer(value_gsm_wcdma_link_timer: number): boolean
    /**
     * Set the 'Raw Message Data' field in the message.
     * @param value_raw_message_data_format a #QmiWmsMessageFormat.
     * @param value_raw_message_data_raw_data a #GArray of #guint8 elements. A new reference to `value_raw_message_data_raw_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_raw_message_data(value_raw_message_data_format: WmsMessageFormat, value_raw_message_data_raw_data: Uint8Array): boolean
    /**
     * Set the 'SMS on IMS' field in the message.
     * @param value_sms_on_ims a #gboolean.
     */
    set_sms_on_ims(value_sms_on_ims: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsRawSendInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsRawSendInput
}
class MessageWmsRawSendOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsRawSendOutput */
    /**
     * Get the 'CDMA Cause Code' field from `self`.
     */
    get_cdma_cause_code(): [ /* returnType */ boolean, /* value_cdma_cause_code */ WmsCdmaCauseCode | null ]
    /**
     * Get the 'CDMA Error Class' field from `self`.
     */
    get_cdma_error_class(): [ /* returnType */ boolean, /* value_cdma_error_class */ WmsCdmaErrorClass | null ]
    /**
     * Get the 'GSM WCDMA Cause Info' field from `self`.
     */
    get_gsm_wcdma_cause_info(): [ /* returnType */ boolean, /* value_gsm_wcdma_cause_info_rp_cause */ WmsGsmUmtsRpCause | null, /* value_gsm_wcdma_cause_info_tp_cause */ WmsGsmUmtsTpCause | null ]
    /**
     * Get the 'Message Delivery Failure Type' field from `self`.
     */
    get_message_delivery_failure_type(): [ /* returnType */ boolean, /* value_message_delivery_failure_type */ WmsMessageDeliveryFailureType | null ]
    /**
     * Get the 'Message ID' field from `self`.
     */
    get_message_id(): [ /* returnType */ boolean, /* value_message_id */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsRawSendOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsRawWriteInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsRawWriteInput */
    /**
     * Get the 'Raw Message Data' field from `self`.
     */
    get_raw_message_data(): [ /* returnType */ boolean, /* value_raw_message_data_storage_type */ WmsStorageType | null, /* value_raw_message_data_format */ WmsMessageFormat | null, /* value_raw_message_data_raw_data */ Uint8Array | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsRawWriteInput
    /**
     * Set the 'Raw Message Data' field in the message.
     * @param value_raw_message_data_storage_type a #QmiWmsStorageType.
     * @param value_raw_message_data_format a #QmiWmsMessageFormat.
     * @param value_raw_message_data_raw_data a #GArray of #guint8 elements. A new reference to `value_raw_message_data_raw_data` will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
     */
    set_raw_message_data(value_raw_message_data_storage_type: WmsStorageType, value_raw_message_data_format: WmsMessageFormat, value_raw_message_data_raw_data: Uint8Array): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsRawWriteInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsRawWriteInput
}
class MessageWmsRawWriteOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsRawWriteOutput */
    /**
     * Get the 'Memory Index' field from `self`.
     */
    get_memory_index(): [ /* returnType */ boolean, /* value_memory_index */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsRawWriteOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsResetOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsResetOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsResetOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsSendAckInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSendAckInput */
    /**
     * Get the '3GPP2 Failure Information' field from `self`.
     */
    get_3gpp2_failure_information(): [ /* returnType */ boolean, /* value_3gpp2_failure_information_error_class */ WmsCdmaErrorClass | null, /* value_3gpp2_failure_information_cause_code */ WmsCdmaCauseCode | null ]
    /**
     * Get the '3GPP Failure Information' field from `self`.
     */
    get_3gpp_failure_information(): [ /* returnType */ boolean, /* value_3gpp_failure_information_rp_cause */ WmsGsmUmtsRpCause | null, /* value_3gpp_failure_information_tp_cause */ WmsGsmUmtsTpCause | null ]
    /**
     * Get the 'Information' field from `self`.
     */
    get_information(): [ /* returnType */ boolean, /* value_information_transaction_id */ number | null, /* value_information_message_protocol */ WmsMessageProtocol | null, /* value_information_success */ boolean | null ]
    /**
     * Get the 'SMS on IMS' field from `self`.
     */
    get_sms_on_ims(): [ /* returnType */ boolean, /* value_sms_on_ims */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSendAckInput
    /**
     * Set the '3GPP2 Failure Information' field in the message.
     * @param value_3gpp2_failure_information_error_class a #QmiWmsCdmaErrorClass.
     * @param value_3gpp2_failure_information_cause_code a #QmiWmsCdmaCauseCode.
     */
    set_3gpp2_failure_information(value_3gpp2_failure_information_error_class: WmsCdmaErrorClass, value_3gpp2_failure_information_cause_code: WmsCdmaCauseCode): boolean
    /**
     * Set the '3GPP Failure Information' field in the message.
     * @param value_3gpp_failure_information_rp_cause a #QmiWmsGsmUmtsRpCause.
     * @param value_3gpp_failure_information_tp_cause a #QmiWmsGsmUmtsTpCause.
     */
    set_3gpp_failure_information(value_3gpp_failure_information_rp_cause: WmsGsmUmtsRpCause, value_3gpp_failure_information_tp_cause: WmsGsmUmtsTpCause): boolean
    /**
     * Set the 'Information' field in the message.
     * @param value_information_transaction_id a #guint32.
     * @param value_information_message_protocol a #QmiWmsMessageProtocol.
     * @param value_information_success a #gboolean.
     */
    set_information(value_information_transaction_id: number, value_information_message_protocol: WmsMessageProtocol, value_information_success: boolean): boolean
    /**
     * Set the 'SMS on IMS' field in the message.
     * @param value_sms_on_ims a #gboolean.
     */
    set_sms_on_ims(value_sms_on_ims: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsSendAckInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsSendAckInput
}
class MessageWmsSendAckOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSendAckOutput */
    /**
     * Get the 'Failure Cause' field from `self`.
     */
    get_failure_cause(): [ /* returnType */ boolean, /* value_failure_cause */ WmsAckFailureCause | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSendAckOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsSendFromMemoryStorageInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSendFromMemoryStorageInput */
    /**
     * Get the 'Information' field from `self`.
     */
    get_information(): [ /* returnType */ boolean, /* value_information_storage_type */ WmsStorageType | null, /* value_information_memory_index */ number | null, /* value_information_message_mode */ WmsMessageMode | null ]
    /**
     * Get the 'SMS on IMS' field from `self`.
     */
    get_sms_on_ims(): [ /* returnType */ boolean, /* value_sms_on_ims */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSendFromMemoryStorageInput
    /**
     * Set the 'Information' field in the message.
     * @param value_information_storage_type a #QmiWmsStorageType.
     * @param value_information_memory_index a #guint32.
     * @param value_information_message_mode a #QmiWmsMessageMode.
     */
    set_information(value_information_storage_type: WmsStorageType, value_information_memory_index: number, value_information_message_mode: WmsMessageMode): boolean
    /**
     * Set the 'SMS on IMS' field in the message.
     * @param value_sms_on_ims a #gboolean.
     */
    set_sms_on_ims(value_sms_on_ims: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsSendFromMemoryStorageInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsSendFromMemoryStorageInput
}
class MessageWmsSendFromMemoryStorageOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSendFromMemoryStorageOutput */
    /**
     * Get the 'CDMA Cause Code' field from `self`.
     */
    get_cdma_cause_code(): [ /* returnType */ boolean, /* value_cdma_cause_code */ WmsCdmaCauseCode | null ]
    /**
     * Get the 'CDMA Error Class' field from `self`.
     */
    get_cdma_error_class(): [ /* returnType */ boolean, /* value_cdma_error_class */ WmsCdmaErrorClass | null ]
    /**
     * Get the 'GSM WCDMA Cause Info' field from `self`.
     */
    get_gsm_wcdma_cause_info(): [ /* returnType */ boolean, /* value_gsm_wcdma_cause_info_rp_cause */ WmsGsmUmtsRpCause | null, /* value_gsm_wcdma_cause_info_tp_cause */ WmsGsmUmtsTpCause | null ]
    /**
     * Get the 'Message Delivery Failure Type' field from `self`.
     */
    get_message_delivery_failure_type(): [ /* returnType */ boolean, /* value_message_delivery_failure_type */ WmsMessageDeliveryFailureType | null ]
    /**
     * Get the 'Message ID' field from `self`.
     */
    get_message_id(): [ /* returnType */ boolean, /* value_message_id */ number | null ]
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSendFromMemoryStorageOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsSetEventReportInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSetEventReportInput */
    /**
     * Get the 'New MT Message Indicator' field from `self`.
     */
    get_new_mt_message_indicator(): [ /* returnType */ boolean, /* value_new_mt_message_indicator_report */ boolean | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSetEventReportInput
    /**
     * Set the 'New MT Message Indicator' field in the message.
     * @param value_new_mt_message_indicator_report a #gboolean.
     */
    set_new_mt_message_indicator(value_new_mt_message_indicator_report: boolean): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsSetEventReportInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsSetEventReportInput
}
class MessageWmsSetEventReportOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSetEventReportOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSetEventReportOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class MessageWmsSetRoutesInput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSetRoutesInput */
    /**
     * Get the 'Route List' field from `self`.
     * 
     * Version of qmi_message_wms_set_routes_input_get_route_list() using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    get_route_list(): [ /* returnType */ boolean, /* value_route_list_ptr */ MessageWmsSetRoutesInputRouteListElement[] | null ]
    /**
     * Get the 'Transfer Status Report' field from `self`.
     */
    get_transfer_status_report(): [ /* returnType */ boolean, /* value_transfer_status_report */ WmsTransferIndication | null ]
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSetRoutesInput
    /**
     * Set the 'Route List' field in the message.
     * @param value_route_list_ptr array of #QmiMessageWmsSetRoutesInputRouteListElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
     */
    set_route_list(value_route_list_ptr: MessageWmsSetRoutesInputRouteListElement[]): boolean
    /**
     * Set the 'Transfer Status Report' field in the message.
     * @param value_transfer_status_report a #QmiWmsTransferIndication.
     */
    set_transfer_status_report(value_transfer_status_report: WmsTransferIndication): boolean
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
    static new(): MessageWmsSetRoutesInput
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MessageWmsSetRoutesInput
}
class MessageWmsSetRoutesInputRouteListElement {
    /* Fields of Qmi-1.0.Qmi.MessageWmsSetRoutesInputRouteListElement */
    /**
     * a #QmiWmsMessageType.
     */
    message_type: WmsMessageType
    /**
     * a #QmiWmsMessageClass.
     */
    message_class: WmsMessageClass
    /**
     * a #QmiWmsStorageType.
     */
    storage: WmsStorageType
    /**
     * a #QmiWmsReceiptAction.
     */
    receipt_action: WmsReceiptAction
    static name: string
}
class MessageWmsSetRoutesOutput {
    /* Methods of Qmi-1.0.Qmi.MessageWmsSetRoutesOutput */
    /**
     * Get the result of the QMI operation.
     */
    get_result(): boolean
    /**
     * Atomically increments the reference count of `self` by one.
     */
    ref(): MessageWmsSetRoutesOutput
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     */
    unref(): void
    static name: string
}
class PhysicalSlotInformationSlot {
    /* Fields of Qmi-1.0.Qmi.PhysicalSlotInformationSlot */
    /**
     * a #QmiUimCardProtocol.
     */
    card_protocol: UimCardProtocol
    /**
     * a #guint8.
     */
    valid_applications: number
    /**
     * a #GArray of #guint8 elements.
     */
    atr_value: object[]
    /**
     * a #gboolean.
     */
    is_euicc: boolean
    static name: string
}
class PhysicalSlotStatusSlot {
    /* Fields of Qmi-1.0.Qmi.PhysicalSlotStatusSlot */
    /**
     * a #QmiUimPhysicalCardState.
     */
    physical_card_status: UimPhysicalCardState
    /**
     * a #QmiUimSlotState.
     */
    physical_slot_status: UimSlotState
    /**
     * a #guint8.
     */
    logical_slot: number
    /**
     * a #GArray of #guint8 elements.
     */
    iccid: object[]
    static name: string
}
abstract class ProxyClass {
    /* Fields of Qmi-1.0.Qmi.ProxyClass */
    parent: GObject.ObjectClass
    static name: string
}
class ProxyPrivate {
    static name: string
}
class SlotEidElement {
    /* Fields of Qmi-1.0.Qmi.SlotEidElement */
    /**
     * a #GArray of #guint8 elements.
     */
    eid: object[]
    static name: string
}
    type Message = Uint8Array
}
export default Qmi;