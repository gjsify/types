/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

// Module dependencies
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';

export namespace Gio {
    /**
     * A convenient helper to create Promise wrappers for asynchronous functions in GJS.
     *
     * This utility replaces the original function on the class prototype with a Promise-based version,
     * allowing the function to be called on any instance of the class, including subclasses.
     * Simply pass the class prototype, the "async" function name, and the "finish" function name as arguments.
     *
     * The function can be used like any other Promise, without the need for a custom wrapper, by leaving out the callback argument.
     * The original function will still be available, and can be used by passing the callback.
     *
     * @param proto - The class prototype that contains the asynchronous function.
     * @param asyncFunc - The name of the asynchronous function.
     * @param finishFunc - The name of the "finish" function that is used to retrieve the result of the asynchronous function.
     *
     * @version Gjs 1.54
     * @see https://gjs.guide/guides/gjs/asynchronous-programming.html#promisify-helper
     *
     * @example
     * ```js
     * import Gio from "gi://Gio?version=2.0";
     *
     * Gio._promisify(Gio.InputStream.prototype, 'read_bytes_async', 'read_bytes_finish');
     *
     * try {
     *    const inputStream = new Gio.UnixInputStream({fd: 0});
     *    const bytes = await inputStream.read_bytes_async(4096, GLib.PRIORITY_DEFAULT, null);
     * } catch (e) {
     *    logError(e, 'Failed to read bytes');
     * }
     * ```
     *
     */
    export function _promisify(proto: any, asyncFunc: string, finishFunc?: string): void;

    /** Temporary Gio.File.prototype fix */
    export const _LocalFilePrototype: typeof File.prototype;

    /**
     * Gio-2.0
     */

    /**
     * An enumeration for well-known message buses.
     */

    /**
     * An enumeration for well-known message buses.
     */
    export namespace BusType {
        export const $gtype: GObject.GType<BusType>;
    }

    enum BusType {
        /**
         * An alias for the message bus that activated the process, if any.
         */
        STARTER,
        /**
         * Not a message bus.
         */
        NONE,
        /**
         * The system-wide message bus.
         */
        SYSTEM,
        /**
         * The login session message bus.
         */
        SESSION,
    }
    /**
     * Results returned from g_converter_convert().
     */

    /**
     * Results returned from g_converter_convert().
     */
    export namespace ConverterResult {
        export const $gtype: GObject.GType<ConverterResult>;
    }

    enum ConverterResult {
        /**
         * There was an error during conversion.
         */
        ERROR,
        /**
         * Some data was consumed or produced
         */
        CONVERTED,
        /**
         * The conversion is finished
         */
        FINISHED,
        /**
         * Flushing is finished
         */
        FLUSHED,
    }
    /**
     * Enumeration describing different kinds of native credential types.
     */

    /**
     * Enumeration describing different kinds of native credential types.
     */
    export namespace CredentialsType {
        export const $gtype: GObject.GType<CredentialsType>;
    }

    enum CredentialsType {
        /**
         * Indicates an invalid native credential type.
         */
        INVALID,
        /**
         * The native credentials type is a `struct ucred`.
         */
        LINUX_UCRED,
        /**
         * The native credentials type is a `struct cmsgcred`.
         */
        FREEBSD_CMSGCRED,
        /**
         * The native credentials type is a `struct sockpeercred`. Added in 2.30.
         */
        OPENBSD_SOCKPEERCRED,
        /**
         * The native credentials type is a `ucred_t`. Added in 2.40.
         */
        SOLARIS_UCRED,
        /**
         * The native credentials type is a `struct unpcbid`. Added in 2.42.
         */
        NETBSD_UNPCBID,
        /**
         * The native credentials type is a `struct xucred`. Added in 2.66.
         */
        APPLE_XUCRED,
        /**
         * The native credentials type is a PID `DWORD`. Added in 2.72.
         */
        WIN32_PID,
    }
    /**
     * Error codes for the %G_DBUS_ERROR error domain.
     */
    class DBusError extends GLib.Error {
        static $gtype: GObject.GType<DBusError>;

        // Static fields

        /**
         * A generic error; "something went wrong" - see the error message for
         * more.
         */
        static FAILED: number;
        /**
         * There was not enough memory to complete an operation.
         */
        static NO_MEMORY: number;
        /**
         * The bus doesn't know how to launch a service to supply the bus name
         * you wanted.
         */
        static SERVICE_UNKNOWN: number;
        /**
         * The bus name you referenced doesn't exist (i.e. no application owns
         * it).
         */
        static NAME_HAS_NO_OWNER: number;
        /**
         * No reply to a message expecting one, usually means a timeout occurred.
         */
        static NO_REPLY: number;
        /**
         * Something went wrong reading or writing to a socket, for example.
         */
        static IO_ERROR: number;
        /**
         * A D-Bus bus address was malformed.
         */
        static BAD_ADDRESS: number;
        /**
         * Requested operation isn't supported (like ENOSYS on UNIX).
         */
        static NOT_SUPPORTED: number;
        /**
         * Some limited resource is exhausted.
         */
        static LIMITS_EXCEEDED: number;
        /**
         * Security restrictions don't allow doing what you're trying to do.
         */
        static ACCESS_DENIED: number;
        /**
         * Authentication didn't work.
         */
        static AUTH_FAILED: number;
        /**
         * Unable to connect to server (probably caused by ECONNREFUSED on a
         * socket).
         */
        static NO_SERVER: number;
        /**
         * Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
         * %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
         * this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
         * exists. We can't fix it for compatibility reasons so just be
         * careful.
         */
        static TIMEOUT: number;
        /**
         * No network access (probably ENETUNREACH on a socket).
         */
        static NO_NETWORK: number;
        /**
         * Can't bind a socket since its address is in use (i.e. EADDRINUSE).
         */
        static ADDRESS_IN_USE: number;
        /**
         * The connection is disconnected and you're trying to use it.
         */
        static DISCONNECTED: number;
        /**
         * Invalid arguments passed to a method call.
         */
        static INVALID_ARGS: number;
        /**
         * Missing file.
         */
        static FILE_NOT_FOUND: number;
        /**
         * Existing file and the operation you're using does not silently overwrite.
         */
        static FILE_EXISTS: number;
        /**
         * Method name you invoked isn't known by the object you invoked it on.
         */
        static UNKNOWN_METHOD: number;
        /**
         * Certain timeout errors, e.g. while starting a service. Warning: this is
         * confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
         * can't fix it for compatibility reasons so just be careful.
         */
        static TIMED_OUT: number;
        /**
         * Tried to remove or modify a match rule that didn't exist.
         */
        static MATCH_RULE_NOT_FOUND: number;
        /**
         * The match rule isn't syntactically valid.
         */
        static MATCH_RULE_INVALID: number;
        /**
         * While starting a new process, the exec() call failed.
         */
        static SPAWN_EXEC_FAILED: number;
        /**
         * While starting a new process, the fork() call failed.
         */
        static SPAWN_FORK_FAILED: number;
        /**
         * While starting a new process, the child exited with a status code.
         */
        static SPAWN_CHILD_EXITED: number;
        /**
         * While starting a new process, the child exited on a signal.
         */
        static SPAWN_CHILD_SIGNALED: number;
        /**
         * While starting a new process, something went wrong.
         */
        static SPAWN_FAILED: number;
        /**
         * We failed to setup the environment correctly.
         */
        static SPAWN_SETUP_FAILED: number;
        /**
         * We failed to setup the config parser correctly.
         */
        static SPAWN_CONFIG_INVALID: number;
        /**
         * Bus name was not valid.
         */
        static SPAWN_SERVICE_INVALID: number;
        /**
         * Service file not found in system-services directory.
         */
        static SPAWN_SERVICE_NOT_FOUND: number;
        /**
         * Permissions are incorrect on the setuid helper.
         */
        static SPAWN_PERMISSIONS_INVALID: number;
        /**
         * Service file invalid (Name, User or Exec missing).
         */
        static SPAWN_FILE_INVALID: number;
        /**
         * Tried to get a UNIX process ID and it wasn't available.
         */
        static SPAWN_NO_MEMORY: number;
        /**
         * Tried to get a UNIX process ID and it wasn't available.
         */
        static UNIX_PROCESS_ID_UNKNOWN: number;
        /**
         * A type signature is not valid.
         */
        static INVALID_SIGNATURE: number;
        /**
         * A file contains invalid syntax or is otherwise broken.
         */
        static INVALID_FILE_CONTENT: number;
        /**
         * Asked for SELinux security context and it wasn't available.
         */
        static SELINUX_SECURITY_CONTEXT_UNKNOWN: number;
        /**
         * Asked for ADT audit data and it wasn't available.
         */
        static ADT_AUDIT_DATA_UNKNOWN: number;
        /**
         * There's already an object with the requested object path.
         */
        static OBJECT_PATH_IN_USE: number;
        /**
         * Object you invoked a method on isn't known. Since 2.42
         */
        static UNKNOWN_OBJECT: number;
        /**
         * Interface you invoked a method on isn't known by the object. Since 2.42
         */
        static UNKNOWN_INTERFACE: number;
        /**
         * Property you tried to access isn't known by the object. Since 2.42
         */
        static UNKNOWN_PROPERTY: number;
        /**
         * Property you tried to set is read-only. Since 2.42
         */
        static PROPERTY_READ_ONLY: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Creates a D-Bus error name to use for `error`. If `error` matches
         * a registered error (cf. g_dbus_error_register_error()), the corresponding
         * D-Bus error name will be returned.
         *
         * Otherwise the a name of the form
         * `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
         * will be used. This allows other GDBus applications to map the error
         * on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
         *
         * This function is typically only used in object mappings to put a
         * #GError on the wire. Regular applications should not use it.
         * @param error A #GError.
         */
        static encode_gerror(error: GLib.Error): string;
        /**
         * Gets the D-Bus error name used for `error,` if any.
         *
         * This function is guaranteed to return a D-Bus error name for all
         * #GErrors returned from functions handling remote method calls
         * (e.g. g_dbus_connection_call_finish()) unless
         * g_dbus_error_strip_remote_error() has been used on `error`.
         * @param error a #GError
         */
        static get_remote_error(error: GLib.Error): string | null;
        /**
         * Checks if `error` represents an error received via D-Bus from a remote peer. If so,
         * use g_dbus_error_get_remote_error() to get the name of the error.
         * @param error A #GError.
         */
        static is_remote_error(error: GLib.Error): boolean;
        /**
         * Creates a #GError based on the contents of `dbus_error_name` and
         * `dbus_error_message`.
         *
         * Errors registered with g_dbus_error_register_error() will be looked
         * up using `dbus_error_name` and if a match is found, the error domain
         * and code is used. Applications can use g_dbus_error_get_remote_error()
         * to recover `dbus_error_name`.
         *
         * If a match against a registered error is not found and the D-Bus
         * error name is in a form as returned by g_dbus_error_encode_gerror()
         * the error domain and code encoded in the name is used to
         * create the #GError. Also, `dbus_error_name` is added to the error message
         * such that it can be recovered with g_dbus_error_get_remote_error().
         *
         * Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
         * in the %G_IO_ERROR error domain is returned. Also, `dbus_error_name` is
         * added to the error message such that it can be recovered with
         * g_dbus_error_get_remote_error().
         *
         * In all three cases, `dbus_error_name` can always be recovered from the
         * returned #GError using the g_dbus_error_get_remote_error() function
         * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
         *
         * This function is typically only used in object mappings to prepare
         * #GError instances for applications. Regular applications should not use
         * it.
         * @param dbus_error_name D-Bus error name.
         * @param dbus_error_message D-Bus error message.
         */
        static new_for_dbus_error(dbus_error_name: string, dbus_error_message: string): GLib.Error;
        static quark(): GLib.Quark;
        /**
         * Creates an association to map between `dbus_error_name` and
         * #GErrors specified by `error_domain` and `error_code`.
         *
         * This is typically done in the routine that returns the #GQuark for
         * an error domain.
         * @param error_domain A #GQuark for an error domain.
         * @param error_code An error code.
         * @param dbus_error_name A D-Bus error name.
         */
        static register_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string): boolean;
        /**
         * Helper function for associating a #GError error domain with D-Bus error names.
         *
         * While `quark_volatile` has a `volatile` qualifier, this is a historical
         * artifact and the argument passed to it should not be `volatile`.
         * @param error_domain_quark_name The error domain name.
         * @param quark_volatile A pointer where to store the #GQuark.
         * @param entries A pointer to @num_entries #GDBusErrorEntry struct items.
         */
        static register_error_domain(
            error_domain_quark_name: string,
            quark_volatile: number,
            entries: DBusErrorEntry[],
        ): void;
        /**
         * Does nothing if `error` is %NULL. Otherwise sets *`error` to
         * a new #GError created with g_dbus_error_new_for_dbus_error()
         * with `dbus_error_message` prepend with `format` (unless %NULL).
         * @param error A pointer to a #GError or %NULL.
         * @param dbus_error_name D-Bus error name.
         * @param dbus_error_message D-Bus error message.
         * @param format printf()-style format to prepend to @dbus_error_message or %NULL.
         * @param ___ Arguments for @format.
         */
        static set_dbus_error(
            error: GLib.Error,
            dbus_error_name: string,
            dbus_error_message: string,
            format: string | null,
            ___: any[],
        ): void;
        /**
         * Like g_dbus_error_set_dbus_error() but intended for language bindings.
         * @param error A pointer to a #GError or %NULL.
         * @param dbus_error_name D-Bus error name.
         * @param dbus_error_message D-Bus error message.
         * @param format printf()-style format to prepend to @dbus_error_message or %NULL.
         * @param var_args Arguments for @format.
         */
        static set_dbus_error_valist(
            error: GLib.Error,
            dbus_error_name: string,
            dbus_error_message: string,
            format: string | null,
            var_args: any,
        ): void;
        /**
         * Looks for extra information in the error message used to recover
         * the D-Bus error name and strips it if found. If stripped, the
         * message field in `error` will correspond exactly to what was
         * received on the wire.
         *
         * This is typically used when presenting errors to the end user.
         * @param error A #GError.
         */
        static strip_remote_error(error: GLib.Error): boolean;
        /**
         * Destroys an association previously set up with g_dbus_error_register_error().
         * @param error_domain A #GQuark for an error domain.
         * @param error_code An error code.
         * @param dbus_error_name A D-Bus error name.
         */
        static unregister_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string): boolean;
    }

    /**
     * Enumeration used to describe the byte order of a D-Bus message.
     */

    /**
     * Enumeration used to describe the byte order of a D-Bus message.
     */
    export namespace DBusMessageByteOrder {
        export const $gtype: GObject.GType<DBusMessageByteOrder>;
    }

    enum DBusMessageByteOrder {
        /**
         * The byte order is big endian.
         */
        BIG_ENDIAN,
        /**
         * The byte order is little endian.
         */
        LITTLE_ENDIAN,
    }
    /**
     * Header fields used in #GDBusMessage.
     */

    /**
     * Header fields used in #GDBusMessage.
     */
    export namespace DBusMessageHeaderField {
        export const $gtype: GObject.GType<DBusMessageHeaderField>;
    }

    enum DBusMessageHeaderField {
        /**
         * Not a valid header field.
         */
        INVALID,
        /**
         * The object path.
         */
        PATH,
        /**
         * The interface name.
         */
        INTERFACE,
        /**
         * The method or signal name.
         */
        MEMBER,
        /**
         * The name of the error that occurred.
         */
        ERROR_NAME,
        /**
         * The serial number the message is a reply to.
         */
        REPLY_SERIAL,
        /**
         * The name the message is intended for.
         */
        DESTINATION,
        /**
         * Unique name of the sender of the message (filled in by the bus).
         */
        SENDER,
        /**
         * The signature of the message body.
         */
        SIGNATURE,
        /**
         * The number of UNIX file descriptors that accompany the message.
         */
        NUM_UNIX_FDS,
    }
    /**
     * Message types used in #GDBusMessage.
     */

    /**
     * Message types used in #GDBusMessage.
     */
    export namespace DBusMessageType {
        export const $gtype: GObject.GType<DBusMessageType>;
    }

    enum DBusMessageType {
        /**
         * Message is of invalid type.
         */
        INVALID,
        /**
         * Method call.
         */
        METHOD_CALL,
        /**
         * Method reply.
         */
        METHOD_RETURN,
        /**
         * Error reply.
         */
        ERROR,
        /**
         * Signal emission.
         */
        SIGNAL,
    }
    /**
     * #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
     * across various machine architectures.
     */

    /**
     * #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
     * across various machine architectures.
     */
    export namespace DataStreamByteOrder {
        export const $gtype: GObject.GType<DataStreamByteOrder>;
    }

    enum DataStreamByteOrder {
        /**
         * Selects Big Endian byte order.
         */
        BIG_ENDIAN,
        /**
         * Selects Little Endian byte order.
         */
        LITTLE_ENDIAN,
        /**
         * Selects endianness based on host machine's architecture.
         */
        HOST_ENDIAN,
    }
    /**
     * #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
     */

    /**
     * #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
     */
    export namespace DataStreamNewlineType {
        export const $gtype: GObject.GType<DataStreamNewlineType>;
    }

    enum DataStreamNewlineType {
        /**
         * Selects "LF" line endings, common on most modern UNIX platforms.
         */
        LF,
        /**
         * Selects "CR" line endings.
         */
        CR,
        /**
         * Selects "CR, LF" line ending, common on Microsoft Windows.
         */
        CR_LF,
        /**
         * Automatically try to handle any line ending type.
         */
        ANY,
    }
    /**
     * Enumeration describing how a drive can be started/stopped.
     */

    /**
     * Enumeration describing how a drive can be started/stopped.
     */
    export namespace DriveStartStopType {
        export const $gtype: GObject.GType<DriveStartStopType>;
    }

    enum DriveStartStopType {
        /**
         * Unknown or drive doesn't support
         *    start/stop.
         */
        UNKNOWN,
        /**
         * The stop method will physically
         *    shut down the drive and e.g. power down the port the drive is
         *    attached to.
         */
        SHUTDOWN,
        /**
         * The start/stop methods are used
         *    for connecting/disconnect to the drive over the network.
         */
        NETWORK,
        /**
         * The start/stop methods will
         *    assemble/disassemble a virtual drive from several physical
         *    drives.
         */
        MULTIDISK,
        /**
         * The start/stop methods will
         *    unlock/lock the disk (for example using the ATA <quote>SECURITY
         *    UNLOCK DEVICE</quote> command)
         */
        PASSWORD,
    }
    /**
     * GEmblemOrigin is used to add information about the origin of the emblem
     * to #GEmblem.
     */

    /**
     * GEmblemOrigin is used to add information about the origin of the emblem
     * to #GEmblem.
     */
    export namespace EmblemOrigin {
        export const $gtype: GObject.GType<EmblemOrigin>;
    }

    enum EmblemOrigin {
        /**
         * Emblem of unknown origin
         */
        UNKNOWN,
        /**
         * Emblem adds device-specific information
         */
        DEVICE,
        /**
         * Emblem depicts live metadata, such as "readonly"
         */
        LIVEMETADATA,
        /**
         * Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
         */
        TAG,
    }
    /**
     * Used by g_file_set_attributes_from_info() when setting file attributes.
     */

    /**
     * Used by g_file_set_attributes_from_info() when setting file attributes.
     */
    export namespace FileAttributeStatus {
        export const $gtype: GObject.GType<FileAttributeStatus>;
    }

    enum FileAttributeStatus {
        /**
         * Attribute value is unset (empty).
         */
        UNSET,
        /**
         * Attribute value is set.
         */
        SET,
        /**
         * Indicates an error in setting the value.
         */
        ERROR_SETTING,
    }
    /**
     * The data types for file attributes.
     */

    /**
     * The data types for file attributes.
     */
    export namespace FileAttributeType {
        export const $gtype: GObject.GType<FileAttributeType>;
    }

    enum FileAttributeType {
        /**
         * indicates an invalid or uninitialized type.
         */
        INVALID,
        /**
         * a null terminated UTF8 string.
         */
        STRING,
        /**
         * a zero terminated string of non-zero bytes.
         */
        BYTE_STRING,
        /**
         * a boolean value.
         */
        BOOLEAN,
        /**
         * an unsigned 4-byte/32-bit integer.
         */
        UINT32,
        /**
         * a signed 4-byte/32-bit integer.
         */
        INT32,
        /**
         * an unsigned 8-byte/64-bit integer.
         */
        UINT64,
        /**
         * a signed 8-byte/64-bit integer.
         */
        INT64,
        /**
         * a #GObject.
         */
        OBJECT,
        /**
         * a %NULL terminated char **. Since 2.22
         */
        STRINGV,
    }
    /**
     * Specifies what type of event a monitor event is.
     */

    /**
     * Specifies what type of event a monitor event is.
     */
    export namespace FileMonitorEvent {
        export const $gtype: GObject.GType<FileMonitorEvent>;
    }

    enum FileMonitorEvent {
        /**
         * a file changed.
         */
        CHANGED,
        /**
         * a hint that this was probably the last change in a set of changes.
         */
        CHANGES_DONE_HINT,
        /**
         * a file was deleted.
         */
        DELETED,
        /**
         * a file was created.
         */
        CREATED,
        /**
         * a file attribute was changed.
         */
        ATTRIBUTE_CHANGED,
        /**
         * the file location will soon be unmounted.
         */
        PRE_UNMOUNT,
        /**
         * the file location was unmounted.
         */
        UNMOUNTED,
        /**
         * the file was moved -- only sent if the
         *   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
         */
        MOVED,
        /**
         * the file was renamed within the
         *   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
         *   flag is set.  Since: 2.46.
         */
        RENAMED,
        /**
         * the file was moved into the
         *   monitored directory from another location -- only sent if the
         *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
         */
        MOVED_IN,
        /**
         * the file was moved out of the
         *   monitored directory to another location -- only sent if the
         *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
         */
        MOVED_OUT,
    }
    /**
     * Indicates the file's on-disk type.
     *
     * On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
     * use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
     * whether a file is a symlink or not. This is due to the fact that NTFS does
     * not have a single filesystem object type for symbolic links - it has
     * files that symlink to files, and directories that symlink to directories.
     * #GFileType enumeration cannot precisely represent this important distinction,
     * which is why all Windows symlinks will continue to be reported as
     * %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
     */

    /**
     * Indicates the file's on-disk type.
     *
     * On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
     * use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
     * whether a file is a symlink or not. This is due to the fact that NTFS does
     * not have a single filesystem object type for symbolic links - it has
     * files that symlink to files, and directories that symlink to directories.
     * #GFileType enumeration cannot precisely represent this important distinction,
     * which is why all Windows symlinks will continue to be reported as
     * %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
     */
    export namespace FileType {
        export const $gtype: GObject.GType<FileType>;
    }

    enum FileType {
        /**
         * File's type is unknown.
         */
        UNKNOWN,
        /**
         * File handle represents a regular file.
         */
        REGULAR,
        /**
         * File handle represents a directory.
         */
        DIRECTORY,
        /**
         * File handle represents a symbolic link
         *    (Unix systems).
         */
        SYMBOLIC_LINK,
        /**
         * File is a "special" file, such as a socket, fifo,
         *    block device, or character device.
         */
        SPECIAL,
        /**
         * File is a shortcut (Windows systems).
         */
        SHORTCUT,
        /**
         * File is a mountable location.
         */
        MOUNTABLE,
    }
    /**
     * Indicates a hint from the file system whether files should be
     * previewed in a file manager. Returned as the value of the key
     * %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
     */

    /**
     * Indicates a hint from the file system whether files should be
     * previewed in a file manager. Returned as the value of the key
     * %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
     */
    export namespace FilesystemPreviewType {
        export const $gtype: GObject.GType<FilesystemPreviewType>;
    }

    enum FilesystemPreviewType {
        /**
         * Only preview files if user has explicitly requested it.
         */
        IF_ALWAYS,
        /**
         * Preview files if user has requested preview of "local" files.
         */
        IF_LOCAL,
        /**
         * Never preview files.
         */
        NEVER,
    }
    /**
     * Error codes returned by GIO functions.
     *
     * Note that this domain may be extended in future GLib releases. In
     * general, new error codes either only apply to new APIs, or else
     * replace %G_IO_ERROR_FAILED in cases that were not explicitly
     * distinguished before. You should therefore avoid writing code like
     *
     * ```c
     * if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
     *   {
     *     // Assume that this is EPRINTERONFIRE
     *     ...
     *   }
     * ```
     *
     * but should instead treat all unrecognized error codes the same as
     * %G_IO_ERROR_FAILED.
     *
     * See also #GPollableReturn for a cheaper way of returning
     * %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError.
     */
    class IOErrorEnum extends GLib.Error {
        static $gtype: GObject.GType<IOErrorEnum>;

        // Static fields

        /**
         * Generic error condition for when an operation fails
         *     and no more specific #GIOErrorEnum value is defined.
         */
        static FAILED: number;
        /**
         * File not found.
         */
        static NOT_FOUND: number;
        /**
         * File already exists.
         */
        static EXISTS: number;
        /**
         * File is a directory.
         */
        static IS_DIRECTORY: number;
        /**
         * File is not a directory.
         */
        static NOT_DIRECTORY: number;
        /**
         * File is a directory that isn't empty.
         */
        static NOT_EMPTY: number;
        /**
         * File is not a regular file.
         */
        static NOT_REGULAR_FILE: number;
        /**
         * File is not a symbolic link.
         */
        static NOT_SYMBOLIC_LINK: number;
        /**
         * File cannot be mounted.
         */
        static NOT_MOUNTABLE_FILE: number;
        /**
         * Filename is too many characters.
         */
        static FILENAME_TOO_LONG: number;
        /**
         * Filename is invalid or contains invalid characters.
         */
        static INVALID_FILENAME: number;
        /**
         * File contains too many symbolic links.
         */
        static TOO_MANY_LINKS: number;
        /**
         * No space left on drive.
         */
        static NO_SPACE: number;
        /**
         * Invalid argument.
         */
        static INVALID_ARGUMENT: number;
        /**
         * Permission denied.
         */
        static PERMISSION_DENIED: number;
        /**
         * Operation (or one of its parameters) not supported
         */
        static NOT_SUPPORTED: number;
        /**
         * File isn't mounted.
         */
        static NOT_MOUNTED: number;
        /**
         * File is already mounted.
         */
        static ALREADY_MOUNTED: number;
        /**
         * File was closed.
         */
        static CLOSED: number;
        /**
         * Operation was cancelled. See #GCancellable.
         */
        static CANCELLED: number;
        /**
         * Operations are still pending.
         */
        static PENDING: number;
        /**
         * File is read only.
         */
        static READ_ONLY: number;
        /**
         * Backup couldn't be created.
         */
        static CANT_CREATE_BACKUP: number;
        /**
         * File's Entity Tag was incorrect.
         */
        static WRONG_ETAG: number;
        /**
         * Operation timed out.
         */
        static TIMED_OUT: number;
        /**
         * Operation would be recursive.
         */
        static WOULD_RECURSE: number;
        /**
         * File is busy.
         */
        static BUSY: number;
        /**
         * Operation would block.
         */
        static WOULD_BLOCK: number;
        /**
         * Host couldn't be found (remote operations).
         */
        static HOST_NOT_FOUND: number;
        /**
         * Operation would merge files.
         */
        static WOULD_MERGE: number;
        /**
         * Operation failed and a helper program has
         *     already interacted with the user. Do not display any error dialog.
         */
        static FAILED_HANDLED: number;
        /**
         * The current process has too many files
         *     open and can't open any more. Duplicate descriptors do count toward
         *     this limit. Since 2.20
         */
        static TOO_MANY_OPEN_FILES: number;
        /**
         * The object has not been initialized. Since 2.22
         */
        static NOT_INITIALIZED: number;
        /**
         * The requested address is already in use. Since 2.22
         */
        static ADDRESS_IN_USE: number;
        /**
         * Need more input to finish operation. Since 2.24
         */
        static PARTIAL_INPUT: number;
        /**
         * The input data was invalid. Since 2.24
         */
        static INVALID_DATA: number;
        /**
         * A remote object generated an error that
         *     doesn't correspond to a locally registered #GError error
         *     domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
         *     error name and g_dbus_error_strip_remote_error() to fix up the
         *     message so it matches what was received on the wire. Since 2.26.
         */
        static DBUS_ERROR: number;
        /**
         * Host unreachable. Since 2.26
         */
        static HOST_UNREACHABLE: number;
        /**
         * Network unreachable. Since 2.26
         */
        static NETWORK_UNREACHABLE: number;
        /**
         * Connection refused. Since 2.26
         */
        static CONNECTION_REFUSED: number;
        /**
         * Connection to proxy server failed. Since 2.26
         */
        static PROXY_FAILED: number;
        /**
         * Proxy authentication failed. Since 2.26
         */
        static PROXY_AUTH_FAILED: number;
        /**
         * Proxy server needs authentication. Since 2.26
         */
        static PROXY_NEED_AUTH: number;
        /**
         * Proxy connection is not allowed by ruleset.
         *     Since 2.26
         */
        static PROXY_NOT_ALLOWED: number;
        /**
         * Broken pipe. Since 2.36
         */
        static BROKEN_PIPE: number;
        /**
         * Connection closed by peer. Note that this
         *     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
         *     "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
         *     returned %G_IO_ERROR_FAILED. Now they should all return the same
         *     value, which has this more logical name. Since 2.44.
         */
        static CONNECTION_CLOSED: number;
        /**
         * Transport endpoint is not connected. Since 2.44
         */
        static NOT_CONNECTED: number;
        /**
         * Message too large. Since 2.48.
         */
        static MESSAGE_TOO_LARGE: number;
        /**
         * No such device found. Since 2.74
         */
        static NO_SUCH_DEVICE: number;
        /**
         * Destination address unset. Since 2.80
         */
        static DESTINATION_UNSET: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    /**
     * Flags for use with g_io_module_scope_new().
     */

    /**
     * Flags for use with g_io_module_scope_new().
     */
    export namespace IOModuleScopeFlags {
        export const $gtype: GObject.GType<IOModuleScopeFlags>;
    }

    enum IOModuleScopeFlags {
        /**
         * No module scan flags
         */
        NONE,
        /**
         * When using this scope to load or
         *     scan modules, automatically block a modules which has the same base
         *     basename as previously loaded module.
         */
        BLOCK_DUPLICATES,
    }
    /**
     * Memory availability warning levels.
     *
     * Note that because new values might be added, it is recommended that applications check
     * #GMemoryMonitorWarningLevel as ranges, for example:
     *
     * ```c
     * if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
     *   drop_caches ();
     * ```
     *
     */

    /**
     * Memory availability warning levels.
     *
     * Note that because new values might be added, it is recommended that applications check
     * #GMemoryMonitorWarningLevel as ranges, for example:
     *
     * ```c
     * if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
     *   drop_caches ();
     * ```
     *
     */
    export namespace MemoryMonitorWarningLevel {
        export const $gtype: GObject.GType<MemoryMonitorWarningLevel>;
    }

    enum MemoryMonitorWarningLevel {
        /**
         * Memory on the device is low, processes
         *   should free up unneeded resources (for example, in-memory caches) so they can
         *   be used elsewhere.
         */
        LOW,
        /**
         * Same as `G_MEMORY_MONITOR_WARNING_LEVEL_LOW`
         *   but the device has even less free memory, so processes should try harder to free
         *   up unneeded resources. If your process does not need to stay running, it is a
         *   good time for it to quit.
         */
        MEDIUM,
        /**
         * The system will soon start terminating
         *   processes to reclaim memory, including background processes.
         */
        CRITICAL,
    }
    /**
     * #GMountOperationResult is returned as a result when a request for
     * information is send by the mounting operation.
     */

    /**
     * #GMountOperationResult is returned as a result when a request for
     * information is send by the mounting operation.
     */
    export namespace MountOperationResult {
        export const $gtype: GObject.GType<MountOperationResult>;
    }

    enum MountOperationResult {
        /**
         * The request was fulfilled and the
         *     user specified data is now available
         */
        HANDLED,
        /**
         * The user requested the mount operation
         *     to be aborted
         */
        ABORTED,
        /**
         * The request was unhandled (i.e. not
         *     implemented)
         */
        UNHANDLED,
    }
    /**
     * The host's network connectivity state, as reported by #GNetworkMonitor.
     */

    /**
     * The host's network connectivity state, as reported by #GNetworkMonitor.
     */
    export namespace NetworkConnectivity {
        export const $gtype: GObject.GType<NetworkConnectivity>;
    }

    enum NetworkConnectivity {
        /**
         * The host is not configured with a
         *   route to the Internet; it may or may not be connected to a local
         *   network.
         */
        LOCAL,
        /**
         * The host is connected to a network, but
         *   does not appear to be able to reach the full Internet, perhaps
         *   due to upstream network problems.
         */
        LIMITED,
        /**
         * The host is behind a captive portal and
         *   cannot reach the full Internet.
         */
        PORTAL,
        /**
         * The host is connected to a network, and
         *   appears to be able to reach the full Internet.
         */
        FULL,
    }
    /**
     * Priority levels for #GNotifications.
     */

    /**
     * Priority levels for #GNotifications.
     */
    export namespace NotificationPriority {
        export const $gtype: GObject.GType<NotificationPriority>;
    }

    enum NotificationPriority {
        /**
         * the default priority, to be used for the
         *   majority of notifications (for example email messages, software updates,
         *   completed download/sync operations)
         */
        NORMAL,
        /**
         * for notifications that do not require
         *   immediate attention - typically used for contextual background
         *   information, such as contact birthdays or local weather
         */
        LOW,
        /**
         * for events that require more attention,
         *   usually because responses are time-sensitive (for example chat and SMS
         *   messages or alarms)
         */
        HIGH,
        /**
         * for urgent notifications, or notifications
         *   that require a response in a short space of time (for example phone calls
         *   or emergency warnings)
         */
        URGENT,
    }
    /**
     * #GPasswordSave is used to indicate the lifespan of a saved password.
     *
     * #Gvfs stores passwords in the Gnome keyring when this flag allows it
     * to, and later retrieves it again from there.
     */

    /**
     * #GPasswordSave is used to indicate the lifespan of a saved password.
     *
     * #Gvfs stores passwords in the Gnome keyring when this flag allows it
     * to, and later retrieves it again from there.
     */
    export namespace PasswordSave {
        export const $gtype: GObject.GType<PasswordSave>;
    }

    enum PasswordSave {
        /**
         * never save a password.
         */
        NEVER,
        /**
         * save a password for the session.
         */
        FOR_SESSION,
        /**
         * save a password permanently.
         */
        PERMANENTLY,
    }
    /**
     * Return value for various IO operations that signal errors via the
     * return value and not necessarily via a #GError.
     *
     * This enum exists to be able to return errors to callers without having to
     * allocate a #GError. Allocating #GErrors can be quite expensive for
     * regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
     *
     * In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
     * operation to give details about the error that happened.
     */

    /**
     * Return value for various IO operations that signal errors via the
     * return value and not necessarily via a #GError.
     *
     * This enum exists to be able to return errors to callers without having to
     * allocate a #GError. Allocating #GErrors can be quite expensive for
     * regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
     *
     * In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
     * operation to give details about the error that happened.
     */
    export namespace PollableReturn {
        export const $gtype: GObject.GType<PollableReturn>;
    }

    enum PollableReturn {
        /**
         * Generic error condition for when an operation fails.
         */
        FAILED,
        /**
         * The operation was successfully finished.
         */
        OK,
        /**
         * The operation would block.
         */
        WOULD_BLOCK,
    }
    /**
     * An error code used with %G_RESOLVER_ERROR in a #GError returned
     * from a #GResolver routine.
     */
    class ResolverError extends GLib.Error {
        static $gtype: GObject.GType<ResolverError>;

        // Static fields

        /**
         * the requested name/address/service was not
         *     found
         */
        static NOT_FOUND: number;
        /**
         * the requested information could not
         *     be looked up due to a network error or similar problem
         */
        static TEMPORARY_FAILURE: number;
        /**
         * unknown error
         */
        static INTERNAL: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets the #GResolver Error Quark.
         */
        static quark(): GLib.Quark;
    }

    /**
     * The type of record that g_resolver_lookup_records() or
     * g_resolver_lookup_records_async() should retrieve. The records are returned
     * as lists of #GVariant tuples. Each record type has different values in
     * the variant tuples returned.
     *
     * %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
     * `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
     * weight, a `guint16` with the port, and a string of the hostname.
     *
     * %G_RESOLVER_RECORD_MX records are returned as variants with the signature
     * `(qs)`, representing a `guint16` with the preference, and a string containing
     * the mail exchanger hostname.
     *
     * %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
     * `(as)`, representing an array of the strings in the text record. Note: Most TXT
     * records only contain a single string, but
     * [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
     * record to contain multiple strings. The RFC which defines the interpretation
     * of a specific TXT record will likely require concatenation of multiple
     * strings if they are present, as with
     * [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
     *
     * %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
     * `(ssuuuuu)`, representing a string containing the primary name server, a
     * string containing the administrator, the serial as a `guint32`, the refresh
     * interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
     * as a `guint32`, and the TTL as a `guint32`.
     *
     * %G_RESOLVER_RECORD_NS records are returned as variants with the signature
     * `(s)`, representing a string of the hostname of the name server.
     */

    /**
     * The type of record that g_resolver_lookup_records() or
     * g_resolver_lookup_records_async() should retrieve. The records are returned
     * as lists of #GVariant tuples. Each record type has different values in
     * the variant tuples returned.
     *
     * %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
     * `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
     * weight, a `guint16` with the port, and a string of the hostname.
     *
     * %G_RESOLVER_RECORD_MX records are returned as variants with the signature
     * `(qs)`, representing a `guint16` with the preference, and a string containing
     * the mail exchanger hostname.
     *
     * %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
     * `(as)`, representing an array of the strings in the text record. Note: Most TXT
     * records only contain a single string, but
     * [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
     * record to contain multiple strings. The RFC which defines the interpretation
     * of a specific TXT record will likely require concatenation of multiple
     * strings if they are present, as with
     * [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
     *
     * %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
     * `(ssuuuuu)`, representing a string containing the primary name server, a
     * string containing the administrator, the serial as a `guint32`, the refresh
     * interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
     * as a `guint32`, and the TTL as a `guint32`.
     *
     * %G_RESOLVER_RECORD_NS records are returned as variants with the signature
     * `(s)`, representing a string of the hostname of the name server.
     */
    export namespace ResolverRecordType {
        export const $gtype: GObject.GType<ResolverRecordType>;
    }

    enum ResolverRecordType {
        /**
         * look up DNS SRV records for a domain
         */
        SRV,
        /**
         * look up DNS MX records for a domain
         */
        MX,
        /**
         * look up DNS TXT records for a name
         */
        TXT,
        /**
         * look up DNS SOA records for a zone
         */
        SOA,
        /**
         * look up DNS NS records for a domain
         */
        NS,
    }
    /**
     * An error code used with %G_RESOURCE_ERROR in a #GError returned
     * from a #GResource routine.
     */
    class ResourceError extends GLib.Error {
        static $gtype: GObject.GType<ResourceError>;

        // Static fields

        /**
         * no file was found at the requested path
         */
        static NOT_FOUND: number;
        /**
         * unknown error
         */
        static INTERNAL: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets the #GResource Error Quark.
         */
        static quark(): GLib.Quark;
    }

    /**
     * Describes an event occurring on a #GSocketClient. See the
     * #GSocketClient::event signal for more details.
     *
     * Additional values may be added to this type in the future.
     */

    /**
     * Describes an event occurring on a #GSocketClient. See the
     * #GSocketClient::event signal for more details.
     *
     * Additional values may be added to this type in the future.
     */
    export namespace SocketClientEvent {
        export const $gtype: GObject.GType<SocketClientEvent>;
    }

    enum SocketClientEvent {
        /**
         * The client is doing a DNS lookup.
         */
        RESOLVING,
        /**
         * The client has completed a DNS lookup.
         */
        RESOLVED,
        /**
         * The client is connecting to a remote
         *   host (either a proxy or the destination server).
         */
        CONNECTING,
        /**
         * The client has connected to a remote
         *   host.
         */
        CONNECTED,
        /**
         * The client is negotiating
         *   with a proxy to connect to the destination server.
         */
        PROXY_NEGOTIATING,
        /**
         * The client has negotiated
         *   with the proxy server.
         */
        PROXY_NEGOTIATED,
        /**
         * The client is performing a
         *   TLS handshake.
         */
        TLS_HANDSHAKING,
        /**
         * The client has performed a
         *   TLS handshake.
         */
        TLS_HANDSHAKED,
        /**
         * The client is done with a particular
         *   #GSocketConnectable.
         */
        COMPLETE,
    }
    /**
     * The protocol family of a #GSocketAddress. (These values are
     * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
     * if available.)
     */

    /**
     * The protocol family of a #GSocketAddress. (These values are
     * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
     * if available.)
     */
    export namespace SocketFamily {
        export const $gtype: GObject.GType<SocketFamily>;
    }

    enum SocketFamily {
        /**
         * no address family
         */
        INVALID,
        /**
         * the UNIX domain family
         */
        UNIX,
        /**
         * the IPv4 family
         */
        IPV4,
        /**
         * the IPv6 family
         */
        IPV6,
    }
    /**
     * Describes an event occurring on a #GSocketListener. See the
     * #GSocketListener::event signal for more details.
     *
     * Additional values may be added to this type in the future.
     */

    /**
     * Describes an event occurring on a #GSocketListener. See the
     * #GSocketListener::event signal for more details.
     *
     * Additional values may be added to this type in the future.
     */
    export namespace SocketListenerEvent {
        export const $gtype: GObject.GType<SocketListenerEvent>;
    }

    enum SocketListenerEvent {
        /**
         * The listener is about to bind a socket.
         */
        BINDING,
        /**
         * The listener has bound a socket.
         */
        BOUND,
        /**
         * The listener is about to start
         *    listening on this socket.
         */
        LISTENING,
        /**
         * The listener is now listening on
         *   this socket.
         */
        LISTENED,
    }
    /**
     * A protocol identifier is specified when creating a #GSocket, which is a
     * family/type specific identifier, where 0 means the default protocol for
     * the particular family/type.
     *
     * This enum contains a set of commonly available and used protocols. You
     * can also pass any other identifiers handled by the platform in order to
     * use protocols not listed here.
     */

    /**
     * A protocol identifier is specified when creating a #GSocket, which is a
     * family/type specific identifier, where 0 means the default protocol for
     * the particular family/type.
     *
     * This enum contains a set of commonly available and used protocols. You
     * can also pass any other identifiers handled by the platform in order to
     * use protocols not listed here.
     */
    export namespace SocketProtocol {
        export const $gtype: GObject.GType<SocketProtocol>;
    }

    enum SocketProtocol {
        /**
         * The protocol type is unknown
         */
        UNKNOWN,
        /**
         * The default protocol for the family/type
         */
        DEFAULT,
        /**
         * TCP over IP
         */
        TCP,
        /**
         * UDP over IP
         */
        UDP,
        /**
         * SCTP over IP
         */
        SCTP,
    }
    /**
     * Flags used when creating a #GSocket. Some protocols may not implement
     * all the socket types.
     */

    /**
     * Flags used when creating a #GSocket. Some protocols may not implement
     * all the socket types.
     */
    export namespace SocketType {
        export const $gtype: GObject.GType<SocketType>;
    }

    enum SocketType {
        /**
         * Type unknown or wrong
         */
        INVALID,
        /**
         * Reliable connection-based byte streams (e.g. TCP).
         */
        STREAM,
        /**
         * Connectionless, unreliable datagram passing.
         *     (e.g. UDP)
         */
        DATAGRAM,
        /**
         * Reliable connection-based passing of datagrams
         *     of fixed maximum length (e.g. SCTP).
         */
        SEQPACKET,
    }
    /**
     * The client authentication mode for a #GTlsServerConnection.
     */

    /**
     * The client authentication mode for a #GTlsServerConnection.
     */
    export namespace TlsAuthenticationMode {
        export const $gtype: GObject.GType<TlsAuthenticationMode>;
    }

    enum TlsAuthenticationMode {
        /**
         * client authentication not required
         */
        NONE,
        /**
         * client authentication is requested
         */
        REQUESTED,
        /**
         * client authentication is required
         */
        REQUIRED,
    }
    /**
     * Flags for g_tls_interaction_request_certificate(),
     * g_tls_interaction_request_certificate_async(), and
     * g_tls_interaction_invoke_request_certificate().
     */

    /**
     * Flags for g_tls_interaction_request_certificate(),
     * g_tls_interaction_request_certificate_async(), and
     * g_tls_interaction_invoke_request_certificate().
     */
    export namespace TlsCertificateRequestFlags {
        export const $gtype: GObject.GType<TlsCertificateRequestFlags>;
    }

    enum TlsCertificateRequestFlags {
        /**
         * No flags
         */
        NONE,
    }
    /**
     * An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
     * indicate a TLS channel binding retrieval error.
     */
    class TlsChannelBindingError extends GLib.Error {
        static $gtype: GObject.GType<TlsChannelBindingError>;

        // Static fields

        /**
         * Either entire binding
         *    retrieval facility or specific binding type is not implemented in the
         *    TLS backend.
         */
        static NOT_IMPLEMENTED: number;
        /**
         * The handshake is not yet
         *    complete on the connection which is a strong requirement for any existing
         *    binding type.
         */
        static INVALID_STATE: number;
        /**
         * Handshake is complete but
         *    binding data is not available. That normally indicates the TLS
         *    implementation failed to provide the binding data. For example, some
         *    implementations do not provide a peer certificate for resumed connections.
         */
        static NOT_AVAILABLE: number;
        /**
         * Binding type is not supported
         *    on the current connection. This error could be triggered when requesting
         *    `tls-server-end-point` binding data for a certificate which has no hash
         *    function or uses multiple hash functions.
         */
        static NOT_SUPPORTED: number;
        /**
         * Any other backend error
         *    preventing binding data retrieval.
         */
        static GENERAL_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets the TLS channel binding error quark.
         */
        static quark(): GLib.Quark;
    }

    /**
     * The type of TLS channel binding data to retrieve from #GTlsConnection
     * or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
     * [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
     * binding type is not currently implemented.
     */

    /**
     * The type of TLS channel binding data to retrieve from #GTlsConnection
     * or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
     * [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
     * binding type is not currently implemented.
     */
    export namespace TlsChannelBindingType {
        export const $gtype: GObject.GType<TlsChannelBindingType>;
    }

    enum TlsChannelBindingType {
        /**
         * [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
         *    type
         */
        UNIQUE,
        /**
         * [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
         *    binding type
         */
        SERVER_END_POINT,
        /**
         * [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
         *    type. Since: 2.74
         */
        EXPORTER,
    }
    /**
     * Flags for g_tls_database_lookup_certificate_for_handle(),
     * g_tls_database_lookup_certificate_issuer(),
     * and g_tls_database_lookup_certificates_issued_by().
     */

    /**
     * Flags for g_tls_database_lookup_certificate_for_handle(),
     * g_tls_database_lookup_certificate_issuer(),
     * and g_tls_database_lookup_certificates_issued_by().
     */
    export namespace TlsDatabaseLookupFlags {
        export const $gtype: GObject.GType<TlsDatabaseLookupFlags>;
    }

    enum TlsDatabaseLookupFlags {
        /**
         * No lookup flags
         */
        NONE,
        /**
         * Restrict lookup to certificates that have
         *     a private key.
         */
        KEYPAIR,
    }
    /**
     * An error code used with %G_TLS_ERROR in a #GError returned from a
     * TLS-related routine.
     */
    class TlsError extends GLib.Error {
        static $gtype: GObject.GType<TlsError>;

        // Static fields

        /**
         * No TLS provider is available
         */
        static UNAVAILABLE: number;
        /**
         * Miscellaneous TLS error
         */
        static MISC: number;
        /**
         * The certificate presented could not
         *   be parsed or failed validation.
         */
        static BAD_CERTIFICATE: number;
        /**
         * The TLS handshake failed because the
         *   peer does not seem to be a TLS server.
         */
        static NOT_TLS: number;
        /**
         * The TLS handshake failed because the
         *   peer's certificate was not acceptable.
         */
        static HANDSHAKE: number;
        /**
         * The TLS handshake failed because
         *   the server requested a client-side certificate, but none was
         *   provided. See g_tls_connection_set_certificate().
         */
        static CERTIFICATE_REQUIRED: number;
        /**
         * The TLS connection was closed without proper
         *   notice, which may indicate an attack. See
         *   g_tls_connection_set_require_close_notify().
         */
        static EOF: number;
        /**
         * The TLS handshake failed
         *   because the client sent the fallback SCSV, indicating a protocol
         *   downgrade attack. Since: 2.60
         */
        static INAPPROPRIATE_FALLBACK: number;
        /**
         * The certificate failed
         *   to load because a password was incorrect. Since: 2.72
         */
        static BAD_CERTIFICATE_PASSWORD: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets the TLS error quark.
         */
        static quark(): GLib.Quark;
    }

    /**
     * #GTlsInteractionResult is returned by various functions in #GTlsInteraction
     * when finishing an interaction request.
     */

    /**
     * #GTlsInteractionResult is returned by various functions in #GTlsInteraction
     * when finishing an interaction request.
     */
    export namespace TlsInteractionResult {
        export const $gtype: GObject.GType<TlsInteractionResult>;
    }

    enum TlsInteractionResult {
        /**
         * The interaction was unhandled (i.e. not
         *     implemented).
         */
        UNHANDLED,
        /**
         * The interaction completed, and resulting data
         *     is available.
         */
        HANDLED,
        /**
         * The interaction has failed, or was cancelled.
         *     and the operation should be aborted.
         */
        FAILED,
    }
    /**
     * The TLS or DTLS protocol version used by a #GTlsConnection or
     * #GDtlsConnection. The integer values of these versions are sequential
     * to ensure newer known protocol versions compare greater than older
     * known versions. Any known DTLS protocol version will compare greater
     * than any SSL or TLS protocol version. The protocol version may be
     * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
     * protocol version that GLib does not yet know about. This means that
     * it's possible for an unknown DTLS protocol version to compare less
     * than the TLS protocol versions.
     */

    /**
     * The TLS or DTLS protocol version used by a #GTlsConnection or
     * #GDtlsConnection. The integer values of these versions are sequential
     * to ensure newer known protocol versions compare greater than older
     * known versions. Any known DTLS protocol version will compare greater
     * than any SSL or TLS protocol version. The protocol version may be
     * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
     * protocol version that GLib does not yet know about. This means that
     * it's possible for an unknown DTLS protocol version to compare less
     * than the TLS protocol versions.
     */
    export namespace TlsProtocolVersion {
        export const $gtype: GObject.GType<TlsProtocolVersion>;
    }

    enum TlsProtocolVersion {
        /**
         * No protocol version or unknown protocol version
         */
        UNKNOWN,
        /**
         * SSL 3.0, which is insecure and should not be used
         */
        SSL_3_0,
        /**
         * TLS 1.0, which is insecure and should not be used
         */
        TLS_1_0,
        /**
         * TLS 1.1, which is insecure and should not be used
         */
        TLS_1_1,
        /**
         * TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
         */
        TLS_1_2,
        /**
         * TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
         */
        TLS_1_3,
        /**
         * DTLS 1.0, which is insecure and should not be used
         */
        DTLS_1_0,
        /**
         * DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
         */
        DTLS_1_2,
    }
    /**
     * When to allow rehandshaking. See
     * g_tls_connection_set_rehandshake_mode().
     */

    /**
     * When to allow rehandshaking. See
     * g_tls_connection_set_rehandshake_mode().
     */
    export namespace TlsRehandshakeMode {
        export const $gtype: GObject.GType<TlsRehandshakeMode>;
    }

    enum TlsRehandshakeMode {
        /**
         * Never allow rehandshaking
         */
        NEVER,
        /**
         * Allow safe rehandshaking only
         */
        SAFELY,
        /**
         * Allow unsafe rehandshaking
         */
        UNSAFELY,
    }
    /**
     * The type of name used by a #GUnixSocketAddress.
     * %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
     * socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
     * indicates a socket not bound to any name (eg, a client-side socket,
     * or a socket created with socketpair()).
     *
     * For abstract sockets, there are two incompatible ways of naming
     * them; the man pages suggest using the entire `struct sockaddr_un`
     * as the name, padding the unused parts of the %sun_path field with
     * zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
     * However, many programs instead just use a portion of %sun_path, and
     * pass an appropriate smaller length to bind() or connect(). This is
     * %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
     */

    /**
     * The type of name used by a #GUnixSocketAddress.
     * %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
     * socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
     * indicates a socket not bound to any name (eg, a client-side socket,
     * or a socket created with socketpair()).
     *
     * For abstract sockets, there are two incompatible ways of naming
     * them; the man pages suggest using the entire `struct sockaddr_un`
     * as the name, padding the unused parts of the %sun_path field with
     * zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
     * However, many programs instead just use a portion of %sun_path, and
     * pass an appropriate smaller length to bind() or connect(). This is
     * %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
     */
    export namespace UnixSocketAddressType {
        export const $gtype: GObject.GType<UnixSocketAddressType>;
    }

    enum UnixSocketAddressType {
        /**
         * invalid
         */
        INVALID,
        /**
         * anonymous
         */
        ANONYMOUS,
        /**
         * a filesystem path
         */
        PATH,
        /**
         * an abstract name
         */
        ABSTRACT,
        /**
         * an abstract name, 0-padded
         *   to the full length of a unix socket name
         */
        ABSTRACT_PADDED,
    }
    /**
     * Used to select the type of data format to use for #GZlibDecompressor
     * and #GZlibCompressor.
     */

    /**
     * Used to select the type of data format to use for #GZlibDecompressor
     * and #GZlibCompressor.
     */
    export namespace ZlibCompressorFormat {
        export const $gtype: GObject.GType<ZlibCompressorFormat>;
    }

    enum ZlibCompressorFormat {
        /**
         * deflate compression with zlib header
         */
        ZLIB,
        /**
         * gzip file format
         */
        GZIP,
        /**
         * deflate compression with no header
         */
        RAW,
    }
    /**
     * The value returned by handlers of the signals generated by
     * the `gdbus-codegen` tool to indicate that a method call has been
     * handled by an implementation. It is equal to %TRUE, but using
     * this macro is sometimes more readable.
     *
     * In code that needs to be backwards-compatible with older GLib,
     * use %TRUE instead, often written like this:
     *
     *
     * ```
     *   g_dbus_method_invocation_return_error (invocation, ...);
     *   return TRUE;    // handled
     * ```
     *
     */
    const DBUS_METHOD_INVOCATION_HANDLED: boolean;
    /**
     * The value returned by handlers of the signals generated by
     * the `gdbus-codegen` tool to indicate that a method call has not been
     * handled by an implementation. It is equal to %FALSE, but using
     * this macro is sometimes more readable.
     *
     * In code that needs to be backwards-compatible with older GLib,
     * use %FALSE instead.
     */
    const DBUS_METHOD_INVOCATION_UNHANDLED: boolean;
    /**
     * Extension point for debug control functionality.
     * See [Extending GIO][extending-gio].
     */
    const DEBUG_CONTROLLER_EXTENSION_POINT_NAME: string;
    /**
     * Extension point for default handler to URI association. See
     * [Extending GIO][extending-gio].
     */
    const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: string;
    /**
     * The string used to obtain a Unix device path with g_drive_get_identifier().
     */
    const DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: string;
    /**
     * A key in the "access" namespace for checking deletion privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to delete the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_DELETE: string;
    /**
     * A key in the "access" namespace for getting execution privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to execute the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: string;
    /**
     * A key in the "access" namespace for getting read privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to read the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_READ: string;
    /**
     * A key in the "access" namespace for checking renaming privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to rename the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_RENAME: string;
    /**
     * A key in the "access" namespace for checking trashing privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to move the file to
     * the trash.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_TRASH: string;
    /**
     * A key in the "access" namespace for getting write privileges.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     *
     * This attribute will be %TRUE if the user is able to write to the file.
     */
    const FILE_ATTRIBUTE_ACCESS_CAN_WRITE: string;
    /**
     * A key in the "dos" namespace for checking if the file's archive flag
     * is set.
     *
     * This attribute is %TRUE if the archive flag is set.
     *
     * This attribute is only available for DOS file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_DOS_IS_ARCHIVE: string;
    /**
     * A key in the "dos" namespace for checking if the file is a NTFS mount point
     * (a volume mount or a junction point).
     *
     * This attribute is %TRUE if file is a reparse point of type
     * [IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
     *
     * This attribute is only available for DOS file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: string;
    /**
     * A key in the "dos" namespace for checking if the file's backup flag
     * is set.
     *
     * This attribute is %TRUE if the backup flag is set.
     *
     * This attribute is only available for DOS file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_DOS_IS_SYSTEM: string;
    /**
     * A key in the "dos" namespace for getting the file NTFS reparse tag.
     *
     * This value is 0 for files that are not reparse points.
     *
     * See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
     * page for possible reparse tag values.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: string;
    /**
     * A key in the "etag" namespace for getting the value of the file's
     * entity tag.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_ETAG_VALUE: string;
    /**
     * A key in the "filesystem" namespace for getting the number of bytes
     * of free space left on the file system.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_FREE: string;
    /**
     * A key in the "filesystem" namespace for checking if the file system
     * is read only.
     *
     * Is set to %TRUE if the file system is read only.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_READONLY: string;
    /**
     * A key in the "filesystem" namespace for checking if the file system
     * is remote.
     *
     * Is set to %TRUE if the file system is remote.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_REMOTE: string;
    /**
     * A key in the "filesystem" namespace for getting the total size (in
     * bytes) of the file system, used in g_file_query_filesystem_info().
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_SIZE: string;
    /**
     * A key in the "filesystem" namespace for getting the file system's type.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_TYPE: string;
    /**
     * A key in the "filesystem" namespace for getting the number of bytes
     * used by data on the file system.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_USED: string;
    /**
     * A key in the "filesystem" namespace for hinting a file manager
     * application whether it should preview (e.g. thumbnail) files on the
     * file system.
     *
     * The value for this key contain a #GFilesystemPreviewType.
     */
    const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: string;
    /**
     * A key in the "gvfs" namespace that gets the name of the current
     * GVFS backend in use.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_GVFS_BACKEND: string;
    /**
     * A key in the "id" namespace for getting a file identifier.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * An example use would be during listing files, to avoid recursive
     * directory scanning.
     */
    const FILE_ATTRIBUTE_ID_FILE: string;
    /**
     * A key in the "id" namespace for getting the file system identifier.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * An example use would be during drag and drop to see if the source
     * and target are on the same filesystem (default to move) or not (default
     * to copy).
     */
    const FILE_ATTRIBUTE_ID_FILESYSTEM: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be ejected.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) is mountable.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be polled.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be started.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_START: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be started degraded.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) can be stopped.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE)  is unmountable.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: string;
    /**
     * A key in the "mountable" namespace for getting the HAL UDI for the mountable
     * file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: string;
    /**
     * A key in the "mountable" namespace for checking if a file (of
     * type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: string;
    /**
     * A key in the "mountable" namespace for getting the #GDriveStartStopType.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: string;
    /**
     * A key in the "mountable" namespace for getting the unix device.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: string;
    /**
     * A key in the "mountable" namespace for getting the unix device file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: string;
    /**
     * A key in the "owner" namespace for getting the file owner's group.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_OWNER_GROUP: string;
    /**
     * A key in the "owner" namespace for getting the user name of the
     * file's owner.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_OWNER_USER: string;
    /**
     * A key in the "owner" namespace for getting the real name of the
     * user that owns the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_OWNER_USER_REAL: string;
    /**
     * A key in the "preview" namespace for getting a #GIcon that can be
     * used to get preview of the file.
     *
     * For example, it may be a low resolution thumbnail without metadata.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
     *
     * The value for this key should contain a #GIcon.
     */
    const FILE_ATTRIBUTE_PREVIEW_ICON: string;
    /**
     * A key in the "recent" namespace for getting time, when the metadata for the
     * file in `recent:///` was last changed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT64.
     */
    const FILE_ATTRIBUTE_RECENT_MODIFIED: string;
    /**
     * A key in the "selinux" namespace for getting the file's SELinux
     * context.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * Note that this attribute is only available if GLib has been built
     * with SELinux support.
     */
    const FILE_ATTRIBUTE_SELINUX_CONTEXT: string;
    /**
     * A key in the "standard" namespace for getting the amount of disk space
     * that is consumed by the file (in bytes).
     *
     * This will generally be larger than the file size (due to block size
     * overhead) but can occasionally be smaller (for example, for sparse files).
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: string;
    /**
     * A key in the "standard" namespace for getting the content type of the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     *
     * The value for this key should contain a valid content type.
     */
    const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: string;
    /**
     * A key in the "standard" namespace for getting the copy name of the file.
     *
     * The copy name is an optional version of the name. If available it's always
     * in UTF8, and corresponds directly to the original filename (only transcoded to
     * UTF8). This is useful if you want to copy the file to another filesystem that
     * might have a different encoding. If the filename is not a valid string in the
     * encoding selected for the filesystem it is in then the copy name will not be set.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_COPY_NAME: string;
    /**
     * A key in the "standard" namespace for getting the description of the file.
     *
     * The description is a utf8 string that describes the file, generally containing
     * the filename, but can also contain further information. Example descriptions
     * could be "filename (on hostname)" for a remote file or "filename (in trash)"
     * for a file in the trash. This is useful for instance as the window title
     * when displaying a directory or for a bookmarks menu.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_DESCRIPTION: string;
    /**
     * A key in the "standard" namespace for getting the display name of the file.
     *
     * A display name is guaranteed to be in UTF-8 and can thus be displayed in
     * the UI. It is guaranteed to be set on every file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: string;
    /**
     * A key in the "standard" namespace for edit name of the file.
     *
     * An edit name is similar to the display name, but it is meant to be
     * used when you want to rename the file in the UI. The display name
     * might contain information you don't want in the new filename (such as
     * "(invalid unicode)" if the filename was in an invalid encoding).
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_EDIT_NAME: string;
    /**
     * A key in the "standard" namespace for getting the fast content type.
     *
     * The fast content type isn't as reliable as the regular one, as it
     * only uses the filename to guess it, but it is faster to calculate than the
     * regular content type.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: string;
    /**
     * A key in the "standard" namespace for getting the icon for the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
     *
     * The value for this key should contain a #GIcon.
     */
    const FILE_ATTRIBUTE_STANDARD_ICON: string;
    /**
     * A key in the "standard" namespace for checking if a file is a backup file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_BACKUP: string;
    /**
     * A key in the "standard" namespace for checking if a file is hidden.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: string;
    /**
     * A key in the "standard" namespace for checking if the file is a symlink.
     * Typically the actual type is something else, if we followed the symlink
     * to get the type.
     *
     * On Windows NTFS mountpoints are considered to be symlinks as well.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: string;
    /**
     * A key in the "standard" namespace for checking if a file is virtual.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: string;
    /**
     * A key in the "standard" namespace for checking if a file is
     * volatile. This is meant for opaque, non-POSIX-like backends to
     * indicate that the URI is not persistent. Applications should look
     * at %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: string;
    /**
     * A key in the "standard" namespace for getting the name of the file.
     *
     * The name is the on-disk filename which may not be in any known encoding,
     * and can thus not be generally displayed as is. It is guaranteed to be set on
     * every file.
     *
     * Use %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
     * name in a user interface.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_NAME: string;
    /**
     * A key in the "standard" namespace for getting the file's size (in bytes).
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_STANDARD_SIZE: string;
    /**
     * A key in the "standard" namespace for setting the sort order of a file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
     *
     * An example use would be in file managers, which would use this key
     * to set the order files are displayed. Files with smaller sort order
     * should be sorted first, and files without sort order as if sort order
     * was zero.
     */
    const FILE_ATTRIBUTE_STANDARD_SORT_ORDER: string;
    /**
     * A key in the "standard" namespace for getting the symbolic icon for the file.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
     *
     * The value for this key should contain a #GIcon.
     */
    const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: string;
    /**
     * A key in the "standard" namespace for getting the symlink target, if the file
     * is a symlink.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: string;
    /**
     * A key in the "standard" namespace for getting the target URI for the file, in
     * the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_STANDARD_TARGET_URI: string;
    /**
     * A key in the "standard" namespace for storing file types.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     *
     * The value for this key should contain a #GFileType.
     */
    const FILE_ATTRIBUTE_STANDARD_TYPE: string;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED: string;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the large image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: string;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the normal image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: string;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the x-large image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: string;
    /**
     * A key in the "thumbnail" namespace for checking if thumbnailing failed
     * for the xx-large image.
     *
     * This attribute is %TRUE if thumbnailing failed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: string;
    /**
     * A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
     *
     * This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
     * and %FALSE if the file has been modified since the thumbnail was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
     * it indicates that thumbnailing may be attempted again and may succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: string;
    /**
     * A key in the "thumbnail" namespace for checking whether the large
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the large thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: string;
    /**
     * A key in the "thumbnail" namespace for checking whether the normal
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the normal thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: string;
    /**
     * A key in the "thumbnail" namespace for checking whether the x-large
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: string;
    /**
     * A key in the "thumbnail" namespace for checking whether the xx-large
     * thumbnail is outdated.
     *
     * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
     * it represents, and %FALSE if the file has been modified since the thumbnail
     * was generated.
     *
     * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE is %TRUE and this attribute
     * is %FALSE, it indicates that thumbnailing may be attempted again and may
     * succeed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: string;
    /**
     * A key in the "thumbnail" namespace for getting the path to the thumbnail
     * image with the biggest size available.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH: string;
    /**
     * A key in the "thumbnail" namespace for getting the path to the large
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: string;
    /**
     * A key in the "thumbnail" namespace for getting the path to the normal
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: string;
    /**
     * A key in the "thumbnail" namespace for getting the path to the x-large
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: string;
    /**
     * A key in the "thumbnail" namespace for getting the path to the xx-large
     * thumbnail image.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: string;
    /**
     * A key in the "time" namespace for getting the time the file was last
     * accessed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
     * contains the time since the file was last accessed, in seconds since the
     * UNIX epoch.
     */
    const FILE_ATTRIBUTE_TIME_ACCESS: string;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last accessed. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_ACCESS. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_ACCESS_NSEC: string;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last accessed.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_ACCESS.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_ACCESS_USEC: string;
    /**
     * A key in the "time" namespace for getting the time the file was last
     * changed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
     * and contains the time since the file was last changed, in seconds since
     * the UNIX epoch.
     *
     * This corresponds to the traditional UNIX ctime.
     */
    const FILE_ATTRIBUTE_TIME_CHANGED: string;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last changed. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_CHANGED. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CHANGED_NSEC: string;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last changed.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CHANGED.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CHANGED_USEC: string;
    /**
     * A key in the "time" namespace for getting the time the file was created.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
     * and contains the time since the file was created, in seconds since the UNIX
     * epoch.
     *
     * This may correspond to Linux `stx_btime`, FreeBSD `st_birthtim`, NetBSD
     * `st_birthtime` or NTFS `ctime`.
     */
    const FILE_ATTRIBUTE_TIME_CREATED: string;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was created. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_CREATED. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CREATED_NSEC: string;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was created.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CREATED.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_CREATED_USEC: string;
    /**
     * A key in the "time" namespace for getting the time the file was last
     * modified.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
     * contains the time since the file was modified, in seconds since the UNIX
     * epoch.
     */
    const FILE_ATTRIBUTE_TIME_MODIFIED: string;
    /**
     * A key in the "time" namespace for getting the nanoseconds of the time
     * the file was last modified. This should be used in conjunction with
     * #G_FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding #GFileAttributeType is
     * %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: string;
    /**
     * A key in the "time" namespace for getting the microseconds of the time
     * the file was last modified.
     *
     * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_MODIFIED.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TIME_MODIFIED_USEC: string;
    /**
     * A key in the "trash" namespace for getting the deletion date and time
     * of a file inside the `trash:///` folder.
     *
     * The format of the returned string is `YYYY-MM-DDThh:mm:ss`.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
     */
    const FILE_ATTRIBUTE_TRASH_DELETION_DATE: string;
    /**
     * A key in the "trash" namespace for getting the number of (toplevel) items
     * that are present in the `trash:///` folder.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_TRASH_ITEM_COUNT: string;
    /**
     * A key in the "trash" namespace for getting the original path of a file
     * inside the `trash:///` folder before it was trashed.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
     */
    const FILE_ATTRIBUTE_TRASH_ORIG_PATH: string;
    /**
     * A key in the "unix" namespace for getting the number of blocks allocated
     * for the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_UNIX_BLOCKS: string;
    /**
     * A key in the "unix" namespace for getting the block size for the file
     * system.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: string;
    /**
     * A key in the "unix" namespace for getting the device id of the device the
     * file is located on (see stat() documentation).
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_DEVICE: string;
    /**
     * A key in the "unix" namespace for getting the group ID for the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_GID: string;
    /**
     * A key in the "unix" namespace for getting the inode of the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
     */
    const FILE_ATTRIBUTE_UNIX_INODE: string;
    /**
     * A key in the "unix" namespace for checking if the file represents a
     * UNIX mount point.
     *
     * This attribute is %TRUE if the file is a UNIX mount point.
     *
     * Since 2.58, `/` is considered to be a mount point.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
     */
    const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: string;
    /**
     * A key in the "unix" namespace for getting the mode of the file
     * (e.g. whether the file is a regular file, symlink, etc).
     *
     * See the documentation for `lstat()`: this attribute is equivalent to
     * the `st_mode` member of `struct stat`, and includes both the file type
     * and permissions.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_MODE: string;
    /**
     * A key in the "unix" namespace for getting the number of hard links
     * for a file.
     *
     * See the documentation for `lstat()`.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_NLINK: string;
    /**
     * A key in the "unix" namespace for getting the device ID for the file
     * (if it is a special file).
     *
     * See the documentation for `lstat()`.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_RDEV: string;
    /**
     * A key in the "unix" namespace for getting the user ID for the file.
     *
     * This attribute is only available for UNIX file systems.
     *
     * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
     */
    const FILE_ATTRIBUTE_UNIX_UID: string;
    /**
     * Extension point for memory usage monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    const MEMORY_MONITOR_EXTENSION_POINT_NAME: string;
    /**
     * The menu item attribute which holds the action name of the item.  Action
     * names are namespaced with an identifier for the action group in which the
     * action resides. For example, "win." for window-specific actions and "app."
     * for application-wide actions.
     *
     * See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().
     */
    const MENU_ATTRIBUTE_ACTION: string;
    /**
     * The menu item attribute that holds the namespace for all action names in
     * menus that are linked from this item.
     */
    const MENU_ATTRIBUTE_ACTION_NAMESPACE: string;
    /**
     * The menu item attribute which holds the icon of the item.
     *
     * The icon is stored in the format returned by g_icon_serialize().
     *
     * This attribute is intended only to represent 'noun' icons such as
     * favicons for a webpage, or application icons.  It should not be used
     * for 'verbs' (ie: stock icons).
     */
    const MENU_ATTRIBUTE_ICON: string;
    /**
     * The menu item attribute which holds the label of the item.
     */
    const MENU_ATTRIBUTE_LABEL: string;
    /**
     * The menu item attribute which holds the target with which the item's action
     * will be activated.
     *
     * See also g_menu_item_set_action_and_target()
     */
    const MENU_ATTRIBUTE_TARGET: string;
    /**
     * The maximum number of entries in a menu section supported by
     * g_dbus_connection_export_menu_model().
     *
     * The exact value of the limit may change in future GLib versions.
     */
    const MENU_EXPORTER_MAX_SECTION_SIZE: number;
    /**
     * The name of the link that associates a menu item with a section.  The linked
     * menu will usually be shown in place of the menu item, using the item's label
     * as a header.
     *
     * See also g_menu_item_set_link().
     */
    const MENU_LINK_SECTION: string;
    /**
     * The name of the link that associates a menu item with a submenu.
     *
     * See also g_menu_item_set_link().
     */
    const MENU_LINK_SUBMENU: string;
    const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: string;
    /**
     * Extension point for network status monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    const NETWORK_MONITOR_EXTENSION_POINT_NAME: string;
    /**
     * Extension point for power profile usage monitoring functionality.
     * See [Extending GIO][extending-gio].
     */
    const POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: string;
    /**
     * Extension point for proxy functionality.
     * See [Extending GIO][extending-gio].
     */
    const PROXY_EXTENSION_POINT_NAME: string;
    /**
     * Extension point for proxy resolving functionality.
     * See [Extending GIO][extending-gio].
     */
    const PROXY_RESOLVER_EXTENSION_POINT_NAME: string;
    /**
     * Extension point for #GSettingsBackend functionality.
     */
    const SETTINGS_BACKEND_EXTENSION_POINT_NAME: string;
    /**
     * Extension point for TLS functionality via #GTlsBackend.
     * See [Extending GIO][extending-gio].
     */
    const TLS_BACKEND_EXTENSION_POINT_NAME: string;
    /**
     * The purpose used to verify the client certificate in a TLS connection.
     * Used by TLS servers.
     */
    const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: string;
    /**
     * The purpose used to verify the server certificate in a TLS connection. This
     * is the most common purpose in use. Used by TLS clients.
     */
    const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: string;
    /**
     * Extension point for #GVfs functionality.
     * See [Extending GIO][extending-gio].
     */
    const VFS_EXTENSION_POINT_NAME: string;
    /**
     * The string used to obtain the volume class with g_volume_get_identifier().
     *
     * Known volume classes include `device`, `network`, and `loop`. Other
     * classes may be added in the future.
     *
     * This is intended to be used by applications to classify #GVolume
     * instances into different sections - for example a file manager or
     * file chooser can use this information to show `network` volumes under
     * a "Network" heading and `device` volumes under a "Devices" heading.
     */
    const VOLUME_IDENTIFIER_KIND_CLASS: string;
    /**
     * The string used to obtain a Hal UDI with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_HAL_UDI: string;
    /**
     * The string used to obtain a filesystem label with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_LABEL: string;
    /**
     * The string used to obtain a NFS mount with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_NFS_MOUNT: string;
    /**
     * The string used to obtain a Unix device path with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: string;
    /**
     * The string used to obtain a UUID with g_volume_get_identifier().
     */
    const VOLUME_IDENTIFIER_KIND_UUID: string;
    /**
     * Extension point for volume monitor functionality.
     * See [Extending GIO][extending-gio].
     */
    const VOLUME_MONITOR_EXTENSION_POINT_NAME: string;
    /**
     * Checks if `action_name` is valid.
     *
     * `action_name` is valid if it consists only of alphanumeric characters,
     * plus '-' and '.'.  The empty string is not a valid action name.
     *
     * It is an error to call this function with a non-utf8 `action_name`.
     * `action_name` must not be %NULL.
     * @param action_name a potential action name
     * @returns %TRUE if @action_name is valid
     */
    function action_name_is_valid(action_name: string): boolean;
    /**
     * Parses a detailed action name into its separate name and target
     * components.
     *
     * Detailed action names can have three formats.
     *
     * The first format is used to represent an action name with no target
     * value and consists of just an action name containing no whitespace
     * nor the characters `:`, `(` or `)`.  For example: `app.action`.
     *
     * The second format is used to represent an action with a target value
     * that is a non-empty string consisting only of alphanumerics, plus `-`
     * and `.`.  In that case, the action name and target value are
     * separated by a double colon (`::`).  For example:
     * `app.action::target`.
     *
     * The third format is used to represent an action with any type of
     * target value, including strings.  The target value follows the action
     * name, surrounded in parens.  For example: `app.action(42)`.  The
     * target value is parsed using g_variant_parse().  If a tuple-typed
     * value is desired, it must be specified in the same way, resulting in
     * two sets of parens, for example: `app.action((1,2,3))`.  A string
     * target can be specified this way as well: `app.action('target')`.
     * For strings, this third format must be used if target value is
     * empty or contains characters other than alphanumerics, `-` and `.`.
     *
     * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
     * in `action_name` (if a pointer is passed in). A %NULL value may still be
     * returned in `target_value,` as the `detailed_name` may not contain a target.
     *
     * If returned, the #GVariant in `target_value` is guaranteed to not be floating.
     * @param detailed_name a detailed action name
     * @returns %TRUE if successful, else %FALSE with @error set
     */
    function action_parse_detailed_name(detailed_name: string): [boolean, string, GLib.Variant | null];
    /**
     * Formats a detailed action name from `action_name` and `target_value`.
     *
     * It is an error to call this function with an invalid action name.
     *
     * This function is the opposite of g_action_parse_detailed_name().
     * It will produce a string that can be parsed back to the `action_name`
     * and `target_value` by that function.
     *
     * See that function for the types of strings that will be printed by
     * this function.
     * @param action_name a valid action name
     * @param target_value a #GVariant target value, or %NULL
     * @returns a detailed format string
     */
    function action_print_detailed_name(action_name: string, target_value?: GLib.Variant | null): string;
    /**
     * Creates a new #GAppInfo from the given information.
     *
     * Note that for `commandline,` the quoting rules of the Exec key of the
     * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
     * are applied. For example, if the `commandline` contains
     * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
     * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
     * @param commandline the commandline to use
     * @param application_name the application name, or %NULL to use @commandline
     * @param flags flags that can specify details of the created #GAppInfo
     * @returns new #GAppInfo for given command.
     */
    function app_info_create_from_commandline(
        commandline: string,
        application_name: string | null,
        flags: AppInfoCreateFlags,
    ): AppInfo;
    /**
     * Gets a list of all of the applications currently registered
     * on this system.
     *
     * For desktop files, this includes applications that have
     * `NoDisplay=true` set or are excluded from display by means
     * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
     * The returned list does not include applications which have
     * the `Hidden` key set.
     * @returns a newly allocated #GList of references to #GAppInfos.
     */
    function app_info_get_all(): AppInfo[];
    /**
     * Gets a list of all #GAppInfos for a given content type,
     * including the recommended and fallback #GAppInfos. See
     * g_app_info_get_recommended_for_type() and
     * g_app_info_get_fallback_for_type().
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    function app_info_get_all_for_type(content_type: string): AppInfo[];
    /**
     * Gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @returns #GAppInfo for given @content_type or     %NULL on error.
     */
    function app_info_get_default_for_type(content_type: string, must_support_uris: boolean): AppInfo | null;
    /**
     * Asynchronously gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @param cancellable optional #GCancellable object, %NULL to ignore
     */
    function app_info_get_default_for_type_async(
        content_type: string,
        must_support_uris: boolean,
        cancellable?: Cancellable | null,
    ): Promise<AppInfo>;
    /**
     * Asynchronously gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_get_default_for_type_async(
        content_type: string,
        must_support_uris: boolean,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<string> | null,
    ): void;
    /**
     * Asynchronously gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_get_default_for_type_async(
        content_type: string,
        must_support_uris: boolean,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<string> | null,
    ): Promise<AppInfo> | void;
    /**
     * Finishes a default #GAppInfo lookup started by
     * g_app_info_get_default_for_type_async().
     *
     * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
     * @param result a #GAsyncResult
     * @returns #GAppInfo for given @content_type or     %NULL on error.
     */
    function app_info_get_default_for_type_finish(result: AsyncResult): AppInfo;
    /**
     * Gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
     */
    function app_info_get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
    /**
     * Asynchronously gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     */
    function app_info_get_default_for_uri_scheme_async(
        uri_scheme: string,
        cancellable?: Cancellable | null,
    ): Promise<AppInfo>;
    /**
     * Asynchronously gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_get_default_for_uri_scheme_async(
        uri_scheme: string,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<string> | null,
    ): void;
    /**
     * Asynchronously gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_get_default_for_uri_scheme_async(
        uri_scheme: string,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<string> | null,
    ): Promise<AppInfo> | void;
    /**
     * Finishes a default #GAppInfo lookup started by
     * g_app_info_get_default_for_uri_scheme_async().
     *
     * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
     * @param result a #GAsyncResult
     * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
     */
    function app_info_get_default_for_uri_scheme_finish(result: AsyncResult): AppInfo;
    /**
     * Gets a list of fallback #GAppInfos for a given content type, i.e.
     * those applications which claim to support the given content type
     * by MIME type subclassing and not directly.
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    function app_info_get_fallback_for_type(content_type: string): AppInfo[];
    /**
     * Gets a list of recommended #GAppInfos for a given content type, i.e.
     * those applications which claim to support the given content type exactly,
     * and not by MIME type subclassing.
     * Note that the first application of the list is the last used one, i.e.
     * the last one for which g_app_info_set_as_last_used_for_type() has been
     * called.
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    function app_info_get_recommended_for_type(content_type: string): AppInfo[];
    /**
     * Utility function that launches the default application
     * registered to handle the specified uri. Synchronous I/O
     * is done on the uri to detect the type of the file if
     * required.
     *
     * The D-Busactivated applications don't have to be started if your application
     * terminates too soon after this function. To prevent this, use
     * g_app_info_launch_default_for_uri_async() instead.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @returns %TRUE on success, %FALSE on error.
     */
    function app_info_launch_default_for_uri(uri: string, context?: AppLaunchContext | null): boolean;
    /**
     * Async version of g_app_info_launch_default_for_uri().
     *
     * This version is useful if you are interested in receiving
     * error information in the case where the application is
     * sandboxed and the portal may present an application chooser
     * dialog to the user.
     *
     * This is also useful if you want to be sure that the D-Busactivated
     * applications are really started before termination and if you are interested
     * in receiving error information from their activation.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @param cancellable a #GCancellable
     */
    function app_info_launch_default_for_uri_async(
        uri: string,
        context?: AppLaunchContext | null,
        cancellable?: Cancellable | null,
    ): Promise<boolean>;
    /**
     * Async version of g_app_info_launch_default_for_uri().
     *
     * This version is useful if you are interested in receiving
     * error information in the case where the application is
     * sandboxed and the portal may present an application chooser
     * dialog to the user.
     *
     * This is also useful if you want to be sure that the D-Busactivated
     * applications are really started before termination and if you are interested
     * in receiving error information from their activation.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_launch_default_for_uri_async(
        uri: string,
        context: AppLaunchContext | null,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<string> | null,
    ): void;
    /**
     * Async version of g_app_info_launch_default_for_uri().
     *
     * This version is useful if you are interested in receiving
     * error information in the case where the application is
     * sandboxed and the portal may present an application chooser
     * dialog to the user.
     *
     * This is also useful if you want to be sure that the D-Busactivated
     * applications are really started before termination and if you are interested
     * in receiving error information from their activation.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function app_info_launch_default_for_uri_async(
        uri: string,
        context?: AppLaunchContext | null,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<string> | null,
    ): Promise<boolean> | void;
    /**
     * Finishes an asynchronous launch-default-for-uri operation.
     * @param result a #GAsyncResult
     * @returns %TRUE if the launch was successful, %FALSE if @error is set
     */
    function app_info_launch_default_for_uri_finish(result: AsyncResult): boolean;
    /**
     * Removes all changes to the type associations done by
     * g_app_info_set_as_default_for_type(),
     * g_app_info_set_as_default_for_extension(),
     * g_app_info_add_supports_type() or
     * g_app_info_remove_supports_type().
     * @param content_type a content type
     */
    function app_info_reset_type_associations(content_type: string): void;
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     *
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     * @param object_type a #GType supporting #GAsyncInitable.
     * @param n_parameters the number of parameters in @parameters
     * @param parameters the parameters to use to construct the object
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the initialization is     finished
     */
    function async_initable_newv_async(
        object_type: GObject.GType,
        n_parameters: number,
        parameters: GObject.Parameter,
        io_priority: number,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<GObject.GType> | null,
    ): void;
    /**
     * Asynchronously connects to the message bus specified by `bus_type`.
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_bus_get_finish() to get the result of the operation.
     *
     * This is an asynchronous failable function. See g_bus_get_sync() for
     * the synchronous version.
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     */
    function bus_get(bus_type: BusType, cancellable?: Cancellable | null): Promise<DBusConnection>;
    /**
     * Asynchronously connects to the message bus specified by `bus_type`.
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_bus_get_finish() to get the result of the operation.
     *
     * This is an asynchronous failable function. See g_bus_get_sync() for
     * the synchronous version.
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    function bus_get(
        bus_type: BusType,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<BusType> | null,
    ): void;
    /**
     * Asynchronously connects to the message bus specified by `bus_type`.
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_bus_get_finish() to get the result of the operation.
     *
     * This is an asynchronous failable function. See g_bus_get_sync() for
     * the synchronous version.
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    function bus_get(
        bus_type: BusType,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<BusType> | null,
    ): Promise<DBusConnection> | void;
    /**
     * Finishes an operation started with g_bus_get().
     *
     * The returned object is a singleton, that is, shared with other
     * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
     * event that you need a private message bus connection, use
     * g_dbus_address_get_for_bus_sync() and
     * g_dbus_connection_new_for_address() with
     * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
     * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
     *
     * Note that the returned #GDBusConnection object will (usually) have
     * the #GDBusConnection:exit-on-close property set to %TRUE.
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_bus_get()
     * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
     */
    function bus_get_finish(res: AsyncResult): DBusConnection;
    /**
     * Synchronously connects to the message bus specified by `bus_type`.
     * Note that the returned object may shared with other callers,
     * e.g. if two separate parts of a process calls this function with
     * the same `bus_type,` they will share the same object.
     *
     * This is a synchronous failable function. See g_bus_get() and
     * g_bus_get_finish() for the asynchronous version.
     *
     * The returned object is a singleton, that is, shared with other
     * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
     * event that you need a private message bus connection, use
     * g_dbus_address_get_for_bus_sync() and
     * g_dbus_connection_new_for_address() with
     * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
     * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
     *
     * Note that the returned #GDBusConnection object will (usually) have
     * the #GDBusConnection:exit-on-close property set to %TRUE.
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
     */
    function bus_get_sync(bus_type: BusType, cancellable?: Cancellable | null): DBusConnection;
    /**
     * Version of g_bus_own_name() using closures instead of callbacks for
     * easier binding in other languages.
     * @param bus_type the type of bus to own a name on
     * @param name the well-known name to own
     * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
     * @param bus_acquired_closure #GClosure to invoke when connected to     the bus of type @bus_type or %NULL
     * @param name_acquired_closure #GClosure to invoke when @name is     acquired or %NULL
     * @param name_lost_closure #GClosure to invoke when @name is lost or     %NULL
     * @returns an identifier (never 0) that can be used with     g_bus_unown_name() to stop owning the name.
     */
    function bus_own_name(
        bus_type: BusType,
        name: string,
        flags: BusNameOwnerFlags,
        bus_acquired_closure?: GObject.Closure | null,
        name_acquired_closure?: GObject.Closure | null,
        name_lost_closure?: GObject.Closure | null,
    ): number;
    /**
     * Version of g_bus_own_name_on_connection() using closures instead of
     * callbacks for easier binding in other languages.
     * @param connection a #GDBusConnection
     * @param name the well-known name to own
     * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
     * @param name_acquired_closure #GClosure to invoke when @name is     acquired or %NULL
     * @param name_lost_closure #GClosure to invoke when @name is lost     or %NULL
     * @returns an identifier (never 0) that can be used with     g_bus_unown_name() to stop owning the name.
     */
    function bus_own_name_on_connection(
        connection: DBusConnection,
        name: string,
        flags: BusNameOwnerFlags,
        name_acquired_closure?: GObject.Closure | null,
        name_lost_closure?: GObject.Closure | null,
    ): number;
    /**
     * Stops owning a name.
     *
     * Note that there may still be D-Bus traffic to process (relating to owning
     * and unowning the name) in the current thread-default #GMainContext after
     * this function has returned. You should continue to iterate the #GMainContext
     * until the #GDestroyNotify function passed to g_bus_own_name() is called, in
     * order to avoid memory leaks through callbacks queued on the #GMainContext
     * after its stopped being iterated.
     * @param owner_id an identifier obtained from g_bus_own_name()
     */
    function bus_unown_name(owner_id: number): void;
    /**
     * Stops watching a name.
     *
     * Note that there may still be D-Bus traffic to process (relating to watching
     * and unwatching the name) in the current thread-default #GMainContext after
     * this function has returned. You should continue to iterate the #GMainContext
     * until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
     * order to avoid memory leaks through callbacks queued on the #GMainContext
     * after its stopped being iterated.
     * @param watcher_id An identifier obtained from g_bus_watch_name()
     */
    function bus_unwatch_name(watcher_id: number): void;
    /**
     * Version of g_bus_watch_name() using closures instead of callbacks for
     * easier binding in other languages.
     * @param bus_type The type of bus to watch a name on.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the #GBusNameWatcherFlags enumeration.
     * @param name_appeared_closure #GClosure to invoke when @name is known to exist or %NULL.
     * @param name_vanished_closure #GClosure to invoke when @name is known to not exist or %NULL.
     * @returns An identifier (never 0) that can be used with g_bus_unwatch_name() to stop watching the name.
     */
    function bus_watch_name(
        bus_type: BusType,
        name: string,
        flags: BusNameWatcherFlags,
        name_appeared_closure?: GObject.Closure | null,
        name_vanished_closure?: GObject.Closure | null,
    ): number;
    /**
     * Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
     * easier binding in other languages.
     * @param connection A #GDBusConnection.
     * @param name The name (well-known or unique) to watch.
     * @param flags Flags from the #GBusNameWatcherFlags enumeration.
     * @param name_appeared_closure #GClosure to invoke when @name is known to exist or %NULL.
     * @param name_vanished_closure #GClosure to invoke when @name is known to not exist or %NULL.
     * @returns An identifier (never 0) that can be used with g_bus_unwatch_name() to stop watching the name.
     */
    function bus_watch_name_on_connection(
        connection: DBusConnection,
        name: string,
        flags: BusNameWatcherFlags,
        name_appeared_closure?: GObject.Closure | null,
        name_vanished_closure?: GObject.Closure | null,
    ): number;
    /**
     * Checks if a content type can be executable. Note that for instance
     * things like text files can be executables (i.e. scripts and batch files).
     * @param type a content type string
     * @returns %TRUE if the file type corresponds to a type that     can be executable, %FALSE otherwise.
     */
    function content_type_can_be_executable(type: string): boolean;
    /**
     * Compares two content types for equality.
     * @param type1 a content type string
     * @param type2 a content type string
     * @returns %TRUE if the two strings are identical or equivalent,     %FALSE otherwise.
     */
    function content_type_equals(type1: string, type2: string): boolean;
    /**
     * Tries to find a content type based on the mime type name.
     * @param mime_type a mime type string
     * @returns Newly allocated string with content type or     %NULL. Free with g_free()
     */
    function content_type_from_mime_type(mime_type: string): string | null;
    /**
     * Gets the human readable description of the content type.
     * @param type a content type string
     * @returns a short description of the content type @type. Free the     returned string with g_free()
     */
    function content_type_get_description(type: string): string;
    /**
     * Gets the generic icon name for a content type.
     *
     * See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on the generic icon name.
     * @param type a content type string
     * @returns the registered generic icon name for the given @type,     or %NULL if unknown. Free with g_free()
     */
    function content_type_get_generic_icon_name(type: string): string | null;
    /**
     * Gets the icon for a content type.
     * @param type a content type string
     * @returns #GIcon corresponding to the content type. Free the returned     object with g_object_unref()
     */
    function content_type_get_icon(type: string): Icon;
    /**
     * Get the list of directories which MIME data is loaded from. See
     * g_content_type_set_mime_dirs() for details.
     * @returns %NULL-terminated list of    directories to load MIME data from, including any `mime/` subdirectory,    and with the first directory to try listed first
     */
    function content_type_get_mime_dirs(): string[];
    /**
     * Gets the mime type for the content type, if one is registered.
     * @param type a content type string
     * @returns the registered mime type for the     given @type, or %NULL if unknown; free with g_free().
     */
    function content_type_get_mime_type(type: string): string | null;
    /**
     * Gets the symbolic icon for a content type.
     * @param type a content type string
     * @returns symbolic #GIcon corresponding to the content type.     Free the returned object with g_object_unref()
     */
    function content_type_get_symbolic_icon(type: string): Icon;
    /**
     * Guesses the content type based on example data. If the function is
     * uncertain, `result_uncertain` will be set to %TRUE. Either `filename`
     * or `data` may be %NULL, in which case the guess will be based solely
     * on the other argument.
     * @param filename a path, or %NULL
     * @param data a stream of data, or %NULL
     * @returns a string indicating a guessed content type for the     given data. Free with g_free()
     */
    function content_type_guess(filename: string | null, data: Uint8Array | null): [string, boolean];
    /**
     * Tries to guess the type of the tree with root `root,` by
     * looking at the files it contains. The result is an array
     * of content types, with the best guess coming first.
     *
     * The types returned all have the form x-content/foo, e.g.
     * x-content/audio-cdda (for audio CDs) or x-content/image-dcf
     * (for a camera memory card). See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on x-content types.
     *
     * This function is useful in the implementation of
     * g_mount_guess_content_type().
     * @param root the root of the tree to guess a type for
     * @returns an %NULL-terminated     array of zero or more content types. Free with g_strfreev()
     */
    function content_type_guess_for_tree(root: File): string[];
    /**
     * Determines if `type` is a subset of `supertype`.
     * @param type a content type string
     * @param supertype a content type string
     * @returns %TRUE if @type is a kind of @supertype,     %FALSE otherwise.
     */
    function content_type_is_a(type: string, supertype: string): boolean;
    /**
     * Determines if `type` is a subset of `mime_type`.
     * Convenience wrapper around g_content_type_is_a().
     * @param type a content type string
     * @param mime_type a mime type string
     * @returns %TRUE if @type is a kind of @mime_type,     %FALSE otherwise.
     */
    function content_type_is_mime_type(type: string, mime_type: string): boolean;
    /**
     * Checks if the content type is the generic "unknown" type.
     * On UNIX this is the "application/octet-stream" mimetype,
     * while on win32 it is "*" and on OSX it is a dynamic type
     * or octet-stream.
     * @param type a content type string
     * @returns %TRUE if the type is the unknown type.
     */
    function content_type_is_unknown(type: string): boolean;
    /**
     * Set the list of directories used by GIO to load the MIME database.
     * If `dirs` is %NULL, the directories used are the default:
     *
     *  - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
     *  - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
     *
     * This function is intended to be used when writing tests that depend on
     * information stored in the MIME database, in order to control the data.
     *
     * Typically, in case your tests use %G_TEST_OPTION_ISOLATE_DIRS, but they
     * depend on the systems MIME database, you should call this function
     * with `dirs` set to %NULL before calling g_test_init(), for instance:
     *
     *
     * ```c
     *   // Load MIME data from the system
     *   g_content_type_set_mime_dirs (NULL);
     *   // Isolate the environment
     *   g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
     *
     *   
     *
     *   return g_test_run ();
     * ```
     *
     * @param dirs %NULL-terminated list of    directories to load MIME data from, including any `mime/` subdirectory,    and with the first directory to try listed first
     */
    function content_type_set_mime_dirs(dirs?: string[] | null): void;
    /**
     * Gets a list of strings containing all the registered content types
     * known to the system. The list and its data should be freed using
     * `g_list_free_full (list, g_free)`.
     * @returns list of the registered     content types
     */
    function content_types_get_registered(): string[];
    /**
     * Escape `string` so it can appear in a D-Bus address as the value
     * part of a key-value pair.
     *
     * For instance, if `string` is `/run/bus-for-:0`,
     * this function would return `/run/bus-for-%3A0`,
     * which could be used in a D-Bus address like
     * `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
     * @param string an unescaped string to be included in a D-Bus address     as the value in a key-value pair
     * @returns a copy of @string with all     non-optionally-escaped bytes escaped
     */
    function dbus_address_escape_value(string: string): string;
    /**
     * Synchronously looks up the D-Bus address for the well-known message
     * bus instance specified by `bus_type`. This may involve using various
     * platform specific mechanisms.
     *
     * The returned address will be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     * @param bus_type a #GBusType
     * @param cancellable a #GCancellable or %NULL
     * @returns a valid D-Bus address string for @bus_type or     %NULL if @error is set
     */
    function dbus_address_get_for_bus_sync(bus_type: BusType, cancellable?: Cancellable | null): string;
    /**
     * Asynchronously connects to an endpoint specified by `address` and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. `address` must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_dbus_address_get_stream_finish() to get the result of
     * the operation.
     *
     * This is an asynchronous failable function. See
     * g_dbus_address_get_stream_sync() for the synchronous version.
     * @param address A valid D-Bus address.
     * @param cancellable A #GCancellable or %NULL.
     */
    function dbus_address_get_stream(address: string, cancellable?: Cancellable | null): Promise<[IOStream, string]>;
    /**
     * Asynchronously connects to an endpoint specified by `address` and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. `address` must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_dbus_address_get_stream_finish() to get the result of
     * the operation.
     *
     * This is an asynchronous failable function. See
     * g_dbus_address_get_stream_sync() for the synchronous version.
     * @param address A valid D-Bus address.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    function dbus_address_get_stream(
        address: string,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<string> | null,
    ): void;
    /**
     * Asynchronously connects to an endpoint specified by `address` and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. `address` must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_dbus_address_get_stream_finish() to get the result of
     * the operation.
     *
     * This is an asynchronous failable function. See
     * g_dbus_address_get_stream_sync() for the synchronous version.
     * @param address A valid D-Bus address.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    function dbus_address_get_stream(
        address: string,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<string> | null,
    ): Promise<[IOStream, string]> | void;
    /**
     * Finishes an operation started with g_dbus_address_get_stream().
     *
     * A server is not required to set a GUID, so `out_guid` may be set to %NULL
     * even on success.
     * @param res A #GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream().
     * @returns A #GIOStream or %NULL if @error is set.
     */
    function dbus_address_get_stream_finish(res: AsyncResult): [IOStream, string];
    /**
     * Synchronously connects to an endpoint specified by `address` and
     * sets up the connection so it is in a state to run the client-side
     * of the D-Bus authentication conversation. `address` must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * A server is not required to set a GUID, so `out_guid` may be set to %NULL
     * even on success.
     *
     * This is a synchronous failable function. See
     * g_dbus_address_get_stream() for the asynchronous version.
     * @param address A valid D-Bus address.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GIOStream or %NULL if @error is set.
     */
    function dbus_address_get_stream_sync(address: string, cancellable?: Cancellable | null): [IOStream, string];
    /**
     * Looks up the value of an annotation.
     *
     * The cost of this function is O(n) in number of annotations.
     * @param annotations A %NULL-terminated array of annotations or %NULL.
     * @param name The name of the annotation to look up.
     * @returns The value or %NULL if not found. Do not free, it is owned by @annotations.
     */
    function dbus_annotation_info_lookup(annotations: DBusAnnotationInfo[] | null, name: string): string | null;
    /**
     * Creates a D-Bus error name to use for `error`. If `error` matches
     * a registered error (cf. g_dbus_error_register_error()), the corresponding
     * D-Bus error name will be returned.
     *
     * Otherwise the a name of the form
     * `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
     * will be used. This allows other GDBus applications to map the error
     * on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
     *
     * This function is typically only used in object mappings to put a
     * #GError on the wire. Regular applications should not use it.
     * @param error A #GError.
     * @returns A D-Bus error name (never %NULL).     Free with g_free().
     */
    function dbus_error_encode_gerror(error: GLib.Error): string;
    /**
     * Gets the D-Bus error name used for `error,` if any.
     *
     * This function is guaranteed to return a D-Bus error name for all
     * #GErrors returned from functions handling remote method calls
     * (e.g. g_dbus_connection_call_finish()) unless
     * g_dbus_error_strip_remote_error() has been used on `error`.
     * @param error a #GError
     * @returns an allocated string or %NULL if the     D-Bus error name could not be found. Free with g_free().
     */
    function dbus_error_get_remote_error(error: GLib.Error): string | null;
    /**
     * Checks if `error` represents an error received via D-Bus from a remote peer. If so,
     * use g_dbus_error_get_remote_error() to get the name of the error.
     * @param error A #GError.
     * @returns %TRUE if @error represents an error from a remote peer, %FALSE otherwise.
     */
    function dbus_error_is_remote_error(error: GLib.Error): boolean;
    /**
     * Creates a #GError based on the contents of `dbus_error_name` and
     * `dbus_error_message`.
     *
     * Errors registered with g_dbus_error_register_error() will be looked
     * up using `dbus_error_name` and if a match is found, the error domain
     * and code is used. Applications can use g_dbus_error_get_remote_error()
     * to recover `dbus_error_name`.
     *
     * If a match against a registered error is not found and the D-Bus
     * error name is in a form as returned by g_dbus_error_encode_gerror()
     * the error domain and code encoded in the name is used to
     * create the #GError. Also, `dbus_error_name` is added to the error message
     * such that it can be recovered with g_dbus_error_get_remote_error().
     *
     * Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
     * in the %G_IO_ERROR error domain is returned. Also, `dbus_error_name` is
     * added to the error message such that it can be recovered with
     * g_dbus_error_get_remote_error().
     *
     * In all three cases, `dbus_error_name` can always be recovered from the
     * returned #GError using the g_dbus_error_get_remote_error() function
     * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
     *
     * This function is typically only used in object mappings to prepare
     * #GError instances for applications. Regular applications should not use
     * it.
     * @param dbus_error_name D-Bus error name.
     * @param dbus_error_message D-Bus error message.
     * @returns An allocated #GError. Free with g_error_free().
     */
    function dbus_error_new_for_dbus_error(dbus_error_name: string, dbus_error_message: string): GLib.Error;
    function dbus_error_quark(): GLib.Quark;
    /**
     * Creates an association to map between `dbus_error_name` and
     * #GErrors specified by `error_domain` and `error_code`.
     *
     * This is typically done in the routine that returns the #GQuark for
     * an error domain.
     * @param error_domain A #GQuark for an error domain.
     * @param error_code An error code.
     * @param dbus_error_name A D-Bus error name.
     * @returns %TRUE if the association was created, %FALSE if it already exists.
     */
    function dbus_error_register_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string): boolean;
    /**
     * Helper function for associating a #GError error domain with D-Bus error names.
     *
     * While `quark_volatile` has a `volatile` qualifier, this is a historical
     * artifact and the argument passed to it should not be `volatile`.
     * @param error_domain_quark_name The error domain name.
     * @param quark_volatile A pointer where to store the #GQuark.
     * @param entries A pointer to @num_entries #GDBusErrorEntry struct items.
     */
    function dbus_error_register_error_domain(
        error_domain_quark_name: string,
        quark_volatile: number,
        entries: DBusErrorEntry[],
    ): void;
    /**
     * Looks for extra information in the error message used to recover
     * the D-Bus error name and strips it if found. If stripped, the
     * message field in `error` will correspond exactly to what was
     * received on the wire.
     *
     * This is typically used when presenting errors to the end user.
     * @param error A #GError.
     * @returns %TRUE if information was stripped, %FALSE otherwise.
     */
    function dbus_error_strip_remote_error(error: GLib.Error): boolean;
    /**
     * Destroys an association previously set up with g_dbus_error_register_error().
     * @param error_domain A #GQuark for an error domain.
     * @param error_code An error code.
     * @param dbus_error_name A D-Bus error name.
     * @returns %TRUE if the association was destroyed, %FALSE if it wasn't found.
     */
    function dbus_error_unregister_error(
        error_domain: GLib.Quark,
        error_code: number,
        dbus_error_name: string,
    ): boolean;
    /**
     * This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
     * @param s the string to escape
     * @returns an escaped version of @s. Free with g_free().
     */
    function dbus_escape_object_path(s: string): string;
    /**
     * Escapes `bytes` for use in a D-Bus object path component.
     * `bytes` is an array of zero or more nonzero bytes in an
     * unspecified encoding, followed by a single zero byte.
     *
     * The escaping method consists of replacing all non-alphanumeric
     * characters (see g_ascii_isalnum()) with their hexadecimal value
     * preceded by an underscore (`_`). For example:
     * `foo.bar.baz` will become `foo_2ebar_2ebaz`.
     *
     * This method is appropriate to use when the input is nearly
     * a valid object path component but is not when your input
     * is far from being a valid object path component.
     * Other escaping algorithms are also valid to use with
     * D-Bus object paths.
     *
     * This can be reversed with g_dbus_unescape_object_path().
     * @param bytes the string of bytes to escape
     * @returns an escaped version of @bytes. Free with g_free().
     */
    function dbus_escape_object_path_bytestring(bytes: Uint8Array | string): string;
    /**
     * Generate a D-Bus GUID that can be used with
     * e.g. g_dbus_connection_new().
     *
     * See the
     * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
     * regarding what strings are valid D-Bus GUIDs. The specification refers to
     * these as UUIDs whereas GLib (for historical reasons) refers to them as
     * GUIDs. The terms are interchangeable.
     *
     * Note that D-Bus GUIDs do not follow
     * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
     * @returns A valid D-Bus GUID. Free with g_free().
     */
    function dbus_generate_guid(): string;
    /**
     * Converts a #GValue to a #GVariant of the type indicated by the `type`
     * parameter.
     *
     * The conversion is using the following rules:
     *
     * - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
     * - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
     * - `G_TYPE_BOOLEAN`: 'b'
     * - `G_TYPE_UCHAR`: 'y'
     * - `G_TYPE_INT`: 'i', 'n'
     * - `G_TYPE_UINT`: 'u', 'q'
     * - `G_TYPE_INT64`: 'x'
     * - `G_TYPE_UINT64`: 't'
     * - `G_TYPE_DOUBLE`: 'd'
     * - `G_TYPE_VARIANT`: Any #GVariantType
     *
     * This can fail if e.g. `gvalue` is of type %G_TYPE_STRING and `type`
     * is 'i', i.e. %G_VARIANT_TYPE_INT32. It will also fail for any #GType
     * (including e.g. %G_TYPE_OBJECT and %G_TYPE_BOXED derived-types) not
     * in the table above.
     *
     * Note that if `gvalue` is of type %G_TYPE_VARIANT and its value is
     * %NULL, the empty #GVariant instance (never %NULL) for `type` is
     * returned (e.g. 0 for scalar types, the empty string for string types,
     * '/' for object path types, the empty array for any array type and so on).
     *
     * See the g_dbus_gvariant_to_gvalue() function for how to convert a
     * #GVariant to a #GValue.
     * @param gvalue A #GValue to convert to a #GVariant
     * @param type A #GVariantType
     * @returns A #GVariant (never floating) of     #GVariantType @type holding the data from @gvalue or an empty #GVariant     in case of failure. Free with g_variant_unref().
     */
    function dbus_gvalue_to_gvariant(gvalue: GObject.Value | any, type: GLib.VariantType): GLib.Variant;
    /**
     * Converts a #GVariant to a #GValue. If `value` is floating, it is consumed.
     *
     * The rules specified in the g_dbus_gvalue_to_gvariant() function are
     * used - this function is essentially its reverse form. So, a #GVariant
     * containing any basic or string array type will be converted to a #GValue
     * containing a basic value or string array. Any other #GVariant (handle,
     * variant, tuple, dict entry) will be converted to a #GValue containing that
     * #GVariant.
     *
     * The conversion never fails - a valid #GValue is always returned in
     * `out_gvalue`.
     * @param value A #GVariant.
     */
    function dbus_gvariant_to_gvalue(value: GLib.Variant): unknown;
    /**
     * Checks if `string` is a
     * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     *
     * This doesn't check if `string` is actually supported by #GDBusServer
     * or #GDBusConnection - use g_dbus_is_supported_address() to do more
     * checks.
     * @param string A string.
     * @returns %TRUE if @string is a valid D-Bus address, %FALSE otherwise.
     */
    function dbus_is_address(string: string): boolean;
    /**
     * Check whether `string` is a valid D-Bus error name.
     *
     * This function returns the same result as g_dbus_is_interface_name(),
     * because D-Bus error names are defined to have exactly the
     * same syntax as interface names.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_error_name(string: string): boolean;
    /**
     * Checks if `string` is a D-Bus GUID.
     *
     * See the documentation for g_dbus_generate_guid() for more information about
     * the format of a GUID.
     * @param string The string to check.
     * @returns %TRUE if @string is a GUID, %FALSE otherwise.
     */
    function dbus_is_guid(string: string): boolean;
    /**
     * Checks if `string` is a valid D-Bus interface name.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_interface_name(string: string): boolean;
    /**
     * Checks if `string` is a valid D-Bus member (e.g. signal or method) name.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_member_name(string: string): boolean;
    /**
     * Checks if `string` is a valid D-Bus bus name (either unique or well-known).
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_name(string: string): boolean;
    /**
     * Like g_dbus_is_address() but also checks if the library supports the
     * transports in `string` and that key/value pairs for each transport
     * are valid. See the specification of the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     * @param string A string.
     * @returns %TRUE if @string is a valid D-Bus address that is supported by this library, %FALSE if @error is set.
     */
    function dbus_is_supported_address(string: string): boolean;
    /**
     * Checks if `string` is a valid D-Bus unique bus name.
     * @param string The string to check.
     * @returns %TRUE if valid, %FALSE otherwise.
     */
    function dbus_is_unique_name(string: string): boolean;
    /**
     * Unescapes an string that was previously escaped with
     * g_dbus_escape_object_path(). If the string is in a format that could
     * not have been returned by g_dbus_escape_object_path(), this function
     * returns %NULL.
     *
     * Encoding alphanumeric characters which do not need to be
     * encoded is not allowed (e.g `_63` is not valid, the string
     * should contain `c` instead).
     * @param s the string to unescape
     * @returns an   unescaped version of @s, or %NULL if @s is not a string returned   from g_dbus_escape_object_path(). Free with g_free().
     */
    function dbus_unescape_object_path(s: string): Uint8Array | null;
    /**
     * Creates a new #GDtlsClientConnection wrapping `base_socket` which is
     * assumed to communicate with the server identified by `server_identity`.
     * @param base_socket the #GDatagramBased to wrap
     * @param server_identity the expected identity of the server
     * @returns the new   #GDtlsClientConnection, or %NULL on error
     */
    function dtls_client_connection_new(
        base_socket: DatagramBased,
        server_identity?: SocketConnectable | null,
    ): DtlsClientConnection;
    /**
     * Creates a new #GDtlsServerConnection wrapping `base_socket`.
     * @param base_socket the #GDatagramBased to wrap
     * @param certificate the default server certificate, or %NULL
     * @returns the new   #GDtlsServerConnection, or %NULL on error
     */
    function dtls_server_connection_new(
        base_socket: DatagramBased,
        certificate?: TlsCertificate | null,
    ): DtlsServerConnection;
    /**
     * Constructs a #GFile from a vector of elements using the correct
     * separator for filenames.
     *
     * Using this function is equivalent to calling g_build_filenamev(),
     * followed by g_file_new_for_path() on the result.
     * @param args %NULL-terminated   array of strings containing the path elements.
     * @returns a new #GFile
     */
    function file_new_build_filenamev(args: string[]): File;
    /**
     * Creates a #GFile with the given argument from the command line.
     * The value of `arg` can be either a URI, an absolute path or a
     * relative path resolved relative to the current working directory.
     * This operation never fails, but the returned object might not
     * support any I/O operation if `arg` points to a malformed path.
     *
     * Note that on Windows, this function expects its argument to be in
     * UTF-8 -- not the system code page.  This means that you
     * should not use this function with string from argv as it is passed
     * to main().  g_win32_get_command_line() will return a UTF-8 version of
     * the commandline.  #GApplication also uses UTF-8 but
     * g_application_command_line_create_file_for_arg() may be more useful
     * for you there.  It is also always possible to use this function with
     * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
     * @param arg a command line string
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_for_commandline_arg(arg: string): File;
    /**
     * Creates a #GFile with the given argument from the command line.
     *
     * This function is similar to g_file_new_for_commandline_arg() except
     * that it allows for passing the current working directory as an
     * argument instead of using the current working directory of the
     * process.
     *
     * This is useful if the commandline argument was given in a context
     * other than the invocation of the current process.
     *
     * See also g_application_command_line_create_file_for_arg().
     * @param arg a command line string
     * @param cwd the current working directory of the commandline
     * @returns a new #GFile
     */
    function file_new_for_commandline_arg_and_cwd(arg: string, cwd: string): File;
    /**
     * Constructs a #GFile for a given path. This operation never
     * fails, but the returned object might not support any I/O
     * operation if `path` is malformed.
     * @param path a string containing a relative or absolute path.   The string must be encoded in the glib filename encoding.
     * @returns a new #GFile for the given @path.   Free the returned object with g_object_unref().
     */
    function file_new_for_path(path: string): File;
    /**
     * Constructs a #GFile for a given URI. This operation never
     * fails, but the returned object might not support any I/O
     * operation if `uri` is malformed or if the uri type is
     * not supported.
     * @param uri a UTF-8 string containing a URI
     * @returns a new #GFile for the given @uri.   Free the returned object with g_object_unref().
     */
    function file_new_for_uri(uri: string): File;
    /**
     * Opens a file in the preferred directory for temporary files (as
     * returned by g_get_tmp_dir()) and returns a #GFile and
     * #GFileIOStream pointing to it.
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     *
     * Unlike the other #GFile constructors, this will return %NULL if
     * a temporary file could not be created.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp(tmpl: string | null): [File, FileIOStream];
    /**
     * Asynchronously opens a file in the preferred directory for temporary files
     *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     */
    function file_new_tmp_async(
        tmpl: string | null,
        io_priority: number,
        cancellable?: Cancellable | null,
    ): Promise<[File, FileIOStream]>;
    /**
     * Asynchronously opens a file in the preferred directory for temporary files
     *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function file_new_tmp_async(
        tmpl: string | null,
        io_priority: number,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<string | null> | null,
    ): void;
    /**
     * Asynchronously opens a file in the preferred directory for temporary files
     *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function file_new_tmp_async(
        tmpl: string | null,
        io_priority: number,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<string | null> | null,
    ): Promise<[File, FileIOStream]> | void;
    /**
     * Asynchronously creates a directory in the preferred directory for
     * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     */
    function file_new_tmp_dir_async(
        tmpl: string | null,
        io_priority: number,
        cancellable?: Cancellable | null,
    ): Promise<File>;
    /**
     * Asynchronously creates a directory in the preferred directory for
     * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function file_new_tmp_dir_async(
        tmpl: string | null,
        io_priority: number,
        cancellable: Cancellable | null,
        callback: AsyncReadyCallback<string | null> | null,
    ): void;
    /**
     * Asynchronously creates a directory in the preferred directory for
     * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
     *
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    function file_new_tmp_dir_async(
        tmpl: string | null,
        io_priority: number,
        cancellable?: Cancellable | null,
        callback?: AsyncReadyCallback<string | null> | null,
    ): Promise<File> | void;
    /**
     * Finishes a temporary directory creation started by
     * g_file_new_tmp_dir_async().
     * @param result a #GAsyncResult
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp_dir_finish(result: AsyncResult): File;
    /**
     * Finishes a temporary file creation started by g_file_new_tmp_async().
     * @param result a #GAsyncResult
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    function file_new_tmp_finish(result: AsyncResult): [File, FileIOStream];
    /**
     * Constructs a #GFile with the given `parse_name` (i.e. something
     * given by g_file_get_parse_name()). This operation never fails,
     * but the returned object might not support any I/O operation if
     * the `parse_name` cannot be parsed.
     * @param parse_name a file name or path to be parsed
     * @returns a new #GFile.
     */
    function file_parse_name(parse_name: string): File;
    /**
     * Deserializes a #GIcon previously serialized using g_icon_serialize().
     * @param value a #GVariant created with g_icon_serialize()
     * @returns a #GIcon, or %NULL when deserialization fails.
     */
    function icon_deserialize(value: GLib.Variant): Icon | null;
    /**
     * Generate a #GIcon instance from `str`. This function can fail if
     * `str` is not valid - see g_icon_to_string() for discussion.
     *
     * If your application or library provides one or more #GIcon
     * implementations you need to ensure that each #GType is registered
     * with the type system prior to calling g_icon_new_for_string().
     * @param str A string obtained via g_icon_to_string().
     * @returns An object implementing the #GIcon          interface or %NULL if @error is set.
     */
    function icon_new_for_string(str: string): Icon;
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     * @param object_type a #GType supporting #GInitable.
     * @param parameters the parameters to use to construct the object
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a newly allocated      #GObject, or %NULL on error
     */
    function initable_newv<T = GObject.Object>(
        object_type: GObject.GType,
        parameters: GObject.Parameter[],
        cancellable?: Cancellable | null,
    ): T;
    /**
     * Converts `errno.h` error codes into GIO error codes.
     *
     * The fallback value %G_IO_ERROR_FAILED is returned for error codes not
     * currently handled (but note that future GLib releases may return a more
     * specific value instead).
     *
     * As `errno` is global and may be modified by intermediate function
     * calls, you should save its value immediately after the call returns,
     * and use the saved value instead of `errno`:
     *
     *
     *
     * ```c
     *   int saved_errno;
     *
     *   ret = read (blah);
     *   saved_errno = errno;
     *
     *   g_io_error_from_errno (saved_errno);
     * ```
     *
     * @param err_no Error number as defined in errno.h.
     * @returns #GIOErrorEnum value for the given `errno.h` error number
     */
    function io_error_from_errno(err_no: number): IOErrorEnum;
    /**
     * Converts #GFileError error codes into GIO error codes.
     * @param file_error a #GFileError.
     * @returns #GIOErrorEnum value for the given #GFileError error value.
     */
    function io_error_from_file_error(file_error: GLib.FileError): IOErrorEnum;
    /**
     * Gets the GIO Error Quark.
     * @returns a #GQuark.
     */
    function io_error_quark(): GLib.Quark;
    /**
     * Registers `type` as extension for the extension point with name
     * `extension_point_name`.
     *
     * If `type` has already been registered as an extension for this
     * extension point, the existing #GIOExtension object is returned.
     * @param extension_point_name the name of the extension point
     * @param type the #GType to register as extension
     * @param extension_name the name for the extension
     * @param priority the priority for the extension
     * @returns a #GIOExtension object for #GType
     */
    function io_extension_point_implement(
        extension_point_name: string,
        type: GObject.GType,
        extension_name: string,
        priority: number,
    ): IOExtension;
    /**
     * Looks up an existing extension point.
     * @param name the name of the extension point
     * @returns the #GIOExtensionPoint, or %NULL if there    is no registered extension point with the given name.
     */
    function io_extension_point_lookup(name: string): IOExtensionPoint;
    /**
     * Registers an extension point.
     * @param name The name of the extension point
     * @returns the new #GIOExtensionPoint. This object is    owned by GIO and should not be freed.
     */
    function io_extension_point_register(name: string): IOExtensionPoint;
    /**
     * Loads all the modules in the specified directory.
     *
     * If don't require all modules to be initialized (and thus registering
     * all gtypes) then you can use g_io_modules_scan_all_in_directory()
     * which allows delayed/lazy loading of modules.
     * @param dirname pathname for a directory containing modules     to load.
     * @returns a list of #GIOModules loaded      from the directory,      All the modules are loaded into memory, if you want to      unload them (enabling on-demand loading) you must call      g_type_module_unuse() on all the modules. Free the list      with g_list_free().
     */
    function io_modules_load_all_in_directory(dirname: string): IOModule[];
    /**
     * Loads all the modules in the specified directory.
     *
     * If don't require all modules to be initialized (and thus registering
     * all gtypes) then you can use g_io_modules_scan_all_in_directory()
     * which allows delayed/lazy loading of modules.
     * @param dirname pathname for a directory containing modules     to load.
     * @param scope a scope to use when scanning the modules.
     * @returns a list of #GIOModules loaded      from the directory,      All the modules are loaded into memory, if you want to      unload them (enabling on-demand loading) you must call      g_type_module_unuse() on all the modules. Free the list      with g_list_free().
     */
    function io_modules_load_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): IOModule[];
    /**
     * Scans all the modules in the specified directory, ensuring that
     * any extension point implemented by a module is registered.
     *
     * This may not actually load and initialize all the types in each
     * module, some modules may be lazily loaded and initialized when
     * an extension point it implements is used with e.g.
     * g_io_extension_point_get_extensions() or
     * g_io_extension_point_get_extension_by_name().
     *
     * If you need to guarantee that all types are loaded in all the modules,
     * use g_io_modules_load_all_in_directory().
     * @param dirname pathname for a directory containing modules     to scan.
     */
    function io_modules_scan_all_in_directory(dirname: string): void;
    /**
     * Scans all the modules in the specified directory, ensuring that
     * any extension point implemented by a module is registered.
     *
     * This may not actually load and initialize all the types in each
     * module, some modules may be lazily loaded and initialized when
     * an extension point it implements is used with e.g.
     * g_io_extension_point_get_extensions() or
     * g_io_extension_point_get_extension_by_name().
     *
     * If you need to guarantee that all types are loaded in all the modules,
     * use g_io_modules_load_all_in_directory().
     * @param dirname pathname for a directory containing modules     to scan.
     * @param scope a scope to use when scanning the modules
     */
    function io_modules_scan_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): void;
    /**
     * Cancels all cancellable I/O jobs.
     *
     * A job is cancellable if a #GCancellable was passed into
     * g_io_scheduler_push_job().
     */
    function io_scheduler_cancel_all_jobs(): void;
    /**
     * Schedules the I/O job to run in another thread.
     *
     * `notify` will be called on `user_data` after `job_func` has returned,
     * regardless whether the job was cancelled or has run to completion.
     *
     * If `cancellable` is not %NULL, it can be used to cancel the I/O job
     * by calling g_cancellable_cancel() or by calling
     * g_io_scheduler_cancel_all_jobs().
     * @param job_func a #GIOSchedulerJobFunc.
     * @param notify a #GDestroyNotify for @user_data, or %NULL
     * @param io_priority the [I/O priority][io-priority] of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     */
    function io_scheduler_push_job(
        job_func: IOSchedulerJobFunc,
        notify: GLib.DestroyNotify | null,
        io_priority: number,
        cancellable?: Cancellable | null,
    ): void;
    /**
     * Creates a keyfile-backed #GSettingsBackend.
     *
     * The filename of the keyfile to use is given by `filename`.
     *
     * All settings read to or written from the backend must fall under the
     * path given in `root_path` (which must start and end with a slash and
     * not contain two consecutive slashes).  `root_path` may be "/".
     *
     * If `root_group` is non-%NULL then it specifies the name of the keyfile
     * group used for keys that are written directly below `root_path`.  For
     * example, if `root_path` is "/apps/example/" and `root_group` is
     * "toplevel", then settings the key "/apps/example/enabled" to a value
     * of %TRUE will cause the following to appear in the keyfile:
     *
     *
     * ```
     *   [toplevel]
     *   enabled=true
     * ```
     *
     *
     * If `root_group` is %NULL then it is not permitted to store keys
     * directly below the `root_path`.
     *
     * For keys not stored directly below `root_path` (ie: in a sub-path),
     * the name of the subpath (with the final slash stripped) is used as
     * the name of the keyfile group.  To continue the example, if
     * "/apps/example/profiles/default/font-size" were set to
     * 12 then the following would appear in the keyfile:
     *
     *
     * ```
     *   [profiles/default]
     *   font-size=12
     * ```
     *
     *
     * The backend will refuse writes (and return writability as being
     * %FALSE) for keys outside of `root_path` and, in the event that
     * `root_group` is %NULL, also for keys directly under `root_path`.
     * Writes will also be refused if the backend detects that it has the
     * inability to rewrite the keyfile (ie: the containing directory is not
     * writable).
     *
     * There is no checking done for your key namespace clashing with the
     * syntax of the key file format.  For example, if you have '[' or ']'
     * characters in your path names or '=' in your key names you may be in
     * trouble.
     *
     * The backend reads default values from a keyfile called `defaults` in
     * the directory specified by the #GKeyfileSettingsBackend:defaults-dir property,
     * and a list of locked keys from a text file with the name `locks` in
     * the same location.
     * @param filename the filename of the keyfile
     * @param root_path the path under which all settings keys appear
     * @param root_group the group name corresponding to              @root_path, or %NULL
     * @returns a keyfile-backed #GSettingsBackend
     */
    function keyfile_settings_backend_new(
        filename: string,
        root_path: string,
        root_group?: string | null,
    ): SettingsBackend;
    /**
     * Gets a reference to the default #GMemoryMonitor for the system.
     * @returns a new reference to the default #GMemoryMonitor
     */
    function memory_monitor_dup_default(): MemoryMonitor;
    /**
     * Creates a memory-backed #GSettingsBackend.
     *
     * This backend allows changes to settings, but does not write them
     * to any backing storage, so the next time you run your application,
     * the memory backend will start out with the default values again.
     * @returns a newly created #GSettingsBackend
     */
    function memory_settings_backend_new(): SettingsBackend;
    /**
     * Gets the default #GNetworkMonitor for the system.
     * @returns a #GNetworkMonitor, which will be     a dummy object if no network monitor is available
     */
    function network_monitor_get_default(): NetworkMonitor;
    /**
     * Initializes the platform networking libraries (eg, on Windows, this
     * calls WSAStartup()). GLib will call this itself if it is needed, so
     * you only need to call it if you directly call system networking
     * functions (without calling any GLib networking functions first).
     */
    function networking_init(): void;
    /**
     * Creates a readonly #GSettingsBackend.
     *
     * This backend does not allow changes to settings, so all settings
     * will always have their default values.
     * @returns a newly created #GSettingsBackend
     */
    function null_settings_backend_new(): SettingsBackend;
    /**
     * Utility method for #GPollableInputStream and #GPollableOutputStream
     * implementations. Creates a new #GSource that expects a callback of
     * type #GPollableSourceFunc. The new source does not actually do
     * anything on its own; use g_source_add_child_source() to add other
     * sources to it to cause it to trigger.
     * @param pollable_stream the stream associated with the new source
     * @returns the new #GSource.
     */
    function pollable_source_new(pollable_stream: GObject.Object): GLib.Source;
    /**
     * Utility method for #GPollableInputStream and #GPollableOutputStream
     * implementations. Creates a new #GSource, as with
     * g_pollable_source_new(), but also attaching `child_source` (with a
     * dummy callback), and `cancellable,` if they are non-%NULL.
     * @param pollable_stream the stream associated with the   new source
     * @param child_source optional child source to attach
     * @param cancellable optional #GCancellable to attach
     * @returns the new #GSource.
     */
    function pollable_source_new_full(
        pollable_stream: GObject.Object,
        child_source?: GLib.Source | null,
        cancellable?: Cancellable | null,
    ): GLib.Source;
    /**
     * Tries to read from `stream,` as with g_input_stream_read() (if
     * `blocking` is %TRUE) or g_pollable_input_stream_read_nonblocking()
     * (if `blocking` is %FALSE). This can be used to more easily share
     * code between blocking and non-blocking implementations of a method.
     *
     * If `blocking` is %FALSE, then `stream` must be a
     * #GPollableInputStream for which g_pollable_input_stream_can_poll()
     * returns %TRUE, or else the behavior is undefined. If `blocking` is
     * %TRUE, then `stream` does not need to be a #GPollableInputStream.
     * @param stream a #GInputStream
     * @param buffer a buffer to   read data into
     * @param blocking whether to do blocking I/O
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns the number of bytes read, or -1 on error.
     */
    function pollable_stream_read(
        stream: InputStream,
        buffer: Uint8Array | string,
        blocking: boolean,
        cancellable?: Cancellable | null,
    ): number;
    /**
     * Tries to write to `stream,` as with g_output_stream_write() (if
     * `blocking` is %TRUE) or g_pollable_output_stream_write_nonblocking()
     * (if `blocking` is %FALSE). This can be used to more easily share
     * code between blocking and non-blocking implementations of a method.
     *
     * If `blocking` is %FALSE, then `stream` must be a
     * #GPollableOutputStream for which
     * g_pollable_output_stream_can_poll() returns %TRUE or else the
     * behavior is undefined. If `blocking` is %TRUE, then `stream` does not
     * need to be a #GPollableOutputStream.
     * @param stream a #GOutputStream.
     * @param buffer the buffer   containing the data to write.
     * @param blocking whether to do blocking I/O
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns the number of bytes written, or -1 on error.
     */
    function pollable_stream_write(
        stream: OutputStream,
        buffer: Uint8Array | string,
        blocking: boolean,
        cancellable?: Cancellable | null,
    ): number;
    /**
     * Tries to write `count` bytes to `stream,` as with
     * g_output_stream_write_all(), but using g_pollable_stream_write()
     * rather than g_output_stream_write().
     *
     * On a successful write of `count` bytes, %TRUE is returned, and
     * `bytes_written` is set to `count`.
     *
     * If there is an error during the operation (including
     * %G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
     * returned and `error` is set to indicate the error status,
     * `bytes_written` is updated to contain the number of bytes written
     * into the stream before the error occurred.
     *
     * As with g_pollable_stream_write(), if `blocking` is %FALSE, then
     * `stream` must be a #GPollableOutputStream for which
     * g_pollable_output_stream_can_poll() returns %TRUE or else the
     * behavior is undefined. If `blocking` is %TRUE, then `stream` does not
     * need to be a #GPollableOutputStream.
     * @param stream a #GOutputStream.
     * @param buffer the buffer   containing the data to write.
     * @param blocking whether to do blocking I/O
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE on success, %FALSE if there was an error
     */
    function pollable_stream_write_all(
        stream: OutputStream,
        buffer: Uint8Array | string,
        blocking: boolean,
        cancellable?: Cancellable | null,
    ): [boolean, number];
    /**
     * Gets a reference to the default #GPowerProfileMonitor for the system.
     * @returns a new reference to the default #GPowerProfileMonitor
     */
    function power_profile_monitor_dup_default(): PowerProfileMonitor;
    /**
     * Find the `gio-proxy` extension point for a proxy implementation that supports
     * the specified protocol.
     * @param protocol the proxy protocol name (e.g. http, socks, etc)
     * @returns return a #GProxy or NULL if protocol               is not supported.
     */
    function proxy_get_default_for_protocol(protocol: string): Proxy | null;
    /**
     * Gets the default #GProxyResolver for the system.
     * @returns the default #GProxyResolver, which     will be a dummy object if no proxy resolver is available
     */
    function proxy_resolver_get_default(): ProxyResolver;
    /**
     * Gets the #GResolver Error Quark.
     * @returns a #GQuark.
     */
    function resolver_error_quark(): GLib.Quark;
    /**
     * Gets the #GResource Error Quark.
     * @returns a #GQuark
     */
    function resource_error_quark(): GLib.Quark;
    /**
     * Loads a binary resource bundle and creates a #GResource representation of it, allowing
     * you to query it for data.
     *
     * If you want to use this resource in the global resource namespace you need
     * to register it with g_resources_register().
     *
     * If `filename` is empty or the data in it is corrupt,
     * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesnt exist, or
     * there is an error in reading it, an error from g_mapped_file_new() will be
     * returned.
     * @param filename the path of a filename to load, in the GLib filename encoding
     * @returns a new #GResource, or %NULL on error
     */
    function resource_load(filename: string): Resource;
    /**
     * Returns all the names of children at the specified `path` in the set of
     * globally registered resources.
     * The return result is a %NULL terminated list of strings which should
     * be released with g_strfreev().
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns an array of constant strings
     */
    function resources_enumerate_children(path: string, lookup_flags: ResourceLookupFlags): string[];
    /**
     * Looks for a file at the specified `path` in the set of
     * globally registered resources and if found returns information about it.
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns %TRUE if the file was found. %FALSE if there were errors
     */
    function resources_get_info(path: string, lookup_flags: ResourceLookupFlags): [boolean, number, number];
    /**
     * Looks for a file at the specified `path` in the set of
     * globally registered resources and returns a #GBytes that
     * lets you directly access the data in memory.
     *
     * The data is always followed by a zero byte, so you
     * can safely use the data as a C string. However, that byte
     * is not included in the size of the GBytes.
     *
     * For uncompressed resource files this is a pointer directly into
     * the resource bundle, which is typically in some readonly data section
     * in the program binary. For compressed files we allocate memory on
     * the heap and automatically uncompress the data.
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns #GBytes or %NULL on error.     Free the returned object with g_bytes_unref()
     */
    function resources_lookup_data(path: string, lookup_flags: ResourceLookupFlags): GLib.Bytes;
    /**
     * Looks for a file at the specified `path` in the set of
     * globally registered resources and returns a #GInputStream
     * that lets you read the data.
     *
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns #GInputStream or %NULL on error.     Free the returned object with g_object_unref()
     */
    function resources_open_stream(path: string, lookup_flags: ResourceLookupFlags): InputStream;
    /**
     * Registers the resource with the process-global set of resources.
     * Once a resource is registered the files in it can be accessed
     * with the global resource lookup functions like g_resources_lookup_data().
     * @param resource A #GResource
     */
    function resources_register(resource: Resource): void;
    /**
     * Unregisters the resource from the process-global set of resources.
     * @param resource A #GResource
     */
    function resources_unregister(resource: Resource): void;
    /**
     * Gets the default system schema source.
     *
     * This function is not required for normal uses of #GSettings but it
     * may be useful to authors of plugin management systems or to those who
     * want to introspect the content of schemas.
     *
     * If no schemas are installed, %NULL will be returned.
     *
     * The returned source may actually consist of multiple schema sources
     * from different directories, depending on which directories were given
     * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
     * lookups performed against the default source should probably be done
     * recursively.
     * @returns the default schema source
     */
    function settings_schema_source_get_default(): SettingsSchemaSource | null;
    /**
     * Reports an error in an idle function. Similar to
     * g_simple_async_report_error_in_idle(), but takes a #GError rather
     * than building a new one.
     * @param object a #GObject, or %NULL
     * @param callback a #GAsyncReadyCallback.
     * @param error the #GError to report
     */
    function simple_async_report_gerror_in_idle(
        object: GObject.Object | null,
        callback: AsyncReadyCallback<GObject.Object | null> | null,
        error: GLib.Error,
    ): void;
    /**
     * Gets the default #GTlsBackend for the system.
     * @returns a #GTlsBackend, which will be a     dummy object if no TLS backend is available
     */
    function tls_backend_get_default(): TlsBackend;
    /**
     * Gets the TLS channel binding error quark.
     * @returns a #GQuark.
     */
    function tls_channel_binding_error_quark(): GLib.Quark;
    /**
     * Creates a new #GTlsClientConnection wrapping `base_io_stream` (which
     * must have pollable input and output streams) which is assumed to
     * communicate with the server identified by `server_identity`.
     *
     * See the documentation for #GTlsConnection:base-io-stream for restrictions
     * on when application code can run operations on the `base_io_stream` after
     * this function has returned.
     * @param base_io_stream the #GIOStream to wrap
     * @param server_identity the expected identity of the server
     * @returns the new #GTlsClientConnection, or %NULL on error
     */
    function tls_client_connection_new(
        base_io_stream: IOStream,
        server_identity?: SocketConnectable | null,
    ): TlsClientConnection;
    /**
     * Gets the TLS error quark.
     * @returns a #GQuark.
     */
    function tls_error_quark(): GLib.Quark;
    /**
     * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
     * in `anchors` to verify certificate chains.
     *
     * The certificates in `anchors` must be PEM encoded.
     * @param anchors filename of anchor certificate authorities.
     * @returns the new #GTlsFileDatabase, or %NULL on error
     */
    function tls_file_database_new(anchors: string): TlsFileDatabase;
    /**
     * Creates a new #GTlsServerConnection wrapping `base_io_stream` (which
     * must have pollable input and output streams).
     *
     * See the documentation for #GTlsConnection:base-io-stream for restrictions
     * on when application code can run operations on the `base_io_stream` after
     * this function has returned.
     * @param base_io_stream the #GIOStream to wrap
     * @param certificate the default server certificate, or %NULL
     * @returns the new #GTlsServerConnection, or %NULL on error
     */
    function tls_server_connection_new(
        base_io_stream: IOStream,
        certificate?: TlsCertificate | null,
    ): TlsServerConnection;
    /**
     * Determines if `mount_path` is considered an implementation of the
     * OS. This is primarily used for hiding mountable and mounted volumes
     * that only are used in the OS and has little to no relevance to the
     * casual user.
     * @param mount_path a mount path, e.g. `/media/disk` or `/usr`
     * @returns %TRUE if @mount_path is considered an implementation detail     of the OS.
     */
    function unix_is_mount_path_system_internal(mount_path: string): boolean;
    /**
     * Determines if `device_path` is considered a block device path which is only
     * used in implementation of the OS. This is primarily used for hiding
     * mounted volumes that are intended as APIs for programs to read, and system
     * administrators at a shell; rather than something that should, for example,
     * appear in a GUI. For example, the Linux `/proc` filesystem.
     *
     * The list of device paths considered system ones may change over time.
     * @param device_path a device path, e.g. `/dev/loop0` or `nfsd`
     * @returns %TRUE if @device_path is considered an implementation detail of    the OS.
     */
    function unix_is_system_device_path(device_path: string): boolean;
    /**
     * Determines if `fs_type` is considered a type of file system which is only
     * used in implementation of the OS. This is primarily used for hiding
     * mounted volumes that are intended as APIs for programs to read, and system
     * administrators at a shell; rather than something that should, for example,
     * appear in a GUI. For example, the Linux `/proc` filesystem.
     *
     * The list of file system types considered system ones may change over time.
     * @param fs_type a file system type, e.g. `procfs` or `tmpfs`
     * @returns %TRUE if @fs_type is considered an implementation detail of the OS.
     */
    function unix_is_system_fs_type(fs_type: string): boolean;
    /**
     * Gets a #GUnixMountEntry for a given mount path. If `time_read`
     * is set, it will be filled with a unix timestamp for checking
     * if the mounts have changed since with g_unix_mounts_changed_since().
     *
     * If more mounts have the same mount path, the last matching mount
     * is returned.
     *
     * This will return %NULL if there is no mount point at `mount_path`.
     * @param mount_path path for a possible unix mount.
     * @returns a #GUnixMountEntry.
     */
    function unix_mount_at(mount_path: string): [UnixMountEntry | null, number];
    /**
     * Compares two unix mounts.
     * @param mount1 first #GUnixMountEntry to compare.
     * @param mount2 second #GUnixMountEntry to compare.
     * @returns 1, 0 or -1 if @mount1 is greater than, equal to, or less than @mount2, respectively.
     */
    function unix_mount_compare(mount1: UnixMountEntry, mount2: UnixMountEntry): number;
    /**
     * Makes a copy of `mount_entry`.
     * @param mount_entry a #GUnixMountEntry.
     * @returns a new #GUnixMountEntry
     */
    function unix_mount_copy(mount_entry: UnixMountEntry): UnixMountEntry;
    /**
     * Gets a #GUnixMountEntry for a given file path. If `time_read`
     * is set, it will be filled with a unix timestamp for checking
     * if the mounts have changed since with g_unix_mounts_changed_since().
     *
     * If more mounts have the same mount path, the last matching mount
     * is returned.
     *
     * This will return %NULL if looking up the mount entry fails, if
     * `file_path` doesnt exist or there is an I/O error.
     * @param file_path file path on some unix mount.
     * @returns a #GUnixMountEntry.
     */
    function unix_mount_for(file_path: string): [UnixMountEntry | null, number];
    /**
     * Frees a unix mount.
     * @param mount_entry a #GUnixMountEntry.
     */
    function unix_mount_free(mount_entry: UnixMountEntry): void;
    /**
     * Gets the device path for a unix mount.
     * @param mount_entry a #GUnixMount.
     * @returns a string containing the device path.
     */
    function unix_mount_get_device_path(mount_entry: UnixMountEntry): string;
    /**
     * Gets the filesystem type for the unix mount.
     * @param mount_entry a #GUnixMount.
     * @returns a string containing the file system type.
     */
    function unix_mount_get_fs_type(mount_entry: UnixMountEntry): string;
    /**
     * Gets the mount path for a unix mount.
     * @param mount_entry input #GUnixMountEntry to get the mount path for.
     * @returns the mount path for @mount_entry.
     */
    function unix_mount_get_mount_path(mount_entry: UnixMountEntry): string;
    /**
     * Gets a comma-separated list of mount options for the unix mount. For example,
     * `rw,relatime,seclabel,data=ordered`.
     *
     * This is similar to g_unix_mount_point_get_options(), but it takes
     * a #GUnixMountEntry as an argument.
     * @param mount_entry a #GUnixMountEntry.
     * @returns a string containing the options, or %NULL if not available.
     */
    function unix_mount_get_options(mount_entry: UnixMountEntry): string | null;
    /**
     * Gets the root of the mount within the filesystem. This is useful e.g. for
     * mounts created by bind operation, or btrfs subvolumes.
     *
     * For example, the root path is equal to "/" for mount created by
     * "mount /dev/sda1 /mnt/foo" and "/bar" for
     * "mount --bind /mnt/foo/bar /mnt/bar".
     * @param mount_entry a #GUnixMountEntry.
     * @returns a string containing the root, or %NULL if not supported.
     */
    function unix_mount_get_root_path(mount_entry: UnixMountEntry): string | null;
    /**
     * Guesses whether a Unix mount can be ejected.
     * @param mount_entry a #GUnixMountEntry
     * @returns %TRUE if @mount_entry is deemed to be ejectable.
     */
    function unix_mount_guess_can_eject(mount_entry: UnixMountEntry): boolean;
    /**
     * Guesses the icon of a Unix mount.
     * @param mount_entry a #GUnixMountEntry
     * @returns a #GIcon
     */
    function unix_mount_guess_icon(mount_entry: UnixMountEntry): Icon;
    /**
     * Guesses the name of a Unix mount.
     * The result is a translated string.
     * @param mount_entry a #GUnixMountEntry
     * @returns A newly allocated string that must     be freed with g_free()
     */
    function unix_mount_guess_name(mount_entry: UnixMountEntry): string;
    /**
     * Guesses whether a Unix mount should be displayed in the UI.
     * @param mount_entry a #GUnixMountEntry
     * @returns %TRUE if @mount_entry is deemed to be displayable.
     */
    function unix_mount_guess_should_display(mount_entry: UnixMountEntry): boolean;
    /**
     * Guesses the symbolic icon of a Unix mount.
     * @param mount_entry a #GUnixMountEntry
     * @returns a #GIcon
     */
    function unix_mount_guess_symbolic_icon(mount_entry: UnixMountEntry): Icon;
    /**
     * Checks if a unix mount is mounted read only.
     * @param mount_entry a #GUnixMount.
     * @returns %TRUE if @mount_entry is read only.
     */
    function unix_mount_is_readonly(mount_entry: UnixMountEntry): boolean;
    /**
     * Checks if a Unix mount is a system mount. This is the Boolean OR of
     * g_unix_is_system_fs_type(), g_unix_is_system_device_path() and
     * g_unix_is_mount_path_system_internal() on `mount_entry`s properties.
     *
     * The definition of what a system mount entry is may change over time as new
     * file system types and device paths are ignored.
     * @param mount_entry a #GUnixMount.
     * @returns %TRUE if the unix mount is for a system path.
     */
    function unix_mount_is_system_internal(mount_entry: UnixMountEntry): boolean;
    /**
     * Gets a #GUnixMountPoint for a given mount path. If `time_read` is set, it
     * will be filled with a unix timestamp for checking if the mount points have
     * changed since with g_unix_mount_points_changed_since().
     *
     * If more mount points have the same mount path, the last matching mount point
     * is returned.
     * @param mount_path path for a possible unix mount point.
     * @returns a #GUnixMountPoint, or %NULL if no match is found.
     */
    function unix_mount_point_at(mount_path: string): [UnixMountPoint | null, number];
    /**
     * Checks if the unix mount points have changed since a given unix time.
     * @param time guint64 to contain a timestamp.
     * @returns %TRUE if the mount points have changed since @time.
     */
    function unix_mount_points_changed_since(time: number): boolean;
    /**
     * Gets a #GList of #GUnixMountPoint containing the unix mount points.
     * If `time_read` is set, it will be filled with the mount timestamp,
     * allowing for checking if the mounts have changed with
     * g_unix_mount_points_changed_since().
     * @returns a #GList of the UNIX mountpoints.
     */
    function unix_mount_points_get(): [UnixMountPoint[], number];
    /**
     * Checks if the unix mounts have changed since a given unix time.
     * @param time guint64 to contain a timestamp.
     * @returns %TRUE if the mounts have changed since @time.
     */
    function unix_mounts_changed_since(time: number): boolean;
    /**
     * Gets a #GList of #GUnixMountEntry containing the unix mounts.
     * If `time_read` is set, it will be filled with the mount
     * timestamp, allowing for checking if the mounts have changed
     * with g_unix_mounts_changed_since().
     * @returns a #GList of the UNIX mounts.
     */
    function unix_mounts_get(): [UnixMountEntry[], number];
    interface AsyncReadyCallback<A = GObject.Object> {
        (source_object: A | null, res: AsyncResult, data?: any | null): void;
    }
    interface BusAcquiredCallback {
        (connection: DBusConnection, name: string): void;
    }
    interface BusNameAcquiredCallback {
        (connection: DBusConnection, name: string): void;
    }
    interface BusNameAppearedCallback {
        (connection: DBusConnection, name: string, name_owner: string): void;
    }
    interface BusNameLostCallback {
        (connection: DBusConnection, name: string): void;
    }
    interface BusNameVanishedCallback {
        (connection: DBusConnection, name: string): void;
    }
    interface CancellableSourceFunc {
        (cancellable?: Cancellable | null, data?: any | null): boolean;
    }
    interface DBusInterfaceGetPropertyFunc {
        (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            property_name: string,
            error: GLib.Error,
        ): GLib.Variant;
    }
    interface DBusInterfaceMethodCallFunc {
        (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            method_name: string,
            parameters: GLib.Variant,
            invocation: DBusMethodInvocation,
        ): void;
    }
    interface DBusInterfaceSetPropertyFunc {
        (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            property_name: string,
            value: GLib.Variant,
            error: GLib.Error,
        ): boolean;
    }
    interface DBusMessageFilterFunction {
        (connection: DBusConnection, message: DBusMessage, incoming: boolean): DBusMessage | null;
    }
    interface DBusProxyTypeFunc {
        (
            manager: DBusObjectManagerClient,
            object_path: string,
            interface_name?: string | null,
            data?: any | null,
        ): GObject.GType;
    }
    interface DBusSignalCallback {
        (
            connection: DBusConnection,
            sender_name: string | null,
            object_path: string,
            interface_name: string,
            signal_name: string,
            parameters: GLib.Variant,
        ): void;
    }
    interface DBusSubtreeDispatchFunc {
        (
            connection: DBusConnection,
            sender: string,
            object_path: string,
            interface_name: string,
            node: string,
            out_user_data: any,
        ): DBusInterfaceVTable | null;
    }
    interface DBusSubtreeEnumerateFunc {
        (connection: DBusConnection, sender: string, object_path: string): string[];
    }
    interface DBusSubtreeIntrospectFunc {
        (connection: DBusConnection, sender: string, object_path: string, node: string): DBusInterfaceInfo[] | null;
    }
    interface DatagramBasedSourceFunc {
        (datagram_based: DatagramBased, condition: GLib.IOCondition, data?: any | null): boolean;
    }
    interface DesktopAppLaunchCallback {
        (appinfo: DesktopAppInfo, pid: GLib.Pid): void;
    }
    interface FileMeasureProgressCallback {
        (reporting: boolean, current_size: number, num_dirs: number, num_files: number, data?: any | null): void;
    }
    interface FileProgressCallback {
        (current_num_bytes: number, total_num_bytes: number, data?: any | null): void;
    }
    interface FileReadMoreCallback {
        (file_contents: string, file_size: number, callback_data?: any | null): boolean;
    }
    interface IOSchedulerJobFunc {
        (job: IOSchedulerJob, cancellable?: Cancellable | null, data?: any | null): boolean;
    }
    interface PollableSourceFunc<A = GObject.Object> {
        (pollable_stream: A, data?: any | null): boolean;
    }
    interface ReallocFunc {
        (data: any | null, size: number): any | null;
    }
    interface SettingsBindGetMapping {
        (value: GObject.Value | any, variant: GLib.Variant): boolean;
    }
    interface SettingsBindSetMapping {
        (value: GObject.Value | any, expected_type: GLib.VariantType): GLib.Variant;
    }
    interface SettingsGetMapping {
        (value: GLib.Variant): boolean;
    }
    interface SimpleAsyncThreadFunc<A = GObject.Object> {
        (res: SimpleAsyncResult, object: A, cancellable?: Cancellable | null): void;
    }
    interface SocketSourceFunc {
        (socket: Socket, condition: GLib.IOCondition, data?: any | null): boolean;
    }
    interface TaskThreadFunc<A = GObject.Object> {
        (task: Task, source_object: A, task_data?: any | null, cancellable?: Cancellable | null): void;
    }
    interface VfsFileLookupFunc {
        (vfs: Vfs, identifier: string): File;
    }
    /**
     * Flags used when creating a #GAppInfo.
     */

    /**
     * Flags used when creating a #GAppInfo.
     */
    export namespace AppInfoCreateFlags {
        export const $gtype: GObject.GType<AppInfoCreateFlags>;
    }

    enum AppInfoCreateFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * Application opens in a terminal window.
         */
        NEEDS_TERMINAL,
        /**
         * Application supports URI arguments.
         */
        SUPPORTS_URIS,
        /**
         * Application supports startup notification. Since 2.26
         */
        SUPPORTS_STARTUP_NOTIFICATION,
    }
    /**
     * Flags used to define the behaviour of a #GApplication.
     */

    /**
     * Flags used to define the behaviour of a #GApplication.
     */
    export namespace ApplicationFlags {
        export const $gtype: GObject.GType<ApplicationFlags>;
    }

    enum ApplicationFlags {
        /**
         * Default. Deprecated in 2.74, use
         *   %G_APPLICATION_DEFAULT_FLAGS instead
         */
        FLAGS_NONE,
        /**
         * Default flags. Since: 2.74
         */
        DEFAULT_FLAGS,
        /**
         * Run as a service. In this mode, registration
         *      fails if the service is already running, and the application
         *      will initially wait up to 10 seconds for an initial activation
         *      message to arrive.
         */
        IS_SERVICE,
        /**
         * Don't try to become the primary instance.
         */
        IS_LAUNCHER,
        /**
         * This application handles opening files (in
         *     the primary instance). Note that this flag only affects the default
         *     implementation of local_command_line(), and has no effect if
         *     %G_APPLICATION_HANDLES_COMMAND_LINE is given.
         *     See g_application_run() for details.
         */
        HANDLES_OPEN,
        /**
         * This application handles command line
         *     arguments (in the primary instance). Note that this flag only affect
         *     the default implementation of local_command_line().
         *     See g_application_run() for details.
         */
        HANDLES_COMMAND_LINE,
        /**
         * Send the environment of the
         *     launching process to the primary instance. Set this flag if your
         *     application is expected to behave differently depending on certain
         *     environment variables. For instance, an editor might be expected
         *     to use the `GIT_COMMITTER_NAME` environment variable
         *     when editing a git commit message. The environment is available
         *     to the #GApplication::command-line signal handler, via
         *     g_application_command_line_getenv().
         */
        SEND_ENVIRONMENT,
        /**
         * Make no attempts to do any of the typical
         *     single-instance application negotiation, even if the application
         *     ID is given.  The application neither attempts to become the
         *     owner of the application ID nor does it check if an existing
         *     owner already exists.  Everything occurs in the local process.
         *     Since: 2.30.
         */
        NON_UNIQUE,
        /**
         * Allow users to override the
         *     application ID from the command line with `--gapplication-app-id`.
         *     Since: 2.48
         */
        CAN_OVERRIDE_APP_ID,
        /**
         * Allow another instance to take over
         *     the bus name. Since: 2.60
         */
        ALLOW_REPLACEMENT,
        /**
         * Take over from another instance. This flag is
         *     usually set by passing `--gapplication-replace` on the commandline.
         *     Since: 2.60
         */
        REPLACE,
    }
    /**
     * #GAskPasswordFlags are used to request specific information from the
     * user, or to notify the user of their choices in an authentication
     * situation.
     */

    /**
     * #GAskPasswordFlags are used to request specific information from the
     * user, or to notify the user of their choices in an authentication
     * situation.
     */
    export namespace AskPasswordFlags {
        export const $gtype: GObject.GType<AskPasswordFlags>;
    }

    enum AskPasswordFlags {
        /**
         * operation requires a password.
         */
        NEED_PASSWORD,
        /**
         * operation requires a username.
         */
        NEED_USERNAME,
        /**
         * operation requires a domain.
         */
        NEED_DOMAIN,
        /**
         * operation supports saving settings.
         */
        SAVING_SUPPORTED,
        /**
         * operation supports anonymous users.
         */
        ANONYMOUS_SUPPORTED,
        /**
         * operation takes TCRYPT parameters (Since: 2.58)
         */
        TCRYPT,
    }
    /**
     * Flags used in g_bus_own_name().
     */

    /**
     * Flags used in g_bus_own_name().
     */
    export namespace BusNameOwnerFlags {
        export const $gtype: GObject.GType<BusNameOwnerFlags>;
    }

    enum BusNameOwnerFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Allow another message bus connection to claim the name.
         */
        ALLOW_REPLACEMENT,
        /**
         * If another message bus connection owns the name and have
         * specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
         */
        REPLACE,
        /**
         * If another message bus connection owns the name, immediately
         * return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)
         */
        DO_NOT_QUEUE,
    }
    /**
     * Flags used in g_bus_watch_name().
     */

    /**
     * Flags used in g_bus_watch_name().
     */
    export namespace BusNameWatcherFlags {
        export const $gtype: GObject.GType<BusNameWatcherFlags>;
    }

    enum BusNameWatcherFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * If no-one owns the name when
         * beginning to watch the name, ask the bus to launch an owner for the
         * name.
         */
        AUTO_START,
    }
    /**
     * Flags used when calling a g_converter_convert().
     */

    /**
     * Flags used when calling a g_converter_convert().
     */
    export namespace ConverterFlags {
        export const $gtype: GObject.GType<ConverterFlags>;
    }

    enum ConverterFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * At end of input data
         */
        INPUT_AT_END,
        /**
         * Flush data
         */
        FLUSH,
    }
    /**
     * Flags used in g_dbus_connection_call() and similar APIs.
     */

    /**
     * Flags used in g_dbus_connection_call() and similar APIs.
     */
    export namespace DBusCallFlags {
        export const $gtype: GObject.GType<DBusCallFlags>;
    }

    enum DBusCallFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * The bus must not launch
         * an owner for the destination name in response to this method
         * invocation.
         */
        NO_AUTO_START,
        /**
         * the caller is prepared to
         * wait for interactive authorization. Since 2.46.
         */
        ALLOW_INTERACTIVE_AUTHORIZATION,
    }
    /**
     * Capabilities negotiated with the remote peer.
     */

    /**
     * Capabilities negotiated with the remote peer.
     */
    export namespace DBusCapabilityFlags {
        export const $gtype: GObject.GType<DBusCapabilityFlags>;
    }

    enum DBusCapabilityFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * The connection
         * supports exchanging UNIX file descriptors with the remote peer.
         */
        UNIX_FD_PASSING,
    }
    /**
     * Flags used when creating a new #GDBusConnection.
     */

    /**
     * Flags used when creating a new #GDBusConnection.
     */
    export namespace DBusConnectionFlags {
        export const $gtype: GObject.GType<DBusConnectionFlags>;
    }

    enum DBusConnectionFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Perform authentication against server.
         */
        AUTHENTICATION_CLIENT,
        /**
         * Perform authentication against client.
         */
        AUTHENTICATION_SERVER,
        /**
         * When
         * authenticating as a server, allow the anonymous authentication
         * method.
         */
        AUTHENTICATION_ALLOW_ANONYMOUS,
        /**
         * Pass this flag if connecting to a peer that is a
         * message bus. This means that the Hello() method will be invoked as part of the connection setup.
         */
        MESSAGE_BUS_CONNECTION,
        /**
         * If set, processing of D-Bus messages is
         * delayed until g_dbus_connection_start_message_processing() is called.
         */
        DELAY_MESSAGE_PROCESSING,
        /**
         * When authenticating
         * as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
         */
        AUTHENTICATION_REQUIRE_SAME_USER,
        /**
         * When authenticating, try to use
         *  protocols that work across a Linux user namespace boundary, even if this
         *  reduces interoperability with older D-Bus implementations. This currently
         *  affects client-side `EXTERNAL` authentication, for which this flag makes
         *  connections to a server in another user namespace succeed, but causes
         *  a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74
         */
        CROSS_NAMESPACE,
    }
    /**
     * Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
     */

    /**
     * Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
     */
    export namespace DBusInterfaceSkeletonFlags {
        export const $gtype: GObject.GType<DBusInterfaceSkeletonFlags>;
    }

    enum DBusInterfaceSkeletonFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Each method invocation is handled in
         *   a thread dedicated to the invocation. This means that the method implementation can use blocking IO
         *   without blocking any other part of the process. It also means that the method implementation must
         *   use locking to access data structures used by other threads.
         */
        HANDLE_METHOD_INVOCATIONS_IN_THREAD,
    }
    /**
     * Message flags used in #GDBusMessage.
     */

    /**
     * Message flags used in #GDBusMessage.
     */
    export namespace DBusMessageFlags {
        export const $gtype: GObject.GType<DBusMessageFlags>;
    }

    enum DBusMessageFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * A reply is not expected.
         */
        NO_REPLY_EXPECTED,
        /**
         * The bus must not launch an
         * owner for the destination name in response to this message.
         */
        NO_AUTO_START,
        /**
         * If set on a method
         * call, this flag means that the caller is prepared to wait for interactive
         * authorization. Since 2.46.
         */
        ALLOW_INTERACTIVE_AUTHORIZATION,
    }
    /**
     * Flags used when constructing a #GDBusObjectManagerClient.
     */

    /**
     * Flags used when constructing a #GDBusObjectManagerClient.
     */
    export namespace DBusObjectManagerClientFlags {
        export const $gtype: GObject.GType<DBusObjectManagerClientFlags>;
    }

    enum DBusObjectManagerClientFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * If not set and the
         *   manager is for a well-known name, then request the bus to launch
         *   an owner for the name if no-one owns the name. This flag can only
         *   be used in managers for well-known names.
         */
        DO_NOT_AUTO_START,
    }
    /**
     * Flags describing the access control of a D-Bus property.
     */

    /**
     * Flags describing the access control of a D-Bus property.
     */
    export namespace DBusPropertyInfoFlags {
        export const $gtype: GObject.GType<DBusPropertyInfoFlags>;
    }

    enum DBusPropertyInfoFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Property is readable.
         */
        READABLE,
        /**
         * Property is writable.
         */
        WRITABLE,
    }
    /**
     * Flags used when constructing an instance of a #GDBusProxy derived class.
     */

    /**
     * Flags used when constructing an instance of a #GDBusProxy derived class.
     */
    export namespace DBusProxyFlags {
        export const $gtype: GObject.GType<DBusProxyFlags>;
    }

    enum DBusProxyFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Don't load properties.
         */
        DO_NOT_LOAD_PROPERTIES,
        /**
         * Don't connect to signals on the remote object.
         */
        DO_NOT_CONNECT_SIGNALS,
        /**
         * If the proxy is for a well-known name,
         * do not ask the bus to launch an owner during proxy initialization or a method call.
         * This flag is only meaningful in proxies for well-known names.
         */
        DO_NOT_AUTO_START,
        /**
         * If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
         */
        GET_INVALIDATED_PROPERTIES,
        /**
         * If the proxy is for a well-known name,
         * do not ask the bus to launch an owner during proxy initialization, but allow it to be
         * autostarted by a method call. This flag is only meaningful in proxies for well-known names,
         * and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
         */
        DO_NOT_AUTO_START_AT_CONSTRUCTION,
        /**
         * Don't actually send the AddMatch D-Bus
         *    call for this signal subscription. This gives you more control
         *    over which match rules you add (but you must add them manually). (Since: 2.72)
         */
        NO_MATCH_RULE,
    }
    /**
     * Flags used when sending #GDBusMessages on a #GDBusConnection.
     */

    /**
     * Flags used when sending #GDBusMessages on a #GDBusConnection.
     */
    export namespace DBusSendMessageFlags {
        export const $gtype: GObject.GType<DBusSendMessageFlags>;
    }

    enum DBusSendMessageFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Do not automatically
         * assign a serial number from the #GDBusConnection object when
         * sending a message.
         */
        PRESERVE_SERIAL,
    }
    /**
     * Flags used when creating a #GDBusServer.
     */

    /**
     * Flags used when creating a #GDBusServer.
     */
    export namespace DBusServerFlags {
        export const $gtype: GObject.GType<DBusServerFlags>;
    }

    enum DBusServerFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * All #GDBusServer::new-connection
         * signals will run in separated dedicated threads (see signal for
         * details).
         */
        RUN_IN_THREAD,
        /**
         * Allow the anonymous
         * authentication method.
         */
        AUTHENTICATION_ALLOW_ANONYMOUS,
        /**
         * Require the UID of the
         * peer to be the same as the UID of the server when authenticating. (Since: 2.68)
         */
        AUTHENTICATION_REQUIRE_SAME_USER,
    }
    /**
     * Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().
     */

    /**
     * Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().
     */
    export namespace DBusSignalFlags {
        export const $gtype: GObject.GType<DBusSignalFlags>;
    }

    enum DBusSignalFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Don't actually send the AddMatch
         * D-Bus call for this signal subscription.  This gives you more control
         * over which match rules you add (but you must add them manually).
         */
        NO_MATCH_RULE,
        /**
         * Match first arguments that
         * contain a bus or interface name with the given namespace.
         */
        MATCH_ARG0_NAMESPACE,
        /**
         * Match first arguments that
         * contain an object path that is either equivalent to the given path,
         * or one of the paths is a subpath of the other.
         */
        MATCH_ARG0_PATH,
    }
    /**
     * Flags passed to g_dbus_connection_register_subtree().
     */

    /**
     * Flags passed to g_dbus_connection_register_subtree().
     */
    export namespace DBusSubtreeFlags {
        export const $gtype: GObject.GType<DBusSubtreeFlags>;
    }

    enum DBusSubtreeFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Method calls to objects not in the enumerated range
         *                                                       will still be dispatched. This is useful if you want
         *                                                       to dynamically spawn objects in the subtree.
         */
        DISPATCH_TO_UNENUMERATED_NODES,
    }
    /**
     * Flags used when starting a drive.
     */

    /**
     * Flags used when starting a drive.
     */
    export namespace DriveStartFlags {
        export const $gtype: GObject.GType<DriveStartFlags>;
    }

    enum DriveStartFlags {
        /**
         * No flags set.
         */
        NONE,
    }
    /**
     * Flags specifying the behaviour of an attribute.
     */

    /**
     * Flags specifying the behaviour of an attribute.
     */
    export namespace FileAttributeInfoFlags {
        export const $gtype: GObject.GType<FileAttributeInfoFlags>;
    }

    enum FileAttributeInfoFlags {
        /**
         * no flags set.
         */
        NONE,
        /**
         * copy the attribute values when the file is copied.
         */
        COPY_WITH_FILE,
        /**
         * copy the attribute values when the file is moved.
         */
        COPY_WHEN_MOVED,
    }
    /**
     * Flags used when copying or moving files.
     */

    /**
     * Flags used when copying or moving files.
     */
    export namespace FileCopyFlags {
        export const $gtype: GObject.GType<FileCopyFlags>;
    }

    enum FileCopyFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Overwrite any existing files
         */
        OVERWRITE,
        /**
         * Make a backup of any existing files.
         */
        BACKUP,
        /**
         * Don't follow symlinks.
         */
        NOFOLLOW_SYMLINKS,
        /**
         * Copy all file metadata instead of just default set used for copy (see #GFileInfo).
         */
        ALL_METADATA,
        /**
         * Don't use copy and delete fallback if native move not supported.
         */
        NO_FALLBACK_FOR_MOVE,
        /**
         * Leaves target file with default perms, instead of setting the source file perms.
         */
        TARGET_DEFAULT_PERMS,
        /**
         * Use default modification
         *     timestamps instead of copying them from the source file. Since 2.80
         */
        TARGET_DEFAULT_MODIFIED_TIME,
    }
    /**
     * Flags used when an operation may create a file.
     */

    /**
     * Flags used when an operation may create a file.
     */
    export namespace FileCreateFlags {
        export const $gtype: GObject.GType<FileCreateFlags>;
    }

    enum FileCreateFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Create a file that can only be
         *    accessed by the current user.
         */
        PRIVATE,
        /**
         * Replace the destination
         *    as if it didn't exist before. Don't try to keep any old
         *    permissions, replace instead of following links. This
         *    is generally useful if you're doing a "copy over"
         *    rather than a "save new version of" replace operation.
         *    You can think of it as "unlink destination" before
         *    writing to it, although the implementation may not
         *    be exactly like that. This flag can only be used with
         *    g_file_replace() and its variants, including g_file_replace_contents().
         *    Since 2.20
         */
        REPLACE_DESTINATION,
    }
    /**
     * Flags that can be used with g_file_measure_disk_usage().
     */

    /**
     * Flags that can be used with g_file_measure_disk_usage().
     */
    export namespace FileMeasureFlags {
        export const $gtype: GObject.GType<FileMeasureFlags>;
    }

    enum FileMeasureFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Report any error encountered
         *   while traversing the directory tree.  Normally errors are only
         *   reported for the toplevel file.
         */
        REPORT_ANY_ERROR,
        /**
         * Tally usage based on apparent file
         *   sizes.  Normally, the block-size is used, if available, as this is a
         *   more accurate representation of disk space used.
         *   Compare with `du --apparent-size`.
         *   Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will
         *   ignore the sizes of file types other than regular files and links, as the
         *   sizes of other file types are not specified in a standard way.
         */
        APPARENT_SIZE,
        /**
         * Do not cross mount point boundaries.
         *   Compare with `du -x`.
         */
        NO_XDEV,
    }
    /**
     * Flags used to set what a #GFileMonitor will watch for.
     */

    /**
     * Flags used to set what a #GFileMonitor will watch for.
     */
    export namespace FileMonitorFlags {
        export const $gtype: GObject.GType<FileMonitorFlags>;
    }

    enum FileMonitorFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Watch for mount events.
         */
        WATCH_MOUNTS,
        /**
         * Pair DELETED and CREATED events caused
         *   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
         *   event instead (NB: not supported on all backends; the default
         *   behaviour -without specifying this flag- is to send single DELETED
         *   and CREATED events).  Deprecated since 2.46: use
         *   %G_FILE_MONITOR_WATCH_MOVES instead.
         */
        SEND_MOVED,
        /**
         * Watch for changes to the file made
         *   via another hard link. Since 2.36.
         */
        WATCH_HARD_LINKS,
        /**
         * Watch for rename operations on a
         *   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
         *   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
         *   events to be emitted when possible.  Since: 2.46.
         */
        WATCH_MOVES,
    }
    /**
     * Flags used when querying a #GFileInfo.
     */

    /**
     * Flags used when querying a #GFileInfo.
     */
    export namespace FileQueryInfoFlags {
        export const $gtype: GObject.GType<FileQueryInfoFlags>;
    }

    enum FileQueryInfoFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Don't follow symlinks.
         */
        NOFOLLOW_SYMLINKS,
    }
    /**
     * GIOStreamSpliceFlags determine how streams should be spliced.
     */

    /**
     * GIOStreamSpliceFlags determine how streams should be spliced.
     */
    export namespace IOStreamSpliceFlags {
        export const $gtype: GObject.GType<IOStreamSpliceFlags>;
    }

    enum IOStreamSpliceFlags {
        /**
         * Do not close either stream.
         */
        NONE,
        /**
         * Close the first stream after
         *     the splice.
         */
        CLOSE_STREAM1,
        /**
         * Close the second stream after
         *     the splice.
         */
        CLOSE_STREAM2,
        /**
         * Wait for both splice operations to finish
         *     before calling the callback.
         */
        WAIT_FOR_BOTH,
    }
    /**
     * Flags used when mounting a mount.
     */

    /**
     * Flags used when mounting a mount.
     */
    export namespace MountMountFlags {
        export const $gtype: GObject.GType<MountMountFlags>;
    }

    enum MountMountFlags {
        /**
         * No flags set.
         */
        NONE,
    }
    /**
     * Flags used when an unmounting a mount.
     */

    /**
     * Flags used when an unmounting a mount.
     */
    export namespace MountUnmountFlags {
        export const $gtype: GObject.GType<MountUnmountFlags>;
    }

    enum MountUnmountFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * Unmount even if there are outstanding
         *  file operations on the mount.
         */
        FORCE,
    }
    /**
     * GOutputStreamSpliceFlags determine how streams should be spliced.
     */

    /**
     * GOutputStreamSpliceFlags determine how streams should be spliced.
     */
    export namespace OutputStreamSpliceFlags {
        export const $gtype: GObject.GType<OutputStreamSpliceFlags>;
    }

    enum OutputStreamSpliceFlags {
        /**
         * Do not close either stream.
         */
        NONE,
        /**
         * Close the source stream after
         *     the splice.
         */
        CLOSE_SOURCE,
        /**
         * Close the target stream after
         *     the splice.
         */
        CLOSE_TARGET,
    }
    /**
     * Flags to modify lookup behavior.
     */

    /**
     * Flags to modify lookup behavior.
     */
    export namespace ResolverNameLookupFlags {
        export const $gtype: GObject.GType<ResolverNameLookupFlags>;
    }

    enum ResolverNameLookupFlags {
        /**
         * default behavior (same as g_resolver_lookup_by_name())
         */
        DEFAULT,
        /**
         * only resolve ipv4 addresses
         */
        IPV4_ONLY,
        /**
         * only resolve ipv6 addresses
         */
        IPV6_ONLY,
    }
    /**
     * GResourceFlags give information about a particular file inside a resource
     * bundle.
     */

    /**
     * GResourceFlags give information about a particular file inside a resource
     * bundle.
     */
    export namespace ResourceFlags {
        export const $gtype: GObject.GType<ResourceFlags>;
    }

    enum ResourceFlags {
        /**
         * No flags set.
         */
        NONE,
        /**
         * The file is compressed.
         */
        COMPRESSED,
    }
    /**
     * GResourceLookupFlags determine how resource path lookups are handled.
     */

    /**
     * GResourceLookupFlags determine how resource path lookups are handled.
     */
    export namespace ResourceLookupFlags {
        export const $gtype: GObject.GType<ResourceLookupFlags>;
    }

    enum ResourceLookupFlags {
        /**
         * No flags set.
         */
        NONE,
    }
    /**
     * Flags used when creating a binding. These flags determine in which
     * direction the binding works. The default is to synchronize in both
     * directions.
     */

    /**
     * Flags used when creating a binding. These flags determine in which
     * direction the binding works. The default is to synchronize in both
     * directions.
     */
    export namespace SettingsBindFlags {
        export const $gtype: GObject.GType<SettingsBindFlags>;
    }

    enum SettingsBindFlags {
        /**
         * Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
         */
        DEFAULT,
        /**
         * Update the #GObject property when the setting changes.
         *     It is an error to use this flag if the property is not writable.
         */
        GET,
        /**
         * Update the setting when the #GObject property changes.
         *     It is an error to use this flag if the property is not readable.
         */
        SET,
        /**
         * Do not try to bind a "sensitivity" property to the writability of the setting
         */
        NO_SENSITIVITY,
        /**
         * When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property
         *     value initially from the setting, but do not listen for changes of the setting
         */
        GET_NO_CHANGES,
        /**
         * When passed to g_settings_bind(), uses a pair of mapping functions that invert
         *     the boolean value when mapping between the setting and the property.  The setting and property must both
         *     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
         */
        INVERT_BOOLEAN,
    }
    /**
     * Flags used in g_socket_receive_message() and g_socket_send_message().
     * The flags listed in the enum are some commonly available flags, but the
     * values used for them are the same as on the platform, and any other flags
     * are passed in/out as is. So to use a platform specific flag, just include
     * the right system header and pass in the flag.
     */

    /**
     * Flags used in g_socket_receive_message() and g_socket_send_message().
     * The flags listed in the enum are some commonly available flags, but the
     * values used for them are the same as on the platform, and any other flags
     * are passed in/out as is. So to use a platform specific flag, just include
     * the right system header and pass in the flag.
     */
    export namespace SocketMsgFlags {
        export const $gtype: GObject.GType<SocketMsgFlags>;
    }

    enum SocketMsgFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * Request to send/receive out of band data.
         */
        OOB,
        /**
         * Read data from the socket without removing it from
         *     the queue.
         */
        PEEK,
        /**
         * Don't use a gateway to send out the packet,
         *     only send to hosts on directly connected networks.
         */
        DONTROUTE,
    }
    /**
     * Flags to define the behaviour of a #GSubprocess.
     *
     * Note that the default for stdin is to redirect from `/dev/null`.  For
     * stdout and stderr the default are for them to inherit the
     * corresponding descriptor from the calling process.
     *
     * Note that it is a programmer error to mix 'incompatible' flags.  For
     * example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
     * %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
     */

    /**
     * Flags to define the behaviour of a #GSubprocess.
     *
     * Note that the default for stdin is to redirect from `/dev/null`.  For
     * stdout and stderr the default are for them to inherit the
     * corresponding descriptor from the calling process.
     *
     * Note that it is a programmer error to mix 'incompatible' flags.  For
     * example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
     * %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
     */
    export namespace SubprocessFlags {
        export const $gtype: GObject.GType<SubprocessFlags>;
    }

    enum SubprocessFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * create a pipe for the stdin of the
         *   spawned process that can be accessed with
         *   g_subprocess_get_stdin_pipe().
         */
        STDIN_PIPE,
        /**
         * stdin is inherited from the
         *   calling process.
         */
        STDIN_INHERIT,
        /**
         * create a pipe for the stdout of the
         *   spawned process that can be accessed with
         *   g_subprocess_get_stdout_pipe().
         */
        STDOUT_PIPE,
        /**
         * silence the stdout of the spawned
         *   process (ie: redirect to `/dev/null`).
         */
        STDOUT_SILENCE,
        /**
         * create a pipe for the stderr of the
         *   spawned process that can be accessed with
         *   g_subprocess_get_stderr_pipe().
         */
        STDERR_PIPE,
        /**
         * silence the stderr of the spawned
         *   process (ie: redirect to `/dev/null`).
         */
        STDERR_SILENCE,
        /**
         * merge the stderr of the spawned
         *   process with whatever the stdout happens to be.  This is a good way
         *   of directing both streams to a common log file, for example.
         */
        STDERR_MERGE,
        /**
         * spawned processes will inherit the
         *   file descriptors of their parent, unless those descriptors have
         *   been explicitly marked as close-on-exec.  This flag has no effect
         *   over the "standard" file descriptors (stdin, stdout, stderr).
         */
        INHERIT_FDS,
        /**
         * if path searching is
         *   needed when spawning the subprocess, use the `PATH` in the launcher
         *   environment. (Since: 2.72)
         */
        SEARCH_PATH_FROM_ENVP,
    }
    /**
     * Flags to define future #GTestDBus behaviour.
     */

    /**
     * Flags to define future #GTestDBus behaviour.
     */
    export namespace TestDBusFlags {
        export const $gtype: GObject.GType<TestDBusFlags>;
    }

    enum TestDBusFlags {
        /**
         * No flags.
         */
        NONE,
    }
    /**
     * A set of flags describing TLS certification validation. This can be
     * used to describe why a particular certificate was rejected (for
     * example, in #GTlsConnection::accept-certificate).
     *
     * GLib guarantees that if certificate verification fails, at least one
     * flag will be set, but it does not guarantee that all possible flags
     * will be set. Accordingly, you may not safely decide to ignore any
     * particular type of error. For example, it would be incorrect to mask
     * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
     * because this could potentially be the only error flag set even if
     * other problems exist with the certificate.
     */

    /**
     * A set of flags describing TLS certification validation. This can be
     * used to describe why a particular certificate was rejected (for
     * example, in #GTlsConnection::accept-certificate).
     *
     * GLib guarantees that if certificate verification fails, at least one
     * flag will be set, but it does not guarantee that all possible flags
     * will be set. Accordingly, you may not safely decide to ignore any
     * particular type of error. For example, it would be incorrect to mask
     * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
     * because this could potentially be the only error flag set even if
     * other problems exist with the certificate.
     */
    export namespace TlsCertificateFlags {
        export const $gtype: GObject.GType<TlsCertificateFlags>;
    }

    enum TlsCertificateFlags {
        /**
         * No flags set. Since: 2.74
         */
        NO_FLAGS,
        /**
         * The signing certificate authority is
         *   not known.
         */
        UNKNOWN_CA,
        /**
         * The certificate does not match the
         *   expected identity of the site that it was retrieved from.
         */
        BAD_IDENTITY,
        /**
         * The certificate's activation time
         *   is still in the future
         */
        NOT_ACTIVATED,
        /**
         * The certificate has expired
         */
        EXPIRED,
        /**
         * The certificate has been revoked
         *   according to the #GTlsConnection's certificate revocation list.
         */
        REVOKED,
        /**
         * The certificate's algorithm is
         *   considered insecure.
         */
        INSECURE,
        /**
         * Some other error occurred validating
         *   the certificate
         */
        GENERIC_ERROR,
        /**
         * the combination of all of the above
         *   flags
         */
        VALIDATE_ALL,
    }
    /**
     * Flags for g_tls_database_verify_chain().
     */

    /**
     * Flags for g_tls_database_verify_chain().
     */
    export namespace TlsDatabaseVerifyFlags {
        export const $gtype: GObject.GType<TlsDatabaseVerifyFlags>;
    }

    enum TlsDatabaseVerifyFlags {
        /**
         * No verification flags
         */
        NONE,
    }
    /**
     * Various flags for the password.
     */

    /**
     * Various flags for the password.
     */
    export namespace TlsPasswordFlags {
        export const $gtype: GObject.GType<TlsPasswordFlags>;
    }

    enum TlsPasswordFlags {
        /**
         * No flags
         */
        NONE,
        /**
         * The password was wrong, and the user should retry.
         */
        RETRY,
        /**
         * Hint to the user that the password has been
         *    wrong many times, and the user may not have many chances left.
         */
        MANY_TRIES,
        /**
         * Hint to the user that this is the last try to get
         *    this password right.
         */
        FINAL_TRY,
        /**
         * For PKCS #11, the user PIN is required.
         *    Since: 2.70.
         */
        PKCS11_USER,
        /**
         * For PKCS #11, the security officer
         *    PIN is required. Since: 2.70.
         */
        PKCS11_SECURITY_OFFICER,
        /**
         * For PKCS #11, the context-specific
         *    PIN is required. Since: 2.70.
         */
        PKCS11_CONTEXT_SPECIFIC,
    }
    module AppInfoMonitor {
        // Signal callback interfaces

        interface Changed {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GAppInfoMonitor` monitors application information for changes.
     *
     * `GAppInfoMonitor` is a very simple object used for monitoring the app
     * info database for changes (newly installed or removed applications).
     *
     * Call [func`Gio`.AppInfoMonitor.get] to get a `GAppInfoMonitor` and connect
     * to the [signal`Gio`.AppInfoMonitor::changed] signal. The signal will be emitted once when
     * the app info database changes, and will not be emitted again until after the
     * next call to [func`Gio`.AppInfo.get_all] or another `g_app_info_*()` function.
     * This is because monitoring the app info database for changes is expensive.
     *
     * The following functions will re-arm the [signal`Gio`.AppInfoMonitor::changed]
     * signal so it can be emitted again:
     *
     *  - [func`Gio`.AppInfo.get_all]
     *  - [func`Gio`.AppInfo.get_all_for_type]
     *  - [func`Gio`.AppInfo.get_default_for_type]
     *  - [func`Gio`.AppInfo.get_fallback_for_type]
     *  - [func`Gio`.AppInfo.get_recommended_for_type]
     *  - [`g_desktop_app_info_get_implementations()`](../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
     *  - [`g_desktop_app_info_new()`](../gio-unix/ctor.DesktopAppInfo.new.html)
     *  - [`g_desktop_app_info_new_from_filename()`](../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
     *  - [`g_desktop_app_info_new_from_keyfile()`](../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
     *  - [`g_desktop_app_info_search()`](../gio-unix/type_func.DesktopAppInfo.search.html)
     *
     * The latter functions are available if using
     * [`GDesktopAppInfo`](../gio-unix/class.DesktopAppInfo.html) from
     * `gio-unix-2.0.pc` (GIR namespace `GioUnix-2.0`).
     *
     * In the usual case, applications should try to make note of the change
     * (doing things like invalidating caches) but not act on it. In
     * particular, applications should avoid making calls to `GAppInfo` APIs
     * in response to the change signal, deferring these until the time that
     * the updated data is actually required. The exception to this case is when
     * application information is actually being displayed on the screen
     * (for example, during a search or when the list of all applications is shown).
     * The reason for this is that changes to the list of installed applications
     * often come in groups (like during system updates) and rescanning the list
     * on every change is pointless and expensive.
     */
    class AppInfoMonitor extends GObject.Object {
        static $gtype: GObject.GType<AppInfoMonitor>;

        // Constructors

        constructor(properties?: Partial<AppInfoMonitor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'changed', callback: (_source: this) => void): number;
        connect_after(signal: 'changed', callback: (_source: this) => void): number;
        emit(signal: 'changed'): void;

        // Static methods

        /**
         * Gets the #GAppInfoMonitor for the current thread-default main
         * context.
         *
         * The #GAppInfoMonitor will emit a "changed" signal in the
         * thread-default main context whenever the list of installed
         * applications (as reported by g_app_info_get_all()) may have changed.
         *
         * The #GAppInfoMonitor::changed signal will only be emitted once until
         * g_app_info_get_all() (or another `g_app_info_*()` function) is called. Doing
         * so will re-arm the signal ready to notify about the next change.
         *
         * You must only call g_object_unref() on the return value from under
         * the same main context as you created it.
         */
        static get(): AppInfoMonitor;
    }

    module AppLaunchContext {
        // Signal callback interfaces

        interface LaunchFailed {
            (startup_notify_id: string): void;
        }

        interface LaunchStarted {
            (info: AppInfo, platform_data?: GLib.Variant | null): void;
        }

        interface Launched {
            (info: AppInfo, platform_data: GLib.Variant): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * Integrating the launch with the launching application. This is used to
     * handle for instance startup notification and launching the new application
     * on the same screen as the launching window.
     */
    class AppLaunchContext extends GObject.Object {
        static $gtype: GObject.GType<AppLaunchContext>;

        // Constructors

        constructor(properties?: Partial<AppLaunchContext.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): AppLaunchContext;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'launch-failed', callback: (_source: this, startup_notify_id: string) => void): number;
        connect_after(signal: 'launch-failed', callback: (_source: this, startup_notify_id: string) => void): number;
        emit(signal: 'launch-failed', startup_notify_id: string): void;
        connect(
            signal: 'launch-started',
            callback: (_source: this, info: AppInfo, platform_data: GLib.Variant | null) => void,
        ): number;
        connect_after(
            signal: 'launch-started',
            callback: (_source: this, info: AppInfo, platform_data: GLib.Variant | null) => void,
        ): number;
        emit(signal: 'launch-started', info: AppInfo, platform_data?: GLib.Variant | null): void;
        connect(
            signal: 'launched',
            callback: (_source: this, info: AppInfo, platform_data: GLib.Variant) => void,
        ): number;
        connect_after(
            signal: 'launched',
            callback: (_source: this, info: AppInfo, platform_data: GLib.Variant) => void,
        ): number;
        emit(signal: 'launched', info: AppInfo, platform_data: GLib.Variant): void;

        // Virtual methods

        /**
         * Gets the display string for the `context`. This is used to ensure new
         * applications are started on the same display as the launching
         * application, by setting the `DISPLAY` environment variable.
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         */
        vfunc_get_display(info: AppInfo, files: File[]): string | null;
        /**
         * Initiates startup notification for the application and returns the
         * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
         * if supported.
         *
         * The returned token may be referred to equivalently as an activation token
         * (using Wayland terminology) or a startup sequence ID (using X11 terminology).
         * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
         *
         * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
         * and startup notification IDs are defined in the
         * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
         *
         * Support for the XDG Activation Protocol was added in GLib 2.76.
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         */
        vfunc_get_startup_notify_id(info: AppInfo, files: File[]): string | null;
        /**
         * Called when an application has failed to launch, so that it can cancel
         * the application startup notification started in g_app_launch_context_get_startup_notify_id().
         * @param startup_notify_id the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().
         */
        vfunc_launch_failed(startup_notify_id: string): void;
        vfunc_launch_started(info: AppInfo, platform_data: GLib.Variant): void;
        vfunc_launched(info: AppInfo, platform_data: GLib.Variant): void;

        // Methods

        /**
         * Gets the display string for the `context`. This is used to ensure new
         * applications are started on the same display as the launching
         * application, by setting the `DISPLAY` environment variable.
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         * @returns a display string for the display.
         */
        get_display(info: AppInfo, files: File[]): string | null;
        /**
         * Gets the complete environment variable list to be passed to
         * the child process when `context` is used to launch an application.
         * This is a %NULL-terminated array of strings, where each string has
         * the form `KEY=VALUE`.
         * @returns the child's environment
         */
        get_environment(): string[];
        /**
         * Initiates startup notification for the application and returns the
         * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
         * if supported.
         *
         * The returned token may be referred to equivalently as an activation token
         * (using Wayland terminology) or a startup sequence ID (using X11 terminology).
         * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
         *
         * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
         * and startup notification IDs are defined in the
         * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
         *
         * Support for the XDG Activation Protocol was added in GLib 2.76.
         * @param info a #GAppInfo
         * @param files a #GList of #GFile objects
         * @returns a startup notification ID for the application, or %NULL if     not supported.
         */
        get_startup_notify_id(info: AppInfo, files: File[]): string | null;
        /**
         * Called when an application has failed to launch, so that it can cancel
         * the application startup notification started in g_app_launch_context_get_startup_notify_id().
         * @param startup_notify_id the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().
         */
        launch_failed(startup_notify_id: string): void;
        /**
         * Arranges for `variable` to be set to `value` in the child's
         * environment when `context` is used to launch an application.
         * @param variable the environment variable to set
         * @param value the value for to set the variable to.
         */
        setenv(variable: string, value: string): void;
        /**
         * Arranges for `variable` to be unset in the child's environment
         * when `context` is used to launch an application.
         * @param variable the environment variable to remove
         */
        unsetenv(variable: string): void;
    }

    module Application {
        // Signal callback interfaces

        interface Activate {
            (): void;
        }

        interface CommandLine {
            (command_line: ApplicationCommandLine): number;
        }

        interface HandleLocalOptions {
            (options: GLib.VariantDict): number;
        }

        interface NameLost {
            (): boolean;
        }

        interface Open {
            (files: File[], hint: string): void;
        }

        interface Shutdown {
            (): void;
        }

        interface Startup {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                ActionGroup.ConstructorProps,
                ActionMap.ConstructorProps {
            action_group: ActionGroup;
            actionGroup: ActionGroup;
            application_id: string;
            applicationId: string;
            flags: ApplicationFlags;
            inactivity_timeout: number;
            inactivityTimeout: number;
            is_busy: boolean;
            isBusy: boolean;
            is_registered: boolean;
            isRegistered: boolean;
            is_remote: boolean;
            isRemote: boolean;
            resource_base_path: string;
            resourceBasePath: string;
            version: string;
        }
    }

    /**
     * `GApplication` is the core class for application support.
     *
     * A `GApplication` is the foundation of an application. It wraps some
     * low-level platform-specific services and is intended to act as the
     * foundation for higher-level application classes such as
     * `GtkApplication` or `MxApplication`. In general, you should not use
     * this class outside of a higher level framework.
     *
     * `GApplication` provides convenient life-cycle management by maintaining
     * a "use count" for the primary application instance. The use count can
     * be changed using [method`Gio`.Application.hold] and
     * [method`Gio`.Application.release]. If it drops to zero, the application
     * exits. Higher-level classes such as `GtkApplication` employ the use count
     * to ensure that the application stays alive as long as it has any opened
     * windows.
     *
     * Another feature that `GApplication` (optionally) provides is process
     * uniqueness. Applications can make use of this functionality by
     * providing a unique application ID. If given, only one application
     * with this ID can be running at a time per session. The session
     * concept is platform-dependent, but corresponds roughly to a graphical
     * desktop login. When your application is launched again, its
     * arguments are passed through platform communication to the already
     * running program. The already running instance of the program is
     * called the "primary instance"; for non-unique applications this is
     * always the current instance. On Linux, the D-Bus session bus
     * is used for communication.
     *
     * The use of `GApplication` differs from some other commonly-used
     * uniqueness libraries (such as libunique) in important ways. The
     * application is not expected to manually register itself and check
     * if it is the primary instance. Instead, the main() function of a
     * `GApplication` should do very little more than instantiating the
     * application instance, possibly connecting signal handlers, then
     * calling [method`Gio`.Application.run]. All checks for uniqueness are done
     * internally. If the application is the primary instance then the
     * startup signal is emitted and the mainloop runs. If the application
     * is not the primary instance then a signal is sent to the primary
     * instance and [method`Gio`.Application.run] promptly returns. See the code
     * examples below.
     *
     * If used, the expected form of an application identifier is the
     * same as that of a
     * [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
     * Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
     * `org._7_zip.Archiver`.
     * For details on valid application identifiers, see [func`Gio`.Application.id_is_valid].
     *
     * On Linux, the application identifier is claimed as a well-known bus name
     * on the user's session bus. This means that the uniqueness of your
     * application is scoped to the current session. It also means that your
     * application may provide additional services (through registration of other
     * object paths) at that bus name. The registration of these object paths
     * should be done with the shared GDBus session bus. Note that due to the
     * internal architecture of GDBus, method calls can be dispatched at any time
     * (even if a main loop is not running). For this reason, you must ensure that
     * any object paths that you wish to register are registered before #GApplication
     * attempts to acquire the bus name of your application (which happens in
     * [method`Gio`.Application.register]). Unfortunately, this means that you cannot
     * use [property`Gio`.Application:is-remote] to decide if you want to register
     * object paths.
     *
     * `GApplication` also implements the [iface`Gio`.ActionGroup] and [iface`Gio`.ActionMap]
     * interfaces and lets you easily export actions by adding them with
     * [method`Gio`.ActionMap.add_action]. When invoking an action by calling
     * [method`Gio`.ActionGroup.activate_action] on the application, it is always
     * invoked in the primary instance. The actions are also exported on
     * the session bus, and GIO provides the [class`Gio`.DBusActionGroup] wrapper to
     * conveniently access them remotely. GIO provides a [class`Gio`.DBusMenuModel] wrapper
     * for remote access to exported [class`Gio`.MenuModel]s.
     *
     * Note: Due to the fact that actions are exported on the session bus,
     * using `maybe` parameters is not supported, since D-Bus does not support
     * `maybe` types.
     *
     * There is a number of different entry points into a `GApplication`:
     *
     * - via 'Activate' (i.e. just starting the application)
     *
     * - via 'Open' (i.e. opening some files)
     *
     * - by handling a command-line
     *
     * - via activating an action
     *
     * The [signal`Gio`.Application::startup] signal lets you handle the application
     * initialization for all of these in a single place.
     *
     * Regardless of which of these entry points is used to start the
     * application, `GApplication` passes some platform data from the
     * launching instance to the primary instance, in the form of a
     * [struct`GLib`.Variant] dictionary mapping strings to variants. To use platform
     * data, override the [vfunc`Gio`.Application.before_emit] or
     * [vfunc`Gio`.Application.after_emit] virtual functions
     * in your `GApplication` subclass. When dealing with
     * [class`Gio`.ApplicationCommandLine] objects, the platform data is
     * directly available via [method`Gio`.ApplicationCommandLine.get_cwd],
     * [method`Gio`.ApplicationCommandLine.get_environ] and
     * [method`Gio`.ApplicationCommandLine.get_platform_data].
     *
     * As the name indicates, the platform data may vary depending on the
     * operating system, but it always includes the current directory (key
     * `cwd`), and optionally the environment (ie the set of environment
     * variables and their values) of the calling process (key `environ`).
     * The environment is only added to the platform data if the
     * `G_APPLICATION_SEND_ENVIRONMENT` flag is set. `GApplication` subclasses
     * can add their own platform data by overriding the
     * [vfunc`Gio`.Application.add_platform_data] virtual function. For instance,
     * `GtkApplication` adds startup notification data in this way.
     *
     * To parse commandline arguments you may handle the
     * [signal`Gio`.Application::command-line] signal or override the
     * [vfunc`Gio`.Application.local_command_line] virtual funcion, to parse them in
     * either the primary instance or the local instance, respectively.
     *
     * For an example of opening files with a `GApplication`, see
     * [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
     *
     * For an example of using actions with `GApplication`, see
     * [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
     *
     * For an example of using extra D-Bus hooks with `GApplication`, see
     * [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
     */
    class Application extends GObject.Object implements ActionGroup, ActionMap {
        static $gtype: GObject.GType<Application>;

        // Properties

        /**
         * The group of actions that the application exports.
         */
        set action_group(val: ActionGroup);
        /**
         * The group of actions that the application exports.
         */
        set actionGroup(val: ActionGroup);
        /**
         * The unique identifier for the application.
         */
        get application_id(): string;
        set application_id(val: string);
        /**
         * The unique identifier for the application.
         */
        get applicationId(): string;
        set applicationId(val: string);
        /**
         * Flags specifying the behaviour of the application.
         */
        get flags(): ApplicationFlags;
        set flags(val: ApplicationFlags);
        /**
         * Time (in milliseconds) to stay alive after becoming idle.
         */
        get inactivity_timeout(): number;
        set inactivity_timeout(val: number);
        /**
         * Time (in milliseconds) to stay alive after becoming idle.
         */
        get inactivityTimeout(): number;
        set inactivityTimeout(val: number);
        /**
         * Whether the application is currently marked as busy through
         * g_application_mark_busy() or g_application_bind_busy_property().
         */
        get is_busy(): boolean;
        /**
         * Whether the application is currently marked as busy through
         * g_application_mark_busy() or g_application_bind_busy_property().
         */
        get isBusy(): boolean;
        /**
         * Whether [method`Gio`.Application.register] has been called.
         */
        get is_registered(): boolean;
        /**
         * Whether [method`Gio`.Application.register] has been called.
         */
        get isRegistered(): boolean;
        /**
         * Whether this application instance is remote.
         */
        get is_remote(): boolean;
        /**
         * Whether this application instance is remote.
         */
        get isRemote(): boolean;
        /**
         * The base resource path for the application.
         */
        get resource_base_path(): string;
        set resource_base_path(val: string);
        /**
         * The base resource path for the application.
         */
        get resourceBasePath(): string;
        set resourceBasePath(val: string);
        /**
         * The human-readable version number of the application.
         */
        get version(): string;
        set version(val: string);

        // Constructors

        constructor(properties?: Partial<Application.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](application_id: string | null, flags: ApplicationFlags): Application;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'activate', callback: (_source: this) => void): number;
        connect_after(signal: 'activate', callback: (_source: this) => void): number;
        emit(signal: 'activate'): void;
        connect(
            signal: 'command-line',
            callback: (_source: this, command_line: ApplicationCommandLine) => number,
        ): number;
        connect_after(
            signal: 'command-line',
            callback: (_source: this, command_line: ApplicationCommandLine) => number,
        ): number;
        emit(signal: 'command-line', command_line: ApplicationCommandLine): void;
        connect(signal: 'handle-local-options', callback: (_source: this, options: GLib.VariantDict) => number): number;
        connect_after(
            signal: 'handle-local-options',
            callback: (_source: this, options: GLib.VariantDict) => number,
        ): number;
        emit(signal: 'handle-local-options', options: GLib.VariantDict): void;
        connect(signal: 'name-lost', callback: (_source: this) => boolean): number;
        connect_after(signal: 'name-lost', callback: (_source: this) => boolean): number;
        emit(signal: 'name-lost'): void;
        connect(signal: 'open', callback: (_source: this, files: File[], hint: string) => void): number;
        connect_after(signal: 'open', callback: (_source: this, files: File[], hint: string) => void): number;
        emit(signal: 'open', files: File[], hint: string): void;
        connect(signal: 'shutdown', callback: (_source: this) => void): number;
        connect_after(signal: 'shutdown', callback: (_source: this) => void): number;
        emit(signal: 'shutdown'): void;
        connect(signal: 'startup', callback: (_source: this) => void): number;
        connect_after(signal: 'startup', callback: (_source: this) => void): number;
        emit(signal: 'startup'): void;

        // Static methods

        /**
         * Returns the default #GApplication instance for this process.
         *
         * Normally there is only one #GApplication per process and it becomes
         * the default when it is created.  You can exercise more control over
         * this by using g_application_set_default().
         *
         * If there is no default application then %NULL is returned.
         */
        static get_default(): Application | null;
        /**
         * Checks if `application_id` is a valid application identifier.
         *
         * A valid ID is required for calls to g_application_new() and
         * g_application_set_application_id().
         *
         * Application identifiers follow the same format as
         * [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
         * For convenience, the restrictions on application identifiers are
         * reproduced here:
         *
         * - Application identifiers are composed of 1 or more elements separated by a
         *   period (`.`) character. All elements must contain at least one character.
         *
         * - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
         *   with `-` discouraged in new application identifiers. Each element must not
         *   begin with a digit.
         *
         * - Application identifiers must contain at least one `.` (period) character
         *   (and thus at least two elements).
         *
         * - Application identifiers must not begin with a `.` (period) character.
         *
         * - Application identifiers must not exceed 255 characters.
         *
         * Note that the hyphen (`-`) character is allowed in application identifiers,
         * but is problematic or not allowed in various specifications and APIs that
         * refer to D-Bus, such as
         * [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
         * the
         * [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
         * and the convention that an application's "main" interface and object path
         * resemble its application identifier and bus name. To avoid situations that
         * require special-case handling, it is recommended that new application
         * identifiers consistently replace hyphens with underscores.
         *
         * Like D-Bus interface names, application identifiers should start with the
         * reversed DNS domain name of the author of the interface (in lower-case), and
         * it is conventional for the rest of the application identifier to consist of
         * words run together, with initial capital letters.
         *
         * As with D-Bus interface names, if the author's DNS domain name contains
         * hyphen/minus characters they should be replaced by underscores, and if it
         * contains leading digits they should be escaped by prepending an underscore.
         * For example, if the owner of 7-zip.org used an application identifier for an
         * archiving application, it might be named `org._7_zip.Archiver`.
         * @param application_id a potential application identifier
         */
        static id_is_valid(application_id: string): boolean;

        // Virtual methods

        /**
         * Activates the application.
         *
         * In essence, this results in the #GApplication::activate signal being
         * emitted in the primary instance.
         *
         * The application must be registered before calling this function.
         */
        vfunc_activate(): void;
        /**
         * invoked (locally) to add 'platform data' to be sent to
         *     the primary instance when activating, opening or invoking actions
         * @param builder
         */
        vfunc_add_platform_data(builder: GLib.VariantBuilder): void;
        /**
         * invoked on the primary instance after 'activate', 'open',
         *     'command-line' or any action invocation, gets the 'platform data' from
         *     the calling instance
         * @param platform_data
         */
        vfunc_after_emit(platform_data: GLib.Variant): void;
        /**
         * invoked on the primary instance before 'activate', 'open',
         *     'command-line' or any action invocation, gets the 'platform data' from
         *     the calling instance
         * @param platform_data
         */
        vfunc_before_emit(platform_data: GLib.Variant): void;
        /**
         * invoked on the primary instance when a command-line is
         *   not handled locally
         * @param command_line
         */
        vfunc_command_line(command_line: ApplicationCommandLine): number;
        /**
         * invoked locally during registration, if the application is
         *     using its D-Bus backend. You can use this to export extra objects on the
         *     bus, that need to exist before the application tries to own the bus name.
         *     The function is passed the #GDBusConnection to to session bus, and the
         *     object path that #GApplication will use to export its D-Bus API.
         *     If this function returns %TRUE, registration will proceed; otherwise
         *     registration will abort. Since: 2.34
         * @param connection
         * @param object_path
         */
        vfunc_dbus_register(connection: DBusConnection, object_path: string): boolean;
        /**
         * invoked locally during unregistration, if the application
         *     is using its D-Bus backend. Use this to undo anything done by
         *     the `dbus_register` vfunc. Since: 2.34
         * @param connection
         * @param object_path
         */
        vfunc_dbus_unregister(connection: DBusConnection, object_path: string): void;
        /**
         * invoked locally after the parsing of the commandline
         *  options has occurred. Since: 2.40
         * @param options
         */
        vfunc_handle_local_options(options: GLib.VariantDict): number;
        /**
         * This virtual function is always invoked in the local instance. It
         * gets passed a pointer to a %NULL-terminated copy of `argv` and is
         * expected to remove arguments that it handled (shifting up remaining
         * arguments).
         *
         * The last argument to local_command_line() is a pointer to the `status`
         * variable which can used to set the exit status that is returned from
         * g_application_run().
         *
         * See g_application_run() for more details on #GApplication startup.
         * @param _arguments array of command line arguments
         */
        vfunc_local_command_line(_arguments: string[]): [boolean, string[], number];
        /**
         * invoked when another instance is taking over the name. Since: 2.60
         */
        vfunc_name_lost(): boolean;
        /**
         * Opens the given files.
         *
         * In essence, this results in the #GApplication::open signal being emitted
         * in the primary instance.
         *
         * `n_files` must be greater than zero.
         *
         * `hint` is simply passed through to the ::open signal.  It is
         * intended to be used by applications that have multiple modes for
         * opening files (eg: "view" vs "edit", etc).  Unless you have a need
         * for this functionality, you should use "".
         *
         * The application must be registered before calling this function
         * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
         * @param files an array of #GFiles to open
         * @param hint a hint (or ""), but never %NULL
         */
        vfunc_open(files: File[], hint: string): void;
        /**
         * Used to be invoked on the primary instance when the use
         *     count of the application drops to zero (and after any inactivity
         *     timeout, if requested). Not used anymore since 2.32
         */
        vfunc_quit_mainloop(): void;
        /**
         * Used to be invoked on the primary instance from
         *     g_application_run() if the use-count is non-zero. Since 2.32,
         *     GApplication is iterating the main context directly and is not
         *     using `run_mainloop` anymore
         */
        vfunc_run_mainloop(): void;
        /**
         * invoked only on the registered primary instance immediately
         *      after the main loop terminates
         */
        vfunc_shutdown(): void;
        /**
         * invoked on the primary instance immediately after registration
         */
        vfunc_startup(): void;

        // Methods

        /**
         * Activates the application.
         *
         * In essence, this results in the #GApplication::activate signal being
         * emitted in the primary instance.
         *
         * The application must be registered before calling this function.
         */
        activate(): void;
        /**
         * Add an option to be handled by `application`.
         *
         * Calling this function is the equivalent of calling
         * g_application_add_main_option_entries() with a single #GOptionEntry
         * that has its arg_data member set to %NULL.
         *
         * The parsed arguments will be packed into a #GVariantDict which
         * is passed to #GApplication::handle-local-options. If
         * %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
         * be sent to the primary instance. See
         * g_application_add_main_option_entries() for more details.
         *
         * See #GOptionEntry for more documentation of the arguments.
         * @param long_name the long name of an option used to specify it in a commandline
         * @param short_name the short name of an option
         * @param flags flags from #GOptionFlags
         * @param arg the type of the option, as a #GOptionArg
         * @param description the description for the option in `--help` output
         * @param arg_description the placeholder to use for the extra argument    parsed by the option in `--help` output
         */
        add_main_option(
            long_name: string,
            short_name: number,
            flags: GLib.OptionFlags,
            arg: GLib.OptionArg,
            description: string,
            arg_description?: string | null,
        ): void;
        /**
         * Adds main option entries to be handled by `application`.
         *
         * This function is comparable to g_option_context_add_main_entries().
         *
         * After the commandline arguments are parsed, the
         * #GApplication::handle-local-options signal will be emitted.  At this
         * point, the application can inspect the values pointed to by `arg_data`
         * in the given #GOptionEntrys.
         *
         * Unlike #GOptionContext, #GApplication supports giving a %NULL
         * `arg_data` for a non-callback #GOptionEntry.  This results in the
         * argument in question being packed into a #GVariantDict which is also
         * passed to #GApplication::handle-local-options, where it can be
         * inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
         * set, then the resulting dictionary is sent to the primary instance,
         * where g_application_command_line_get_options_dict() will return it.
         * As it has been passed outside the process at this point, the types of all
         * values in the options dict must be checked before being used.
         * This "packing" is done according to the type of the argument --
         * booleans for normal flags, strings for strings, bytestrings for
         * filenames, etc.  The packing only occurs if the flag is given (ie: we
         * do not pack a "false" #GVariant in the case that a flag is missing).
         *
         * In general, it is recommended that all commandline arguments are
         * parsed locally.  The options dictionary should then be used to
         * transmit the result of the parsing to the primary instance, where
         * g_variant_dict_lookup() can be used.  For local options, it is
         * possible to either use `arg_data` in the usual way, or to consult (and
         * potentially remove) the option from the options dictionary.
         *
         * This function is new in GLib 2.40.  Before then, the only real choice
         * was to send all of the commandline arguments (options and all) to the
         * primary instance for handling.  #GApplication ignored them completely
         * on the local side.  Calling this function "opts in" to the new
         * behaviour, and in particular, means that unrecognised options will be
         * treated as errors.  Unrecognised options have never been ignored when
         * %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
         *
         * If #GApplication::handle-local-options needs to see the list of
         * filenames, then the use of %G_OPTION_REMAINING is recommended.  If
         * `arg_data` is %NULL then %G_OPTION_REMAINING can be used as a key into
         * the options dictionary.  If you do use %G_OPTION_REMAINING then you
         * need to handle these arguments for yourself because once they are
         * consumed, they will no longer be visible to the default handling
         * (which treats them as filenames to be opened).
         *
         * It is important to use the proper GVariant format when retrieving
         * the options with g_variant_dict_lookup():
         * - for %G_OPTION_ARG_NONE, use `b`
         * - for %G_OPTION_ARG_STRING, use `&s`
         * - for %G_OPTION_ARG_INT, use `i`
         * - for %G_OPTION_ARG_INT64, use `x`
         * - for %G_OPTION_ARG_DOUBLE, use `d`
         * - for %G_OPTION_ARG_FILENAME, use `^&ay`
         * - for %G_OPTION_ARG_STRING_ARRAY, use `^a&s`
         * - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&ay`
         * @param entries the   main options for the application
         */
        add_main_option_entries(entries: GLib.OptionEntry[]): void;
        /**
         * Adds a #GOptionGroup to the commandline handling of `application`.
         *
         * This function is comparable to g_option_context_add_group().
         *
         * Unlike g_application_add_main_option_entries(), this function does
         * not deal with %NULL `arg_data` and never transmits options to the
         * primary instance.
         *
         * The reason for that is because, by the time the options arrive at the
         * primary instance, it is typically too late to do anything with them.
         * Taking the GTK option group as an example: GTK will already have been
         * initialised by the time the #GApplication::command-line handler runs.
         * In the case that this is not the first-running instance of the
         * application, the existing instance may already have been running for
         * a very long time.
         *
         * This means that the options from #GOptionGroup are only really usable
         * in the case that the instance of the application being run is the
         * first instance.  Passing options like `--display=` or `--gdk-debug=`
         * on future runs will have no effect on the existing primary instance.
         *
         * Calling this function will cause the options in the supplied option
         * group to be parsed, but it does not cause you to be "opted in" to the
         * new functionality whereby unrecognised options are rejected even if
         * %G_APPLICATION_HANDLES_COMMAND_LINE was given.
         * @param group a #GOptionGroup
         */
        add_option_group(group: GLib.OptionGroup): void;
        /**
         * Marks `application` as busy (see g_application_mark_busy()) while
         * `property` on `object` is %TRUE.
         *
         * The binding holds a reference to `application` while it is active, but
         * not to `object`. Instead, the binding is destroyed when `object` is
         * finalized.
         * @param object a #GObject
         * @param property the name of a boolean property of @object
         */
        bind_busy_property(object: GObject.Object, property: string): void;
        /**
         * Gets the unique identifier for `application`.
         * @returns the identifier for @application, owned by @application
         */
        get_application_id(): string | null;
        /**
         * Gets the #GDBusConnection being used by the application, or %NULL.
         *
         * If #GApplication is using its D-Bus backend then this function will
         * return the #GDBusConnection being used for uniqueness and
         * communication with the desktop environment and other instances of the
         * application.
         *
         * If #GApplication is not using D-Bus then this function will return
         * %NULL.  This includes the situation where the D-Bus backend would
         * normally be in use but we were unable to connect to the bus.
         *
         * This function must not be called before the application has been
         * registered.  See g_application_get_is_registered().
         * @returns a #GDBusConnection, or %NULL
         */
        get_dbus_connection(): DBusConnection | null;
        /**
         * Gets the D-Bus object path being used by the application, or %NULL.
         *
         * If #GApplication is using its D-Bus backend then this function will
         * return the D-Bus object path that #GApplication is using.  If the
         * application is the primary instance then there is an object published
         * at this path.  If the application is not the primary instance then
         * the result of this function is undefined.
         *
         * If #GApplication is not using D-Bus then this function will return
         * %NULL.  This includes the situation where the D-Bus backend would
         * normally be in use but we were unable to connect to the bus.
         *
         * This function must not be called before the application has been
         * registered.  See g_application_get_is_registered().
         * @returns the object path, or %NULL
         */
        get_dbus_object_path(): string | null;
        /**
         * Gets the flags for `application`.
         *
         * See #GApplicationFlags.
         * @returns the flags for @application
         */
        get_flags(): ApplicationFlags;
        /**
         * Gets the current inactivity timeout for the application.
         *
         * This is the amount of time (in milliseconds) after the last call to
         * g_application_release() before the application stops running.
         * @returns the timeout, in milliseconds
         */
        get_inactivity_timeout(): number;
        /**
         * Gets the application's current busy state, as set through
         * g_application_mark_busy() or g_application_bind_busy_property().
         * @returns %TRUE if @application is currently marked as busy
         */
        get_is_busy(): boolean;
        /**
         * Checks if `application` is registered.
         *
         * An application is registered if g_application_register() has been
         * successfully called.
         * @returns %TRUE if @application is registered
         */
        get_is_registered(): boolean;
        /**
         * Checks if `application` is remote.
         *
         * If `application` is remote then it means that another instance of
         * application already exists (the 'primary' instance).  Calls to
         * perform actions on `application` will result in the actions being
         * performed by the primary instance.
         *
         * The value of this property cannot be accessed before
         * g_application_register() has been called.  See
         * g_application_get_is_registered().
         * @returns %TRUE if @application is remote
         */
        get_is_remote(): boolean;
        /**
         * Gets the resource base path of `application`.
         *
         * See g_application_set_resource_base_path() for more information.
         * @returns the base resource path, if one is set
         */
        get_resource_base_path(): string | null;
        /**
         * Gets the version of `application`.
         * @returns the version of @application
         */
        get_version(): string | null;
        /**
         * Increases the use count of `application`.
         *
         * Use this function to indicate that the application has a reason to
         * continue to run.  For example, g_application_hold() is called by GTK
         * when a toplevel window is on the screen.
         *
         * To cancel the hold, call g_application_release().
         */
        hold(): void;
        /**
         * Increases the busy count of `application`.
         *
         * Use this function to indicate that the application is busy, for instance
         * while a long running operation is pending.
         *
         * The busy state will be exposed to other processes, so a session shell will
         * use that information to indicate the state to the user (e.g. with a
         * spinner).
         *
         * To cancel the busy indication, use g_application_unmark_busy().
         *
         * The application must be registered before calling this function.
         */
        mark_busy(): void;
        /**
         * Opens the given files.
         *
         * In essence, this results in the #GApplication::open signal being emitted
         * in the primary instance.
         *
         * `n_files` must be greater than zero.
         *
         * `hint` is simply passed through to the ::open signal.  It is
         * intended to be used by applications that have multiple modes for
         * opening files (eg: "view" vs "edit", etc).  Unless you have a need
         * for this functionality, you should use "".
         *
         * The application must be registered before calling this function
         * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
         * @param files an array of #GFiles to open
         * @param hint a hint (or ""), but never %NULL
         */
        open(files: File[], hint: string): void;
        /**
         * Immediately quits the application.
         *
         * Upon return to the mainloop, g_application_run() will return,
         * calling only the 'shutdown' function before doing so.
         *
         * The hold count is ignored.
         * Take care if your code has called g_application_hold() on the application and
         * is therefore still expecting it to exist.
         * (Note that you may have called g_application_hold() indirectly, for example
         * through gtk_application_add_window().)
         *
         * The result of calling g_application_run() again after it returns is
         * unspecified.
         */
        quit(): void;
        /**
         * Attempts registration of the application.
         *
         * This is the point at which the application discovers if it is the
         * primary instance or merely acting as a remote for an already-existing
         * primary instance.  This is implemented by attempting to acquire the
         * application identifier as a unique bus name on the session bus using
         * GDBus.
         *
         * If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
         * given, then this process will always become the primary instance.
         *
         * Due to the internal architecture of GDBus, method calls can be
         * dispatched at any time (even if a main loop is not running).  For
         * this reason, you must ensure that any object paths that you wish to
         * register are registered before calling this function.
         *
         * If the application has already been registered then %TRUE is
         * returned with no work performed.
         *
         * The #GApplication::startup signal is emitted if registration succeeds
         * and `application` is the primary instance (including the non-unique
         * case).
         *
         * In the event of an error (such as `cancellable` being cancelled, or a
         * failure to connect to the session bus), %FALSE is returned and `error`
         * is set appropriately.
         *
         * Note: the return value of this function is not an indicator that this
         * instance is or is not the primary instance of the application.  See
         * g_application_get_is_remote() for that.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if registration succeeded
         */
        register(cancellable?: Cancellable | null): boolean;
        /**
         * Decrease the use count of `application`.
         *
         * When the use count reaches zero, the application will stop running.
         *
         * Never call this function except to cancel the effect of a previous
         * call to g_application_hold().
         */
        release(): void;
        /**
         * Runs the application.
         *
         * This function is intended to be run from main() and its return value
         * is intended to be returned by main(). Although you are expected to pass
         * the `argc,` `argv` parameters from main() to this function, it is possible
         * to pass %NULL if `argv` is not available or commandline handling is not
         * required.  Note that on Windows, `argc` and `argv` are ignored, and
         * g_win32_get_command_line() is called internally (for proper support
         * of Unicode commandline arguments).
         *
         * #GApplication will attempt to parse the commandline arguments.  You
         * can add commandline flags to the list of recognised options by way of
         * g_application_add_main_option_entries().  After this, the
         * #GApplication::handle-local-options signal is emitted, from which the
         * application can inspect the values of its #GOptionEntrys.
         *
         * #GApplication::handle-local-options is a good place to handle options
         * such as `--version`, where an immediate reply from the local process is
         * desired (instead of communicating with an already-running instance).
         * A #GApplication::handle-local-options handler can stop further processing
         * by returning a non-negative value, which then becomes the exit status of
         * the process.
         *
         * What happens next depends on the flags: if
         * %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
         * commandline arguments are sent to the primary instance, where a
         * #GApplication::command-line signal is emitted.  Otherwise, the
         * remaining commandline arguments are assumed to be a list of files.
         * If there are no files listed, the application is activated via the
         * #GApplication::activate signal.  If there are one or more files, and
         * %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
         * via the #GApplication::open signal.
         *
         * If you are interested in doing more complicated local handling of the
         * commandline then you should implement your own #GApplication subclass
         * and override local_command_line(). In this case, you most likely want
         * to return %TRUE from your local_command_line() implementation to
         * suppress the default handling. See
         * [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
         * for an example.
         *
         * If, after the above is done, the use count of the application is zero
         * then the exit status is returned immediately.  If the use count is
         * non-zero then the default main context is iterated until the use count
         * falls to zero, at which point 0 is returned.
         *
         * If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
         * run for as much as 10 seconds with a use count of zero while waiting
         * for the message that caused the activation to arrive.  After that,
         * if the use count falls to zero the application will exit immediately,
         * except in the case that g_application_set_inactivity_timeout() is in
         * use.
         *
         * This function sets the prgname (g_set_prgname()), if not already set,
         * to the basename of argv[0].
         *
         * Much like g_main_loop_run(), this function will acquire the main context
         * for the duration that the application is running.
         *
         * Since 2.40, applications that are not explicitly flagged as services
         * or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
         * %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
         * default handler for local_command_line) if "--gapplication-service"
         * was given in the command line.  If this flag is present then normal
         * commandline processing is interrupted and the
         * %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
         * solution whereby running an application directly from the commandline
         * will invoke it in the normal way (which can be useful for debugging)
         * while still allowing applications to be D-Bus activated in service
         * mode.  The D-Bus service file should invoke the executable with
         * "--gapplication-service" as the sole commandline argument.  This
         * approach is suitable for use by most graphical applications but
         * should not be used from applications like editors that need precise
         * control over when processes invoked via the commandline will exit and
         * what their exit status will be.
         * @param argv the argv from main(), or %NULL
         * @returns the exit status
         */
        run(argv?: string[] | null): number;
        /**
         * Sends a notification on behalf of `application` to the desktop shell.
         * There is no guarantee that the notification is displayed immediately,
         * or even at all.
         *
         * Notifications may persist after the application exits. It will be
         * D-Bus-activated when the notification or one of its actions is
         * activated.
         *
         * Modifying `notification` after this call has no effect. However, the
         * object can be reused for a later call to this function.
         *
         * `id` may be any string that uniquely identifies the event for the
         * application. It does not need to be in any special format. For
         * example, "new-message" might be appropriate for a notification about
         * new messages.
         *
         * If a previous notification was sent with the same `id,` it will be
         * replaced with `notification` and shown again as if it was a new
         * notification. This works even for notifications sent from a previous
         * execution of the application, as long as `id` is the same string.
         *
         * `id` may be %NULL, but it is impossible to replace or withdraw
         * notifications without an id.
         *
         * If `notification` is no longer relevant, it can be withdrawn with
         * g_application_withdraw_notification().
         *
         * It is an error to call this function if `application` has no
         * application ID.
         * @param id id of the notification, or %NULL
         * @param notification the #GNotification to send
         */
        send_notification(id: string | null, notification: Notification): void;
        /**
         * This used to be how actions were associated with a #GApplication.
         * Now there is #GActionMap for that.
         * @param action_group a #GActionGroup, or %NULL
         */
        set_action_group(action_group?: ActionGroup | null): void;
        /**
         * Sets the unique identifier for `application`.
         *
         * The application id can only be modified if `application` has not yet
         * been registered.
         *
         * If non-%NULL, the application id must be valid.  See
         * g_application_id_is_valid().
         * @param application_id the identifier for @application
         */
        set_application_id(application_id?: string | null): void;
        /**
         * Sets or unsets the default application for the process, as returned
         * by g_application_get_default().
         *
         * This function does not take its own reference on `application`.  If
         * `application` is destroyed then the default application will revert
         * back to %NULL.
         */
        set_default(): void;
        /**
         * Sets the flags for `application`.
         *
         * The flags can only be modified if `application` has not yet been
         * registered.
         *
         * See #GApplicationFlags.
         * @param flags the flags for @application
         */
        set_flags(flags: ApplicationFlags): void;
        /**
         * Sets the current inactivity timeout for the application.
         *
         * This is the amount of time (in milliseconds) after the last call to
         * g_application_release() before the application stops running.
         *
         * This call has no side effects of its own.  The value set here is only
         * used for next time g_application_release() drops the use count to
         * zero.  Any timeouts currently in progress are not impacted.
         * @param inactivity_timeout the timeout, in milliseconds
         */
        set_inactivity_timeout(inactivity_timeout: number): void;
        /**
         * Adds a description to the `application` option context.
         *
         * See g_option_context_set_description() for more information.
         * @param description a string to be shown in `--help` output  after the list of options, or %NULL
         */
        set_option_context_description(description?: string | null): void;
        /**
         * Sets the parameter string to be used by the commandline handling of `application`.
         *
         * This function registers the argument to be passed to g_option_context_new()
         * when the internal #GOptionContext of `application` is created.
         *
         * See g_option_context_new() for more information about `parameter_string`.
         * @param parameter_string a string which is displayed   in the first line of `--help` output, after the usage summary `programname [OPTION...]`.
         */
        set_option_context_parameter_string(parameter_string?: string | null): void;
        /**
         * Adds a summary to the `application` option context.
         *
         * See g_option_context_set_summary() for more information.
         * @param summary a string to be shown in `--help` output  before the list of options, or %NULL
         */
        set_option_context_summary(summary?: string | null): void;
        /**
         * Sets (or unsets) the base resource path of `application`.
         *
         * The path is used to automatically load various [application
         * resources][gresource] such as menu layouts and action descriptions.
         * The various types of resources will be found at fixed names relative
         * to the given base path.
         *
         * By default, the resource base path is determined from the application
         * ID by prefixing '/' and replacing each '.' with '/'.  This is done at
         * the time that the #GApplication object is constructed.  Changes to
         * the application ID after that point will not have an impact on the
         * resource base path.
         *
         * As an example, if the application has an ID of "org.example.app" then
         * the default resource base path will be "/org/example/app".  If this
         * is a #GtkApplication (and you have not manually changed the path)
         * then Gtk will then search for the menus of the application at
         * "/org/example/app/gtk/menus.ui".
         *
         * See #GResource for more information about adding resources to your
         * application.
         *
         * You can disable automatic resource loading functionality by setting
         * the path to %NULL.
         *
         * Changing the resource base path once the application is running is
         * not recommended.  The point at which the resource path is consulted
         * for forming paths for various purposes is unspecified.  When writing
         * a sub-class of #GApplication you should either set the
         * #GApplication:resource-base-path property at construction time, or call
         * this function during the instance initialization. Alternatively, you
         * can call this function in the #GApplicationClass.startup virtual function,
         * before chaining up to the parent implementation.
         * @param resource_path the resource path to use
         */
        set_resource_base_path(resource_path?: string | null): void;
        /**
         * Sets the version number of `application`. This will be used to implement
         * a `--version` command line argument
         *
         * The application version can only be modified if `application` has not yet
         * been registered.
         * @param version the version of @application
         */
        set_version(version: string): void;
        /**
         * Destroys a binding between `property` and the busy state of
         * `application` that was previously created with
         * g_application_bind_busy_property().
         * @param object a #GObject
         * @param property the name of a boolean property of @object
         */
        unbind_busy_property(object: GObject.Object, property: string): void;
        /**
         * Decreases the busy count of `application`.
         *
         * When the busy count reaches zero, the new state will be propagated
         * to other processes.
         *
         * This function must only be called to cancel the effect of a previous
         * call to g_application_mark_busy().
         */
        unmark_busy(): void;
        /**
         * Withdraws a notification that was sent with
         * g_application_send_notification().
         *
         * This call does nothing if a notification with `id` doesn't exist or
         * the notification was never sent.
         *
         * This function works even for notifications sent in previous
         * executions of this application, as long `id` is the same as it was for
         * the sent notification.
         *
         * Note that notifications are dismissed when the user clicks on one
         * of the buttons in a notification or triggers its default action, so
         * there is no need to explicitly withdraw the notification in that case.
         * @param id id of a previously sent notification
         */
        withdraw_notification(id: string): void;
        /**
         * Similar to `Gio.Application.run` but return a Promise which resolves when the main loop ends, instead of blocking while the main loop runs.
         * This helps avoid the situation where Promises never resolved if you didn't run the application inside a callback.
         * @param argv Commandline arguments
         */
        runAsync(argv?: string[]): Promise<number>;

        // Inherited methods
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         * @returns whether or not the action is currently enabled
         */
        get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         * @returns the parameter type
         */
        get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the current state of the action
         */
        get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the state range hint
         */
        get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         * @returns the state type, if the action is stateful
         */
        get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         * @returns whether the named action exists
         */
        has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         * @returns a %NULL-terminated array of the names of the actions in the group
         */
        list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         * @returns %TRUE if the action exists, else %FALSE
         */
        query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         */
        vfunc_has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         */
        vfunc_list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         */
        vfunc_query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        add_action(action: Action): void;
        /**
         * A convenience function for creating multiple #GSimpleAction instances
         * and adding them to a #GActionMap.
         *
         * Each action is constructed as per one #GActionEntry.
         *
         *
         * ```c
         * static void
         * activate_quit (GSimpleAction *simple,
         *                GVariant      *parameter,
         *                gpointer       user_data)
         * {
         *   exit (0);
         * }
         *
         * static void
         * activate_print_string (GSimpleAction *simple,
         *                        GVariant      *parameter,
         *                        gpointer       user_data)
         * {
         *   g_print ("%s\n", g_variant_get_string (parameter, NULL));
         * }
         *
         * static GActionGroup *
         * create_action_group (void)
         * {
         *   const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         *   };
         *   GSimpleActionGroup *group;
         *
         *   group = g_simple_action_group_new ();
         *   g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
         *
         *   return G_ACTION_GROUP (group);
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         * @param user_data the user data for signal connections
         */
        add_action_entries(entries: ActionEntry[], user_data?: any | null): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        lookup_action(action_name: string): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        remove_action(action_name: string): void;
        /**
         * Remove actions from a #GActionMap. This is meant as the reverse of
         * g_action_map_add_action_entries().
         *
         *
         *
         * ```c
         * static const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         * };
         *
         * void
         * add_actions (GActionMap *map)
         * {
         *   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
         * }
         *
         * void
         * remove_actions (GActionMap *map)
         * {
         *   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         */
        remove_action_entries(entries: ActionEntry[]): void;
        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        vfunc_add_action(action: Action): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         */
        vfunc_lookup_action(action_name: string): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        vfunc_remove_action(action_name: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ApplicationCommandLine {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            arguments: GLib.Variant;
            is_remote: boolean;
            isRemote: boolean;
            options: GLib.Variant;
            platform_data: GLib.Variant;
            platformData: GLib.Variant;
        }
    }

    /**
     * `GApplicationCommandLine` represents a command-line invocation of
     * an application.
     *
     * It is created by [class`Gio`.Application] and emitted
     * in the [signal`Gio`.Application::command-line] signal and virtual function.
     *
     * The class contains the list of arguments that the program was invoked
     * with. It is also possible to query if the commandline invocation was
     * local (ie: the current process is running in direct response to the
     * invocation) or remote (ie: some other process forwarded the
     * commandline to this process).
     *
     * The `GApplicationCommandLine` object can provide the `argc` and `argv`
     * parameters for use with the [struct`GLib`.OptionContext] command-line parsing API,
     * with the [method`Gio`.ApplicationCommandLine.get_arguments] function. See
     * [gapplication-example-cmdline3.c][gapplication-example-cmdline3]
     * for an example.
     *
     * The exit status of the originally-invoked process may be set and
     * messages can be printed to stdout or stderr of that process.
     *
     * For remote invocation, the originally-invoked process exits when
     * [method`Gio`.ApplicationCommandLine.done] method is called. This method is
     * also automatically called when the object is disposed.
     *
     * The main use for `GApplicationCommandLine` (and the
     * [signal`Gio`.Application::command-line] signal) is 'Emacs server' like use cases:
     * You can set the `EDITOR` environment variable to have e.g. git use
     * your favourite editor to edit commit messages, and if you already
     * have an instance of the editor running, the editing will happen
     * in the running instance, instead of opening a new one. An important
     * aspect of this use case is that the process that gets started by git
     * does not return until the editing is done.
     *
     * Normally, the commandline is completely handled in the
     * [signal`Gio`.Application::command-line] handler. The launching instance exits
     * once the signal handler in the primary instance has returned, and
     * the return value of the signal handler becomes the exit status
     * of the launching instance.
     *
     * ```c
     * static int
     * command_line (GApplication            *application,
     *               GApplicationCommandLine *cmdline)
     * {
     *   gchar **argv;
     *   gint argc;
     *   gint i;
     *
     *   argv = g_application_command_line_get_arguments (cmdline, &argc);
     *
     *   g_application_command_line_print (cmdline,
     *                                     "This text is written back\n"
     *                                     "to stdout of the caller\n");
     *
     *   for (i = 0; i < argc; i++)
     *     g_print ("argument %d: %s\n", i, argv[i]);
     *
     *   g_strfreev (argv);
     *
     *   return 0;
     * }
     * ```
     *
     * The complete example can be found here:
     * [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)
     *
     * In more complicated cases, the handling of the commandline can be
     * split between the launcher and the primary instance.
     *
     * ```c
     * static gboolean
     *  test_local_cmdline (GApplication   *application,
     *                      gchar        ***arguments,
     *                      gint           *exit_status)
     * {
     *   gint i, j;
     *   gchar **argv;
     *
     *   argv = *arguments;
     *
     *   if (argv[0] == NULL)
     *     {
     *       *exit_status = 0;
     *       return FALSE;
     *     }
     *
     *   i = 1;
     *   while (argv[i])
     *     {
     *       if (g_str_has_prefix (argv[i], "--local-"))
     *         {
     *           g_print ("handling argument %s locally\n", argv[i]);
     *           g_free (argv[i]);
     *           for (j = i; argv[j]; j++)
     *             argv[j] = argv[j + 1];
     *         }
     *       else
     *         {
     *           g_print ("not handling argument %s locally\n", argv[i]);
     *           i++;
     *         }
     *     }
     *
     *   *exit_status = 0;
     *
     *   return FALSE;
     * }
     *
     * static void
     * test_application_class_init (TestApplicationClass *class)
     * {
     *   G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
     *
     *   ...
     * }
     * ```
     *
     * In this example of split commandline handling, options that start
     * with `--local-` are handled locally, all other options are passed
     * to the [signal`Gio`.Application::command-line] handler which runs in the primary
     * instance.
     *
     * The complete example can be found here:
     * [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)
     *
     * If handling the commandline requires a lot of work, it may be better to defer it.
     *
     * ```c
     * static gboolean
     * my_cmdline_handler (gpointer data)
     * {
     *   GApplicationCommandLine *cmdline = data;
     *
     *   // do the heavy lifting in an idle
     *
     *   g_application_command_line_set_exit_status (cmdline, 0);
     *   g_object_unref (cmdline); // this releases the application
     *
     *   return G_SOURCE_REMOVE;
     * }
     *
     * static int
     * command_line (GApplication            *application,
     *               GApplicationCommandLine *cmdline)
     * {
     *   // keep the application running until we are done with this commandline
     *   g_application_hold (application);
     *
     *   g_object_set_data_full (G_OBJECT (cmdline),
     *                           "application", application,
     *                           (GDestroyNotify)g_application_release);
     *
     *   g_object_ref (cmdline);
     *   g_idle_add (my_cmdline_handler, cmdline);
     *
     *   return 0;
     * }
     * ```
     *
     * In this example the commandline is not completely handled before
     * the [signal`Gio`.Application::command-line] handler returns. Instead, we keep
     * a reference to the `GApplicationCommandLine` object and handle it
     * later (in this example, in an idle). Note that it is necessary to
     * hold the application until you are done with the commandline.
     *
     * The complete example can be found here:
     * [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
     */
    class ApplicationCommandLine extends GObject.Object {
        static $gtype: GObject.GType<ApplicationCommandLine>;

        // Properties

        /**
         * The commandline that caused this [signal`Gio`.Application::command-line]
         * signal emission.
         */
        set arguments(val: GLib.Variant);
        /**
         * Whether this is a remote commandline.
         */
        get is_remote(): boolean;
        /**
         * Whether this is a remote commandline.
         */
        get isRemote(): boolean;
        /**
         * The options sent along with the commandline.
         */
        set options(val: GLib.Variant);
        /**
         * Platform-specific data for the commandline.
         */
        set platform_data(val: GLib.Variant);
        /**
         * Platform-specific data for the commandline.
         */
        set platformData(val: GLib.Variant);

        // Constructors

        constructor(properties?: Partial<ApplicationCommandLine.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Signals that command line processing is completed.
         *
         * For remote invocation, it causes the invoking process to terminate.
         *
         * For local invocation, it does nothing.
         *
         * This method should be called in the [signal`Gio`.Application::command-line]
         * handler, after the exit status is set and all messages are printed.
         *
         * After this call, g_application_command_line_set_exit_status() has no effect.
         * Subsequent calls to this method are no-ops.
         *
         * This method is automatically called when the #GApplicationCommandLine
         * object is disposed  so you can omit the call in non-garbage collected
         * languages.
         */
        vfunc_done(): void;
        /**
         * Gets the stdin of the invoking process.
         *
         * The #GInputStream can be used to read data passed to the standard
         * input of the invoking process.
         * This doesn't work on all platforms.  Presently, it is only available
         * on UNIX when using a D-Bus daemon capable of passing file descriptors.
         * If stdin is not available then %NULL will be returned.  In the
         * future, support may be expanded to other platforms.
         *
         * You must only call this function once per commandline invocation.
         */
        vfunc_get_stdin(): InputStream | null;
        /**
         * Prints a message using the stdout print handler in the invoking process.
         *
         * Unlike g_application_command_line_print(), `message` is not a `printf()`-style
         * format string. Use this function if `message` contains text you don't have
         * control over, that could include `printf()` escape sequences.
         * @param message the message
         */
        vfunc_print_literal(message: string): void;
        /**
         * Prints a message using the stderr print handler in the invoking process.
         *
         * Unlike g_application_command_line_printerr(), `message` is not
         * a `printf()`-style format string. Use this function if `message` contains text
         * you don't have control over, that could include `printf()` escape sequences.
         * @param message the message
         */
        vfunc_printerr_literal(message: string): void;

        // Methods

        /**
         * Creates a #GFile corresponding to a filename that was given as part
         * of the invocation of `cmdline`.
         *
         * This differs from g_file_new_for_commandline_arg() in that it
         * resolves relative pathnames using the current working directory of
         * the invoking process rather than the local process.
         * @param arg an argument from @cmdline
         * @returns a new #GFile
         */
        create_file_for_arg(arg: string): File;
        /**
         * Signals that command line processing is completed.
         *
         * For remote invocation, it causes the invoking process to terminate.
         *
         * For local invocation, it does nothing.
         *
         * This method should be called in the [signal`Gio`.Application::command-line]
         * handler, after the exit status is set and all messages are printed.
         *
         * After this call, g_application_command_line_set_exit_status() has no effect.
         * Subsequent calls to this method are no-ops.
         *
         * This method is automatically called when the #GApplicationCommandLine
         * object is disposed  so you can omit the call in non-garbage collected
         * languages.
         */
        done(): void;
        /**
         * Gets the list of arguments that was passed on the command line.
         *
         * The strings in the array may contain non-UTF-8 data on UNIX (such as
         * filenames or arguments given in the system locale) but are always in
         * UTF-8 on Windows.
         *
         * If you wish to use the return value with #GOptionContext, you must
         * use g_option_context_parse_strv().
         *
         * The return value is %NULL-terminated and should be freed using
         * g_strfreev().
         * @returns the string array containing the arguments (the argv)
         */
        get_arguments(): string[];
        /**
         * Gets the working directory of the command line invocation.
         * The string may contain non-utf8 data.
         *
         * It is possible that the remote application did not send a working
         * directory, so this may be %NULL.
         *
         * The return value should not be modified or freed and is valid for as
         * long as `cmdline` exists.
         * @returns the current directory, or %NULL
         */
        get_cwd(): string | null;
        /**
         * Gets the contents of the 'environ' variable of the command line
         * invocation, as would be returned by g_get_environ(), ie as a
         * %NULL-terminated list of strings in the form 'NAME=VALUE'.
         * The strings may contain non-utf8 data.
         *
         * The remote application usually does not send an environment.  Use
         * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
         * set it is possible that the environment is still not available (due
         * to invocation messages from other applications).
         *
         * The return value should not be modified or freed and is valid for as
         * long as `cmdline` exists.
         *
         * See g_application_command_line_getenv() if you are only interested
         * in the value of a single environment variable.
         * @returns the environment strings, or %NULL if they were not sent
         */
        get_environ(): string[];
        /**
         * Gets the exit status of `cmdline`.  See
         * g_application_command_line_set_exit_status() for more information.
         * @returns the exit status
         */
        get_exit_status(): number;
        /**
         * Determines if `cmdline` represents a remote invocation.
         * @returns %TRUE if the invocation was remote
         */
        get_is_remote(): boolean;
        /**
         * Gets the options that were passed to g_application_command_line().
         *
         * If you did not override local_command_line() then these are the same
         * options that were parsed according to the #GOptionEntrys added to the
         * application with g_application_add_main_option_entries() and possibly
         * modified from your GApplication::handle-local-options handler.
         *
         * If no options were sent then an empty dictionary is returned so that
         * you don't need to check for %NULL.
         *
         * The data has been passed via an untrusted external process, so the types of
         * all values must be checked before being used.
         * @returns a #GVariantDict with the options
         */
        get_options_dict(): GLib.VariantDict;
        /**
         * Gets the platform data associated with the invocation of `cmdline`.
         *
         * This is a #GVariant dictionary containing information about the
         * context in which the invocation occurred.  It typically contains
         * information like the current working directory and the startup
         * notification ID.
         *
         * It comes from an untrusted external process and hence the types of all
         * values must be validated before being used.
         *
         * For local invocation, it will be %NULL.
         * @returns the platform data, or %NULL
         */
        get_platform_data(): GLib.Variant | null;
        /**
         * Gets the stdin of the invoking process.
         *
         * The #GInputStream can be used to read data passed to the standard
         * input of the invoking process.
         * This doesn't work on all platforms.  Presently, it is only available
         * on UNIX when using a D-Bus daemon capable of passing file descriptors.
         * If stdin is not available then %NULL will be returned.  In the
         * future, support may be expanded to other platforms.
         *
         * You must only call this function once per commandline invocation.
         * @returns a #GInputStream for stdin
         */
        get_stdin(): InputStream | null;
        /**
         * Gets the value of a particular environment variable of the command
         * line invocation, as would be returned by g_getenv().  The strings may
         * contain non-utf8 data.
         *
         * The remote application usually does not send an environment.  Use
         * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
         * set it is possible that the environment is still not available (due
         * to invocation messages from other applications).
         *
         * The return value should not be modified or freed and is valid for as
         * long as `cmdline` exists.
         * @param name the environment variable to get
         * @returns the value of the variable, or %NULL if unset or unsent
         */
        getenv(name: string): string | null;
        /**
         * Prints a message using the stdout print handler in the invoking process.
         *
         * Unlike g_application_command_line_print(), `message` is not a `printf()`-style
         * format string. Use this function if `message` contains text you don't have
         * control over, that could include `printf()` escape sequences.
         * @param message the message
         */
        print_literal(message: string): void;
        /**
         * Prints a message using the stderr print handler in the invoking process.
         *
         * Unlike g_application_command_line_printerr(), `message` is not
         * a `printf()`-style format string. Use this function if `message` contains text
         * you don't have control over, that could include `printf()` escape sequences.
         * @param message the message
         */
        printerr_literal(message: string): void;
        /**
         * Sets the exit status that will be used when the invoking process
         * exits.
         *
         * The return value of the #GApplication::command-line signal is
         * passed to this function when the handler returns.  This is the usual
         * way of setting the exit status.
         *
         * In the event that you want the remote invocation to continue running
         * and want to decide on the exit status in the future, you can use this
         * call.  For the case of a remote invocation, the remote process will
         * typically exit when the last reference is dropped on `cmdline`.  The
         * exit status of the remote process will be equal to the last value
         * that was set with this function.
         *
         * In the case that the commandline invocation is local, the situation
         * is slightly more complicated.  If the commandline invocation results
         * in the mainloop running (ie: because the use-count of the application
         * increased to a non-zero value) then the application is considered to
         * have been 'successful' in a certain sense, and the exit status is
         * always zero.  If the application use count is zero, though, the exit
         * status of the local #GApplicationCommandLine is used.
         *
         * This method is a no-op if g_application_command_line_done() has
         * been called.
         * @param exit_status the exit status
         */
        set_exit_status(exit_status: number): void;
    }

    module BufferedInputStream {
        // Constructor properties interface

        interface ConstructorProps extends FilterInputStream.ConstructorProps, Seekable.ConstructorProps {
            buffer_size: number;
            bufferSize: number;
        }
    }

    /**
     * Buffered input stream implements #GFilterInputStream and provides
     * for buffered reads.
     *
     * By default, `GBufferedInputStream`'s buffer size is set at 4 kilobytes.
     *
     * To create a buffered input stream, use [ctor`Gio`.BufferedInputStream.new],
     * or [ctor`Gio`.BufferedInputStream.new_sized] to specify the buffer's size at
     * construction.
     *
     * To get the size of a buffer within a buffered input stream, use
     * [method`Gio`.BufferedInputStream.get_buffer_size]. To change the size of a
     * buffered input stream's buffer, use [method`Gio`.BufferedInputStream.set_buffer_size].
     * Note that the buffer's size cannot be reduced below the size of the data within the buffer.
     */
    class BufferedInputStream extends FilterInputStream implements Seekable {
        static $gtype: GObject.GType<BufferedInputStream>;

        // Properties

        /**
         * The size of the backend buffer, in bytes.
         */
        get buffer_size(): number;
        set buffer_size(val: number);
        /**
         * The size of the backend buffer, in bytes.
         */
        get bufferSize(): number;
        set bufferSize(val: number);

        // Constructors

        constructor(properties?: Partial<BufferedInputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](base_stream: InputStream): BufferedInputStream;

        static new_sized(base_stream: InputStream, size: number): BufferedInputStream;

        // Virtual methods

        /**
         * Tries to read `count` bytes from the stream into the buffer.
         * Will block during this read.
         *
         * If `count` is zero, returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * If `count` is -1 then the attempted read size is equal to the number of
         * bytes that are required to fill the buffer.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         *
         * For the asynchronous, non-blocking, version of this function, see
         * g_buffered_input_stream_fill_async().
         * @param count the number of bytes that will be read from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore
         */
        vfunc_fill(count: number, cancellable?: Cancellable | null): number;
        /**
         * Reads data into `stream'`s buffer asynchronously, up to `count` size.
         * `io_priority` can be used to prioritize reads. For the synchronous
         * version of this function, see g_buffered_input_stream_fill().
         *
         * If `count` is -1 then the attempted read size is equal to the number
         * of bytes that are required to fill the buffer.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object
         * @param callback a #GAsyncReadyCallback
         */
        vfunc_fill_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous read.
         * @param result a #GAsyncResult
         */
        vfunc_fill_finish(result: AsyncResult): number;

        // Methods

        /**
         * Tries to read `count` bytes from the stream into the buffer.
         * Will block during this read.
         *
         * If `count` is zero, returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * If `count` is -1 then the attempted read size is equal to the number of
         * bytes that are required to fill the buffer.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         *
         * For the asynchronous, non-blocking, version of this function, see
         * g_buffered_input_stream_fill_async().
         * @param count the number of bytes that will be read from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns the number of bytes read into @stream's buffer, up to @count,     or -1 on error.
         */
        fill(count: number, cancellable?: Cancellable | null): number;
        /**
         * Reads data into `stream'`s buffer asynchronously, up to `count` size.
         * `io_priority` can be used to prioritize reads. For the synchronous
         * version of this function, see g_buffered_input_stream_fill().
         *
         * If `count` is -1 then the attempted read size is equal to the number
         * of bytes that are required to fill the buffer.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object
         * @param callback a #GAsyncReadyCallback
         */
        fill_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous read.
         * @param result a #GAsyncResult
         * @returns a #gssize of the read stream, or `-1` on an error.
         */
        fill_finish(result: AsyncResult): number;
        /**
         * Gets the size of the available data within the stream.
         * @returns size of the available stream.
         */
        get_available(): number;
        /**
         * Gets the size of the input buffer.
         * @returns the current buffer size.
         */
        get_buffer_size(): number;
        /**
         * Peeks in the buffer, copying data of size `count` into `buffer,`
         * offset `offset` bytes.
         * @param buffer a pointer to   an allocated chunk of memory
         * @param offset a #gsize
         * @returns a #gsize of the number of bytes peeked, or -1 on error.
         */
        peek(buffer: Uint8Array | string, offset: number): number;
        /**
         * Returns the buffer with the currently available bytes. The returned
         * buffer must not be modified and will become invalid when reading from
         * the stream or filling the buffer.
         * @returns read-only buffer
         */
        peek_buffer(): Uint8Array;
        /**
         * Tries to read a single byte from the stream or the buffer. Will block
         * during this read.
         *
         * On success, the byte read from the stream is returned. On end of stream
         * -1 is returned but it's not an exceptional error and `error` is not set.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns the byte read from the @stream, or -1 on end of stream or error.
         */
        read_byte(cancellable?: Cancellable | null): number;
        /**
         * Sets the size of the internal buffer of `stream` to `size,` or to the
         * size of the contents of the buffer. The buffer can never be resized
         * smaller than its current contents.
         * @param size a #gsize
         */
        set_buffer_size(size: number): void;

        // Inherited methods
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Tests if the stream supports the #GSeekableIface.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module BufferedOutputStream {
        // Constructor properties interface

        interface ConstructorProps extends FilterOutputStream.ConstructorProps, Seekable.ConstructorProps {
            auto_grow: boolean;
            autoGrow: boolean;
            buffer_size: number;
            bufferSize: number;
        }
    }

    /**
     * Buffered output stream implements [class`Gio`.FilterOutputStream] and provides
     * for buffered writes.
     *
     * By default, `GBufferedOutputStream`'s buffer size is set at 4 kilobytes.
     *
     * To create a buffered output stream, use [ctor`Gio`.BufferedOutputStream.new],
     * or [ctor`Gio`.BufferedOutputStream.new_sized] to specify the buffer's size
     * at construction.
     *
     * To get the size of a buffer within a buffered input stream, use
     * [method`Gio`.BufferedOutputStream.get_buffer_size]. To change the size of a
     * buffered output stream's buffer, use [method`Gio`.BufferedOutputStream.set_buffer_size].
     * Note that the buffer's size cannot be reduced below the size of the data within the buffer.
     */
    class BufferedOutputStream extends FilterOutputStream implements Seekable {
        static $gtype: GObject.GType<BufferedOutputStream>;

        // Properties

        /**
         * Whether the buffer should automatically grow.
         */
        get auto_grow(): boolean;
        set auto_grow(val: boolean);
        /**
         * Whether the buffer should automatically grow.
         */
        get autoGrow(): boolean;
        set autoGrow(val: boolean);
        /**
         * The size of the backend buffer, in bytes.
         */
        get buffer_size(): number;
        set buffer_size(val: number);
        /**
         * The size of the backend buffer, in bytes.
         */
        get bufferSize(): number;
        set bufferSize(val: number);

        // Constructors

        constructor(properties?: Partial<BufferedOutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](base_stream: OutputStream): BufferedOutputStream;

        static new_sized(base_stream: OutputStream, size: number): BufferedOutputStream;

        // Methods

        /**
         * Checks if the buffer automatically grows as data is added.
         * @returns %TRUE if the @stream's buffer automatically grows, %FALSE otherwise.
         */
        get_auto_grow(): boolean;
        /**
         * Gets the size of the buffer in the `stream`.
         * @returns the current size of the buffer.
         */
        get_buffer_size(): number;
        /**
         * Sets whether or not the `stream'`s buffer should automatically grow.
         * If `auto_grow` is true, then each write will just make the buffer
         * larger, and you must manually flush the buffer to actually write out
         * the data to the underlying stream.
         * @param auto_grow a #gboolean.
         */
        set_auto_grow(auto_grow: boolean): void;
        /**
         * Sets the size of the internal buffer to `size`.
         * @param size a #gsize.
         */
        set_buffer_size(size: number): void;

        // Inherited methods
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Tests if the stream supports the #GSeekableIface.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module BytesIcon {
        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                Icon.ConstructorProps,
                LoadableIcon.ConstructorProps {
            bytes: GLib.Bytes;
        }
    }

    /**
     * `GBytesIcon` specifies an image held in memory in a common format (usually
     * PNG) to be used as icon.
     */
    class BytesIcon extends GObject.Object implements Icon, LoadableIcon {
        static $gtype: GObject.GType<BytesIcon>;

        // Properties

        /**
         * The bytes containing the icon.
         */
        get bytes(): GLib.Bytes;

        // Constructors

        constructor(properties?: Partial<BytesIcon.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](bytes: GLib.Bytes | Uint8Array): BytesIcon;

        // Methods

        /**
         * Gets the #GBytes associated with the given `icon`.
         * @returns a #GBytes.
         */
        get_bytes(): GLib.Bytes;

        // Inherited methods
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @returns a #guint containing a hash for the @icon, suitable for   use in a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        serialize(): GLib.Variant | null;
        /**
         * Generates a textual representation of `icon` that can be used for
         * serialization such as when passing `icon` to a different process or
         * saving it to persistent storage. Use g_icon_new_for_string() to
         * get `icon` back from the returned string.
         *
         * The encoding of the returned string is proprietary to #GIcon except
         * in the following two cases
         *
         * - If `icon` is a #GFileIcon, the returned string is a native path
         *   (such as `/path/to/my icon.png`) without escaping
         *   if the #GFile for `icon` is a native file.  If the file is not
         *   native, the returned string is the result of g_file_get_uri()
         *   (such as `sftp://path/to/my%20icon.png`).
         *
         * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
         *   the encoding is simply the name (such as `network-server`).
         * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
         */
        to_string(): string | null;
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         */
        vfunc_equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         */
        vfunc_hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         */
        vfunc_serialize(): GLib.Variant | null;
        /**
         * Serializes the `icon` into string tokens.
         * This is can be invoked when g_icon_new_for_string() is called.
         */
        vfunc_to_tokens(): [boolean, string[], number];
        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GInputStream to read the icon from.
         */
        load(size: number, cancellable?: Cancellable | null): [InputStream, string];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        load_async(size: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @param res a #GAsyncResult.
         * @returns a #GInputStream to read the icon from.
         */
        load_finish(res: AsyncResult): [InputStream, string];
        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_load(size: number, cancellable?: Cancellable | null): [InputStream, string];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_load_async(
            size: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @param res a #GAsyncResult.
         */
        vfunc_load_finish(res: AsyncResult): [InputStream, string];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Cancellable {
        // Signal callback interfaces

        interface Cancelled {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GCancellable` allows operations to be cancelled.
     *
     * `GCancellable` is a thread-safe operation cancellation stack used
     * throughout GIO to allow for cancellation of synchronous and
     * asynchronous operations.
     */
    class Cancellable extends GObject.Object {
        static $gtype: GObject.GType<Cancellable>;

        // Constructors

        constructor(properties?: Partial<Cancellable.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Cancellable;

        // Signals

        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect_after(signal: 'cancelled', callback: (_source: this) => void): number;
        emit(signal: 'cancelled'): void;

        // Static methods

        /**
         * Gets the top cancellable from the stack.
         */
        static get_current(): Cancellable | null;

        // Virtual methods

        vfunc_cancelled(): void;

        // Methods

        /**
         * Will set `cancellable` to cancelled, and will emit the
         * #GCancellable::cancelled signal. (However, see the warning about
         * race conditions in the documentation for that signal if you are
         * planning to connect to it.)
         *
         * This function is thread-safe. In other words, you can safely call
         * it from a thread other than the one running the operation that was
         * passed the `cancellable`.
         *
         * If `cancellable` is %NULL, this function returns immediately for convenience.
         *
         * The convention within GIO is that cancelling an asynchronous
         * operation causes it to complete asynchronously. That is, if you
         * cancel the operation from the same thread in which it is running,
         * then the operation's #GAsyncReadyCallback will not be invoked until
         * the application returns to the main loop.
         */
        cancel(): void;
        /**
         * Convenience function to connect to the #GCancellable::cancelled
         * signal. Also handles the race condition that may happen
         * if the cancellable is cancelled right before connecting.
         *
         * `callback` is called at most once, either directly at the
         * time of the connect if `cancellable` is already cancelled,
         * or when `cancellable` is cancelled in some thread.
         *
         * `data_destroy_func` will be called when the handler is
         * disconnected, or immediately if the cancellable is already
         * cancelled.
         *
         * See #GCancellable::cancelled for details on how to use this.
         *
         * Since GLib 2.40, the lock protecting `cancellable` is not held when
         * `callback` is invoked.  This lifts a restriction in place for
         * earlier GLib versions which now makes it easier to write cleanup
         * code that unconditionally invokes e.g. g_cancellable_cancel().
         * @param callback The #GCallback to connect.
         * @param data_destroy_func Free function for @data or %NULL.
         * @returns The id of the signal handler or 0 if @cancellable has already          been cancelled.
         */
        connect(callback: GObject.Callback, data_destroy_func?: GLib.DestroyNotify | null): number;
        connect(...args: never[]): any;
        /**
         * Disconnects a handler from a cancellable instance similar to
         * g_signal_handler_disconnect().  Additionally, in the event that a
         * signal handler is currently running, this call will block until the
         * handler has finished.  Calling this function from a
         * #GCancellable::cancelled signal handler will therefore result in a
         * deadlock.
         *
         * This avoids a race condition where a thread cancels at the
         * same time as the cancellable operation is finished and the
         * signal handler is removed. See #GCancellable::cancelled for
         * details on how to use this.
         *
         * If `cancellable` is %NULL or `handler_id` is `0` this function does
         * nothing.
         * @param handler_id Handler id of the handler to be disconnected, or `0`.
         */
        disconnect(handler_id: number): void;
        /**
         * Gets the file descriptor for a cancellable job. This can be used to
         * implement cancellable operations on Unix systems. The returned fd will
         * turn readable when `cancellable` is cancelled.
         *
         * You are not supposed to read from the fd yourself, just check for
         * readable status. Reading to unset the readable status is done
         * with g_cancellable_reset().
         *
         * After a successful return from this function, you should use
         * g_cancellable_release_fd() to free up resources allocated for
         * the returned file descriptor.
         *
         * See also g_cancellable_make_pollfd().
         * @returns A valid file descriptor. `-1` if the file descriptor is not supported, or on errors.
         */
        get_fd(): number;
        /**
         * Checks if a cancellable job has been cancelled.
         * @returns %TRUE if @cancellable is cancelled, FALSE if called with %NULL or if item is not cancelled.
         */
        is_cancelled(): boolean;
        /**
         * Creates a #GPollFD corresponding to `cancellable;` this can be passed
         * to g_poll() and used to poll for cancellation. This is useful both
         * for unix systems without a native poll and for portability to
         * windows.
         *
         * When this function returns %TRUE, you should use
         * g_cancellable_release_fd() to free up resources allocated for the
         * `pollfd`. After a %FALSE return, do not call g_cancellable_release_fd().
         *
         * If this function returns %FALSE, either no `cancellable` was given or
         * resource limits prevent this function from allocating the necessary
         * structures for polling. (On Linux, you will likely have reached
         * the maximum number of file descriptors.) The suggested way to handle
         * these cases is to ignore the `cancellable`.
         *
         * You are not supposed to read from the fd yourself, just check for
         * readable status. Reading to unset the readable status is done
         * with g_cancellable_reset().
         * @param pollfd a pointer to a #GPollFD
         * @returns %TRUE if @pollfd was successfully initialized, %FALSE on          failure to prepare the cancellable.
         */
        make_pollfd(pollfd: GLib.PollFD): boolean;
        /**
         * Pops `cancellable` off the cancellable stack (verifying that `cancellable`
         * is on the top of the stack).
         */
        pop_current(): void;
        /**
         * Pushes `cancellable` onto the cancellable stack. The current
         * cancellable can then be received using g_cancellable_get_current().
         *
         * This is useful when implementing cancellable operations in
         * code that does not allow you to pass down the cancellable object.
         *
         * This is typically called automatically by e.g. #GFile operations,
         * so you rarely have to call this yourself.
         */
        push_current(): void;
        /**
         * Releases a resources previously allocated by g_cancellable_get_fd()
         * or g_cancellable_make_pollfd().
         *
         * For compatibility reasons with older releases, calling this function
         * is not strictly required, the resources will be automatically freed
         * when the `cancellable` is finalized. However, the `cancellable` will
         * block scarce file descriptors until it is finalized if this function
         * is not called. This can cause the application to run out of file
         * descriptors when many #GCancellables are used at the same time.
         */
        release_fd(): void;
        /**
         * Resets `cancellable` to its uncancelled state.
         *
         * If cancellable is currently in use by any cancellable operation
         * then the behavior of this function is undefined.
         *
         * Note that it is generally not a good idea to reuse an existing
         * cancellable for more operations after it has been cancelled once,
         * as this function might tempt you to do. The recommended practice
         * is to drop the reference to a cancellable after cancelling it,
         * and let it die with the outstanding async operations. You should
         * create a fresh cancellable for further async operations.
         */
        reset(): void;
        /**
         * If the `cancellable` is cancelled, sets the error to notify
         * that the operation was cancelled.
         * @returns %TRUE if @cancellable was cancelled, %FALSE if it was not
         */
        set_error_if_cancelled(): boolean;
        /**
         * Creates a source that triggers if `cancellable` is cancelled and
         * calls its callback of type #GCancellableSourceFunc. This is
         * primarily useful for attaching to another (non-cancellable) source
         * with g_source_add_child_source() to add cancellability to it.
         *
         * For convenience, you can call this with a %NULL #GCancellable,
         * in which case the source will never trigger.
         *
         * The new #GSource will hold a reference to the #GCancellable.
         * @returns the new #GSource.
         */
        source_new(): GLib.Source;
    }

    module CharsetConverter {
        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                Converter.ConstructorProps,
                Initable.ConstructorProps {
            from_charset: string;
            fromCharset: string;
            to_charset: string;
            toCharset: string;
            use_fallback: boolean;
            useFallback: boolean;
        }
    }

    /**
     * `GCharsetConverter` is an implementation of [iface`Gio`.Converter] based on
     * [struct`GLib`.IConv].
     */
    class CharsetConverter extends GObject.Object implements Converter, Initable {
        static $gtype: GObject.GType<CharsetConverter>;

        // Properties

        /**
         * The character encoding to convert from.
         */
        get from_charset(): string;
        /**
         * The character encoding to convert from.
         */
        get fromCharset(): string;
        /**
         * The character encoding to convert to.
         */
        get to_charset(): string;
        /**
         * The character encoding to convert to.
         */
        get toCharset(): string;
        /**
         * Use fallback (of form `\<hexval>`) for invalid bytes.
         */
        get use_fallback(): boolean;
        set use_fallback(val: boolean);
        /**
         * Use fallback (of form `\<hexval>`) for invalid bytes.
         */
        get useFallback(): boolean;
        set useFallback(val: boolean);

        // Constructors

        constructor(properties?: Partial<CharsetConverter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](to_charset: string, from_charset: string): CharsetConverter;

        // Methods

        /**
         * Gets the number of fallbacks that `converter` has applied so far.
         * @returns the number of fallbacks that @converter has applied
         */
        get_num_fallbacks(): number;
        /**
         * Gets the #GCharsetConverter:use-fallback property.
         * @returns %TRUE if fallbacks are used by @converter
         */
        get_use_fallback(): boolean;
        /**
         * Sets the #GCharsetConverter:use-fallback property.
         * @param use_fallback %TRUE to use fallbacks
         */
        set_use_fallback(use_fallback: boolean): void;

        // Inherited methods
        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
         */
        convert(
            inbuf: Uint8Array | string,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        reset(): void;
        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         */
        vfunc_convert(
            inbuf: Uint8Array | null,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        vfunc_reset(): void;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ConverterInputStream {
        // Constructor properties interface

        interface ConstructorProps extends FilterInputStream.ConstructorProps, PollableInputStream.ConstructorProps {
            converter: Converter;
        }
    }

    /**
     * Converter input stream implements [class`Gio`.InputStream] and allows
     * conversion of data of various types during reading.
     *
     * As of GLib 2.34, `GConverterInputStream` implements
     * [iface`Gio`.PollableInputStream].
     */
    class ConverterInputStream extends FilterInputStream implements PollableInputStream {
        static $gtype: GObject.GType<ConverterInputStream>;

        // Properties

        /**
         * The converter object.
         */
        get converter(): Converter;

        // Constructors

        constructor(properties?: Partial<ConverterInputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](base_stream: InputStream, converter: Converter): ConverterInputStream;

        // Methods

        /**
         * Gets the #GConverter that is used by `converter_stream`.
         * @returns the converter of the converter input stream
         */
        get_converter(): Converter;

        // Inherited methods
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
         */
        is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_read_nonblocking(): [number, Uint8Array | null];
        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but some streams
         * can use a faster close that doesn't block to e.g. check errors.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         * @returns %TRUE if the stream was closed successfully.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Checks if an input stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an input stream is closed.
         * @returns %TRUE if the stream is closed.
         */
        is_closed(): boolean;
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * If count is zero returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * The returned `buffer` is not a nul-terminated string, it can contain nul bytes
         * at any position, and this function doesn't nul-terminate the `buffer`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes read, or -1 on error, or 0 on end of file.
         */
        read(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * This function is similar to g_input_stream_read(), except it tries to
         * read as many bytes as requested, only stopping on an error or end of stream.
         *
         * On a successful read of `count` bytes, or if we reached the end of the
         * stream,  %TRUE is returned, and `bytes_read` is set to the number of bytes
         * read into `buffer`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all(cancellable?: Cancellable | null): [boolean, Uint8Array, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the
         * buffer starting at `buffer`.
         *
         * This is the asynchronous equivalent of g_input_stream_read_all().
         *
         * Call g_input_stream_read_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_all_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Finishes an asynchronous stream read operation started with
         * g_input_stream_read_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Like g_input_stream_read(), this tries to read `count` bytes from
         * the stream in a blocking fashion. However, rather than reading into
         * a user-supplied buffer, this will create a new #GBytes containing
         * the data that was read. This may be easier to use from language
         * bindings.
         *
         * If count is zero, returns a zero-length #GBytes and does nothing. A
         * value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, a new #GBytes is returned. It is not an error if the
         * size of this object is not the same as the requested size, as it
         * can happen e.g. near the end of a file. A zero-length #GBytes is
         * returned on end of file (or if `count` is zero), but never
         * otherwise.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error %NULL is returned and `error` is set accordingly.
         * @param count maximum number of bytes that will be read from the stream. Common values include 4096 and 8192.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a new #GBytes, or %NULL on error
         */
        read_bytes(count: number, cancellable?: Cancellable | null): GLib.Bytes;
        /**
         * Request an asynchronous read of `count` bytes from the stream into a
         * new #GBytes. When the operation is finished `callback` will be
         * called. You can then call g_input_stream_read_bytes_finish() to get the
         * result of the operation.
         *
         * During an async request no other sync and async calls are allowed
         * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the new #GBytes will be passed to the callback. It is
         * not an error if this is smaller than the requested size, as it can
         * happen e.g. near the end of a file, but generally we try to read as
         * many bytes as requested. Zero is returned on end of file (or if
         * `count` is zero), but never otherwise.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_bytes_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream read-into-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns the newly-allocated #GBytes, or %NULL on error
         */
        read_bytes_finish(result: AsyncResult): GLib.Bytes;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         * @returns number of bytes read in, or -1 on error, or 0 on end of file.
         */
        read_finish(result: AsyncResult): number;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes skipped, or -1 on error
         */
        skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         * @returns the size of the bytes skipped, or `-1` on error.
         */
        skip_finish(result: AsyncResult): number;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array | null;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         */
        vfunc_read_finish(result: AsyncResult): number;
        vfunc_read_fn(buffer: any | null, count: number, cancellable?: Cancellable | null): number;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         */
        vfunc_skip_finish(result: AsyncResult): number;
    }

    module ConverterOutputStream {
        // Constructor properties interface

        interface ConstructorProps extends FilterOutputStream.ConstructorProps, PollableOutputStream.ConstructorProps {
            converter: Converter;
        }
    }

    /**
     * Converter output stream implements [class`Gio`.OutputStream] and allows
     * conversion of data of various types during reading.
     *
     * As of GLib 2.34, `GConverterOutputStream` implements
     * [iface`Gio`.PollableOutputStream].
     */
    class ConverterOutputStream extends FilterOutputStream implements PollableOutputStream {
        static $gtype: GObject.GType<ConverterOutputStream>;

        // Properties

        /**
         * The converter object.
         */
        get converter(): Converter;

        // Constructors

        constructor(properties?: Partial<ConverterOutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](base_stream: OutputStream, converter: Converter): ConverterOutputStream;

        // Methods

        /**
         * Gets the #GConverter that is used by `converter_stream`.
         * @returns the converter of the converter output stream
         */
        get_converter(): Converter;

        // Inherited methods
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
         */
        is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
         */
        writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         */
        vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         */
        vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Closing a stream will automatically flush any outstanding buffers in the
         * stream.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user, otherwise
         * there might be a loss of data as all data might not be written.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but there some streams
         * can use a faster close that doesn't block to e.g. check errors. On
         * cancellation (as with any error) there is no guarantee that all written
         * data will reach the target.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on error
         */
        flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
         */
        flush_finish(result: AsyncResult): boolean;
        /**
         * Checks if an output stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an output stream has already been closed.
         * @returns %TRUE if @stream is closed. %FALSE otherwise.
         */
        is_closed(): boolean;
        /**
         * Checks if an output stream is being closed. This can be
         * used inside e.g. a flush implementation to see if the
         * flush (or other i/o operation) is called from within
         * the closing operation.
         * @returns %TRUE if @stream is being closed. %FALSE otherwise.
         */
        is_closing(): boolean;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
         */
        splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
         */
        splice_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * This function is similar to g_output_stream_write(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of `count` bytes, %TRUE is returned, and `bytes_written`
         * is set to `count`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all(buffer: Uint8Array | string, cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_write_all().
         *
         * Call g_output_stream_write_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called.
         * @param buffer the buffer containing the data to write
         * @param io_priority the io priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_all_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_write_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * A wrapper function for g_output_stream_write() which takes a
         * #GBytes as input.  This can be more convenient for use by language
         * bindings or in other cases where the refcounted nature of #GBytes
         * is helpful over a bare pointer interface.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write().  If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         * @param bytes the #GBytes to write
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write_bytes(bytes: GLib.Bytes | Uint8Array, cancellable?: Cancellable | null): number;
        /**
         * This function is similar to g_output_stream_write_async(), but
         * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
         * this allows the stream to avoid taking a copy of the data.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write_async(). If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write_bytes().
         * @param bytes The bytes to write
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        write_bytes_async(
            bytes: GLib.Bytes | Uint8Array,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write-from-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_bytes_finish(result: AsyncResult): number;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_finish(result: AsyncResult): number;
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * This function is similar to g_output_stream_writev(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of all `n_vectors` vectors, %TRUE is returned, and
         * `bytes_written` is set to the sum of all the sizes of `vectors`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C. If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         *
         * The content of the individual elements of `vectors` might be changed by this
         * function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_writev_all().
         *
         * Call g_output_stream_writev_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called. The content of the individual elements
         * of `vectors` might be changed by this function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_all_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_writev_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_writev_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_finish(result: AsyncResult): [boolean, number];
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         */
        vfunc_flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         */
        vfunc_flush_finish(result: AsyncResult): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         */
        vfunc_splice_finish(result: AsyncResult): number;
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_write_async(
            buffer: Uint8Array | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         */
        vfunc_write_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         */
        vfunc_write_fn(buffer?: Uint8Array | null, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         */
        vfunc_writev_finish(result: AsyncResult): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         */
        vfunc_writev_fn(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
    }

    module Credentials {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * The `GCredentials` type is a reference-counted wrapper for native
     * credentials.
     *
     * The information in `GCredentials` is typically used for identifying,
     * authenticating and authorizing other processes.
     *
     * Some operating systems supports looking up the credentials of the remote
     * peer of a communication endpoint - see e.g. [method`Gio`.Socket.get_credentials].
     *
     * Some operating systems supports securely sending and receiving
     * credentials over a Unix Domain Socket, see [class`Gio`.UnixCredentialsMessage],
     * [method`Gio`.UnixConnection.send_credentials] and
     * [method`Gio`.UnixConnection.receive_credentials] for details.
     *
     * On Linux, the native credential type is a `struct ucred` - see the
     * [`unix(7)` man page](man:unix(7)) for details. This corresponds to
     * `G_CREDENTIALS_TYPE_LINUX_UCRED`.
     *
     * On Apple operating systems (including iOS, tvOS, and macOS), the native credential
     * type is a `struct xucred`. This corresponds to `G_CREDENTIALS_TYPE_APPLE_XUCRED`.
     *
     * On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is a
     * `struct cmsgcred`. This corresponds to `G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED`.
     *
     * On NetBSD, the native credential type is a `struct unpcbid`.
     * This corresponds to `G_CREDENTIALS_TYPE_NETBSD_UNPCBID`.
     *
     * On OpenBSD, the native credential type is a `struct sockpeercred`.
     * This corresponds to `G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED`.
     *
     * On Solaris (including OpenSolaris and its derivatives), the native credential type
     * is a `ucred_t`. This corresponds to `G_CREDENTIALS_TYPE_SOLARIS_UCRED`.
     *
     * Since GLib 2.72, on Windows, the native credentials may contain the PID of a
     * process. This corresponds to `G_CREDENTIALS_TYPE_WIN32_PID`.
     */
    class Credentials extends GObject.Object {
        static $gtype: GObject.GType<Credentials>;

        // Constructors

        constructor(properties?: Partial<Credentials.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Credentials;

        // Methods

        /**
         * Tries to get the UNIX process identifier from `credentials`. This
         * method is only available on UNIX platforms.
         *
         * This operation can fail if #GCredentials is not supported on the
         * OS or if the native credentials type does not contain information
         * about the UNIX process ID.
         * @returns The UNIX process ID, or `-1` if @error is set.
         */
        get_unix_pid(): number;
        /**
         * Tries to get the UNIX user identifier from `credentials`. This
         * method is only available on UNIX platforms.
         *
         * This operation can fail if #GCredentials is not supported on the
         * OS or if the native credentials type does not contain information
         * about the UNIX user.
         * @returns The UNIX user identifier or `-1` if @error is set.
         */
        get_unix_user(): number;
        /**
         * Checks if `credentials` and `other_credentials` is the same user.
         *
         * This operation can fail if #GCredentials is not supported on the
         * the OS.
         * @param other_credentials A #GCredentials.
         * @returns %TRUE if @credentials and @other_credentials has the same user, %FALSE otherwise or if @error is set.
         */
        is_same_user(other_credentials: Credentials): boolean;
        /**
         * Copies the native credentials of type `native_type` from `native`
         * into `credentials`.
         *
         * It is a programming error (which will cause a warning to be
         * logged) to use this method if there is no #GCredentials support for
         * the OS or if `native_type` isn't supported by the OS.
         * @param native_type The type of native credentials to set.
         * @param _native A pointer to native credentials.
         */
        set_native(native_type: CredentialsType, _native: any): void;
        /**
         * Tries to set the UNIX user identifier on `credentials`. This method
         * is only available on UNIX platforms.
         *
         * This operation can fail if #GCredentials is not supported on the
         * OS or if the native credentials type does not contain information
         * about the UNIX user. It can also fail if the OS does not allow the
         * use of "spoofed" credentials.
         * @param uid The UNIX user identifier to set.
         * @returns %TRUE if @uid was set, %FALSE if error is set.
         */
        set_unix_user(uid: number): boolean;
        /**
         * Creates a human-readable textual representation of `credentials`
         * that can be used in logging and debug messages. The format of the
         * returned string may change in future GLib release.
         * @returns A string that should be freed with g_free().
         */
        to_string(): string;
    }

    module DBusActionGroup {
        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                ActionGroup.ConstructorProps,
                RemoteActionGroup.ConstructorProps {}
    }

    /**
     * `GDBusActionGroup` is an implementation of the [iface`Gio`.ActionGroup]
     * interface.
     *
     * `GDBusActionGroup` can be used as a proxy for an action group
     * that is exported over D-Bus with [method`Gio`.DBusConnection.export_action_group].
     */
    class DBusActionGroup extends GObject.Object implements ActionGroup, RemoteActionGroup {
        static $gtype: GObject.GType<DBusActionGroup>;

        // Constructors

        constructor(properties?: Partial<DBusActionGroup.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Obtains a #GDBusActionGroup for the action group which is exported at
         * the given `bus_name` and `object_path`.
         *
         * The thread default main context is taken at the time of this call.
         * All signals on the menu model (and any linked models) are reported
         * with respect to this context.  All calls on the returned menu model
         * (and linked models) must also originate from this same context, with
         * the thread default main context unchanged.
         *
         * This call is non-blocking.  The returned action group may or may not
         * already be filled in.  The correct thing to do is connect the signals
         * for the action group to monitor for changes and then to call
         * g_action_group_list_actions() to get the initial list.
         * @param connection A #GDBusConnection
         * @param bus_name the bus name which exports the action     group or %NULL if @connection is not a message bus connection
         * @param object_path the object path at which the action group is exported
         */
        static get(connection: DBusConnection, bus_name: string | null, object_path: string): DBusActionGroup;

        // Inherited methods
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         * @returns whether or not the action is currently enabled
         */
        get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         * @returns the parameter type
         */
        get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the current state of the action
         */
        get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the state range hint
         */
        get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         * @returns the state type, if the action is stateful
         */
        get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         * @returns whether the named action exists
         */
        has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         * @returns a %NULL-terminated array of the names of the actions in the group
         */
        list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         * @returns %TRUE if the action exists, else %FALSE
         */
        query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         */
        vfunc_has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         */
        vfunc_list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         */
        vfunc_query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Activates the remote action.
         *
         * This is the same as g_action_group_activate_action() except that it
         * allows for provision of "platform data" to be sent along with the
         * activation request.  This typically contains details such as the user
         * interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to activate
         * @param parameter the optional parameter to the activation
         * @param platform_data the platform data to send
         */
        activate_action_full(action_name: string, parameter: GLib.Variant | null, platform_data: GLib.Variant): void;
        /**
         * Changes the state of a remote action.
         *
         * This is the same as g_action_group_change_action_state() except that
         * it allows for provision of "platform data" to be sent along with the
         * state change request.  This typically contains details such as the
         * user interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to change the state of
         * @param value the new requested value for the state
         * @param platform_data the platform data to send
         */
        change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
        /**
         * Activates the remote action.
         *
         * This is the same as g_action_group_activate_action() except that it
         * allows for provision of "platform data" to be sent along with the
         * activation request.  This typically contains details such as the user
         * interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to activate
         * @param parameter the optional parameter to the activation
         * @param platform_data the platform data to send
         */
        vfunc_activate_action_full(
            action_name: string,
            parameter: GLib.Variant | null,
            platform_data: GLib.Variant,
        ): void;
        /**
         * Changes the state of a remote action.
         *
         * This is the same as g_action_group_change_action_state() except that
         * it allows for provision of "platform data" to be sent along with the
         * state change request.  This typically contains details such as the
         * user interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to change the state of
         * @param value the new requested value for the state
         * @param platform_data the platform data to send
         */
        vfunc_change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusAuthObserver {
        // Signal callback interfaces

        interface AllowMechanism {
            (mechanism: string): boolean;
        }

        interface AuthorizeAuthenticatedPeer {
            (stream: IOStream, credentials?: Credentials | null): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GDBusAuthObserver` provides a mechanism for participating
     * in how a [class`Gio`.DBusServer] (or a [class`Gio`.DBusConnection])
     * authenticates remote peers.
     *
     * Simply instantiate a `GDBusAuthObserver` and connect to the
     * signals you are interested in. Note that new signals may be added
     * in the future.
     *
     * ## Controlling Authentication Mechanisms
     *
     * By default, a `GDBusServer` or server-side `GDBusConnection` will allow
     * any authentication mechanism to be used. If you only want to allow D-Bus
     * connections with the `EXTERNAL` mechanism, which makes use of credentials
     * passing and is the recommended mechanism for modern Unix platforms such
     * as Linux and the BSD family, you would use a signal handler like this:
     *
     * ```c
     * static gboolean
     * on_allow_mechanism (GDBusAuthObserver *observer,
     *                     const gchar       *mechanism,
     *                     gpointer           user_data)
     * {
     *   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
     *     {
     *       return TRUE;
     *     }
     *
     *   return FALSE;
     * }
     * ```
     *
     * ## Controlling Authorization
     *
     * By default, a `GDBusServer` or server-side `GDBusConnection` will accept
     * connections from any successfully authenticated user (but not from
     * anonymous connections using the `ANONYMOUS` mechanism). If you only
     * want to allow D-Bus connections from processes owned by the same uid
     * as the server, since GLib 2.68, you should use the
     * `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. Its equivalent
     * to the following signal handler:
     *
     * ```c
     * static gboolean
     * on_authorize_authenticated_peer (GDBusAuthObserver *observer,
     *                                  GIOStream         *stream,
     *                                  GCredentials      *credentials,
     *                                  gpointer           user_data)
     * {
     *   gboolean authorized;
     *
     *   authorized = FALSE;
     *   if (credentials != NULL)
     *     {
     *       GCredentials *own_credentials;
     *       own_credentials = g_credentials_new ();
     *       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
     *         authorized = TRUE;
     *       g_object_unref (own_credentials);
     *     }
     *
     *   return authorized;
     * }
     * ```
     */
    class DBusAuthObserver extends GObject.Object {
        static $gtype: GObject.GType<DBusAuthObserver>;

        // Constructors

        constructor(properties?: Partial<DBusAuthObserver.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DBusAuthObserver;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'allow-mechanism', callback: (_source: this, mechanism: string) => boolean): number;
        connect_after(signal: 'allow-mechanism', callback: (_source: this, mechanism: string) => boolean): number;
        emit(signal: 'allow-mechanism', mechanism: string): void;
        connect(
            signal: 'authorize-authenticated-peer',
            callback: (_source: this, stream: IOStream, credentials: Credentials | null) => boolean,
        ): number;
        connect_after(
            signal: 'authorize-authenticated-peer',
            callback: (_source: this, stream: IOStream, credentials: Credentials | null) => boolean,
        ): number;
        emit(signal: 'authorize-authenticated-peer', stream: IOStream, credentials?: Credentials | null): void;

        // Methods

        /**
         * Emits the #GDBusAuthObserver::allow-mechanism signal on `observer`.
         * @param mechanism The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`.
         * @returns %TRUE if @mechanism can be used to authenticate the other peer, %FALSE if not.
         */
        allow_mechanism(mechanism: string): boolean;
        /**
         * Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on `observer`.
         * @param stream A #GIOStream for the #GDBusConnection.
         * @param credentials Credentials received from the peer or %NULL.
         * @returns %TRUE if the peer is authorized, %FALSE if not.
         */
        authorize_authenticated_peer(stream: IOStream, credentials?: Credentials | null): boolean;
    }

    module DBusConnection {
        // Signal callback interfaces

        interface Closed {
            (remote_peer_vanished: boolean, error?: GLib.Error | null): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                AsyncInitable.ConstructorProps,
                Initable.ConstructorProps {
            address: string;
            authentication_observer: DBusAuthObserver;
            authenticationObserver: DBusAuthObserver;
            capabilities: DBusCapabilityFlags;
            closed: boolean;
            exit_on_close: boolean;
            exitOnClose: boolean;
            flags: DBusConnectionFlags;
            guid: string;
            stream: IOStream;
            unique_name: string;
            uniqueName: string;
        }
    }

    /**
     * The `GDBusConnection` type is used for D-Bus connections to remote
     * peers such as a message buses.
     *
     * It is a low-level API that offers a lot of flexibility. For instance,
     * it lets you establish a connection over any transport that can by represented
     * as a [class`Gio`.IOStream].
     *
     * This class is rarely used directly in D-Bus clients. If you are writing
     * a D-Bus client, it is often easier to use the [func`Gio`.bus_own_name],
     * [func`Gio`.bus_watch_name] or [func`Gio`.DBusProxy.new_for_bus] APIs.
     *
     * As an exception to the usual GLib rule that a particular object must not
     * be used by two threads at the same time, `GDBusConnection`s methods may be
     * called from any thread. This is so that [func`Gio`.bus_get] and
     * [func`Gio`.bus_get_sync] can safely return the same `GDBusConnection` when
     * called from any thread.
     *
     * Most of the ways to obtain a `GDBusConnection` automatically initialize it
     * (i.e. connect to D-Bus): for instance, [func`Gio`.DBusConnection.new] and
     * [func`Gio`.bus_get], and the synchronous versions of those methods, give you
     * an initialized connection. Language bindings for GIO should use
     * [func`Gio`.Initable.new] or [func`Gio`.AsyncInitable.new_async], which also
     * initialize the connection.
     *
     * If you construct an uninitialized `GDBusConnection`, such as via
     * [ctor`GObject`.Object.new], you must initialize it via [method`Gio`.Initable.init] or
     * [method`Gio`.AsyncInitable.init_async] before using its methods or properties.
     * Calling methods or accessing properties on a `GDBusConnection` that has not
     * completed initialization successfully is considered to be invalid, and leads
     * to undefined behaviour. In particular, if initialization fails with a
     * `GError`, the only valid thing you can do with that `GDBusConnection` is to
     * free it with [method`GObject`.Object.unref].
     *
     * ## An example D-Bus server
     *
     * Here is an example for a D-Bus server:
     * [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
     *
     * ## An example for exporting a subtree
     *
     * Here is an example for exporting a subtree:
     * [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
     *
     * ## An example for file descriptor passing
     *
     * Here is an example for passing UNIX file descriptors:
     * [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
     *
     * ## An example for exporting a GObject
     *
     * Here is an example for exporting a #GObject:
     * [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
     */
    class DBusConnection extends GObject.Object implements AsyncInitable<DBusConnection>, Initable {
        static $gtype: GObject.GType<DBusConnection>;

        // Properties

        /**
         * A D-Bus address specifying potential endpoints that can be used
         * when establishing the connection.
         */
        set address(val: string);
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        set authentication_observer(val: DBusAuthObserver);
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        set authenticationObserver(val: DBusAuthObserver);
        /**
         * Flags from the #GDBusCapabilityFlags enumeration
         * representing connection features negotiated with the other peer.
         */
        get capabilities(): DBusCapabilityFlags;
        /**
         * A boolean specifying whether the connection has been closed.
         */
        get closed(): boolean;
        /**
         * A boolean specifying whether the process will be terminated (by
         * calling `raise(SIGTERM)`) if the connection is closed by the
         * remote peer.
         *
         * Note that #GDBusConnection objects returned by g_bus_get_finish()
         * and g_bus_get_sync() will (usually) have this property set to %TRUE.
         */
        get exit_on_close(): boolean;
        set exit_on_close(val: boolean);
        /**
         * A boolean specifying whether the process will be terminated (by
         * calling `raise(SIGTERM)`) if the connection is closed by the
         * remote peer.
         *
         * Note that #GDBusConnection objects returned by g_bus_get_finish()
         * and g_bus_get_sync() will (usually) have this property set to %TRUE.
         */
        get exitOnClose(): boolean;
        set exitOnClose(val: boolean);
        /**
         * Flags from the #GDBusConnectionFlags enumeration.
         */
        get flags(): DBusConnectionFlags;
        /**
         * The GUID of the peer performing the role of server when
         * authenticating.
         *
         * If you are constructing a #GDBusConnection and pass
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
         * #GDBusConnection:flags property then you **must** also set this
         * property to a valid guid.
         *
         * If you are constructing a #GDBusConnection and pass
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
         * #GDBusConnection:flags property you will be able to read the GUID
         * of the other peer here after the connection has been successfully
         * initialized.
         *
         * Note that the
         * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
         * uses the term UUID to refer to this, whereas GLib consistently uses the
         * term GUID for historical reasons.
         *
         * Despite its name, the format of #GDBusConnection:guid does not follow
         * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
         * GUID format.
         */
        get guid(): string;
        /**
         * The underlying #GIOStream used for I/O.
         *
         * If this is passed on construction and is a #GSocketConnection,
         * then the corresponding #GSocket will be put into non-blocking mode.
         *
         * While the #GDBusConnection is active, it will interact with this
         * stream from a worker thread, so it is not safe to interact with
         * the stream directly.
         */
        get stream(): IOStream;
        /**
         * The unique name as assigned by the message bus or %NULL if the
         * connection is not open or not a message bus connection.
         */
        get unique_name(): string;
        /**
         * The unique name as assigned by the message bus or %NULL if the
         * connection is not open or not a message bus connection.
         */
        get uniqueName(): string;

        // Constructors

        constructor(properties?: Partial<DBusConnection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_finish(res: AsyncResult): DBusConnection;
        // Conflicted with Gio.AsyncInitable.new_finish

        static new_finish(...args: never[]): any;

        static new_for_address_finish(res: AsyncResult): DBusConnection;

        static new_for_address_sync(
            address: string,
            flags: DBusConnectionFlags,
            observer?: DBusAuthObserver | null,
            cancellable?: Cancellable | null,
        ): DBusConnection;

        static new_sync(
            stream: IOStream,
            guid: string | null,
            flags: DBusConnectionFlags,
            observer?: DBusAuthObserver | null,
            cancellable?: Cancellable | null,
        ): DBusConnection;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'closed',
            callback: (_source: this, remote_peer_vanished: boolean, error: GLib.Error | null) => void,
        ): number;
        connect_after(
            signal: 'closed',
            callback: (_source: this, remote_peer_vanished: boolean, error: GLib.Error | null) => void,
        ): number;
        emit(signal: 'closed', remote_peer_vanished: boolean, error?: GLib.Error | null): void;

        // Static methods

        /**
         * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
         * with the end represented by `stream`.
         *
         * If `stream` is a #GSocketConnection, then the corresponding #GSocket
         * will be put into non-blocking mode.
         *
         * The D-Bus connection will interact with `stream` from a worker thread.
         * As a result, the caller should not interact with `stream` after this
         * method has been called, except by calling g_object_unref() on it.
         *
         * If `observer` is not %NULL it may be used to control the
         * authentication process.
         *
         * When the operation is finished, `callback` will be invoked. You can
         * then call g_dbus_connection_new_finish() to get the result of the
         * operation.
         *
         * This is an asynchronous failable constructor. See
         * g_dbus_connection_new_sync() for the synchronous
         * version.
         * @param stream a #GIOStream
         * @param guid the GUID to use if authenticating as a server or %NULL
         * @param flags flags describing how to make the connection
         * @param observer a #GDBusAuthObserver or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        static ['new'](
            stream: IOStream,
            guid: string | null,
            flags: DBusConnectionFlags,
            observer?: DBusAuthObserver | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<DBusConnection> | null,
        ): void;
        /**
         * Asynchronously connects and sets up a D-Bus client connection for
         * exchanging D-Bus messages with an endpoint specified by `address`
         * which must be in the
         * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
         *
         * This constructor can only be used to initiate client-side
         * connections - use g_dbus_connection_new() if you need to act as the
         * server. In particular, `flags` cannot contain the
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
         *
         * When the operation is finished, `callback` will be invoked. You can
         * then call g_dbus_connection_new_for_address_finish() to get the result of
         * the operation.
         *
         * If `observer` is not %NULL it may be used to control the
         * authentication process.
         *
         * This is an asynchronous failable constructor. See
         * g_dbus_connection_new_for_address_sync() for the synchronous
         * version.
         * @param address a D-Bus address
         * @param flags flags describing how to make the connection
         * @param observer a #GDBusAuthObserver or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        static new_for_address(
            address: string,
            flags: DBusConnectionFlags,
            observer?: DBusAuthObserver | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<DBusConnection> | null,
        ): void;

        // Methods

        /**
         * Adds a message filter. Filters are handlers that are run on all
         * incoming and outgoing messages, prior to standard dispatch. Filters
         * are run in the order that they were added.  The same handler can be
         * added as a filter more than once, in which case it will be run more
         * than once.  Filters added during a filter callback won't be run on
         * the message being processed. Filter functions are allowed to modify
         * and even drop messages.
         *
         * Note that filters are run in a dedicated message handling thread so
         * they can't block and, generally, can't do anything but signal a
         * worker thread. Also note that filters are rarely needed - use API
         * such as g_dbus_connection_send_message_with_reply(),
         * g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
         *
         * If a filter consumes an incoming message the message is not
         * dispatched anywhere else - not even the standard dispatch machinery
         * (that API such as g_dbus_connection_signal_subscribe() and
         * g_dbus_connection_send_message_with_reply() relies on) will see the
         * message. Similarly, if a filter consumes an outgoing message, the
         * message will not be sent to the other peer.
         *
         * If `user_data_free_func` is non-%NULL, it will be called (in the
         * thread-default main context of the thread you are calling this
         * method from) at some point after `user_data` is no longer
         * needed. (It is not guaranteed to be called synchronously when the
         * filter is removed, and may be called after `connection` has been
         * destroyed.)
         * @param filter_function a filter function
         * @returns a filter identifier that can be used with     g_dbus_connection_remove_filter()
         */
        add_filter(filter_function: DBusMessageFilterFunction): number;
        /**
         * Asynchronously invokes the `method_name` method on the
         * `interface_name` D-Bus interface on the remote object at
         * `object_path` owned by `bus_name`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
         * fail with %G_IO_ERROR_CANCELLED. If `parameters` contains a value
         * not compatible with the D-Bus protocol, the operation fails with
         * %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If `reply_type` is non-%NULL then the reply will be checked for having this type and an
         * error will be raised if it does not match.  Said another way, if you give a `reply_type`
         * then any non-%NULL return value will be of this type. Unless its
         * %G_VARIANT_TYPE_UNIT, the `reply_type` will be a tuple containing one or more
         * values.
         *
         * If the `parameters` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_connection_call (connection,
         *                          "org.freedesktop.StringThings",
         *                          "/org/freedesktop/StringThings",
         *                          "org.freedesktop.StringThings",
         *                          "TwoStrings",
         *                          g_variant_new ("(ss)",
         *                                         "Thing One",
         *                                         "Thing Two"),
         *                          NULL,
         *                          G_DBUS_CALL_FLAGS_NONE,
         *                          -1,
         *                          NULL,
         *                          (GAsyncReadyCallback) two_strings_done,
         *                          NULL);
         * ```
         *
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can then call
         * g_dbus_connection_call_finish() to get the result of the operation.
         * See g_dbus_connection_call_sync() for the synchronous version of this
         * function.
         *
         * If `callback` is %NULL then the D-Bus method call message will be sent with
         * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
         * @param bus_name a unique or well-known bus name or %NULL if     @connection is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
         * @param reply_type the expected type of the reply (which will be a     tuple), or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request     is satisfied or %NULL if you don't care about the result of the     method invocation
         */
        call<T extends string = any>(
            bus_name: string | null,
            object_path: string,
            interface_name: string,
            method_name: string,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType<T> | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an operation started with g_dbus_connection_call().
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_call()
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_finish<T extends string = any>(res: AsyncResult): GLib.Variant<T>;
        /**
         * Synchronously invokes the `method_name` method on the
         * `interface_name` D-Bus interface on the remote object at
         * `object_path` owned by `bus_name`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the
         * operation will fail with %G_IO_ERROR_CANCELLED. If `parameters`
         * contains a value not compatible with the D-Bus protocol, the operation
         * fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If `reply_type` is non-%NULL then the reply will be checked for having
         * this type and an error will be raised if it does not match.  Said
         * another way, if you give a `reply_type` then any non-%NULL return
         * value will be of this type.
         *
         * If the `parameters` #GVariant is floating, it is consumed.
         * This allows convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_connection_call_sync (connection,
         *                               "org.freedesktop.StringThings",
         *                               "/org/freedesktop/StringThings",
         *                               "org.freedesktop.StringThings",
         *                               "TwoStrings",
         *                               g_variant_new ("(ss)",
         *                                              "Thing One",
         *                                              "Thing Two"),
         *                               NULL,
         *                               G_DBUS_CALL_FLAGS_NONE,
         *                               -1,
         *                               NULL,
         *                               &error);
         * ```
         *
         *
         * The calling thread is blocked until a reply is received. See
         * g_dbus_connection_call() for the asynchronous version of
         * this method.
         * @param bus_name a unique or well-known bus name or %NULL if     @connection is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
         * @param reply_type the expected type of the reply, or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_sync(
            bus_name: string | null,
            object_path: string,
            interface_name: string,
            method_name: string,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable?: Cancellable | null,
        ): GLib.Variant;
        /**
         * Like g_dbus_connection_call() but also takes a #GUnixFDList object.
         *
         * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
         * values in the body of the message. For example, if a message contains
         * two file descriptors, `fd_list` would have length 2, and
         * `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
         * somewhere in the body of the message (not necessarily in that order!)
         * to represent the file descriptors at indexes 0 and 1 respectively.
         *
         * When designing D-Bus APIs that are intended to be interoperable,
         * please note that non-GDBus implementations of D-Bus can usually only
         * access file descriptors if they are referenced in this way by a
         * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
         *
         * This method is only available on UNIX.
         * @param bus_name a unique or well-known bus name or %NULL if     @connection is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
         * @param reply_type the expected type of the reply, or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param fd_list a #GUnixFDList or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is     satisfied or %NULL if you don't * care about the result of the     method invocation
         */
        call_with_unix_fd_list(
            bus_name: string | null,
            object_path: string,
            interface_name: string,
            method_name: string,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list?: UnixFDList | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().
         *
         * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
         * values in the body of the message. For example,
         * if g_variant_get_handle() returns 5, that is intended to be a reference
         * to the file descriptor that can be accessed by
         * `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
         *
         * When designing D-Bus APIs that are intended to be interoperable,
         * please note that non-GDBus implementations of D-Bus can usually only
         * access file descriptors if they are referenced in this way by a
         * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to     g_dbus_connection_call_with_unix_fd_list()
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_finish(res: AsyncResult): [GLib.Variant, UnixFDList | null];
        /**
         * Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.
         * See g_dbus_connection_call_with_unix_fd_list() and
         * g_dbus_connection_call_with_unix_fd_list_finish() for more details.
         *
         * This method is only available on UNIX.
         * @param bus_name a unique or well-known bus name or %NULL     if @connection is not a message bus connection
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to invoke method on
         * @param method_name the name of the method to invoke
         * @param parameters a #GVariant tuple with parameters for     the method or %NULL if not passing parameters
         * @param reply_type the expected type of the reply, or %NULL
         * @param flags flags from the #GDBusCallFlags enumeration
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param fd_list a #GUnixFDList or %NULL
         * @param cancellable a #GCancellable or %NULL
         * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_sync(
            bus_name: string | null,
            object_path: string,
            interface_name: string,
            method_name: string,
            parameters: GLib.Variant | null,
            reply_type: GLib.VariantType | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list?: UnixFDList | null,
            cancellable?: Cancellable | null,
        ): [GLib.Variant, UnixFDList | null];
        /**
         * Closes `connection`. Note that this never causes the process to
         * exit (this might only happen if the other end of a shared message
         * bus connection disconnects, see #GDBusConnection:exit-on-close).
         *
         * Once the connection is closed, operations such as sending a message
         * will return with the error %G_IO_ERROR_CLOSED. Closing a connection
         * will not automatically flush the connection so queued messages may
         * be lost. Use g_dbus_connection_flush() if you need such guarantees.
         *
         * If `connection` is already closed, this method fails with
         * %G_IO_ERROR_CLOSED.
         *
         * When `connection` has been closed, the #GDBusConnection::closed
         * signal is emitted in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread that `connection` was constructed in.
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_connection_close_finish() to get the result of the
         * operation. See g_dbus_connection_close_sync() for the synchronous
         * version.
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is     satisfied or %NULL if you don't care about the result
         */
        close(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an operation started with g_dbus_connection_close().
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_close()
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        close_finish(res: AsyncResult): boolean;
        /**
         * Synchronously closes `connection`. The calling thread is blocked
         * until this is done. See g_dbus_connection_close() for the
         * asynchronous version of this method and more details about what it
         * does.
         * @param cancellable a #GCancellable or %NULL
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        close_sync(cancellable?: Cancellable | null): boolean;
        /**
         * Emits a signal.
         *
         * If the parameters GVariant is floating, it is consumed.
         *
         * This can only fail if `parameters` is not compatible with the D-Bus protocol
         * (%G_IO_ERROR_INVALID_ARGUMENT), or if `connection` has been closed
         * (%G_IO_ERROR_CLOSED).
         * @param destination_bus_name the unique bus name for the destination     for the signal or %NULL to emit to all listeners
         * @param object_path path of remote object
         * @param interface_name D-Bus interface to emit a signal on
         * @param signal_name the name of the signal to emit
         * @param parameters a #GVariant tuple with parameters for the signal              or %NULL if not passing parameters
         * @returns %TRUE unless @error is set
         */
        emit_signal(
            destination_bus_name: string | null,
            object_path: string,
            interface_name: string,
            signal_name: string,
            parameters?: GLib.Variant | null,
        ): boolean;
        /**
         * Exports `action_group` on `connection` at `object_path`.
         *
         * The implemented D-Bus API should be considered private.  It is
         * subject to change in the future.
         *
         * A given object path can only have one action group exported on it.
         * If this constraint is violated, the export will fail and 0 will be
         * returned (with `error` set accordingly).
         *
         * You can unexport the action group using
         * g_dbus_connection_unexport_action_group() with the return value of
         * this function.
         *
         * The thread default main context is taken at the time of this call.
         * All incoming action activations and state change requests are
         * reported from this context.  Any changes on the action group that
         * cause it to emit signals must also come from this same context.
         * Since incoming action activations and state change requests are
         * rather likely to cause changes on the action group, this effectively
         * limits a given action group to being exported from only one main
         * context.
         * @param object_path a D-Bus object path
         * @param action_group a #GActionGroup
         * @returns the ID of the export (never zero), or 0 in case of failure
         */
        export_action_group(object_path: string, action_group: ActionGroup): number;
        /**
         * Exports `menu` on `connection` at `object_path`.
         *
         * The implemented D-Bus API should be considered private.
         * It is subject to change in the future.
         *
         * An object path can only have one menu model exported on it. If this
         * constraint is violated, the export will fail and 0 will be
         * returned (with `error` set accordingly).
         *
         * Exporting menus with sections containing more than
         * %G_MENU_EXPORTER_MAX_SECTION_SIZE items is not supported and results in
         * undefined behavior.
         *
         * You can unexport the menu model using
         * g_dbus_connection_unexport_menu_model() with the return value of
         * this function.
         * @param object_path a D-Bus object path
         * @param menu a #GMenuModel
         * @returns the ID of the export (never zero), or 0 in case of failure
         */
        export_menu_model(object_path: string, menu: MenuModel): number;
        /**
         * Asynchronously flushes `connection,` that is, writes all queued
         * outgoing message to the transport and then flushes the transport
         * (using g_output_stream_flush_async()). This is useful in programs
         * that wants to emit a D-Bus signal and then exit immediately. Without
         * flushing the connection, there is no guaranteed that the message has
         * been sent to the networking buffers in the OS kernel.
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_connection_flush_finish() to get the result of the
         * operation. See g_dbus_connection_flush_sync() for the synchronous
         * version.
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the     request is satisfied or %NULL if you don't care about the result
         */
        flush(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an operation started with g_dbus_connection_flush().
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_flush()
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        flush_finish(res: AsyncResult): boolean;
        /**
         * Synchronously flushes `connection`. The calling thread is blocked
         * until this is done. See g_dbus_connection_flush() for the
         * asynchronous version of this method and more details about what it
         * does.
         * @param cancellable a #GCancellable or %NULL
         * @returns %TRUE if the operation succeeded, %FALSE if @error is set
         */
        flush_sync(cancellable?: Cancellable | null): boolean;
        /**
         * Gets the capabilities negotiated with the remote peer
         * @returns zero or more flags from the #GDBusCapabilityFlags enumeration
         */
        get_capabilities(): DBusCapabilityFlags;
        /**
         * Gets whether the process is terminated when `connection` is
         * closed by the remote peer. See
         * #GDBusConnection:exit-on-close for more details.
         * @returns whether the process is terminated when @connection is     closed by the remote peer
         */
        get_exit_on_close(): boolean;
        /**
         * Gets the flags used to construct this connection
         * @returns zero or more flags from the #GDBusConnectionFlags enumeration
         */
        get_flags(): DBusConnectionFlags;
        /**
         * The GUID of the peer performing the role of server when
         * authenticating. See #GDBusConnection:guid for more details.
         * @returns The GUID. Do not free this string, it is owned by     @connection.
         */
        get_guid(): string;
        /**
         * Retrieves the last serial number assigned to a #GDBusMessage on
         * the current thread. This includes messages sent via both low-level
         * API such as g_dbus_connection_send_message() as well as
         * high-level API such as g_dbus_connection_emit_signal(),
         * g_dbus_connection_call() or g_dbus_proxy_call().
         * @returns the last used serial or zero when no message has been sent     within the current thread
         */
        get_last_serial(): number;
        /**
         * Gets the credentials of the authenticated peer. This will always
         * return %NULL unless `connection` acted as a server
         * (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
         * when set up and the client passed credentials as part of the
         * authentication process.
         *
         * In a message bus setup, the message bus is always the server and
         * each application is a client. So this method will always return
         * %NULL for message bus clients.
         * @returns a #GCredentials or %NULL if not     available. Do not free this object, it is owned by @connection.
         */
        get_peer_credentials(): Credentials | null;
        /**
         * Gets the underlying stream used for IO.
         *
         * While the #GDBusConnection is active, it will interact with this
         * stream from a worker thread, so it is not safe to interact with
         * the stream directly.
         * @returns the stream used for IO
         */
        get_stream(): IOStream;
        /**
         * Gets the unique name of `connection` as assigned by the message
         * bus. This can also be used to figure out if `connection` is a
         * message bus connection.
         * @returns the unique name or %NULL if @connection is not a message     bus connection. Do not free this string, it is owned by     @connection.
         */
        get_unique_name(): string | null;
        /**
         * Gets whether `connection` is closed.
         * @returns %TRUE if the connection is closed, %FALSE otherwise
         */
        is_closed(): boolean;
        /**
         * Registers callbacks for exported objects at `object_path` with the
         * D-Bus interface that is described in `interface_info`.
         *
         * Calls to functions in `vtable` (and `user_data_free_func)` will happen
         * in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from.
         *
         * Note that all #GVariant values passed to functions in `vtable` will match
         * the signature given in `interface_info` - if a remote caller passes
         * incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
         * is returned to the remote caller.
         *
         * Additionally, if the remote caller attempts to invoke methods or
         * access properties not mentioned in `interface_info` the
         * `org.freedesktop.DBus.Error.UnknownMethod` resp.
         * `org.freedesktop.DBus.Error.InvalidArgs` errors
         * are returned to the caller.
         *
         * It is considered a programming error if the
         * #GDBusInterfaceGetPropertyFunc function in `vtable` returns a
         * #GVariant of incorrect type.
         *
         * If an existing callback is already registered at `object_path` and
         * `interface_name,` then `error` is set to %G_IO_ERROR_EXISTS.
         *
         * GDBus automatically implements the standard D-Bus interfaces
         * org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
         * and org.freedesktop.Peer, so you don't have to implement those for the
         * objects you export. You can implement org.freedesktop.DBus.Properties
         * yourself, e.g. to handle getting and setting of properties asynchronously.
         *
         * Note that the reference count on `interface_info` will be
         * incremented by 1 (unless allocated statically, e.g. if the
         * reference count is -1, see g_dbus_interface_info_ref()) for as long
         * as the object is exported. Also note that `vtable` will be copied.
         *
         * See this [server][gdbus-server] for an example of how to use this method.
         * @param object_path the object path to register at
         * @param interface_info introspection data for the interface
         * @param vtable a #GDBusInterfaceVTable to call into or %NULL
         * @param user_data data to pass to functions in @vtable
         * @returns 0 if @error is set, otherwise a registration id (never 0)     that can be used with g_dbus_connection_unregister_object()
         */
        register_object(
            object_path: string,
            interface_info: DBusInterfaceInfo,
            vtable?: DBusInterfaceVTable | null,
            user_data?: any | null,
        ): number;
        /**
         * Version of g_dbus_connection_register_object() using closures instead of a
         * #GDBusInterfaceVTable for easier binding in other languages.
         * @param object_path The object path to register at.
         * @param interface_info Introspection data for the interface.
         * @param method_call_closure #GClosure for handling incoming method calls.
         * @param get_property_closure #GClosure for getting a property.
         * @param set_property_closure #GClosure for setting a property.
         * @returns 0 if @error is set, otherwise a registration ID (never 0) that can be used with g_dbus_connection_unregister_object() .
         */
        register_object(
            object_path: string,
            interface_info: DBusInterfaceInfo,
            method_call_closure?: GObject.Closure | null,
            get_property_closure?: GObject.Closure | null,
            set_property_closure?: GObject.Closure | null,
        ): number;
        /**
         * Registers a whole subtree of dynamic objects.
         *
         * The `enumerate` and `introspection` functions in `vtable` are used to
         * convey, to remote callers, what nodes exist in the subtree rooted
         * by `object_path`.
         *
         * When handling remote calls into any node in the subtree, first the
         * `enumerate` function is used to check if the node exists. If the node exists
         * or the %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
         * the `introspection` function is used to check if the node supports the
         * requested method. If so, the `dispatch` function is used to determine
         * where to dispatch the call. The collected #GDBusInterfaceVTable and
         * #gpointer will be used to call into the interface vtable for processing
         * the request.
         *
         * All calls into user-provided code will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from.
         *
         * If an existing subtree is already registered at `object_path` or
         * then `error` is set to %G_IO_ERROR_EXISTS.
         *
         * Note that it is valid to register regular objects (using
         * g_dbus_connection_register_object()) in a subtree registered with
         * g_dbus_connection_register_subtree() - if so, the subtree handler
         * is tried as the last resort. One way to think about a subtree
         * handler is to consider it a fallback handler for object paths not
         * registered via g_dbus_connection_register_object() or other bindings.
         *
         * Note that `vtable` will be copied so you cannot change it after
         * registration.
         *
         * See this [server][gdbus-subtree-server] for an example of how to use
         * this method.
         * @param object_path the object path to register the subtree at
         * @param vtable a #GDBusSubtreeVTable to enumerate, introspect and     dispatch nodes in the subtree
         * @param flags flags used to fine tune the behavior of the subtree
         * @param user_data data to pass to functions in @vtable
         * @returns 0 if @error is set, otherwise a subtree registration ID (never 0) that can be used with g_dbus_connection_unregister_subtree()
         */
        register_subtree(
            object_path: string,
            vtable: DBusSubtreeVTable,
            flags: DBusSubtreeFlags,
            user_data?: any | null,
        ): number;
        /**
         * Removes a filter.
         *
         * Note that since filters run in a different thread, there is a race
         * condition where it is possible that the filter will be running even
         * after calling g_dbus_connection_remove_filter(), so you cannot just
         * free data that the filter might be using. Instead, you should pass
         * a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
         * called when it is guaranteed that the data is no longer needed.
         * @param filter_id an identifier obtained from g_dbus_connection_add_filter()
         */
        remove_filter(filter_id: number): void;
        /**
         * Asynchronously sends `message` to the peer represented by `connection`.
         *
         * Unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
         * will be assigned by `connection` and set on `message` via
         * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
         * serial number used will be written to this location prior to
         * submitting the message to the underlying transport. While it has a `volatile`
         * qualifier, this is a historical artifact and the argument passed to it should
         * not be `volatile`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `message` is not well-formed,
         * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         *
         * Note that `message` must be unlocked, unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
         * @param message a #GDBusMessage
         * @param flags flags affecting how the message is sent
         * @returns %TRUE if the message was well-formed and queued for     transmission, %FALSE if @error is set
         */
        send_message(message: DBusMessage, flags: DBusSendMessageFlags): [boolean, number];
        /**
         * Asynchronously sends `message` to the peer represented by `connection`.
         *
         * Unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
         * will be assigned by `connection` and set on `message` via
         * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
         * serial number used will be written to this location prior to
         * submitting the message to the underlying transport. While it has a `volatile`
         * qualifier, this is a historical artifact and the argument passed to it should
         * not be `volatile`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
         * fail with %G_IO_ERROR_CANCELLED. If `message` is not well-formed,
         * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * This is an asynchronous method. When the operation is finished, `callback`
         * will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can then call
         * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
         * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
         *
         * Note that `message` must be unlocked, unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         * @param message a #GDBusMessage
         * @param flags flags affecting how the message is sent
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request     is satisfied or %NULL if you don't care about the result
         */
        send_message_with_reply(
            message: DBusMessage,
            flags: DBusSendMessageFlags,
            timeout_msec: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): number;
        /**
         * Finishes an operation started with g_dbus_connection_send_message_with_reply().
         *
         * Note that `error` is only set if a local in-process error
         * occurred. That is to say that the returned #GDBusMessage object may
         * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
         * g_dbus_message_to_gerror() to transcode this to a #GError.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to     g_dbus_connection_send_message_with_reply()
         * @returns a locked #GDBusMessage or %NULL if @error is set
         */
        send_message_with_reply_finish(res: AsyncResult): DBusMessage;
        /**
         * Synchronously sends `message` to the peer represented by `connection`
         * and blocks the calling thread until a reply is received or the
         * timeout is reached. See g_dbus_connection_send_message_with_reply()
         * for the asynchronous version of this method.
         *
         * Unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
         * will be assigned by `connection` and set on `message` via
         * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
         * serial number used will be written to this location prior to
         * submitting the message to the underlying transport. While it has a `volatile`
         * qualifier, this is a historical artifact and the argument passed to it should
         * not be `volatile`.
         *
         * If `connection` is closed then the operation will fail with
         * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
         * fail with %G_IO_ERROR_CANCELLED. If `message` is not well-formed,
         * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * Note that `error` is only set if a local in-process error
         * occurred. That is to say that the returned #GDBusMessage object may
         * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
         * g_dbus_message_to_gerror() to transcode this to a #GError.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         *
         * Note that `message` must be unlocked, unless `flags` contain the
         * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
         * @param message a #GDBusMessage
         * @param flags flags affecting how the message is sent.
         * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
         * @param cancellable a #GCancellable or %NULL
         * @returns a locked #GDBusMessage that is the reply     to @message or %NULL if @error is set
         */
        send_message_with_reply_sync(
            message: DBusMessage,
            flags: DBusSendMessageFlags,
            timeout_msec: number,
            cancellable?: Cancellable | null,
        ): [DBusMessage, number];
        /**
         * Sets whether the process should be terminated when `connection` is
         * closed by the remote peer. See #GDBusConnection:exit-on-close for
         * more details.
         *
         * Note that this function should be used with care. Most modern UNIX
         * desktops tie the notion of a user session with the session bus, and expect
         * all of a user's applications to quit when their bus connection goes away.
         * If you are setting `exit_on_close` to %FALSE for the shared session
         * bus connection, you should make sure that your application exits
         * when the user session ends.
         * @param exit_on_close whether the process should be terminated     when @connection is closed by the remote peer
         */
        set_exit_on_close(exit_on_close: boolean): void;
        /**
         * Subscribes to signals on `connection` and invokes `callback` whenever
         * the signal is received. Note that `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from.
         *
         * If `connection` is not a message bus connection, `sender` must be
         * %NULL.
         *
         * If `sender` is a well-known name note that `callback` is invoked with
         * the unique name for the owner of `sender,` not the well-known name
         * as one would expect. This is because the message bus rewrites the
         * name. As such, to avoid certain race conditions, users should be
         * tracking the name owner of the well-known name and use that when
         * processing the received signal.
         *
         * If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
         * %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, `arg0` is
         * interpreted as part of a namespace or path.  The first argument
         * of a signal is matched against that part as specified by D-Bus.
         *
         * If `user_data_free_func` is non-%NULL, it will be called (in the
         * thread-default main context of the thread you are calling this
         * method from) at some point after `user_data` is no longer
         * needed. (It is not guaranteed to be called synchronously when the
         * signal is unsubscribed from, and may be called after `connection`
         * has been destroyed.)
         *
         * As `callback` is potentially invoked in a different thread from where its
         * emitted, its possible for this to happen after
         * g_dbus_connection_signal_unsubscribe() has been called in another thread.
         * Due to this, `user_data` should have a strong reference which is freed with
         * `user_data_free_func,` rather than pointing to data whose lifecycle is tied
         * to the signal subscription. For example, if a #GObject is used to store the
         * subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
         * to that #GObject must be passed to `user_data,` and g_object_unref() passed to
         * `user_data_free_func`. You are responsible for breaking the resulting
         * reference count cycle by explicitly unsubscribing from the signal when
         * dropping the last external reference to the #GObject. Alternatively, a weak
         * reference may be used.
         *
         * It is guaranteed that if you unsubscribe from a signal using
         * g_dbus_connection_signal_unsubscribe() from the same thread which made the
         * corresponding g_dbus_connection_signal_subscribe() call, `callback` will not
         * be invoked after g_dbus_connection_signal_unsubscribe() returns.
         *
         * The returned subscription identifier is an opaque value which is guaranteed
         * to never be zero.
         *
         * This function can never fail.
         * @param sender sender name to match on (unique or well-known name)     or %NULL to listen from all senders
         * @param interface_name D-Bus interface name to match on or %NULL to     match on all interfaces
         * @param member D-Bus signal name to match on or %NULL to match on     all signals
         * @param object_path object path to match on or %NULL to match on     all object paths
         * @param arg0 contents of first string argument to match on or %NULL     to match on all kinds of arguments
         * @param flags #GDBusSignalFlags describing how arg0 is used in subscribing to the     signal
         * @param callback callback to invoke when there is a signal matching the requested data
         * @param user_data_free_func function to free @user_data with when     subscription is removed or %NULL
         * @returns a subscription identifier that can be used with g_dbus_connection_signal_unsubscribe()
         */
        signal_subscribe(
            sender: string | null,
            interface_name: string | null,
            member: string | null,
            object_path: string | null,
            arg0: string | null,
            flags: DBusSignalFlags,
            callback: DBusSignalCallback,
            user_data_free_func?: GLib.DestroyNotify | null,
        ): number;
        /**
         * Unsubscribes from signals.
         *
         * Note that there may still be D-Bus traffic to process (relating to this
         * signal subscription) in the current thread-default #GMainContext after this
         * function has returned. You should continue to iterate the #GMainContext
         * until the #GDestroyNotify function passed to
         * g_dbus_connection_signal_subscribe() is called, in order to avoid memory
         * leaks through callbacks queued on the #GMainContext after its stopped being
         * iterated.
         * Alternatively, any idle source with a priority lower than %G_PRIORITY_DEFAULT
         * that was scheduled after unsubscription, also indicates that all resources
         * of this subscription are released.
         * @param subscription_id a subscription id obtained from     g_dbus_connection_signal_subscribe()
         */
        signal_unsubscribe(subscription_id: number): void;
        /**
         * If `connection` was created with
         * %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
         * starts processing messages. Does nothing on if `connection` wasn't
         * created with this flag or if the method has already been called.
         */
        start_message_processing(): void;
        /**
         * Reverses the effect of a previous call to
         * g_dbus_connection_export_action_group().
         *
         * It is an error to call this function with an ID that wasn't returned
         * from g_dbus_connection_export_action_group() or to call it with the
         * same ID more than once.
         * @param export_id the ID from g_dbus_connection_export_action_group()
         */
        unexport_action_group(export_id: number): void;
        /**
         * Reverses the effect of a previous call to
         * g_dbus_connection_export_menu_model().
         *
         * It is an error to call this function with an ID that wasn't returned
         * from g_dbus_connection_export_menu_model() or to call it with the
         * same ID more than once.
         * @param export_id the ID from g_dbus_connection_export_menu_model()
         */
        unexport_menu_model(export_id: number): void;
        /**
         * Unregisters an object.
         * @param registration_id a registration id obtained from     g_dbus_connection_register_object()
         * @returns %TRUE if the object was unregistered, %FALSE otherwise
         */
        unregister_object(registration_id: number): boolean;
        /**
         * Unregisters a subtree.
         * @param registration_id a subtree registration id obtained from     g_dbus_connection_register_subtree()
         * @returns %TRUE if the subtree was unregistered, %FALSE otherwise
         */
        unregister_subtree(registration_id: number): boolean;
        watch_name(
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure?: GObject.Closure | null,
            name_vanished_closure?: GObject.Closure | null,
        ): number;
        unwatch_name(watcher_id: number): void;
        own_name(
            name: string,
            flags: BusNameOwnerFlags,
            name_acquired_closure?: GObject.Closure | null,
            name_lost_closure?: GObject.Closure | null,
        ): number;
        unown_name(owner_id: number): void;

        // Inherited methods
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        init_finish(res: AsyncResult): boolean;
        /**
         * Finishes the async construction for the various g_async_initable_new
         * calls, returning the created object or %NULL on error.
         * @param res the #GAsyncResult from the callback
         * @returns a newly created #GObject,      or %NULL on error. Free with g_object_unref().
         */
        new_finish(res: AsyncResult): DBusConnection;
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        vfunc_init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         */
        vfunc_init_finish(res: AsyncResult): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusInterfaceSkeleton {
        // Signal callback interfaces

        interface GAuthorizeMethod {
            (invocation: DBusMethodInvocation): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DBusInterface.ConstructorProps {
            g_flags: DBusInterfaceSkeletonFlags;
            gFlags: DBusInterfaceSkeletonFlags;
        }
    }

    /**
     * Abstract base class for D-Bus interfaces on the service side.
     */
    abstract class DBusInterfaceSkeleton extends GObject.Object implements DBusInterface {
        static $gtype: GObject.GType<DBusInterfaceSkeleton>;

        // Properties

        /**
         * Flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        get g_flags(): DBusInterfaceSkeletonFlags;
        set g_flags(val: DBusInterfaceSkeletonFlags);
        /**
         * Flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        get gFlags(): DBusInterfaceSkeletonFlags;
        set gFlags(val: DBusInterfaceSkeletonFlags);

        // Constructors

        constructor(properties?: Partial<DBusInterfaceSkeleton.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'g-authorize-method',
            callback: (_source: this, invocation: DBusMethodInvocation) => boolean,
        ): number;
        connect_after(
            signal: 'g-authorize-method',
            callback: (_source: this, invocation: DBusMethodInvocation) => boolean,
        ): number;
        emit(signal: 'g-authorize-method', invocation: DBusMethodInvocation): void;

        // Virtual methods

        /**
         * If `interface_` has outstanding changes, request for these changes to be
         * emitted immediately.
         *
         * For example, an exported D-Bus interface may queue up property
         * changes and emit the
         * `org.freedesktop.DBus.Properties.PropertiesChanged`
         * signal later (e.g. in an idle handler). This technique is useful
         * for collapsing multiple property changes into one.
         */
        vfunc_flush(): void;
        /**
         * Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.
         * @param invocation
         */
        vfunc_g_authorize_method(invocation: DBusMethodInvocation): boolean;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         */
        vfunc_get_info(): DBusInterfaceInfo;
        /**
         * Gets all D-Bus properties for `interface_`.
         */
        vfunc_get_properties(): GLib.Variant;
        /**
         * Gets the interface vtable for the D-Bus interface implemented by
         * `interface_`. The returned function pointers should expect `interface_`
         * itself to be passed as `user_data`.
         */
        vfunc_get_vtable(): DBusInterfaceVTable;

        // Methods

        /**
         * Exports `interface_` at `object_path` on `connection`.
         *
         * This can be called multiple times to export the same `interface_`
         * onto multiple connections however the `object_path` provided must be
         * the same for all connections.
         *
         * Use g_dbus_interface_skeleton_unexport() to unexport the object.
         * @param connection A #GDBusConnection to export @interface_ on.
         * @param object_path The path to export the interface at.
         * @returns %TRUE if the interface was exported on @connection, otherwise %FALSE with @error set.
         */
        ['export'](connection: DBusConnection, object_path: string): boolean;
        /**
         * If `interface_` has outstanding changes, request for these changes to be
         * emitted immediately.
         *
         * For example, an exported D-Bus interface may queue up property
         * changes and emit the
         * `org.freedesktop.DBus.Properties.PropertiesChanged`
         * signal later (e.g. in an idle handler). This technique is useful
         * for collapsing multiple property changes into one.
         */
        flush(): void;
        /**
         * Gets the first connection that `interface_` is exported on, if any.
         * @returns A #GDBusConnection or %NULL if @interface_ is not exported anywhere. Do not free, the object belongs to @interface_.
         */
        get_connection(): DBusConnection | null;
        /**
         * Gets a list of the connections that `interface_` is exported on.
         * @returns A list of   all the connections that @interface_ is exported on. The returned   list should be freed with g_list_free() after each element has   been freed with g_object_unref().
         */
        get_connections(): DBusConnection[];
        /**
         * Gets the #GDBusInterfaceSkeletonFlags that describes what the behavior
         * of `interface_`
         * @returns One or more flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        get_flags(): DBusInterfaceSkeletonFlags;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
         */
        get_info(): DBusInterfaceInfo;
        /**
         * Gets the object path that `interface_` is exported on, if any.
         * @returns A string owned by @interface_ or %NULL if @interface_ is not exported anywhere. Do not free, the string belongs to @interface_.
         */
        get_object_path(): string | null;
        /**
         * Gets all D-Bus properties for `interface_`.
         * @returns A #GVariant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with g_variant_unref().
         */
        get_properties(): GLib.Variant;
        /**
         * Gets the interface vtable for the D-Bus interface implemented by
         * `interface_`. The returned function pointers should expect `interface_`
         * itself to be passed as `user_data`.
         * @returns the vtable of the D-Bus interface implemented by the skeleton
         */
        get_vtable(): DBusInterfaceVTable;
        /**
         * Checks if `interface_` is exported on `connection`.
         * @param connection A #GDBusConnection.
         * @returns %TRUE if @interface_ is exported on @connection, %FALSE otherwise.
         */
        has_connection(connection: DBusConnection): boolean;
        /**
         * Sets flags describing what the behavior of `skeleton` should be.
         * @param flags Flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        set_flags(flags: DBusInterfaceSkeletonFlags): void;
        /**
         * Stops exporting `interface_` on all connections it is exported on.
         *
         * To unexport `interface_` from only a single connection, use
         * g_dbus_interface_skeleton_unexport_from_connection()
         */
        unexport(): void;
        /**
         * Stops exporting `interface_` on `connection`.
         *
         * To stop exporting on all connections the interface is exported on,
         * use g_dbus_interface_skeleton_unexport().
         * @param connection A #GDBusConnection.
         */
        unexport_from_connection(connection: DBusConnection): void;

        // Inherited methods
        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         * @returns A #GDBusObject or %NULL. The returned reference should be freed with g_object_unref().
         */
        get_object(): DBusObject | null;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @param object A #GDBusObject or %NULL.
         */
        set_object(object?: DBusObject | null): void;
        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         */
        vfunc_dup_object(): DBusObject | null;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @param object A #GDBusObject or %NULL.
         */
        vfunc_set_object(object?: DBusObject | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusMenuModel {
        // Constructor properties interface

        interface ConstructorProps extends MenuModel.ConstructorProps {}
    }

    /**
     * `GDBusMenuModel` is an implementation of [class`Gio`.MenuModel] that can be
     * used as a proxy for a menu model that is exported over D-Bus with
     * [method`Gio`.DBusConnection.export_menu_model].
     */
    class DBusMenuModel extends MenuModel {
        static $gtype: GObject.GType<DBusMenuModel>;

        // Constructors

        constructor(properties?: Partial<DBusMenuModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Obtains a #GDBusMenuModel for the menu model which is exported
         * at the given `bus_name` and `object_path`.
         *
         * The thread default main context is taken at the time of this call.
         * All signals on the menu model (and any linked models) are reported
         * with respect to this context.  All calls on the returned menu model
         * (and linked models) must also originate from this same context, with
         * the thread default main context unchanged.
         * @param connection a #GDBusConnection
         * @param bus_name the bus name which exports the menu model     or %NULL if @connection is not a message bus connection
         * @param object_path the object path at which the menu model is exported
         */
        static get(connection: DBusConnection, bus_name: string | null, object_path: string): DBusMenuModel;
    }

    module DBusMessage {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            locked: boolean;
        }
    }

    /**
     * A type for representing D-Bus messages that can be sent or received
     * on a [class`Gio`.DBusConnection].
     */
    class DBusMessage extends GObject.Object {
        static $gtype: GObject.GType<DBusMessage>;

        // Properties

        get locked(): boolean;

        // Constructors

        constructor(properties?: Partial<DBusMessage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DBusMessage;

        static new_from_blob(blob: Uint8Array | string, capabilities: DBusCapabilityFlags): DBusMessage;

        static new_method_call(
            name: string | null,
            path: string,
            interface_: string | null,
            method: string,
        ): DBusMessage;

        static new_signal(path: string, interface_: string, signal: string): DBusMessage;

        // Static methods

        /**
         * Utility function to calculate how many bytes are needed to
         * completely deserialize the D-Bus message stored at `blob`.
         * @param blob A blob representing a binary D-Bus message.
         */
        static bytes_needed(blob: Uint8Array | string): number;

        // Methods

        /**
         * Copies `message`. The copy is a deep copy and the returned
         * #GDBusMessage is completely identical except that it is guaranteed
         * to not be locked.
         *
         * This operation can fail if e.g. `message` contains file descriptors
         * and the per-process or system-wide open files limit is reached.
         * @returns A new #GDBusMessage or %NULL if @error is set.     Free with g_object_unref().
         */
        copy(): DBusMessage;
        /**
         * Convenience to get the first item in the body of `message`.
         *
         * See [method`Gio`.DBusMessage.get_arg0_path] for returning object-path-typed
         * arg0 values.
         * @returns The string item or %NULL if the first item in the body of @message is not a string.
         */
        get_arg0(): string | null;
        /**
         * Convenience to get the first item in the body of `message`.
         *
         * See [method`Gio`.DBusMessage.get_arg0] for returning string-typed arg0 values.
         * @returns The object path item or `NULL` if the first item in the   body of @message is not an object path.
         */
        get_arg0_path(): string | null;
        /**
         * Gets the body of a message.
         * @returns A #GVariant or %NULL if the body is empty. Do not free, it is owned by @message.
         */
        get_body(): GLib.Variant | null;
        /**
         * Gets the byte order of `message`.
         * @returns The byte order.
         */
        get_byte_order(): DBusMessageByteOrder;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
         * @returns The value.
         */
        get_destination(): string | null;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
         * @returns The value.
         */
        get_error_name(): string | null;
        /**
         * Gets the flags for `message`.
         * @returns Flags that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).
         */
        get_flags(): DBusMessageFlags;
        /**
         * Gets a header field on `message`.
         *
         * The caller is responsible for checking the type of the returned #GVariant
         * matches what is expected.
         * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
         * @returns A #GVariant with the value if the header was found, %NULL otherwise. Do not free, it is owned by @message.
         */
        get_header(header_field: DBusMessageHeaderField): GLib.Variant | null;
        /**
         * Gets an array of all header fields on `message` that are set.
         * @returns An array of header fields terminated by %G_DBUS_MESSAGE_HEADER_FIELD_INVALID.  Each element is a #guchar. Free with g_free().
         */
        get_header_fields(): Uint8Array;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
         * @returns The value.
         */
        get_interface(): string | null;
        /**
         * Checks whether `message` is locked. To monitor changes to this
         * value, conncet to the #GObject::notify signal to listen for changes
         * on the #GDBusMessage:locked property.
         * @returns %TRUE if @message is locked, %FALSE otherwise.
         */
        get_locked(): boolean;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
         * @returns The value.
         */
        get_member(): string | null;
        /**
         * Gets the type of `message`.
         * @returns A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
         */
        get_message_type(): DBusMessageType;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
         * @returns The value.
         */
        get_num_unix_fds(): number;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
         * @returns The value.
         */
        get_path(): string | null;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
         * @returns The value.
         */
        get_reply_serial(): number;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
         * @returns The value.
         */
        get_sender(): string | null;
        /**
         * Gets the serial for `message`.
         * @returns A #guint32.
         */
        get_serial(): number;
        /**
         * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
         *
         * This will always be non-%NULL, but may be an empty string.
         * @returns The value.
         */
        get_signature(): string;
        /**
         * Gets the UNIX file descriptors associated with `message,` if any.
         *
         * This method is only available on UNIX.
         *
         * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
         * values in the body of the message. For example,
         * if g_variant_get_handle() returns 5, that is intended to be a reference
         * to the file descriptor that can be accessed by
         * `g_unix_fd_list_get (list, 5, ...)`.
         * @returns A #GUnixFDList or %NULL if no file descriptors are associated. Do not free, this object is owned by @message.
         */
        get_unix_fd_list(): UnixFDList | null;
        /**
         * If `message` is locked, does nothing. Otherwise locks the message.
         */
        lock(): void;
        /**
         * Creates a new #GDBusMessage that is an error reply to `method_call_message`.
         * @param error_name A valid D-Bus error name.
         * @param error_message The D-Bus error message.
         * @returns A #GDBusMessage. Free with g_object_unref().
         */
        new_method_error_literal(error_name: string, error_message: string): DBusMessage;
        /**
         * Creates a new #GDBusMessage that is a reply to `method_call_message`.
         * @returns #GDBusMessage. Free with g_object_unref().
         */
        new_method_reply(): DBusMessage;
        /**
         * Produces a human-readable multi-line description of `message`.
         *
         * The contents of the description has no ABI guarantees, the contents
         * and formatting is subject to change at any time. Typical output
         * looks something like this:
         * ```
         * Flags:   none
         * Version: 0
         * Serial:  4
         * Headers:
         *   path -> objectpath '/org/gtk/GDBus/TestObject'
         *   interface -> 'org.gtk.GDBus.TestInterface'
         *   member -> 'GimmeStdout'
         *   destination -> ':1.146'
         * Body: ()
         * UNIX File Descriptors:
         *   (none)
         * ```
         * or
         * ```
         * Flags:   no-reply-expected
         * Version: 0
         * Serial:  477
         * Headers:
         *   reply-serial -> uint32 4
         *   destination -> ':1.159'
         *   sender -> ':1.146'
         *   num-unix-fds -> uint32 1
         * Body: ()
         * UNIX File Descriptors:
         *   fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
         * ```
         * @param indent Indentation level.
         * @returns A string that should be freed with [func@GLib.free].
         */
        print(indent: number): string;
        /**
         * Sets the body `message`. As a side-effect the
         * %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
         * type string of `body` (or cleared if `body` is %NULL).
         *
         * If `body` is floating, `message` assumes ownership of `body`.
         * @param body Either %NULL or a #GVariant that is a tuple.
         */
        set_body(body: GLib.Variant): void;
        /**
         * Sets the byte order of `message`.
         * @param byte_order The byte order.
         */
        set_byte_order(byte_order: DBusMessageByteOrder): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
         * @param value The value to set.
         */
        set_destination(value?: string | null): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
         * @param value The value to set.
         */
        set_error_name(value: string): void;
        /**
         * Sets the flags to set on `message`.
         * @param flags Flags for @message that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).
         */
        set_flags(flags: DBusMessageFlags): void;
        /**
         * Sets a header field on `message`.
         *
         * If `value` is floating, `message` assumes ownership of `value`.
         * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
         * @param value A #GVariant to set the header field or %NULL to clear the header field.
         */
        set_header(header_field: DBusMessageHeaderField, value?: GLib.Variant | null): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
         * @param value The value to set.
         */
        set_interface(value?: string | null): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
         * @param value The value to set.
         */
        set_member(value?: string | null): void;
        /**
         * Sets `message` to be of `type`.
         * @param type A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
         */
        set_message_type(type: DBusMessageType): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
         * @param value The value to set.
         */
        set_num_unix_fds(value: number): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
         * @param value The value to set.
         */
        set_path(value?: string | null): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
         * @param value The value to set.
         */
        set_reply_serial(value: number): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
         * @param value The value to set.
         */
        set_sender(value?: string | null): void;
        /**
         * Sets the serial for `message`.
         * @param serial A #guint32.
         */
        set_serial(serial: number): void;
        /**
         * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
         * @param value The value to set.
         */
        set_signature(value?: string | null): void;
        /**
         * Sets the UNIX file descriptors associated with `message`. As a
         * side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
         * field is set to the number of fds in `fd_list` (or cleared if
         * `fd_list` is %NULL).
         *
         * This method is only available on UNIX.
         *
         * When designing D-Bus APIs that are intended to be interoperable,
         * please note that non-GDBus implementations of D-Bus can usually only
         * access file descriptors if they are referenced by a value of type
         * %G_VARIANT_TYPE_HANDLE in the body of the message.
         * @param fd_list A #GUnixFDList or %NULL.
         */
        set_unix_fd_list(fd_list?: UnixFDList | null): void;
        /**
         * Serializes `message` to a blob. The byte order returned by
         * g_dbus_message_get_byte_order() will be used.
         * @param capabilities A #GDBusCapabilityFlags describing what protocol features are supported.
         * @returns A pointer to a valid binary D-Bus message of @out_size bytes generated by @message or %NULL if @error is set. Free with g_free().
         */
        to_blob(capabilities: DBusCapabilityFlags): Uint8Array;
        /**
         * If `message` is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
         * nothing and returns %FALSE.
         *
         * Otherwise this method encodes the error in `message` as a #GError
         * using g_dbus_error_set_dbus_error() using the information in the
         * %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of `message` as
         * well as the first string item in `message'`s body.
         * @returns %TRUE if @error was set, %FALSE otherwise.
         */
        to_gerror(): boolean;
    }

    module DBusMethodInvocation {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * Instances of the `GDBusMethodInvocation` class are used when
     * handling D-Bus method calls. It provides a way to asynchronously
     * return results and errors.
     *
     * The normal way to obtain a `GDBusMethodInvocation` object is to receive
     * it as an argument to the `handle_method_call()` function in a
     * [type`Gio`.DBusInterfaceVTable] that was passed to
     * [method`Gio`.DBusConnection.register_object].
     */
    class DBusMethodInvocation extends GObject.Object {
        static $gtype: GObject.GType<DBusMethodInvocation>;

        // Constructors

        constructor(properties?: Partial<DBusMethodInvocation.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Gets the #GDBusConnection the method was invoked on.
         * @returns A #GDBusConnection. Do not free, it is owned by @invocation.
         */
        get_connection(): DBusConnection;
        /**
         * Gets the name of the D-Bus interface the method was invoked on.
         *
         * If this method call is a property Get, Set or GetAll call that has
         * been redirected to the method call handler then
         * "org.freedesktop.DBus.Properties" will be returned.  See
         * #GDBusInterfaceVTable for more information.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_interface_name(): string;
        /**
         * Gets the #GDBusMessage for the method invocation. This is useful if
         * you need to use low-level protocol features, such as UNIX file
         * descriptor passing, that cannot be properly expressed in the
         * #GVariant API.
         *
         * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
         * for an example of how to use this low-level API to send and receive
         * UNIX file descriptors.
         * @returns #GDBusMessage. Do not free, it is owned by @invocation.
         */
        get_message(): DBusMessage;
        /**
         * Gets information about the method call, if any.
         *
         * If this method invocation is a property Get, Set or GetAll call that
         * has been redirected to the method call handler then %NULL will be
         * returned.  See g_dbus_method_invocation_get_property_info() and
         * #GDBusInterfaceVTable for more information.
         * @returns A #GDBusMethodInfo or %NULL. Do not free, it is owned by @invocation.
         */
        get_method_info(): DBusMethodInfo | null;
        /**
         * Gets the name of the method that was invoked.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_method_name(): string;
        /**
         * Gets the object path the method was invoked on.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_object_path(): string;
        /**
         * Gets the parameters of the method invocation. If there are no input
         * parameters then this will return a GVariant with 0 children rather than NULL.
         * @returns A #GVariant tuple. Do not unref this because it is owned by @invocation.
         */
        get_parameters(): GLib.Variant;
        /**
         * Gets information about the property that this method call is for, if
         * any.
         *
         * This will only be set in the case of an invocation in response to a
         * property Get or Set call that has been directed to the method call
         * handler for an object on account of its property_get() or
         * property_set() vtable pointers being unset.
         *
         * See #GDBusInterfaceVTable for more information.
         *
         * If the call was GetAll, %NULL will be returned.
         * @returns a #GDBusPropertyInfo or %NULL
         */
        get_property_info(): DBusPropertyInfo | null;
        /**
         * Gets the bus name that invoked the method.
         * @returns A string. Do not free, it is owned by @invocation.
         */
        get_sender(): string;
        /**
         * Finishes handling a D-Bus method call by returning an error.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param error_name A valid D-Bus error name.
         * @param error_message A valid D-Bus error message.
         */
        return_dbus_error(error_name: string, error_message: string): void;
        /**
         * Like g_dbus_method_invocation_return_error() but without printf()-style formatting.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param domain A #GQuark for the #GError error domain.
         * @param code The error code.
         * @param message The error message.
         */
        return_error_literal(domain: GLib.Quark, code: number, message: string): void;
        /**
         * Like g_dbus_method_invocation_return_error() but takes a #GError
         * instead of the error domain, error code and message.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param error A #GError.
         */
        return_gerror(error: GLib.Error): void;
        /**
         * Finishes handling a D-Bus method call by returning `parameters`.
         * If the `parameters` GVariant is floating, it is consumed.
         *
         * It is an error if `parameters` is not of the right format: it must be a tuple
         * containing the out-parameters of the D-Bus method. Even if the method has a
         * single out-parameter, it must be contained in a tuple. If the method has no
         * out-parameters, `parameters` may be %NULL or an empty tuple.
         *
         *
         * ```c
         * GDBusMethodInvocation *invocation = some_invocation;
         * g_autofree gchar *result_string = NULL;
         * g_autoptr (GError) error = NULL;
         *
         * result_string = calculate_result (&error);
         *
         * if (error != NULL)
         *   g_dbus_method_invocation_return_gerror (invocation, error);
         * else
         *   g_dbus_method_invocation_return_value (invocation,
         *                                          g_variant_new ("(s)", result_string));
         *
         * // Do not free `invocation` here; returning a value does that
         * ```
         *
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         *
         * Since 2.48, if the method call requested for a reply not to be sent
         * then this call will sink `parameters` and free `invocation,` but
         * otherwise do nothing (as per the recommendations of the D-Bus
         * specification).
         * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
         */
        return_value(parameters?: GLib.Variant | null): void;
        /**
         * Like g_dbus_method_invocation_return_value() but also takes a #GUnixFDList.
         *
         * This method is only available on UNIX.
         *
         * This method will take ownership of `invocation`. See
         * #GDBusInterfaceVTable for more information about the ownership of
         * `invocation`.
         * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
         * @param fd_list A #GUnixFDList or %NULL.
         */
        return_value_with_unix_fd_list(parameters?: GLib.Variant | null, fd_list?: UnixFDList | null): void;
    }

    module DBusObjectManagerClient {
        // Signal callback interfaces

        interface InterfaceProxyPropertiesChanged {
            (
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                changed_properties: GLib.Variant,
                invalidated_properties: string[],
            ): void;
        }

        interface InterfaceProxySignal {
            (
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                sender_name: string,
                signal_name: string,
                parameters: GLib.Variant,
            ): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                AsyncInitable.ConstructorProps,
                DBusObjectManager.ConstructorProps,
                Initable.ConstructorProps {
            bus_type: BusType;
            busType: BusType;
            connection: DBusConnection;
            flags: DBusObjectManagerClientFlags;
            get_proxy_type_destroy_notify: any;
            getProxyTypeDestroyNotify: any;
            get_proxy_type_func: any;
            getProxyTypeFunc: any;
            get_proxy_type_user_data: any;
            getProxyTypeUserData: any;
            name: string;
            name_owner: string;
            nameOwner: string;
            object_path: string;
            objectPath: string;
        }
    }

    /**
     * `GDBusObjectManagerClient` is used to create, monitor and delete object
     * proxies for remote objects exported by a [class`Gio`.DBusObjectManagerServer]
     * (or any code implementing the
     * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
     * interface).
     *
     * Once an instance of this type has been created, you can connect to
     * the [signal`Gio`.DBusObjectManager::object-added] and
     * [signal`Gio`.DBusObjectManager::object-removed signals] and inspect the
     * [class`Gio`.DBusObjectProxy] objects returned by
     * [method`Gio`.DBusObjectManager.get_objects].
     *
     * If the name for a `GDBusObjectManagerClient` is not owned by anyone at
     * object construction time, the default behavior is to request the
     * message bus to launch an owner for the name. This behavior can be
     * disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
     * flag. Its also worth noting that this only works if the name of
     * interest is activatable in the first place. E.g. in some cases it
     * is not possible to launch an owner for the requested name. In this
     * case, `GDBusObjectManagerClient` object construction still succeeds but
     * there will be no object proxies
     * (e.g. [method`Gio`.DBusObjectManager.get_objects] returns the empty list) and
     * the [property`Gio`.DBusObjectManagerClient:name-owner] property is `NULL`.
     *
     * The owner of the requested name can come and go (for example
     * consider a system service being restarted)  `GDBusObjectManagerClient`
     * handles this case too; simply connect to the [signal`GObject`.Object::notify]
     * signal to watch for changes on the
     * [property`Gio`.DBusObjectManagerClient:name-owner] property. When the name
     * owner vanishes, the behavior is that
     * [property`Gio`.DBusObjectManagerClient:name-owner] is set to `NULL` (this
     * includes emission of the [signal`GObject`.Object::notify] signal) and then
     * [signal`Gio`.DBusObjectManager::object-removed] signals are synthesized
     * for all currently existing object proxies. Since
     * [property`Gio`.DBusObjectManagerClient:name-owner] is `NULL` when this
     * happens, you can use this information to disambiguate a synthesized signal
     * from a genuine signal caused by object removal on the remote
     * [iface`Gio`.DBusObjectManager]. Similarly, when a new name owner appears,
     * [signal`Gio`.DBusObjectManager::object-added] signals are synthesized
     * while [property`Gio`.DBusObjectManagerClient:name-owner] is still `NULL`. Only
     * when all object proxies have been added, the
     * [property`Gio`.DBusObjectManagerClient:name-owner] is set to the new name
     * owner (this includes emission of the [signal`GObject`.Object::notify] signal).
     * Furthermore, you are guaranteed that
     * [property`Gio`.DBusObjectManagerClient:name-owner] will alternate between a
     * name owner (e.g. `:1.42`) and `NULL` even in the case where
     * the name of interest is atomically replaced
     *
     * Ultimately, `GDBusObjectManagerClient` is used to obtain
     * [class`Gio`.DBusProxy] instances. All signals (including the
     * `org.freedesktop.DBus.Properties::PropertiesChanged` signal)
     * delivered to [class`Gio`.DBusProxy] instances are guaranteed to originate
     * from the name owner. This guarantee along with the behavior
     * described above, means that certain race conditions including the
     * half the proxy is from the old owner and the other half is from
     * the new owner problem cannot happen.
     *
     * To avoid having the application connect to signals on the returned
     * [class`Gio`.DBusObjectProxy] and [class`Gio`.DBusProxy] objects, the
     * [signal`Gio`.DBusObject::interface-added],
     * [signal`Gio`.DBusObject::interface-removed],
     * [signal`Gio`.DBusProxy::g-properties-changed] and
     * [signal`Gio`.DBusProxy::g-signal] signals
     * are also emitted on the `GDBusObjectManagerClient` instance managing these
     * objects. The signals emitted are
     * [signal`Gio`.DBusObjectManager::interface-added],
     * [signal`Gio`.DBusObjectManager::interface-removed],
     * [signal`Gio`.DBusObjectManagerClient::interface-proxy-properties-changed] and
     * [signal`Gio`.DBusObjectManagerClient::interface-proxy-signal].
     *
     * Note that all callbacks and signals are emitted in the
     * thread-default main context (see
     * [method`GLib`.MainContext.push_thread_default]) that the
     * `GDBusObjectManagerClient` object was constructed in. Additionally, the
     * [class`Gio`.DBusObjectProxy] and [class`Gio`.DBusProxy] objects
     * originating from the `GDBusObjectManagerClient` object will be created in
     * the same context and, consequently, will deliver signals in the
     * same main loop.
     */
    class DBusObjectManagerClient
        extends GObject.Object
        implements AsyncInitable<DBusObjectManagerClient>, DBusObjectManager, Initable
    {
        static $gtype: GObject.GType<DBusObjectManagerClient>;

        // Properties

        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusObjectManagerClient:connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        set bus_type(val: BusType);
        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusObjectManagerClient:connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        set busType(val: BusType);
        /**
         * The #GDBusConnection to use.
         */
        get connection(): DBusConnection;
        /**
         * Flags from the #GDBusObjectManagerClientFlags enumeration.
         */
        get flags(): DBusObjectManagerClientFlags;
        /**
         * A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
         */
        get get_proxy_type_destroy_notify(): any;
        /**
         * A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
         */
        get getProxyTypeDestroyNotify(): any;
        /**
         * The #GDBusProxyTypeFunc to use when determining what #GType to
         * use for interface proxies or %NULL.
         */
        get get_proxy_type_func(): any;
        /**
         * The #GDBusProxyTypeFunc to use when determining what #GType to
         * use for interface proxies or %NULL.
         */
        get getProxyTypeFunc(): any;
        /**
         * The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
         */
        get get_proxy_type_user_data(): any;
        /**
         * The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
         */
        get getProxyTypeUserData(): any;
        /**
         * The well-known name or unique name that the manager is for.
         */
        get name(): string;
        /**
         * The unique name that owns #GDBusObjectManagerClient:name or %NULL if
         * no-one is currently owning the name. Connect to the
         * #GObject::notify signal to track changes to this property.
         */
        get name_owner(): string;
        /**
         * The unique name that owns #GDBusObjectManagerClient:name or %NULL if
         * no-one is currently owning the name. Connect to the
         * #GObject::notify signal to track changes to this property.
         */
        get nameOwner(): string;
        /**
         * The object path the manager is for.
         */
        get object_path(): string;
        /**
         * The object path the manager is for.
         */
        get objectPath(): string;

        // Constructors

        constructor(properties?: Partial<DBusObjectManagerClient.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_finish(res: AsyncResult): DBusObjectManagerClient;
        // Conflicted with Gio.AsyncInitable.new_finish

        static new_finish(...args: never[]): any;

        static new_for_bus_finish(res: AsyncResult): DBusObjectManagerClient;

        static new_for_bus_sync(
            bus_type: BusType,
            flags: DBusObjectManagerClientFlags,
            name: string,
            object_path: string,
            get_proxy_type_func?: DBusProxyTypeFunc | null,
            get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
            cancellable?: Cancellable | null,
        ): DBusObjectManagerClient;

        static new_sync(
            connection: DBusConnection,
            flags: DBusObjectManagerClientFlags,
            name: string | null,
            object_path: string,
            get_proxy_type_func?: DBusProxyTypeFunc | null,
            get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
            cancellable?: Cancellable | null,
        ): DBusObjectManagerClient;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'interface-proxy-properties-changed',
            callback: (
                _source: this,
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                changed_properties: GLib.Variant,
                invalidated_properties: string[],
            ) => void,
        ): number;
        connect_after(
            signal: 'interface-proxy-properties-changed',
            callback: (
                _source: this,
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                changed_properties: GLib.Variant,
                invalidated_properties: string[],
            ) => void,
        ): number;
        emit(
            signal: 'interface-proxy-properties-changed',
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            changed_properties: GLib.Variant,
            invalidated_properties: string[],
        ): void;
        connect(
            signal: 'interface-proxy-signal',
            callback: (
                _source: this,
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                sender_name: string,
                signal_name: string,
                parameters: GLib.Variant,
            ) => void,
        ): number;
        connect_after(
            signal: 'interface-proxy-signal',
            callback: (
                _source: this,
                object_proxy: DBusObjectProxy,
                interface_proxy: DBusProxy,
                sender_name: string,
                signal_name: string,
                parameters: GLib.Variant,
            ) => void,
        ): number;
        emit(
            signal: 'interface-proxy-signal',
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            sender_name: string,
            signal_name: string,
            parameters: GLib.Variant,
        ): void;

        // Static methods

        /**
         * Asynchronously creates a new #GDBusObjectManagerClient object.
         *
         * This is an asynchronous failable constructor. When the result is
         * ready, `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_object_manager_client_new_finish() to get the result. See
         * g_dbus_object_manager_client_new_sync() for the synchronous version.
         * @param connection A #GDBusConnection.
         * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
         * @param name The owner of the control object (unique or well-known name).
         * @param object_path The object path of the control object.
         * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
         * @param get_proxy_type_destroy_notify Free function for @get_proxy_type_user_data or %NULL.
         * @param cancellable A #GCancellable or %NULL
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
         */
        static ['new'](
            connection: DBusConnection,
            flags: DBusObjectManagerClientFlags,
            name: string,
            object_path: string,
            get_proxy_type_func?: DBusProxyTypeFunc | null,
            get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<DBusObjectManagerClient> | null,
        ): void;
        /**
         * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
         * #GDBusConnection.
         *
         * This is an asynchronous failable constructor. When the result is
         * ready, `callback` will be invoked in the
         * [thread-default main loop][g-main-context-push-thread-default]
         * of the thread you are calling this method from. You can
         * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
         * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
         * @param bus_type A #GBusType.
         * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
         * @param name The owner of the control object (unique or well-known name).
         * @param object_path The object path of the control object.
         * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
         * @param get_proxy_type_destroy_notify Free function for @get_proxy_type_user_data or %NULL.
         * @param cancellable A #GCancellable or %NULL
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
         */
        static new_for_bus(
            bus_type: BusType,
            flags: DBusObjectManagerClientFlags,
            name: string,
            object_path: string,
            get_proxy_type_func?: DBusProxyTypeFunc | null,
            get_proxy_type_destroy_notify?: GLib.DestroyNotify | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<DBusObjectManagerClient> | null,
        ): void;

        // Virtual methods

        /**
         * Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.
         * @param object_proxy
         * @param interface_proxy
         * @param changed_properties
         * @param invalidated_properties
         */
        vfunc_interface_proxy_properties_changed(
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            changed_properties: GLib.Variant,
            invalidated_properties: string,
        ): void;
        /**
         * Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.
         * @param object_proxy
         * @param interface_proxy
         * @param sender_name
         * @param signal_name
         * @param parameters
         */
        vfunc_interface_proxy_signal(
            object_proxy: DBusObjectProxy,
            interface_proxy: DBusProxy,
            sender_name: string,
            signal_name: string,
            parameters: GLib.Variant,
        ): void;

        // Methods

        /**
         * Gets the #GDBusConnection used by `manager`.
         * @returns A #GDBusConnection object. Do not free,   the object belongs to @manager.
         */
        get_connection(): DBusConnection;
        /**
         * Gets the flags that `manager` was constructed with.
         * @returns Zero of more flags from the #GDBusObjectManagerClientFlags enumeration.
         */
        get_flags(): DBusObjectManagerClientFlags;
        /**
         * Gets the name that `manager` is for, or %NULL if not a message bus
         * connection.
         * @returns A unique or well-known name. Do not free, the string belongs to @manager.
         */
        get_name(): string;
        /**
         * The unique name that owns the name that `manager` is for or %NULL if
         * no-one currently owns that name. You can connect to the
         * #GObject::notify signal to track changes to the
         * #GDBusObjectManagerClient:name-owner property.
         * @returns The name owner or %NULL if no name owner exists. Free with g_free().
         */
        get_name_owner(): string | null;

        // Inherited methods
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        init_finish(res: AsyncResult): boolean;
        /**
         * Finishes the async construction for the various g_async_initable_new
         * calls, returning the created object or %NULL on error.
         * @param res the #GAsyncResult from the callback
         * @returns a newly created #GObject,      or %NULL on error. Free with g_object_unref().
         */
        new_finish(res: AsyncResult): DBusObjectManagerClient;
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        vfunc_init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         */
        vfunc_init_finish(res: AsyncResult): boolean;
        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         * @returns A #GDBusInterface instance or %NULL. Free   with g_object_unref().
         */
        get_interface(object_path: string, interface_name: string): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @param object_path Object path to look up.
         * @returns A #GDBusObject or %NULL. Free with   g_object_unref().
         */
        get_object(object_path: string): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         * @returns A string owned by @manager. Do not free.
         */
        get_object_path(): string;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         * @returns A list of   #GDBusObject objects. The returned list should be freed with   g_list_free() after each element has been freed with   g_object_unref().
         */
        get_objects(): DBusObject[];
        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         */
        vfunc_get_interface(object_path: string, interface_name: string): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @param object_path Object path to look up.
         */
        vfunc_get_object(object_path: string): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         */
        vfunc_get_object_path(): string;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         */
        vfunc_get_objects(): DBusObject[];
        /**
         * Signal handler for the #GDBusObjectManager::interface-added signal.
         * @param object
         * @param interface_
         */
        vfunc_interface_added(object: DBusObject, interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObjectManager::interface-removed signal.
         * @param object
         * @param interface_
         */
        vfunc_interface_removed(object: DBusObject, interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObjectManager::object-added signal.
         * @param object
         */
        vfunc_object_added(object: DBusObject): void;
        /**
         * Signal handler for the #GDBusObjectManager::object-removed signal.
         * @param object
         */
        vfunc_object_removed(object: DBusObject): void;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusObjectManagerServer {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DBusObjectManager.ConstructorProps {
            connection: DBusConnection;
            object_path: string;
            objectPath: string;
        }
    }

    /**
     * `GDBusObjectManagerServer` is used to export [iface`Gio`.DBusObject] instances
     * using the standardized
     * [`org.freedesktop.DBus.ObjectManager`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
     * interface. For example, remote D-Bus clients can get all objects
     * and properties in a single call. Additionally, any change in the
     * object hierarchy is broadcast using signals. This means that D-Bus
     * clients can keep caches up to date by only listening to D-Bus
     * signals.
     *
     * The recommended path to export an object manager at is the path form of the
     * well-known name of a D-Bus service, or below. For example, if a D-Bus service
     * is available at the well-known name `net.example.ExampleService1`, the object
     * manager should typically be exported at `/net/example/ExampleService1`, or
     * below (to allow for multiple object managers in a service).
     *
     * It is supported, but not recommended, to export an object manager at the root
     * path, `/`.
     *
     * See [class`Gio`.DBusObjectManagerClient] for the client-side code that is
     * intended to be used with `GDBusObjectManagerServer` or any D-Bus
     * object implementing the `org.freedesktop.DBus.ObjectManager` interface.
     */
    class DBusObjectManagerServer extends GObject.Object implements DBusObjectManager {
        static $gtype: GObject.GType<DBusObjectManagerServer>;

        // Properties

        /**
         * The #GDBusConnection to export objects on.
         */
        get connection(): DBusConnection;
        set connection(val: DBusConnection);
        /**
         * The object path to register the manager object at.
         */
        get object_path(): string;
        /**
         * The object path to register the manager object at.
         */
        get objectPath(): string;

        // Constructors

        constructor(properties?: Partial<DBusObjectManagerServer.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](object_path: string): DBusObjectManagerServer;

        // Methods

        /**
         * Exports `object` on `manager`.
         *
         * If there is already a #GDBusObject exported at the object path,
         * then the old object is removed.
         *
         * The object path for `object` must be in the hierarchy rooted by the
         * object path for `manager`.
         *
         * Note that `manager` will take a reference on `object` for as long as
         * it is exported.
         * @param object A #GDBusObjectSkeleton.
         */
        ['export'](object: DBusObjectSkeleton): void;
        /**
         * Like g_dbus_object_manager_server_export() but appends a string of
         * the form _N (with N being a natural number) to `object'`s object path
         * if an object with the given path already exists. As such, the
         * #GDBusObjectProxy:g-object-path property of `object` may be modified.
         * @param object An object.
         */
        export_uniquely(object: DBusObjectSkeleton): void;
        /**
         * Gets the #GDBusConnection used by `manager`.
         * @returns A #GDBusConnection object or %NULL if   @manager isn't exported on a connection. The returned object should   be freed with g_object_unref().
         */
        get_connection(): DBusConnection | null;
        /**
         * Returns whether `object` is currently exported on `manager`.
         * @param object An object.
         * @returns %TRUE if @object is exported
         */
        is_exported(object: DBusObjectSkeleton): boolean;
        /**
         * Exports all objects managed by `manager` on `connection`. If
         * `connection` is %NULL, stops exporting objects.
         * @param connection A #GDBusConnection or %NULL.
         */
        set_connection(connection?: DBusConnection | null): void;
        /**
         * If `manager` has an object at `path,` removes the object. Otherwise
         * does nothing.
         *
         * Note that `object_path` must be in the hierarchy rooted by the
         * object path for `manager`.
         * @param object_path An object path.
         * @returns %TRUE if object at @object_path was removed, %FALSE otherwise.
         */
        unexport(object_path: string): boolean;

        // Inherited methods
        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         * @returns A #GDBusInterface instance or %NULL. Free   with g_object_unref().
         */
        get_interface(object_path: string, interface_name: string): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @param object_path Object path to look up.
         * @returns A #GDBusObject or %NULL. Free with   g_object_unref().
         */
        get_object(object_path: string): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         * @returns A string owned by @manager. Do not free.
         */
        get_object_path(): string;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         * @returns A list of   #GDBusObject objects. The returned list should be freed with   g_list_free() after each element has been freed with   g_object_unref().
         */
        get_objects(): DBusObject[];
        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         */
        vfunc_get_interface(object_path: string, interface_name: string): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @param object_path Object path to look up.
         */
        vfunc_get_object(object_path: string): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         */
        vfunc_get_object_path(): string;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         */
        vfunc_get_objects(): DBusObject[];
        /**
         * Signal handler for the #GDBusObjectManager::interface-added signal.
         * @param object
         * @param interface_
         */
        vfunc_interface_added(object: DBusObject, interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObjectManager::interface-removed signal.
         * @param object
         * @param interface_
         */
        vfunc_interface_removed(object: DBusObject, interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObjectManager::object-added signal.
         * @param object
         */
        vfunc_object_added(object: DBusObject): void;
        /**
         * Signal handler for the #GDBusObjectManager::object-removed signal.
         * @param object
         */
        vfunc_object_removed(object: DBusObject): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusObjectProxy {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DBusObject.ConstructorProps {
            g_connection: DBusConnection;
            gConnection: DBusConnection;
            g_object_path: string;
            gObjectPath: string;
        }
    }

    /**
     * A `GDBusObjectProxy` is an object used to represent a remote object
     * with one or more D-Bus interfaces. Normally, you dont instantiate
     * a `GDBusObjectProxy` yourself  typically [class`Gio`.DBusObjectManagerClient]
     * is used to obtain it.
     */
    class DBusObjectProxy extends GObject.Object implements DBusObject {
        static $gtype: GObject.GType<DBusObjectProxy>;

        // Properties

        /**
         * The connection of the proxy.
         */
        get g_connection(): DBusConnection;
        /**
         * The connection of the proxy.
         */
        get gConnection(): DBusConnection;
        /**
         * The object path of the proxy.
         */
        get g_object_path(): string;
        /**
         * The object path of the proxy.
         */
        get gObjectPath(): string;

        // Constructors

        constructor(properties?: Partial<DBusObjectProxy.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](connection: DBusConnection, object_path: string): DBusObjectProxy;

        // Methods

        /**
         * Gets the connection that `proxy` is for.
         * @returns A #GDBusConnection. Do not free, the   object is owned by @proxy.
         */
        get_connection(): DBusConnection;

        // Inherited methods
        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @param interface_name A D-Bus interface name.
         * @returns %NULL if not found, otherwise a   #GDBusInterface that must be freed with g_object_unref().
         */
        get_interface(interface_name: string): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         * @returns A list of #GDBusInterface instances.   The returned list must be freed by g_list_free() after each element has been freed   with g_object_unref().
         */
        get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         * @returns A string owned by @object. Do not free.
         */
        get_object_path(): string;
        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @param interface_name A D-Bus interface name.
         */
        vfunc_get_interface(interface_name: string): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         */
        vfunc_get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         */
        vfunc_get_object_path(): string;
        /**
         * Signal handler for the #GDBusObject::interface-added signal.
         * @param interface_
         */
        vfunc_interface_added(interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObject::interface-removed signal.
         * @param interface_
         */
        vfunc_interface_removed(interface_: DBusInterface): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusObjectSkeleton {
        // Signal callback interfaces

        interface AuthorizeMethod {
            (_interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DBusObject.ConstructorProps {
            g_object_path: string;
            gObjectPath: string;
        }
    }

    /**
     * A `GDBusObjectSkeleton` instance is essentially a group of D-Bus
     * interfaces. The set of exported interfaces on the object may be
     * dynamic and change at runtime.
     *
     * This type is intended to be used with [iface`Gio`.DBusObjectManager].
     */
    class DBusObjectSkeleton extends GObject.Object implements DBusObject {
        static $gtype: GObject.GType<DBusObjectSkeleton>;

        // Properties

        /**
         * The object path where the object is exported.
         */
        get g_object_path(): string;
        set g_object_path(val: string);
        /**
         * The object path where the object is exported.
         */
        get gObjectPath(): string;
        set gObjectPath(val: string);

        // Constructors

        constructor(properties?: Partial<DBusObjectSkeleton.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](object_path: string): DBusObjectSkeleton;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'authorize-method',
            callback: (_source: this, _interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation) => boolean,
        ): number;
        connect_after(
            signal: 'authorize-method',
            callback: (_source: this, _interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation) => boolean,
        ): number;
        emit(signal: 'authorize-method', _interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): void;

        // Virtual methods

        /**
         * Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.
         * @param interface_
         * @param invocation
         */
        vfunc_authorize_method(interface_: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): boolean;

        // Methods

        /**
         * Adds `interface_` to `object`.
         *
         * If `object` already contains a #GDBusInterfaceSkeleton with the same
         * interface name, it is removed before `interface_` is added.
         *
         * Note that `object` takes its own reference on `interface_` and holds
         * it until removed.
         * @param interface_ A #GDBusInterfaceSkeleton.
         */
        add_interface(interface_: DBusInterfaceSkeleton): void;
        /**
         * This method simply calls g_dbus_interface_skeleton_flush() on all
         * interfaces belonging to `object`. See that method for when flushing
         * is useful.
         */
        flush(): void;
        /**
         * Removes `interface_` from `object`.
         * @param interface_ A #GDBusInterfaceSkeleton.
         */
        remove_interface(interface_: DBusInterfaceSkeleton): void;
        /**
         * Removes the #GDBusInterface with `interface_name` from `object`.
         *
         * If no D-Bus interface of the given interface exists, this function
         * does nothing.
         * @param interface_name A D-Bus interface name.
         */
        remove_interface_by_name(interface_name: string): void;
        /**
         * Sets the object path for `object`.
         * @param object_path A valid D-Bus object path.
         */
        set_object_path(object_path: string): void;

        // Inherited methods
        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @param interface_name A D-Bus interface name.
         * @returns %NULL if not found, otherwise a   #GDBusInterface that must be freed with g_object_unref().
         */
        get_interface(interface_name: string): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         * @returns A list of #GDBusInterface instances.   The returned list must be freed by g_list_free() after each element has been freed   with g_object_unref().
         */
        get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         * @returns A string owned by @object. Do not free.
         */
        get_object_path(): string;
        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @param interface_name A D-Bus interface name.
         */
        vfunc_get_interface(interface_name: string): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         */
        vfunc_get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         */
        vfunc_get_object_path(): string;
        /**
         * Signal handler for the #GDBusObject::interface-added signal.
         * @param interface_
         */
        vfunc_interface_added(interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObject::interface-removed signal.
         * @param interface_
         */
        vfunc_interface_removed(interface_: DBusInterface): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusProxy {
        // Signal callback interfaces

        interface GPropertiesChanged {
            (changed_properties: GLib.Variant, invalidated_properties: string[]): void;
        }

        interface GSignal {
            (sender_name: string | null, signal_name: string, parameters: GLib.Variant): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                AsyncInitable.ConstructorProps,
                DBusInterface.ConstructorProps,
                Initable.ConstructorProps {
            g_bus_type: BusType;
            gBusType: BusType;
            g_connection: DBusConnection;
            gConnection: DBusConnection;
            g_default_timeout: number;
            gDefaultTimeout: number;
            g_flags: DBusProxyFlags;
            gFlags: DBusProxyFlags;
            g_interface_info: DBusInterfaceInfo;
            gInterfaceInfo: DBusInterfaceInfo;
            g_interface_name: string;
            gInterfaceName: string;
            g_name: string;
            gName: string;
            g_name_owner: string;
            gNameOwner: string;
            g_object_path: string;
            gObjectPath: string;
        }
    }

    /**
     * `GDBusProxy` is a base class used for proxies to access a D-Bus
     * interface on a remote object. A `GDBusProxy` can be constructed for
     * both well-known and unique names.
     *
     * By default, `GDBusProxy` will cache all properties (and listen to
     * changes) of the remote object, and proxy all signals that get
     * emitted. This behaviour can be changed by passing suitable
     * [flags`Gio`.DBusProxyFlags] when the proxy is created. If the proxy is for a
     * well-known name, the property cache is flushed when the name owner
     * vanishes and reloaded when a name owner appears.
     *
     * The unique name owner of the proxys name is tracked and can be read from
     * [property`Gio`.DBusProxy:g-name-owner]. Connect to the
     * [signal`GObject`.Object::notify] signal to get notified of changes.
     * Additionally, only signals and property changes emitted from the current name
     * owner are considered and calls are always sent to the current name owner.
     * This avoids a number of race conditions when the name is lost by one owner
     * and claimed by another. However, if no name owner currently exists,
     * then calls will be sent to the well-known name which may result in
     * the message bus launching an owner (unless
     * `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` is set).
     *
     * If the proxy is for a stateless D-Bus service, where the name owner may
     * be started and stopped between calls, the
     * [property`Gio`.DBusProxy:g-name-owner] tracking of `GDBusProxy` will cause the
     * proxy to drop signal and property changes from the service after it has
     * restarted for the first time. When interacting with a stateless D-Bus
     * service, do not use `GDBusProxy`  use direct D-Bus method calls and signal
     * connections.
     *
     * The generic [signal`Gio`.DBusProxy::g-properties-changed] and
     * [signal`Gio`.DBusProxy::g-signal] signals are not very convenient to work
     * with. Therefore, the recommended way of working with proxies is to subclass
     * `GDBusProxy`, and have more natural properties and signals in your derived
     * class. This [example](migrating-gdbus.html#using-gdbus-codegen) shows how
     * this can easily be done using the [`gdbus-codegen`](gdbus-codegen.html) tool.
     *
     * A `GDBusProxy` instance can be used from multiple threads but note
     * that all signals (e.g. [signal`Gio`.DBusProxy::g-signal],
     * [signal`Gio`.DBusProxy::g-properties-changed] and
     * [signal`GObject`.Object::notify]) are emitted in the thread-default main
     * context (see [method`GLib`.MainContext.push_thread_default]) of the thread
     * where the instance was constructed.
     *
     * An example using a proxy for a well-known name can be found in
     * [`gdbus-example-watch-proxy.c`](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c).
     */
    class DBusProxy extends GObject.Object implements AsyncInitable<DBusProxy>, DBusInterface, Initable {
        static $gtype: GObject.GType<DBusProxy>;

        [key: string]: any;

        // Properties

        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusProxy:g-connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        set g_bus_type(val: BusType);
        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusProxy:g-connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        set gBusType(val: BusType);
        /**
         * The #GDBusConnection the proxy is for.
         */
        get g_connection(): DBusConnection;
        /**
         * The #GDBusConnection the proxy is for.
         */
        get gConnection(): DBusConnection;
        /**
         * The timeout to use if -1 (specifying default timeout) is passed
         * as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         *
         * This allows applications to set a proxy-wide timeout for all
         * remote method invocations on the proxy. If this property is -1,
         * the default timeout (typically 25 seconds) is used. If set to
         * %G_MAXINT, then no timeout is used.
         */
        get g_default_timeout(): number;
        set g_default_timeout(val: number);
        /**
         * The timeout to use if -1 (specifying default timeout) is passed
         * as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         *
         * This allows applications to set a proxy-wide timeout for all
         * remote method invocations on the proxy. If this property is -1,
         * the default timeout (typically 25 seconds) is used. If set to
         * %G_MAXINT, then no timeout is used.
         */
        get gDefaultTimeout(): number;
        set gDefaultTimeout(val: number);
        /**
         * Flags from the #GDBusProxyFlags enumeration.
         */
        get g_flags(): DBusProxyFlags;
        /**
         * Flags from the #GDBusProxyFlags enumeration.
         */
        get gFlags(): DBusProxyFlags;
        /**
         * Ensure that interactions with this proxy conform to the given
         * interface. This is mainly to ensure that malformed data received
         * from the other peer is ignored. The given #GDBusInterfaceInfo is
         * said to be the "expected interface".
         *
         * The checks performed are:
         * - When completing a method call, if the type signature of
         *   the reply message isn't what's expected, the reply is
         *   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * - Received signals that have a type signature mismatch are dropped and
         *   a warning is logged via g_warning().
         *
         * - Properties received via the initial `GetAll()` call or via the
         *   `::PropertiesChanged` signal (on the
         *   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
         *   interface) or set using g_dbus_proxy_set_cached_property()
         *   with a type signature mismatch are ignored and a warning is
         *   logged via g_warning().
         *
         * Note that these checks are never done on methods, signals and
         * properties that are not referenced in the given
         * #GDBusInterfaceInfo, since extending a D-Bus interface on the
         * service-side is not considered an ABI break.
         */
        get g_interface_info(): DBusInterfaceInfo;
        set g_interface_info(val: DBusInterfaceInfo);
        /**
         * Ensure that interactions with this proxy conform to the given
         * interface. This is mainly to ensure that malformed data received
         * from the other peer is ignored. The given #GDBusInterfaceInfo is
         * said to be the "expected interface".
         *
         * The checks performed are:
         * - When completing a method call, if the type signature of
         *   the reply message isn't what's expected, the reply is
         *   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * - Received signals that have a type signature mismatch are dropped and
         *   a warning is logged via g_warning().
         *
         * - Properties received via the initial `GetAll()` call or via the
         *   `::PropertiesChanged` signal (on the
         *   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
         *   interface) or set using g_dbus_proxy_set_cached_property()
         *   with a type signature mismatch are ignored and a warning is
         *   logged via g_warning().
         *
         * Note that these checks are never done on methods, signals and
         * properties that are not referenced in the given
         * #GDBusInterfaceInfo, since extending a D-Bus interface on the
         * service-side is not considered an ABI break.
         */
        get gInterfaceInfo(): DBusInterfaceInfo;
        set gInterfaceInfo(val: DBusInterfaceInfo);
        /**
         * The D-Bus interface name the proxy is for.
         */
        get g_interface_name(): string;
        /**
         * The D-Bus interface name the proxy is for.
         */
        get gInterfaceName(): string;
        /**
         * The well-known or unique name that the proxy is for.
         */
        get g_name(): string;
        /**
         * The well-known or unique name that the proxy is for.
         */
        get gName(): string;
        /**
         * The unique name that owns #GDBusProxy:g-name or %NULL if no-one
         * currently owns that name. You may connect to #GObject::notify signal to
         * track changes to this property.
         */
        get g_name_owner(): string;
        /**
         * The unique name that owns #GDBusProxy:g-name or %NULL if no-one
         * currently owns that name. You may connect to #GObject::notify signal to
         * track changes to this property.
         */
        get gNameOwner(): string;
        /**
         * The object path the proxy is for.
         */
        get g_object_path(): string;
        /**
         * The object path the proxy is for.
         */
        get gObjectPath(): string;

        // Constructors

        constructor(properties?: Partial<DBusProxy.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_finish(res: AsyncResult): DBusProxy;
        // Conflicted with Gio.AsyncInitable.new_finish

        static new_finish(...args: never[]): any;

        static new_for_bus_finish(res: AsyncResult): DBusProxy;

        static new_for_bus_sync(
            bus_type: BusType,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string,
            object_path: string,
            interface_name: string,
            cancellable?: Cancellable | null,
        ): DBusProxy;

        static new_sync(
            connection: DBusConnection,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string | null,
            object_path: string,
            interface_name: string,
            cancellable?: Cancellable | null,
        ): DBusProxy;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'g-properties-changed',
            callback: (_source: this, changed_properties: GLib.Variant, invalidated_properties: string[]) => void,
        ): number;
        connect_after(
            signal: 'g-properties-changed',
            callback: (_source: this, changed_properties: GLib.Variant, invalidated_properties: string[]) => void,
        ): number;
        emit(signal: 'g-properties-changed', changed_properties: GLib.Variant, invalidated_properties: string[]): void;
        connect(
            signal: 'g-signal',
            callback: (
                _source: this,
                sender_name: string | null,
                signal_name: string,
                parameters: GLib.Variant,
            ) => void,
        ): number;
        connect_after(
            signal: 'g-signal',
            callback: (
                _source: this,
                sender_name: string | null,
                signal_name: string,
                parameters: GLib.Variant,
            ) => void,
        ): number;
        emit(signal: 'g-signal', sender_name: string | null, signal_name: string, parameters: GLib.Variant): void;

        // Static methods

        /**
         * Creates a proxy for accessing `interface_name` on the remote object
         * at `object_path` owned by `name` at `connection` and asynchronously
         * loads D-Bus properties unless the
         * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
         * the #GDBusProxy::g-properties-changed signal to get notified about
         * property changes.
         *
         * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
         * match rules for signals. Connect to the #GDBusProxy::g-signal signal
         * to handle signals from the remote object.
         *
         * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
         * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
         * guaranteed to complete immediately without blocking.
         *
         * If `name` is a well-known name and the
         * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
         * flags aren't set and no name owner currently exists, the message bus
         * will be requested to launch a name owner for the name.
         *
         * This is a failable asynchronous constructor - when the proxy is
         * ready, `callback` will be invoked and you can use
         * g_dbus_proxy_new_finish() to get the result.
         *
         * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
         *
         * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
         * @param connection A #GDBusConnection.
         * @param flags Flags used when constructing the proxy.
         * @param info A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.
         * @param name A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
         * @param object_path An object path.
         * @param interface_name A D-Bus interface name.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback Callback function to invoke when the proxy is ready.
         */
        static ['new'](
            connection: DBusConnection,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string | null,
            object_path: string,
            interface_name: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<DBusProxy> | null,
        ): void;
        /**
         * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
         *
         * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
         * @param bus_type A #GBusType.
         * @param flags Flags used when constructing the proxy.
         * @param info A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.
         * @param name A bus name (well-known or unique).
         * @param object_path An object path.
         * @param interface_name A D-Bus interface name.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback Callback function to invoke when the proxy is ready.
         */
        static new_for_bus(
            bus_type: BusType,
            flags: DBusProxyFlags,
            info: DBusInterfaceInfo | null,
            name: string,
            object_path: string,
            interface_name: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<DBusProxy> | null,
        ): void;
        static makeProxyWrapper<T>(
            ...args: any[]
        ): (
            bus: DBusConnection,
            name: string,
            object: string,
            asyncCallback?: (initable: (T & DBusProxy) | null, error: unknown | null) => void,
            cancellable?: Cancellable | null,
            flags?: DBusProxyFlags,
        ) => T & DBusProxy;

        // Virtual methods

        /**
         * Signal class handler for the #GDBusProxy::g-properties-changed signal.
         * @param changed_properties
         * @param invalidated_properties
         */
        vfunc_g_properties_changed(changed_properties: GLib.Variant, invalidated_properties: string): void;
        /**
         * Signal class handler for the #GDBusProxy::g-signal signal.
         * @param sender_name
         * @param signal_name
         * @param parameters
         */
        vfunc_g_signal(sender_name: string, signal_name: string, parameters: GLib.Variant): void;

        // Methods

        /**
         * Asynchronously invokes the `method_name` method on `proxy`.
         *
         * If `method_name` contains any dots, then `name` is split into interface and
         * method name parts. This allows using `proxy` for invoking methods on
         * other interfaces.
         *
         * If the #GDBusConnection associated with `proxy` is closed then
         * the operation will fail with %G_IO_ERROR_CLOSED. If
         * `cancellable` is canceled, the operation will fail with
         * %G_IO_ERROR_CANCELLED. If `parameters` contains a value not
         * compatible with the D-Bus protocol, the operation fails with
         * %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If the `parameters` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_proxy_call (proxy,
         *                     "TwoStrings",
         *                     g_variant_new ("(ss)",
         *                                    "Thing One",
         *                                    "Thing Two"),
         *                     G_DBUS_CALL_FLAGS_NONE,
         *                     -1,
         *                     NULL,
         *                     (GAsyncReadyCallback) two_strings_done,
         *                     &data);
         * ```
         *
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `method_name` is referenced by it,
         * then the return value is checked against the return type.
         *
         * This is an asynchronous method. When the operation is finished,
         * `callback` will be invoked in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread you are calling this method from.
         * You can then call g_dbus_proxy_call_finish() to get the result of
         * the operation. See g_dbus_proxy_call_sync() for the synchronous
         * version of this method.
         *
         * If `callback` is %NULL then the D-Bus method call message will be sent with
         * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.
         */
        call(
            method_name: string,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an operation started with g_dbus_proxy_call().
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call().
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_finish(res: AsyncResult): GLib.Variant;
        /**
         * Synchronously invokes the `method_name` method on `proxy`.
         *
         * If `method_name` contains any dots, then `name` is split into interface and
         * method name parts. This allows using `proxy` for invoking methods on
         * other interfaces.
         *
         * If the #GDBusConnection associated with `proxy` is disconnected then
         * the operation will fail with %G_IO_ERROR_CLOSED. If
         * `cancellable` is canceled, the operation will fail with
         * %G_IO_ERROR_CANCELLED. If `parameters` contains a value not
         * compatible with the D-Bus protocol, the operation fails with
         * %G_IO_ERROR_INVALID_ARGUMENT.
         *
         * If the `parameters` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.:
         *
         * ```c
         *  g_dbus_proxy_call_sync (proxy,
         *                          "TwoStrings",
         *                          g_variant_new ("(ss)",
         *                                         "Thing One",
         *                                         "Thing Two"),
         *                          G_DBUS_CALL_FLAGS_NONE,
         *                          -1,
         *                          NULL,
         *                          &error);
         * ```
         *
         *
         * The calling thread is blocked until a reply is received. See
         * g_dbus_proxy_call() for the asynchronous version of this
         * method.
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `method_name` is referenced by it,
         * then the return value is checked against the return type.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal              or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param cancellable A #GCancellable or %NULL.
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_sync(
            method_name: string,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            cancellable?: Cancellable | null,
        ): GLib.Variant;
        /**
         * Like g_dbus_proxy_call() but also takes a #GUnixFDList object.
         *
         * This method is only available on UNIX.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param fd_list A #GUnixFDList or %NULL.
         * @param cancellable A #GCancellable or %NULL.
         * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.
         */
        call_with_unix_fd_list(
            method_name: string,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list?: UnixFDList | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an operation started with g_dbus_proxy_call_with_unix_fd_list().
         * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call_with_unix_fd_list().
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_finish(res: AsyncResult): [GLib.Variant, UnixFDList | null];
        /**
         * Like g_dbus_proxy_call_sync() but also takes and returns #GUnixFDList objects.
         *
         * This method is only available on UNIX.
         * @param method_name Name of method to invoke.
         * @param parameters A #GVariant tuple with parameters for the signal              or %NULL if not passing parameters.
         * @param flags Flags from the #GDBusCallFlags enumeration.
         * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
         * @param fd_list A #GUnixFDList or %NULL.
         * @param cancellable A #GCancellable or %NULL.
         * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
         */
        call_with_unix_fd_list_sync(
            method_name: string,
            parameters: GLib.Variant | null,
            flags: DBusCallFlags,
            timeout_msec: number,
            fd_list?: UnixFDList | null,
            cancellable?: Cancellable | null,
        ): [GLib.Variant, UnixFDList | null];
        /**
         * Looks up the value for a property from the cache. This call does no
         * blocking IO.
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `property_name` is referenced by
         * it, then `value` is checked against the type of the property.
         * @param property_name Property name.
         * @returns A reference to the #GVariant instance    that holds the value for @property_name or %NULL if the value is not in    the cache. The returned reference must be freed with g_variant_unref().
         */
        get_cached_property(property_name: string): GLib.Variant | null;
        /**
         * Gets the names of all cached properties on `proxy`.
         * @returns A          %NULL-terminated array of strings or %NULL if          @proxy has no cached properties. Free the returned array with          g_strfreev().
         */
        get_cached_property_names(): string[] | null;
        /**
         * Gets the connection `proxy` is for.
         * @returns A #GDBusConnection owned by @proxy. Do not free.
         */
        get_connection(): DBusConnection;
        /**
         * Gets the timeout to use if -1 (specifying default timeout) is
         * passed as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         *
         * See the #GDBusProxy:g-default-timeout property for more details.
         * @returns Timeout to use for @proxy.
         */
        get_default_timeout(): number;
        /**
         * Gets the flags that `proxy` was constructed with.
         * @returns Flags from the #GDBusProxyFlags enumeration.
         */
        get_flags(): DBusProxyFlags;
        /**
         * Returns the #GDBusInterfaceInfo, if any, specifying the interface
         * that `proxy` conforms to. See the #GDBusProxy:g-interface-info
         * property for more details.
         * @returns A #GDBusInterfaceInfo or %NULL.    Do not unref the returned object, it is owned by @proxy.
         */
        get_interface_info(): DBusInterfaceInfo | null;
        /**
         * Gets the D-Bus interface name `proxy` is for.
         * @returns A string owned by @proxy. Do not free.
         */
        get_interface_name(): string;
        /**
         * Gets the name that `proxy` was constructed for.
         *
         * When connected to a message bus, this will usually be non-%NULL.
         * However, it may be %NULL for a proxy that communicates using a peer-to-peer
         * pattern.
         * @returns A string owned by @proxy. Do not free.
         */
        get_name(): string | null;
        /**
         * The unique name that owns the name that `proxy` is for or %NULL if
         * no-one currently owns that name. You may connect to the
         * #GObject::notify signal to track changes to the
         * #GDBusProxy:g-name-owner property.
         * @returns The name owner or %NULL if no name    owner exists. Free with g_free().
         */
        get_name_owner(): string | null;
        /**
         * Gets the object path `proxy` is for.
         * @returns A string owned by @proxy. Do not free.
         */
        get_object_path(): string;
        /**
         * If `value` is not %NULL, sets the cached value for the property with
         * name `property_name` to the value in `value`.
         *
         * If `value` is %NULL, then the cached value is removed from the
         * property cache.
         *
         * If `proxy` has an expected interface (see
         * #GDBusProxy:g-interface-info) and `property_name` is referenced by
         * it, then `value` is checked against the type of the property.
         *
         * If the `value` #GVariant is floating, it is consumed. This allows
         * convenient 'inline' use of g_variant_new(), e.g.
         *
         * ```c
         *  g_dbus_proxy_set_cached_property (proxy,
         *                                    "SomeProperty",
         *                                    g_variant_new ("(si)",
         *                                                  "A String",
         *                                                  42));
         * ```
         *
         *
         * Normally you will not need to use this method since `proxy`
         * is tracking changes using the
         * `org.freedesktop.DBus.Properties.PropertiesChanged`
         * D-Bus signal. However, for performance reasons an object may
         * decide to not use this signal for some properties and instead
         * use a proprietary out-of-band mechanism to transmit changes.
         *
         * As a concrete example, consider an object with a property
         * `ChatroomParticipants` which is an array of strings. Instead of
         * transmitting the same (long) array every time the property changes,
         * it is more efficient to only transmit the delta using e.g. signals
         * `ChatroomParticipantJoined(String name)` and
         * `ChatroomParticipantParted(String name)`.
         * @param property_name Property name.
         * @param value Value for the property or %NULL to remove it from the cache.
         */
        set_cached_property(property_name: string, value?: GLib.Variant | null): void;
        /**
         * Sets the timeout to use if -1 (specifying default timeout) is
         * passed as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         *
         * See the #GDBusProxy:g-default-timeout property for more details.
         * @param timeout_msec Timeout in milliseconds.
         */
        set_default_timeout(timeout_msec: number): void;
        /**
         * Ensure that interactions with `proxy` conform to the given
         * interface. See the #GDBusProxy:g-interface-info property for more
         * details.
         * @param info Minimum interface this proxy conforms to    or %NULL to unset.
         */
        set_interface_info(info?: DBusInterfaceInfo | null): void;
        connectSignal(proxy: this, name: string, args: any[]): any;
        disconnectSignal(...args: any[]): any;

        // Inherited methods
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        init_finish(res: AsyncResult): boolean;
        /**
         * Finishes the async construction for the various g_async_initable_new
         * calls, returning the created object or %NULL on error.
         * @param res the #GAsyncResult from the callback
         * @returns a newly created #GObject,      or %NULL on error. Free with g_object_unref().
         */
        new_finish(res: AsyncResult): DBusProxy;
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        vfunc_init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         */
        vfunc_init_finish(res: AsyncResult): boolean;
        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         * @returns A #GDBusObject or %NULL. The returned reference should be freed with g_object_unref().
         */
        get_object(): DBusObject | null;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         * @returns A #GDBusInterfaceInfo. Do not free.
         */
        get_info(): DBusInterfaceInfo;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @param object A #GDBusObject or %NULL.
         */
        set_object(object?: DBusObject | null): void;
        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         */
        vfunc_dup_object(): DBusObject | null;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         */
        vfunc_get_info(): DBusInterfaceInfo;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @param object A #GDBusObject or %NULL.
         */
        vfunc_set_object(object?: DBusObject | null): void;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DBusServer {
        // Signal callback interfaces

        interface NewConnection {
            (connection: DBusConnection): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Initable.ConstructorProps {
            active: boolean;
            address: string;
            authentication_observer: DBusAuthObserver;
            authenticationObserver: DBusAuthObserver;
            client_address: string;
            clientAddress: string;
            flags: DBusServerFlags;
            guid: string;
        }
    }

    /**
     * `GDBusServer` is a helper for listening to and accepting D-Bus
     * connections. This can be used to create a new D-Bus server, allowing two
     * peers to use the D-Bus protocol for their own specialized communication.
     * A server instance provided in this way will not perform message routing or
     * implement the
     * [`org.freedesktop.DBus` interface](https://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-messages).
     *
     * To just export an object on a well-known name on a message bus, such as the
     * session or system bus, you should instead use [func`Gio`.bus_own_name].
     *
     * An example of peer-to-peer communication with GDBus can be found
     * in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
     *
     * Note that a minimal `GDBusServer` will accept connections from any
     * peer. In many use-cases it will be necessary to add a
     * [class`Gio`.DBusAuthObserver] that only accepts connections that have
     * successfully authenticated as the same user that is running the
     * `GDBusServer`. Since GLib 2.68 this can be achieved more simply by passing
     * the `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the
     * server.
     */
    class DBusServer extends GObject.Object implements Initable {
        static $gtype: GObject.GType<DBusServer>;

        // Properties

        /**
         * Whether the server is currently active.
         */
        get active(): boolean;
        /**
         * The D-Bus address to listen on.
         */
        get address(): string;
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        get authentication_observer(): DBusAuthObserver;
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        get authenticationObserver(): DBusAuthObserver;
        /**
         * The D-Bus address that clients can use.
         */
        get client_address(): string;
        /**
         * The D-Bus address that clients can use.
         */
        get clientAddress(): string;
        /**
         * Flags from the #GDBusServerFlags enumeration.
         */
        get flags(): DBusServerFlags;
        /**
         * The GUID of the server.
         *
         * See #GDBusConnection:guid for more details.
         */
        get guid(): string;

        // Constructors

        constructor(properties?: Partial<DBusServer.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_sync(
            address: string,
            flags: DBusServerFlags,
            guid: string,
            observer?: DBusAuthObserver | null,
            cancellable?: Cancellable | null,
        ): DBusServer;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'new-connection', callback: (_source: this, connection: DBusConnection) => boolean): number;
        connect_after(
            signal: 'new-connection',
            callback: (_source: this, connection: DBusConnection) => boolean,
        ): number;
        emit(signal: 'new-connection', connection: DBusConnection): void;

        // Methods

        /**
         * Gets a
         * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
         * string that can be used by clients to connect to `server`.
         *
         * This is valid and non-empty if initializing the #GDBusServer succeeded.
         * @returns A D-Bus address string. Do not free, the string is owned by @server.
         */
        get_client_address(): string;
        /**
         * Gets the flags for `server`.
         * @returns A set of flags from the #GDBusServerFlags enumeration.
         */
        get_flags(): DBusServerFlags;
        /**
         * Gets the GUID for `server,` as provided to g_dbus_server_new_sync().
         * @returns A D-Bus GUID. Do not free this string, it is owned by @server.
         */
        get_guid(): string;
        /**
         * Gets whether `server` is active.
         * @returns %TRUE if server is active, %FALSE otherwise.
         */
        is_active(): boolean;
        /**
         * Starts `server`.
         */
        start(): void;
        /**
         * Stops `server`.
         */
        stop(): void;

        // Inherited methods
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DataInputStream {
        // Constructor properties interface

        interface ConstructorProps extends BufferedInputStream.ConstructorProps, Seekable.ConstructorProps {
            byte_order: DataStreamByteOrder;
            byteOrder: DataStreamByteOrder;
            newline_type: DataStreamNewlineType;
            newlineType: DataStreamNewlineType;
        }
    }

    /**
     * Data input stream implements [class`Gio`.InputStream] and includes functions
     * for reading structured data directly from a binary input stream.
     */
    class DataInputStream extends BufferedInputStream implements Seekable {
        static $gtype: GObject.GType<DataInputStream>;

        // Properties

        /**
         * The :byte-order property determines the byte ordering that
         * is used when reading multi-byte entities (such as integers)
         * from the stream.
         */
        get byte_order(): DataStreamByteOrder;
        set byte_order(val: DataStreamByteOrder);
        /**
         * The :byte-order property determines the byte ordering that
         * is used when reading multi-byte entities (such as integers)
         * from the stream.
         */
        get byteOrder(): DataStreamByteOrder;
        set byteOrder(val: DataStreamByteOrder);
        /**
         * The :newline-type property determines what is considered
         * as a line ending when reading complete lines from the stream.
         */
        get newline_type(): DataStreamNewlineType;
        set newline_type(val: DataStreamNewlineType);
        /**
         * The :newline-type property determines what is considered
         * as a line ending when reading complete lines from the stream.
         */
        get newlineType(): DataStreamNewlineType;
        set newlineType(val: DataStreamNewlineType);

        // Constructors

        constructor(properties?: Partial<DataInputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](base_stream: InputStream): DataInputStream;

        // Methods

        /**
         * Gets the byte order for the data input stream.
         * @returns the @stream's current #GDataStreamByteOrder.
         */
        get_byte_order(): DataStreamByteOrder;
        /**
         * Gets the current newline type for the `stream`.
         * @returns #GDataStreamNewlineType for the given @stream.
         */
        get_newline_type(): DataStreamNewlineType;
        /**
         * Reads an unsigned 8-bit/1-byte value from `stream`.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 8-bit/1-byte value read from the @stream or `0` if an error occurred.
         */
        read_byte(cancellable?: Cancellable | null): number;
        /**
         * Reads a 16-bit/2-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a signed 16-bit/2-byte value read from @stream or `0` if an error occurred.
         */
        read_int16(cancellable?: Cancellable | null): number;
        /**
         * Reads a signed 32-bit/4-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a signed 32-bit/4-byte value read from the @stream or `0` if an error occurred.
         */
        read_int32(cancellable?: Cancellable | null): number;
        /**
         * Reads a 64-bit/8-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a signed 64-bit/8-byte value read from @stream or `0` if an error occurred.
         */
        read_int64(cancellable?: Cancellable | null): number;
        /**
         * Reads a line from the data input stream.  Note that no encoding
         * checks or conversion is performed; the input is not guaranteed to
         * be UTF-8, and may in fact have embedded NUL characters.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a NUL terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
         */
        read_line(cancellable?: Cancellable | null): [Uint8Array | null, number];
        /**
         * The asynchronous version of g_data_input_stream_read_line().  It is
         * an error to have two outstanding calls to this function.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_line_finish() to get
         * the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied.
         */
        read_line_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_line_async().  Note the warning about
         * string encoding in g_data_input_stream_read_line() applies here as
         * well.
         * @param result the #GAsyncResult that was provided to the callback.
         * @returns a NUL-terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
         */
        read_line_finish(result: AsyncResult): [Uint8Array | null, number];
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_line_async().
         * @param result the #GAsyncResult that was provided to the callback.
         * @returns a string with the line that  was read in (without the newlines).  Set @length to a #gsize to  get the length of the read line.  On an error, it will return  %NULL and @error will be set. For UTF-8 conversion errors, the set  error domain is %G_CONVERT_ERROR.  If there's no content to read,  it will still return %NULL, but @error won't be set.
         */
        read_line_finish_utf8(result: AsyncResult): [string | null, number];
        /**
         * Reads a UTF-8 encoded line from the data input stream.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a NUL terminated UTF-8 string  with the line that was read in (without the newlines).  Set  @length to a #gsize to get the length of the read line.  On an  error, it will return %NULL and @error will be set.  For UTF-8  conversion errors, the set error domain is %G_CONVERT_ERROR.  If  there's no content to read, it will still return %NULL, but @error  won't be set.
         */
        read_line_utf8(cancellable?: Cancellable | null): [string | null, number];
        /**
         * Reads an unsigned 16-bit/2-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 16-bit/2-byte value read from the @stream or `0` if an error occurred.
         */
        read_uint16(cancellable?: Cancellable | null): number;
        /**
         * Reads an unsigned 32-bit/4-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 32-bit/4-byte value read from the @stream or `0` if an error occurred.
         */
        read_uint32(cancellable?: Cancellable | null): number;
        /**
         * Reads an unsigned 64-bit/8-byte value from `stream`.
         *
         * In order to get the correct byte order for this read operation,
         * see g_data_input_stream_get_byte_order().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns an unsigned 64-bit/8-byte read from @stream or `0` if an error occurred.
         */
        read_uint64(cancellable?: Cancellable | null): number;
        /**
         * Reads a string from the data input stream, up to the first
         * occurrence of any of the stop characters.
         *
         * Note that, in contrast to g_data_input_stream_read_until_async(),
         * this function consumes the stop character that it finds.
         *
         * Don't use this function in new code.  Its functionality is
         * inconsistent with g_data_input_stream_read_until_async().  Both
         * functions will be marked as deprecated in a future release.  Use
         * g_data_input_stream_read_upto() instead, but note that that function
         * does not consume the stop character.
         * @param stop_chars characters to terminate the read.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_until(stop_chars: string, cancellable?: Cancellable | null): [string, number];
        /**
         * The asynchronous version of g_data_input_stream_read_until().
         * It is an error to have two outstanding calls to this function.
         *
         * Note that, in contrast to g_data_input_stream_read_until(),
         * this function does not consume the stop character that it finds.  You
         * must read it for yourself.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_until_finish() to get
         * the result of the operation.
         *
         * Don't use this function in new code.  Its functionality is
         * inconsistent with g_data_input_stream_read_until().  Both functions
         * will be marked as deprecated in a future release.  Use
         * g_data_input_stream_read_upto_async() instead.
         * @param stop_chars characters to terminate the read.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied.
         */
        read_until_async(
            stop_chars: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_until_async().
         * @param result the #GAsyncResult that was provided to the callback.
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_until_finish(result: AsyncResult): [string, number];
        /**
         * Reads a string from the data input stream, up to the first
         * occurrence of any of the stop characters.
         *
         * In contrast to g_data_input_stream_read_until(), this function
         * does not consume the stop character. You have to use
         * g_data_input_stream_read_byte() to get it before calling
         * g_data_input_stream_read_upto() again.
         *
         * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
         * specified.
         *
         * The returned string will always be nul-terminated on success.
         * @param stop_chars characters to terminate the read
         * @param stop_chars_len length of @stop_chars. May be -1 if @stop_chars is     nul-terminated
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error
         */
        read_upto(stop_chars: string, stop_chars_len: number, cancellable?: Cancellable | null): [string, number];
        /**
         * The asynchronous version of g_data_input_stream_read_upto().
         * It is an error to have two outstanding calls to this function.
         *
         * In contrast to g_data_input_stream_read_until(), this function
         * does not consume the stop character. You have to use
         * g_data_input_stream_read_byte() to get it before calling
         * g_data_input_stream_read_upto() again.
         *
         * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
         * specified.
         *
         * When the operation is finished, `callback` will be called. You
         * can then call g_data_input_stream_read_upto_finish() to get
         * the result of the operation.
         * @param stop_chars characters to terminate the read
         * @param stop_chars_len length of @stop_chars. May be -1 if @stop_chars is     nul-terminated
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback callback to call when the request is satisfied
         */
        read_upto_async(
            stop_chars: string,
            stop_chars_len: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous call started by
         * g_data_input_stream_read_upto_async().
         *
         * Note that this function does not consume the stop character. You
         * have to use g_data_input_stream_read_byte() to get it before calling
         * g_data_input_stream_read_upto_async() again.
         *
         * The returned string will always be nul-terminated on success.
         * @param result the #GAsyncResult that was provided to the callback
         * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
         */
        read_upto_finish(result: AsyncResult): [string, number];
        /**
         * This function sets the byte order for the given `stream`. All subsequent
         * reads from the `stream` will be read in the given `order`.
         * @param order a #GDataStreamByteOrder to set.
         */
        set_byte_order(order: DataStreamByteOrder): void;
        /**
         * Sets the newline type for the `stream`.
         *
         * Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
         * chunk ends in "CR" we must read an additional byte to know if this is "CR" or
         * "CR LF", and this might block if there is no more data available.
         * @param type the type of new line return as #GDataStreamNewlineType.
         */
        set_newline_type(type: DataStreamNewlineType): void;

        // Inherited methods
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Tests if the stream supports the #GSeekableIface.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DataOutputStream {
        // Constructor properties interface

        interface ConstructorProps extends FilterOutputStream.ConstructorProps, Seekable.ConstructorProps {
            byte_order: DataStreamByteOrder;
            byteOrder: DataStreamByteOrder;
        }
    }

    /**
     * Data output stream implements [class`Gio`.OutputStream] and includes functions
     * for writing data directly to an output stream.
     */
    class DataOutputStream extends FilterOutputStream implements Seekable {
        static $gtype: GObject.GType<DataOutputStream>;

        // Properties

        /**
         * Determines the byte ordering that is used when writing
         * multi-byte entities (such as integers) to the stream.
         */
        get byte_order(): DataStreamByteOrder;
        set byte_order(val: DataStreamByteOrder);
        /**
         * Determines the byte ordering that is used when writing
         * multi-byte entities (such as integers) to the stream.
         */
        get byteOrder(): DataStreamByteOrder;
        set byteOrder(val: DataStreamByteOrder);

        // Constructors

        constructor(properties?: Partial<DataOutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](base_stream: OutputStream): DataOutputStream;

        // Methods

        /**
         * Gets the byte order for the stream.
         * @returns the #GDataStreamByteOrder for the @stream.
         */
        get_byte_order(): DataStreamByteOrder;
        /**
         * Puts a byte into the output stream.
         * @param data a #guchar.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_byte(data: number, cancellable?: Cancellable | null): boolean;
        /**
         * Puts a signed 16-bit integer into the output stream.
         * @param data a #gint16.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_int16(data: number, cancellable?: Cancellable | null): boolean;
        /**
         * Puts a signed 32-bit integer into the output stream.
         * @param data a #gint32.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_int32(data: number, cancellable?: Cancellable | null): boolean;
        /**
         * Puts a signed 64-bit integer into the stream.
         * @param data a #gint64.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_int64(data: number, cancellable?: Cancellable | null): boolean;
        /**
         * Puts a string into the output stream.
         * @param str a string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @string was successfully added to the @stream.
         */
        put_string(str: string, cancellable?: Cancellable | null): boolean;
        /**
         * Puts an unsigned 16-bit integer into the output stream.
         * @param data a #guint16.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_uint16(data: number, cancellable?: Cancellable | null): boolean;
        /**
         * Puts an unsigned 32-bit integer into the stream.
         * @param data a #guint32.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_uint32(data: number, cancellable?: Cancellable | null): boolean;
        /**
         * Puts an unsigned 64-bit integer into the stream.
         * @param data a #guint64.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if @data was successfully added to the @stream.
         */
        put_uint64(data: number, cancellable?: Cancellable | null): boolean;
        /**
         * Sets the byte order of the data output stream to `order`.
         * @param order a %GDataStreamByteOrder.
         */
        set_byte_order(order: DataStreamByteOrder): void;

        // Inherited methods
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Tests if the stream supports the #GSeekableIface.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DebugControllerDBus {
        // Signal callback interfaces

        interface Authorize {
            (invocation: DBusMethodInvocation): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                DebugController.ConstructorProps,
                Initable.ConstructorProps {
            connection: DBusConnection;
        }
    }

    /**
     * `GDebugControllerDBus` is an implementation of [iface`Gio`.DebugController]
     * which exposes debug settings as a D-Bus object.
     *
     * It is a [iface`Gio`.Initable] object, and will register an object at
     * `/org/gtk/Debugging` on the bus given as
     * [property`Gio`.DebugControllerDBus:connection] once its initialized. The
     * object will be unregistered when the last reference to the
     * `GDebugControllerDBus` is dropped.
     *
     * This D-Bus object can be used by remote processes to enable or disable debug
     * output in this process. Remote processes calling
     * `org.gtk.Debugging.SetDebugEnabled()` will affect the value of
     * [property`Gio`.DebugController:debug-enabled] and, by default,
     * [func`GLib`.log_get_debug_enabled].
     *
     * By default, no processes are allowed to call `SetDebugEnabled()` unless a
     * [signal`Gio`.DebugControllerDBus::authorize] signal handler is installed. This
     * is because the process may be privileged, or might expose sensitive
     * information in its debug output. You may want to restrict the ability to
     * enable debug output to privileged users or processes.
     *
     * One option is to install a D-Bus security policy which restricts access to
     * `SetDebugEnabled()`, installing something like the following in
     * `$datadir/dbus-1/system.d/`:
     *
     * ```xml
     * <?xml version="1.0"?> <!--*-nxml-*-->
     * <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
     *      "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
     * <busconfig>
     *   <policy user="root">
     *     <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
     *   </policy>
     *   <policy context="default">
     *     <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
     *   </policy>
     * </busconfig>
     * ```
     *
     * This will prevent the `SetDebugEnabled()` method from being called by all
     * except root. It will not prevent the `DebugEnabled` property from being read,
     * as its accessed through the `org.freedesktop.DBus.Properties` interface.
     *
     * Another option is to use polkit to allow or deny requests on a case-by-case
     * basis, allowing for the possibility of dynamic authorisation. To do this,
     * connect to the [signal`Gio`.DebugControllerDBus::authorize] signal and query
     * polkit in it:
     *
     * ```c
     *   g_autoptr(GError) child_error = NULL;
     *   g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
     *   gulong debug_controller_authorize_id = 0;
     *
     *   // Set up the debug controller.
     *   debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
     *   if (debug_controller == NULL)
     *     {
     *       g_error ("Could not register debug controller on bus: %s"),
     *                child_error->message);
     *     }
     *
     *   debug_controller_authorize_id = g_signal_connect (debug_controller,
     *                                                     "authorize",
     *                                                     G_CALLBACK (debug_controller_authorize_cb),
     *                                                     self);
     *
     *   static gboolean
     *   debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
     *                                  GDBusMethodInvocation *invocation,
     *                                  gpointer               user_data)
     *   {
     *     g_autoptr(PolkitAuthority) authority = NULL;
     *     g_autoptr(PolkitSubject) subject = NULL;
     *     g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
     *     g_autoptr(GError) local_error = NULL;
     *     GDBusMessage *message;
     *     GDBusMessageFlags message_flags;
     *     PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
     *
     *     message = g_dbus_method_invocation_get_message (invocation);
     *     message_flags = g_dbus_message_get_flags (message);
     *
     *     authority = polkit_authority_get_sync (NULL, &local_error);
     *     if (authority == NULL)
     *       {
     *         g_warning ("Failed to get polkit authority: %s", local_error->message);
     *         return FALSE;
     *       }
     *
     *     if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
     *       flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
     *
     *     subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
     *
     *     auth_result = polkit_authority_check_authorization_sync (authority,
     *                                                              subject,
     *                                                              "com.example.MyService.set-debug-enabled",
     *                                                              NULL,
     *                                                              flags,
     *                                                              NULL,
     *                                                              &local_error);
     *     if (auth_result == NULL)
     *       {
     *         g_warning ("Failed to get check polkit authorization: %s", local_error->message);
     *         return FALSE;
     *       }
     *
     *     return polkit_authorization_result_get_is_authorized (auth_result);
     *   }
     * ```
     */
    class DebugControllerDBus extends GObject.Object implements DebugController, Initable {
        static $gtype: GObject.GType<DebugControllerDBus>;

        // Properties

        /**
         * The D-Bus connection to expose the debugging interface on.
         *
         * Typically this will be the same connection (to the system or session bus)
         * which the rest of the application or services D-Bus objects are registered
         * on.
         */
        get connection(): DBusConnection;

        // Constructors

        constructor(properties?: Partial<DebugControllerDBus.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](connection: DBusConnection, cancellable?: Cancellable | null): DebugControllerDBus;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'authorize', callback: (_source: this, invocation: DBusMethodInvocation) => boolean): number;
        connect_after(
            signal: 'authorize',
            callback: (_source: this, invocation: DBusMethodInvocation) => boolean,
        ): number;
        emit(signal: 'authorize', invocation: DBusMethodInvocation): void;

        // Virtual methods

        /**
         * Default handler for the #GDebugControllerDBus::authorize signal.
         * @param invocation
         */
        vfunc_authorize(invocation: DBusMethodInvocation): boolean;

        // Methods

        /**
         * Stop the debug controller, unregistering its object from the bus.
         *
         * Any pending method calls to the object will complete successfully, but new
         * ones will return an error. This method will block until all pending
         * #GDebugControllerDBus::authorize signals have been handled. This is expected
         * to not take long, as it will just be waiting for threads to join. If any
         * #GDebugControllerDBus::authorize signal handlers are still executing in other
         * threads, this will block until after they have returned.
         *
         * This method will be called automatically when the final reference to the
         * #GDebugControllerDBus is dropped. You may want to call it explicitly to know
         * when the controller has been fully removed from the bus, or to break
         * reference count cycles.
         *
         * Calling this method from within a #GDebugControllerDBus::authorize signal
         * handler will cause a deadlock and must not be done.
         */
        stop(): void;

        // Inherited properties
        /**
         * %TRUE if debug output should be exposed (for example by forwarding it to
         * the journal), %FALSE otherwise.
         */
        get debug_enabled(): boolean;
        set debug_enabled(val: boolean);
        /**
         * %TRUE if debug output should be exposed (for example by forwarding it to
         * the journal), %FALSE otherwise.
         */
        get debugEnabled(): boolean;
        set debugEnabled(val: boolean);

        // Inherited methods
        /**
         * Get the value of #GDebugController:debug-enabled.
         * @returns %TRUE if debug output should be exposed, %FALSE otherwise
         */
        get_debug_enabled(): boolean;
        /**
         * Set the value of #GDebugController:debug-enabled.
         * @param debug_enabled %TRUE if debug output should be exposed, %FALSE otherwise
         */
        set_debug_enabled(debug_enabled: boolean): void;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module DesktopAppInfo {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, AppInfo.ConstructorProps {
            filename: string;
        }
    }

    /**
     * `GDesktopAppInfo` is an implementation of [iface`Gio`.AppInfo] based on
     * desktop files.
     *
     * Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific
     * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
     * file or the `GioUnix-2.0` GIR namespace when using it.
     */
    class DesktopAppInfo extends GObject.Object implements AppInfo {
        static $gtype: GObject.GType<DesktopAppInfo>;

        // Properties

        /**
         * The origin filename of this #GDesktopAppInfo
         */
        get filename(): string;

        // Constructors

        constructor(properties?: Partial<DesktopAppInfo.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](desktop_id: string): DesktopAppInfo;

        static new_from_filename(filename: string): DesktopAppInfo;

        static new_from_keyfile(key_file: GLib.KeyFile): DesktopAppInfo;

        // Static methods

        /**
         * Gets all applications that implement `interface`.
         *
         * An application implements an interface if that interface is listed in
         * the Implements= line of the desktop file of the application.
         * @param _interface the name of the interface
         */
        static get_implementations(_interface: string): DesktopAppInfo[];
        /**
         * Searches desktop files for ones that match `search_string`.
         *
         * The return value is an array of strvs.  Each strv contains a list of
         * applications that matched `search_string` with an equal score.  The
         * outer list is sorted by score so that the first strv contains the
         * best-matching applications, and so on.
         * The algorithm for determining matches is undefined and may change at
         * any time.
         *
         * None of the search results are subjected to the normal validation
         * checks performed by g_desktop_app_info_new() (for example, checking that
         * the executable referenced by a result exists), and so it is possible for
         * g_desktop_app_info_new() to return %NULL when passed an app ID returned by
         * this function. It is expected that calling code will do this when
         * subsequently creating a #GDesktopAppInfo for each result.
         * @param search_string the search string to use
         */
        static search(search_string: string): string[][];
        /**
         * Sets the name of the desktop that the application is running in.
         * This is used by g_app_info_should_show() and
         * g_desktop_app_info_get_show_in() to evaluate the
         * `OnlyShowIn` and `NotShowIn`
         * desktop entry fields.
         *
         * Should be called only once; subsequent calls are ignored.
         * @param desktop_env a string specifying what desktop this is
         */
        static set_desktop_env(desktop_env: string): void;

        // Methods

        /**
         * Gets the user-visible display name of the "additional application
         * action" specified by `action_name`.
         *
         * This corresponds to the "Name" key within the keyfile group for the
         * action.
         * @param action_name the name of the action as from   g_desktop_app_info_list_actions()
         * @returns the locale-specific action name
         */
        get_action_name(action_name: string): string;
        /**
         * Looks up a boolean value in the keyfile backing `info`.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns the boolean value, or %FALSE if the key     is not found
         */
        get_boolean(key: string): boolean;
        /**
         * Gets the categories from the desktop file.
         * @returns The unparsed Categories key from the desktop file;     i.e. no attempt is made to split it by ';' or validate it.
         */
        get_categories(): string | null;
        /**
         * When `info` was created from a known filename, return it.  In some
         * situations such as the #GDesktopAppInfo returned from
         * g_desktop_app_info_new_from_keyfile(), this function will return %NULL.
         * @returns The full path to the file for @info,     or %NULL if not known.
         */
        get_filename(): string | null;
        /**
         * Gets the generic name from the desktop file.
         * @returns The value of the GenericName key
         */
        get_generic_name(): string | null;
        /**
         * A desktop file is hidden if the Hidden key in it is
         * set to True.
         * @returns %TRUE if hidden, %FALSE otherwise.
         */
        get_is_hidden(): boolean;
        /**
         * Gets the keywords from the desktop file.
         * @returns The value of the Keywords key
         */
        get_keywords(): string[];
        /**
         * Looks up a localized string value in the keyfile backing `info`
         * translated to the current locale.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns a newly allocated string, or %NULL if the key     is not found
         */
        get_locale_string(key: string): string | null;
        /**
         * Gets the value of the NoDisplay key, which helps determine if the
         * application info should be shown in menus. See
         * %G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
         * @returns The value of the NoDisplay key
         */
        get_nodisplay(): boolean;
        /**
         * Checks if the application info should be shown in menus that list available
         * applications for a specific name of the desktop, based on the
         * `OnlyShowIn` and `NotShowIn` keys.
         *
         * `desktop_env` should typically be given as %NULL, in which case the
         * `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
         * to override the default mechanism then you may specify `desktop_env,`
         * but this is not recommended.
         *
         * Note that g_app_info_should_show() for `info` will include this check (with
         * %NULL for `desktop_env)` as well as additional checks.
         * @param desktop_env a string specifying a desktop name
         * @returns %TRUE if the @info should be shown in @desktop_env according to the `OnlyShowIn` and `NotShowIn` keys, %FALSE otherwise.
         */
        get_show_in(desktop_env?: string | null): boolean;
        /**
         * Retrieves the StartupWMClass field from `info`. This represents the
         * WM_CLASS property of the main window of the application, if launched
         * through `info`.
         * @returns the startup WM class, or %NULL if none is set in the desktop file.
         */
        get_startup_wm_class(): string | null;
        /**
         * Looks up a string value in the keyfile backing `info`.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns a newly allocated string, or %NULL if the key     is not found
         */
        get_string(key: string): string | null;
        /**
         * Looks up a string list value in the keyfile backing `info`.
         *
         * The `key` is looked up in the "Desktop Entry" group.
         * @param key the key to look up
         * @returns a %NULL-terminated string array or %NULL if the specified  key cannot be found. The array should be freed with g_strfreev().
         */
        get_string_list(key: string): string[];
        /**
         * Returns whether `key` exists in the "Desktop Entry" group
         * of the keyfile backing `info`.
         * @param key the key to look up
         * @returns %TRUE if the @key exists
         */
        has_key(key: string): boolean;
        /**
         * Activates the named application action.
         *
         * You may only call this function on action names that were
         * returned from g_desktop_app_info_list_actions().
         *
         * Note that if the main entry of the desktop file indicates that the
         * application supports startup notification, and `launch_context` is
         * non-%NULL, then startup notification will be used when activating the
         * action (and as such, invocation of the action on the receiving side
         * must signal the end of startup notification when it is completed).
         * This is the expected behaviour of applications declaring additional
         * actions, as per the desktop file specification.
         *
         * As with g_app_info_launch() there is no way to detect failures that
         * occur while using this function.
         * @param action_name the name of the action as from   g_desktop_app_info_list_actions()
         * @param launch_context a #GAppLaunchContext
         */
        launch_action(action_name: string, launch_context?: AppLaunchContext | null): void;
        /**
         * This function performs the equivalent of g_app_info_launch_uris(),
         * but is intended primarily for operating system components that
         * launch applications.  Ordinary applications should use
         * g_app_info_launch_uris().
         *
         * If the application is launched via GSpawn, then `spawn_flags,` `user_setup`
         * and `user_setup_data` are used for the call to g_spawn_async().
         * Additionally, `pid_callback` (with `pid_callback_data)` will be called to
         * inform about the PID of the created process. See g_spawn_async_with_pipes()
         * for information on certain parameter conditions that can enable an
         * optimized posix_spawn() codepath to be used.
         *
         * If application launching occurs via some other mechanism (eg: D-Bus
         * activation) then `spawn_flags,` `user_setup,` `user_setup_data,`
         * `pid_callback` and `pid_callback_data` are ignored.
         * @param uris List of URIs
         * @param launch_context a #GAppLaunchContext
         * @param spawn_flags #GSpawnFlags, used for each process
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_as_manager(
            uris: string[],
            launch_context: AppLaunchContext | null,
            spawn_flags: GLib.SpawnFlags,
        ): boolean;
        /**
         * Equivalent to g_desktop_app_info_launch_uris_as_manager() but allows
         * you to pass in file descriptors for the stdin, stdout and stderr streams
         * of the launched process.
         *
         * If application launching occurs via some non-spawn mechanism (e.g. D-Bus
         * activation) then `stdin_fd,` `stdout_fd` and `stderr_fd` are ignored.
         * @param uris List of URIs
         * @param launch_context a #GAppLaunchContext
         * @param spawn_flags #GSpawnFlags, used for each process
         * @param user_setup a #GSpawnChildSetupFunc, used once     for each process.
         * @param pid_callback Callback for child processes
         * @param stdin_fd file descriptor to use for child's stdin, or -1
         * @param stdout_fd file descriptor to use for child's stdout, or -1
         * @param stderr_fd file descriptor to use for child's stderr, or -1
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_as_manager_with_fds(
            uris: string[],
            launch_context: AppLaunchContext | null,
            spawn_flags: GLib.SpawnFlags,
            user_setup: GLib.SpawnChildSetupFunc | null,
            pid_callback: DesktopAppLaunchCallback | null,
            stdin_fd: number,
            stdout_fd: number,
            stderr_fd: number,
        ): boolean;
        /**
         * Returns the list of "additional application actions" supported on the
         * desktop file, as per the desktop file specification.
         *
         * As per the specification, this is the list of actions that are
         * explicitly listed in the "Actions" key of the [Desktop Entry] group.
         * @returns a list of strings, always non-%NULL
         */
        list_actions(): string[];

        // Inherited methods
        /**
         * Adds a content type to the application information to indicate the
         * application is capable of opening files with the given content type.
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        add_supports_type(content_type: string): boolean;
        /**
         * Obtains the information whether the #GAppInfo can be deleted.
         * See g_app_info_delete().
         * @returns %TRUE if @appinfo can be deleted
         */
        can_delete(): boolean;
        /**
         * Checks if a supported content type can be removed from an application.
         * @returns %TRUE if it is possible to remove supported     content types from a given @appinfo, %FALSE if not.
         */
        can_remove_supports_type(): boolean;
        /**
         * Tries to delete a #GAppInfo.
         *
         * On some platforms, there may be a difference between user-defined
         * #GAppInfos which can be deleted, and system-wide ones which cannot.
         * See g_app_info_can_delete().
         * @returns %TRUE if @appinfo has been deleted
         */
        ['delete'](): boolean;
        /**
         * Creates a duplicate of a #GAppInfo.
         * @returns a duplicate of @appinfo.
         */
        dup(): AppInfo;
        /**
         * Checks if two #GAppInfos are equal.
         *
         * Note that the check *may not* compare each individual
         * field, and only does an identity check. In case detecting changes in the
         * contents is needed, program code must additionally compare relevant fields.
         * @param appinfo2 the second #GAppInfo.
         * @returns %TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.
         */
        equal(appinfo2: AppInfo): boolean;
        /**
         * Gets the commandline with which the application will be
         * started.
         * @returns a string containing the @appinfo's commandline,     or %NULL if this information is not available
         */
        get_commandline(): string | null;
        /**
         * Gets a human-readable description of an installed application.
         * @returns a string containing a description of the application @appinfo, or %NULL if none.
         */
        get_description(): string | null;
        /**
         * Gets the display name of the application. The display name is often more
         * descriptive to the user than the name itself.
         * @returns the display name of the application for @appinfo, or the name if no display name is available.
         */
        get_display_name(): string;
        /**
         * Gets the executable's name for the installed application.
         *
         * This is intended to be used for debugging or labelling what program is going
         * to be run. To launch the executable, use g_app_info_launch() and related
         * functions, rather than spawning the return value from this function.
         * @returns a string containing the @appinfo's application binaries name
         */
        get_executable(): string;
        /**
         * Gets the icon for the application.
         * @returns the default #GIcon for @appinfo or %NULL if there is no default icon.
         */
        get_icon(): Icon | null;
        /**
         * Gets the ID of an application. An id is a string that
         * identifies the application. The exact format of the id is
         * platform dependent. For instance, on Unix this is the
         * desktop file id from the xdg menu specification.
         *
         * Note that the returned ID may be %NULL, depending on how
         * the `appinfo` has been constructed.
         * @returns a string containing the application's ID.
         */
        get_id(): string | null;
        /**
         * Gets the installed name of the application.
         * @returns the name of the application for @appinfo.
         */
        get_name(): string;
        /**
         * Retrieves the list of content types that `app_info` claims to support.
         * If this information is not provided by the environment, this function
         * will return %NULL.
         * This function does not take in consideration associations added with
         * g_app_info_add_supports_type(), but only those exported directly by
         * the application.
         * @returns a list of content types.
         */
        get_supported_types(): string[];
        /**
         * Launches the application. Passes `files` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly.
         *
         * To launch the application without arguments pass a %NULL `files` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         *
         * Some URIs can be changed when passed through a GFile (for instance
         * unsupported URIs with strange formats like mailto:), so if you have
         * a textual URI you want to pass in as argument, consider using
         * g_app_info_launch_uris() instead.
         *
         * The launched application inherits the environment of the launching
         * process, but it can be modified with g_app_launch_context_setenv()
         * and g_app_launch_context_unsetenv().
         *
         * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
         * environment variable with the path of the launched desktop file and
         * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
         * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
         * should it be inherited by further processes. The `DISPLAY`,
         * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
         * variables are also set, based on information provided in `context`.
         * @param files a #GList of #GFile objects
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Launches the application. This passes the `uris` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly. If the application only supports
         * one URI per invocation as part of their command-line, multiple instances
         * of the application will be spawned.
         *
         * To launch the application without arguments pass a %NULL `uris` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Async version of g_app_info_launch_uris().
         *
         * The `callback` is invoked immediately after the application launch, but it
         * waits for activation in case of D-Busactivated applications and also provides
         * extended error information for sandboxed applications, see notes for
         * g_app_info_launch_default_for_uri_async().
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        launch_uris_async(
            uris?: string[] | null,
            context?: AppLaunchContext | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a g_app_info_launch_uris_async() operation.
         * @param result a #GAsyncResult
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_finish(result: AsyncResult): boolean;
        /**
         * Removes a supported type from an application, if possible.
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        remove_supports_type(content_type: string): boolean;
        /**
         * Sets the application as the default handler for the given file extension.
         * @param extension a string containing the file extension     (without the dot).
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_default_for_extension(extension: string): boolean;
        /**
         * Sets the application as the default handler for a given type.
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_default_for_type(content_type: string): boolean;
        /**
         * Sets the application as the last used application for a given type.
         * This will make the application appear as first in the list returned
         * by g_app_info_get_recommended_for_type(), regardless of the default
         * application for that content type.
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_last_used_for_type(content_type: string): boolean;
        /**
         * Checks if the application info should be shown in menus that
         * list available applications.
         * @returns %TRUE if the @appinfo should be shown, %FALSE otherwise.
         */
        should_show(): boolean;
        /**
         * Checks if the application accepts files as arguments.
         * @returns %TRUE if the @appinfo supports files.
         */
        supports_files(): boolean;
        /**
         * Checks if the application supports reading files and directories from URIs.
         * @returns %TRUE if the @appinfo supports URIs.
         */
        supports_uris(): boolean;
        /**
         * Adds a content type to the application information to indicate the
         * application is capable of opening files with the given content type.
         * @param content_type a string.
         */
        vfunc_add_supports_type(content_type: string): boolean;
        /**
         * Obtains the information whether the #GAppInfo can be deleted.
         * See g_app_info_delete().
         */
        vfunc_can_delete(): boolean;
        /**
         * Checks if a supported content type can be removed from an application.
         */
        vfunc_can_remove_supports_type(): boolean;
        /**
         * Tries to delete a #GAppInfo.
         *
         * On some platforms, there may be a difference between user-defined
         * #GAppInfos which can be deleted, and system-wide ones which cannot.
         * See g_app_info_can_delete().
         */
        vfunc_do_delete(): boolean;
        /**
         * Creates a duplicate of a #GAppInfo.
         */
        vfunc_dup(): AppInfo;
        /**
         * Checks if two #GAppInfos are equal.
         *
         * Note that the check *may not* compare each individual
         * field, and only does an identity check. In case detecting changes in the
         * contents is needed, program code must additionally compare relevant fields.
         * @param appinfo2 the second #GAppInfo.
         */
        vfunc_equal(appinfo2: AppInfo): boolean;
        /**
         * Gets the commandline with which the application will be
         * started.
         */
        vfunc_get_commandline(): string | null;
        /**
         * Gets a human-readable description of an installed application.
         */
        vfunc_get_description(): string | null;
        /**
         * Gets the display name of the application. The display name is often more
         * descriptive to the user than the name itself.
         */
        vfunc_get_display_name(): string;
        /**
         * Gets the executable's name for the installed application.
         *
         * This is intended to be used for debugging or labelling what program is going
         * to be run. To launch the executable, use g_app_info_launch() and related
         * functions, rather than spawning the return value from this function.
         */
        vfunc_get_executable(): string;
        /**
         * Gets the icon for the application.
         */
        vfunc_get_icon(): Icon | null;
        /**
         * Gets the ID of an application. An id is a string that
         * identifies the application. The exact format of the id is
         * platform dependent. For instance, on Unix this is the
         * desktop file id from the xdg menu specification.
         *
         * Note that the returned ID may be %NULL, depending on how
         * the `appinfo` has been constructed.
         */
        vfunc_get_id(): string | null;
        /**
         * Gets the installed name of the application.
         */
        vfunc_get_name(): string;
        /**
         * Retrieves the list of content types that `app_info` claims to support.
         * If this information is not provided by the environment, this function
         * will return %NULL.
         * This function does not take in consideration associations added with
         * g_app_info_add_supports_type(), but only those exported directly by
         * the application.
         */
        vfunc_get_supported_types(): string[];
        /**
         * Launches the application. Passes `files` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly.
         *
         * To launch the application without arguments pass a %NULL `files` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         *
         * Some URIs can be changed when passed through a GFile (for instance
         * unsupported URIs with strange formats like mailto:), so if you have
         * a textual URI you want to pass in as argument, consider using
         * g_app_info_launch_uris() instead.
         *
         * The launched application inherits the environment of the launching
         * process, but it can be modified with g_app_launch_context_setenv()
         * and g_app_launch_context_unsetenv().
         *
         * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
         * environment variable with the path of the launched desktop file and
         * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
         * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
         * should it be inherited by further processes. The `DISPLAY`,
         * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
         * variables are also set, based on information provided in `context`.
         * @param files a #GList of #GFile objects
         * @param context a #GAppLaunchContext or %NULL
         */
        vfunc_launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Launches the application. This passes the `uris` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly. If the application only supports
         * one URI per invocation as part of their command-line, multiple instances
         * of the application will be spawned.
         *
         * To launch the application without arguments pass a %NULL `uris` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         */
        vfunc_launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Async version of g_app_info_launch_uris().
         *
         * The `callback` is invoked immediately after the application launch, but it
         * waits for activation in case of D-Busactivated applications and also provides
         * extended error information for sandboxed applications, see notes for
         * g_app_info_launch_default_for_uri_async().
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        vfunc_launch_uris_async(
            uris?: string[] | null,
            context?: AppLaunchContext | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a g_app_info_launch_uris_async() operation.
         * @param result a #GAsyncResult
         */
        vfunc_launch_uris_finish(result: AsyncResult): boolean;
        /**
         * Removes a supported type from an application, if possible.
         * @param content_type a string.
         */
        vfunc_remove_supports_type(content_type: string): boolean;
        /**
         * Sets the application as the default handler for the given file extension.
         * @param extension a string containing the file extension     (without the dot).
         */
        vfunc_set_as_default_for_extension(extension: string): boolean;
        /**
         * Sets the application as the default handler for a given type.
         * @param content_type the content type.
         */
        vfunc_set_as_default_for_type(content_type: string): boolean;
        /**
         * Sets the application as the last used application for a given type.
         * This will make the application appear as first in the list returned
         * by g_app_info_get_recommended_for_type(), regardless of the default
         * application for that content type.
         * @param content_type the content type.
         */
        vfunc_set_as_last_used_for_type(content_type: string): boolean;
        /**
         * Checks if the application info should be shown in menus that
         * list available applications.
         */
        vfunc_should_show(): boolean;
        /**
         * Checks if the application accepts files as arguments.
         */
        vfunc_supports_files(): boolean;
        /**
         * Checks if the application supports reading files and directories from URIs.
         */
        vfunc_supports_uris(): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Emblem {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Icon.ConstructorProps {
            icon: GObject.Object;
            origin: EmblemOrigin;
        }
    }

    /**
     * `GEmblem` is an implementation of [iface`Gio`.Icon] that supports
     * having an emblem, which is an icon with additional properties.
     * It can than be added to a [class`Gio`.EmblemedIcon].
     *
     * Currently, only metainformation about the emblem's origin is
     * supported. More may be added in the future.
     */
    class Emblem extends GObject.Object implements Icon {
        static $gtype: GObject.GType<Emblem>;

        // Properties

        /**
         * The actual icon of the emblem.
         */
        get icon(): GObject.Object;
        /**
         * The origin the emblem is derived from.
         */
        get origin(): EmblemOrigin;

        // Constructors

        constructor(properties?: Partial<Emblem.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](icon: Icon): Emblem;

        static new_with_origin(icon: Icon, origin: EmblemOrigin): Emblem;

        // Methods

        /**
         * Gives back the icon from `emblem`.
         * @returns a #GIcon. The returned object belongs to          the emblem and should not be modified or freed.
         */
        get_icon(): Icon;
        /**
         * Gets the origin of the emblem.
         * @returns the origin of the emblem
         */
        get_origin(): EmblemOrigin;

        // Inherited methods
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @returns a #guint containing a hash for the @icon, suitable for   use in a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        serialize(): GLib.Variant | null;
        /**
         * Generates a textual representation of `icon` that can be used for
         * serialization such as when passing `icon` to a different process or
         * saving it to persistent storage. Use g_icon_new_for_string() to
         * get `icon` back from the returned string.
         *
         * The encoding of the returned string is proprietary to #GIcon except
         * in the following two cases
         *
         * - If `icon` is a #GFileIcon, the returned string is a native path
         *   (such as `/path/to/my icon.png`) without escaping
         *   if the #GFile for `icon` is a native file.  If the file is not
         *   native, the returned string is the result of g_file_get_uri()
         *   (such as `sftp://path/to/my%20icon.png`).
         *
         * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
         *   the encoding is simply the name (such as `network-server`).
         * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
         */
        to_string(): string | null;
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         */
        vfunc_equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         */
        vfunc_hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         */
        vfunc_serialize(): GLib.Variant | null;
        /**
         * Serializes the `icon` into string tokens.
         * This is can be invoked when g_icon_new_for_string() is called.
         */
        vfunc_to_tokens(): [boolean, string[], number];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module EmblemedIcon {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Icon.ConstructorProps {
            gicon: Icon;
        }
    }

    /**
     * `GEmblemedIcon` is an implementation of [iface`Gio`.Icon] that supports
     * adding an emblem to an icon. Adding multiple emblems to an
     * icon is ensured via [method`Gio`.EmblemedIcon.add_emblem].
     *
     * Note that `GEmblemedIcon` allows no control over the position
     * of the emblems. See also [class`Gio`.Emblem] for more information.
     */
    class EmblemedIcon extends GObject.Object implements Icon {
        static $gtype: GObject.GType<EmblemedIcon>;

        // Properties

        /**
         * The [iface`Gio`.Icon] to attach emblems to.
         */
        get gicon(): Icon;

        // Constructors

        constructor(properties?: Partial<EmblemedIcon.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](icon: Icon, emblem?: Emblem | null): EmblemedIcon;

        // Methods

        /**
         * Adds `emblem` to the #GList of #GEmblems.
         * @param emblem a #GEmblem
         */
        add_emblem(emblem: Emblem): void;
        /**
         * Removes all the emblems from `icon`.
         */
        clear_emblems(): void;
        /**
         * Gets the list of emblems for the `icon`.
         * @returns a #GList of     #GEmblems that is owned by @emblemed
         */
        get_emblems(): Emblem[];
        /**
         * Gets the main icon for `emblemed`.
         * @returns a #GIcon that is owned by @emblemed
         */
        get_icon(): Icon;

        // Inherited methods
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @returns a #guint containing a hash for the @icon, suitable for   use in a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        serialize(): GLib.Variant | null;
        /**
         * Generates a textual representation of `icon` that can be used for
         * serialization such as when passing `icon` to a different process or
         * saving it to persistent storage. Use g_icon_new_for_string() to
         * get `icon` back from the returned string.
         *
         * The encoding of the returned string is proprietary to #GIcon except
         * in the following two cases
         *
         * - If `icon` is a #GFileIcon, the returned string is a native path
         *   (such as `/path/to/my icon.png`) without escaping
         *   if the #GFile for `icon` is a native file.  If the file is not
         *   native, the returned string is the result of g_file_get_uri()
         *   (such as `sftp://path/to/my%20icon.png`).
         *
         * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
         *   the encoding is simply the name (such as `network-server`).
         * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
         */
        to_string(): string | null;
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         */
        vfunc_equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         */
        vfunc_hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         */
        vfunc_serialize(): GLib.Variant | null;
        /**
         * Serializes the `icon` into string tokens.
         * This is can be invoked when g_icon_new_for_string() is called.
         */
        vfunc_to_tokens(): [boolean, string[], number];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module FileEnumerator {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            container: File;
        }
    }

    /**
     * `GFileEnumerator` allows you to operate on a set of [iface`Gio`.File] objects,
     * returning a [class`Gio`.FileInfo] structure for each file enumerated (e.g.
     * [method`Gio`.File.enumerate_children] will return a `GFileEnumerator` for each
     * of the children within a directory).
     *
     * To get the next file's information from a `GFileEnumerator`, use
     * [method`Gio`.FileEnumerator.next_file] or its asynchronous version,
     * [method`Gio`.FileEnumerator.next_files_async]. Note that the asynchronous
     * version will return a list of [class`Gio`.FileInfo] objects, whereas the
     * synchronous will only return the next file in the enumerator.
     *
     * The ordering of returned files is unspecified for non-Unix
     * platforms; for more information, see [method`GLib`.Dir.read_name].  On Unix,
     * when operating on local files, returned files will be sorted by
     * inode number.  Effectively you can assume that the ordering of
     * returned files will be stable between successive calls (and
     * applications) assuming the directory is unchanged.
     *
     * If your application needs a specific ordering, such as by name or
     * modification time, you will have to implement that in your
     * application code.
     *
     * To close a `GFileEnumerator`, use [method`Gio`.FileEnumerator.close], or
     * its asynchronous version, [method`Gio`.FileEnumerator.close_async]. Once
     * a `GFileEnumerator` is closed, no further actions may be performed
     * on it, and it should be freed with [method`GObject`.Object.unref].
     */
    class FileEnumerator extends GObject.Object {
        static $gtype: GObject.GType<FileEnumerator>;

        // Properties

        /**
         * The container that is being enumerated.
         */
        set container(val: File);

        // Constructors

        constructor(properties?: Partial<FileEnumerator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Asynchronously closes the file enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
         * g_file_enumerator_close_finish().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
         *
         * If the file enumerator was already closed when g_file_enumerator_close_async()
         * was called, then this function will report %G_IO_ERROR_CLOSED in `error,` and
         * return %FALSE. If the file enumerator had pending operation when the close
         * operation was started, then this function will report %G_IO_ERROR_PENDING, and
         * return %FALSE.  If `cancellable` was not %NULL, then the operation may have been
         * cancelled by triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
         * returned.
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Returns information for the next file in the enumerated object.
         * Will block until the information is available. The #GFileInfo
         * returned from this function will contain attributes that match the
         * attribute string that was passed when the #GFileEnumerator was created.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * On error, returns %NULL and sets `error` to the error. If the
         * enumerator is at the end, %NULL will be returned and `error` will
         * be unset.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_next_file(cancellable?: Cancellable | null): FileInfo | null;
        /**
         * Request information for a number of files from the enumerator asynchronously.
         * When all I/O for the operation is finished the `callback` will be called with
         * the requested information.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * Once the end of the enumerator is reached, or if an error occurs, the
         * `callback` will be called with an empty list. In this case, the previous call
         * to g_file_enumerator_next_files_async() will typically have returned fewer
         * than `num_files` items.
         *
         * If a request is cancelled the callback will be called with
         * %G_IO_ERROR_CANCELLED.
         *
         * This leads to the following pseudo-code usage:
         *
         * ```
         * g_autoptr(GFile) dir = get_directory ();
         * g_autoptr(GFileEnumerator) enumerator = NULL;
         * g_autolist(GFileInfo) files = NULL;
         * g_autoptr(GError) local_error = NULL;
         *
         * enumerator = yield g_file_enumerate_children_async (dir,
         *                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
         *                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
         *                                                     G_FILE_QUERY_INFO_NONE,
         *                                                     G_PRIORITY_DEFAULT,
         *                                                     cancellable,
         *                                                     ,
         *                                                     &local_error);
         * if (enumerator == NULL)
         *   g_error ("Error enumerating: %s", local_error->message);
         *
         * // Loop until no files are returned, either because the end of the enumerator
         * // has been reached, or an error was returned.
         * do
         *   {
         *     files = yield g_file_enumerator_next_files_async (enumerator,
         *                                                       5,  // number of files to request
         *                                                       G_PRIORITY_DEFAULT,
         *                                                       cancellable,
         *                                                       ,
         *                                                       &local_error);
         *
         *     // Process the returned files, but dont assume that exactly 5 were returned.
         *     for (GList *l = files; l != NULL; l = l->next)
         *       {
         *         GFileInfo *info = l->data;
         *         handle_file_info (info);
         *       }
         *   }
         * while (files != NULL);
         *
         * if (local_error != NULL &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
         *   g_error ("Error while enumerating: %s", local_error->message);
         * ```
         *
         *
         * During an async request no other sync and async calls are allowed, and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * Any outstanding I/O request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         * @param num_files the number of file info objects to request
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_next_files_async(
            num_files: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
         * @param result a #GAsyncResult.
         */
        vfunc_next_files_finish(result: AsyncResult): FileInfo[];

        // Methods

        /**
         * Releases all resources used by this enumerator, making the
         * enumerator return %G_IO_ERROR_CLOSED on all calls.
         *
         * This will be automatically called when the last reference
         * is dropped, but you might want to call this function to make
         * sure resources are released as early as possible.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns #TRUE on success or #FALSE on error.
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously closes the file enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
         * g_file_enumerator_close_finish().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
         *
         * If the file enumerator was already closed when g_file_enumerator_close_async()
         * was called, then this function will report %G_IO_ERROR_CLOSED in `error,` and
         * return %FALSE. If the file enumerator had pending operation when the close
         * operation was started, then this function will report %G_IO_ERROR_PENDING, and
         * return %FALSE.  If `cancellable` was not %NULL, then the operation may have been
         * cancelled by triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
         * returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the close operation has finished successfully.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Return a new #GFile which refers to the file named by `info` in the source
         * directory of `enumerator`.  This function is primarily intended to be used
         * inside loops with g_file_enumerator_next_file().
         *
         * To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
         * attributes list used when creating the #GFileEnumerator.
         *
         * This is a convenience method that's equivalent to:
         *
         * ```c
         *   gchar *name = g_file_info_get_name (info);
         *   GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
         *                                    name);
         * ```
         *
         * @param info a #GFileInfo gotten from g_file_enumerator_next_file()   or the async equivalents.
         * @returns a #GFile for the #GFileInfo passed it.
         */
        get_child(info: FileInfo): File;
        /**
         * Get the #GFile container which is being enumerated.
         * @returns the #GFile which is being enumerated.
         */
        get_container(): File;
        /**
         * Checks if the file enumerator has pending operations.
         * @returns %TRUE if the @enumerator has pending operations.
         */
        has_pending(): boolean;
        /**
         * Checks if the file enumerator has been closed.
         * @returns %TRUE if the @enumerator is closed.
         */
        is_closed(): boolean;
        /**
         * This is a version of g_file_enumerator_next_file() that's easier to
         * use correctly from C programs.  With g_file_enumerator_next_file(),
         * the gboolean return value signifies "end of iteration or error", which
         * requires allocation of a temporary #GError.
         *
         * In contrast, with this function, a %FALSE return from
         * g_file_enumerator_iterate() *always* means
         * "error".  End of iteration is signaled by `out_info` or `out_child` being %NULL.
         *
         * Another crucial difference is that the references for `out_info` and
         * `out_child` are owned by `direnum` (they are cached as hidden
         * properties).  You must not unref them in your own code.  This makes
         * memory management significantly easier for C code in combination
         * with loops.
         *
         * Finally, this function optionally allows retrieving a #GFile as
         * well.
         *
         * You must specify at least one of `out_info` or `out_child`.
         *
         * The code pattern for correctly using g_file_enumerator_iterate() from C
         * is:
         *
         *
         * ```
         * direnum = g_file_enumerate_children (file, ...);
         * while (TRUE)
         *   {
         *     GFileInfo *info;
         *     if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
         *       goto out;
         *     if (!info)
         *       break;
         *     ... do stuff with "info"; do not unref it! ...
         *   }
         *
         * out:
         *   g_object_unref (direnum); // Note: frees the last `info`
         * ```
         *
         * @param cancellable a #GCancellable
         */
        iterate(cancellable?: Cancellable | null): [boolean, FileInfo | null, File | null];
        /**
         * Returns information for the next file in the enumerated object.
         * Will block until the information is available. The #GFileInfo
         * returned from this function will contain attributes that match the
         * attribute string that was passed when the #GFileEnumerator was created.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * On error, returns %NULL and sets `error` to the error. If the
         * enumerator is at the end, %NULL will be returned and `error` will
         * be unset.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns A #GFileInfo or %NULL on error    or end of enumerator.  Free the returned object with    g_object_unref() when no longer needed.
         */
        next_file(cancellable?: Cancellable | null): FileInfo | null;
        /**
         * Request information for a number of files from the enumerator asynchronously.
         * When all I/O for the operation is finished the `callback` will be called with
         * the requested information.
         *
         * See the documentation of #GFileEnumerator for information about the
         * order of returned files.
         *
         * Once the end of the enumerator is reached, or if an error occurs, the
         * `callback` will be called with an empty list. In this case, the previous call
         * to g_file_enumerator_next_files_async() will typically have returned fewer
         * than `num_files` items.
         *
         * If a request is cancelled the callback will be called with
         * %G_IO_ERROR_CANCELLED.
         *
         * This leads to the following pseudo-code usage:
         *
         * ```
         * g_autoptr(GFile) dir = get_directory ();
         * g_autoptr(GFileEnumerator) enumerator = NULL;
         * g_autolist(GFileInfo) files = NULL;
         * g_autoptr(GError) local_error = NULL;
         *
         * enumerator = yield g_file_enumerate_children_async (dir,
         *                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
         *                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
         *                                                     G_FILE_QUERY_INFO_NONE,
         *                                                     G_PRIORITY_DEFAULT,
         *                                                     cancellable,
         *                                                     ,
         *                                                     &local_error);
         * if (enumerator == NULL)
         *   g_error ("Error enumerating: %s", local_error->message);
         *
         * // Loop until no files are returned, either because the end of the enumerator
         * // has been reached, or an error was returned.
         * do
         *   {
         *     files = yield g_file_enumerator_next_files_async (enumerator,
         *                                                       5,  // number of files to request
         *                                                       G_PRIORITY_DEFAULT,
         *                                                       cancellable,
         *                                                       ,
         *                                                       &local_error);
         *
         *     // Process the returned files, but dont assume that exactly 5 were returned.
         *     for (GList *l = files; l != NULL; l = l->next)
         *       {
         *         GFileInfo *info = l->data;
         *         handle_file_info (info);
         *       }
         *   }
         * while (files != NULL);
         *
         * if (local_error != NULL &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
         *   g_error ("Error while enumerating: %s", local_error->message);
         * ```
         *
         *
         * During an async request no other sync and async calls are allowed, and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * Any outstanding I/O request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         * @param num_files the number of file info objects to request
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        next_files_async(
            num_files: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
         * @param result a #GAsyncResult.
         * @returns a #GList of #GFileInfos. You must free the list with     g_list_free() and unref the infos with g_object_unref() when you're     done with them.
         */
        next_files_finish(result: AsyncResult): FileInfo[];
        /**
         * Sets the file enumerator as having pending operations.
         * @param pending a boolean value.
         */
        set_pending(pending: boolean): void;
    }

    module FileIOStream {
        // Constructor properties interface

        interface ConstructorProps extends IOStream.ConstructorProps, Seekable.ConstructorProps {}
    }

    /**
     * `GFileIOStream` provides I/O streams that both read and write to the same
     * file handle.
     *
     * `GFileIOStream` implements [iface`Gio`.Seekable], which allows the I/O
     * stream to jump to arbitrary positions in the file and to truncate
     * the file, provided the filesystem of the file supports these
     * operations.
     *
     * To find the position of a file I/O stream, use [method`Gio`.Seekable.tell].
     *
     * To find out if a file I/O stream supports seeking, use
     * [method`Gio`.Seekable.can_seek]. To position a file I/O stream, use
     * [method`Gio`.Seekable.seek]. To find out if a file I/O stream supports
     * truncating, use [method`Gio`.Seekable.can_truncate]. To truncate a file I/O
     * stream, use [method`Gio`.Seekable.truncate].
     *
     * The default implementation of all the `GFileIOStream` operations
     * and the implementation of [iface`Gio`.Seekable] just call into the same
     * operations on the output stream.
     */
    class FileIOStream extends IOStream implements Seekable {
        static $gtype: GObject.GType<FileIOStream>;

        // Constructors

        constructor(properties?: Partial<FileIOStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        vfunc_can_seek(): boolean;
        vfunc_can_truncate(): boolean;
        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         */
        vfunc_get_etag(): string | null;
        /**
         * Queries a file io stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_io_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). I
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_io_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_io_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the   request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finalizes the asynchronous query started
         * by g_file_io_stream_query_info_async().
         * @param result a #GAsyncResult.
         */
        vfunc_query_info_finish(result: AsyncResult): FileInfo;
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        vfunc_tell(): number;
        vfunc_truncate_fn(size: number, cancellable?: Cancellable | null): boolean;

        // Methods

        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         * @returns the entity tag for the stream.
         */
        get_etag(): string | null;
        /**
         * Queries a file io stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_io_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). I
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo for the @stream, or %NULL on error.
         */
        query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_io_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_io_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the   request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finalizes the asynchronous query started
         * by g_file_io_stream_query_info_async().
         * @param result a #GAsyncResult.
         * @returns A #GFileInfo for the finished query.
         */
        query_info_finish(result: AsyncResult): FileInfo;

        // Inherited methods
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module FileIcon {
        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                Icon.ConstructorProps,
                LoadableIcon.ConstructorProps {
            file: File;
        }
    }

    /**
     * `GFileIcon` specifies an icon by pointing to an image file
     * to be used as icon.
     *
     * It implements [iface`Gio`.LoadableIcon].
     */
    class FileIcon extends GObject.Object implements Icon, LoadableIcon {
        static $gtype: GObject.GType<FileIcon>;

        // Properties

        /**
         * The file containing the icon.
         */
        get file(): File;

        // Constructors

        constructor(properties?: Partial<FileIcon.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](file: File): FileIcon;

        // Methods

        /**
         * Gets the #GFile associated with the given `icon`.
         * @returns a #GFile.
         */
        get_file(): File;

        // Inherited methods
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @returns a #guint containing a hash for the @icon, suitable for   use in a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        serialize(): GLib.Variant | null;
        /**
         * Generates a textual representation of `icon` that can be used for
         * serialization such as when passing `icon` to a different process or
         * saving it to persistent storage. Use g_icon_new_for_string() to
         * get `icon` back from the returned string.
         *
         * The encoding of the returned string is proprietary to #GIcon except
         * in the following two cases
         *
         * - If `icon` is a #GFileIcon, the returned string is a native path
         *   (such as `/path/to/my icon.png`) without escaping
         *   if the #GFile for `icon` is a native file.  If the file is not
         *   native, the returned string is the result of g_file_get_uri()
         *   (such as `sftp://path/to/my%20icon.png`).
         *
         * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
         *   the encoding is simply the name (such as `network-server`).
         * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
         */
        to_string(): string | null;
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         */
        vfunc_equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         */
        vfunc_hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         */
        vfunc_serialize(): GLib.Variant | null;
        /**
         * Serializes the `icon` into string tokens.
         * This is can be invoked when g_icon_new_for_string() is called.
         */
        vfunc_to_tokens(): [boolean, string[], number];
        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GInputStream to read the icon from.
         */
        load(size: number, cancellable?: Cancellable | null): [InputStream, string];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        load_async(size: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @param res a #GAsyncResult.
         * @returns a #GInputStream to read the icon from.
         */
        load_finish(res: AsyncResult): [InputStream, string];
        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_load(size: number, cancellable?: Cancellable | null): [InputStream, string];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_load_async(
            size: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @param res a #GAsyncResult.
         */
        vfunc_load_finish(res: AsyncResult): [InputStream, string];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module FileInfo {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * Stores information about a file system object referenced by a [iface`Gio`.File].
     *
     * Functionality for manipulating basic metadata for files. `GFileInfo`
     * implements methods for getting information that all files should
     * contain, and allows for manipulation of extended attributes.
     *
     * See [file-attributes.html](file attributes) for more information on how GIO
     * handles file attributes.
     *
     * To obtain a `GFileInfo` for a [iface`Gio`.File], use
     * [method`Gio`.File.query_info] (or its async variant). To obtain a `GFileInfo`
     * for a file input or output stream, use [method`Gio`.FileInputStream.query_info]
     * or [method`Gio`.FileOutputStream.query_info] (or their async variants).
     *
     * To change the actual attributes of a file, you should then set the
     * attribute in the `GFileInfo` and call [method`Gio`.File.set_attributes_from_info]
     * or [method`Gio`.File.set_attributes_async] on a `GFile`.
     *
     * However, not all attributes can be changed in the file. For instance,
     * the actual size of a file cannot be changed via [method`Gio`.FileInfo.set_size].
     * You may call [method`Gio`.File.query_settable_attributes] and
     * [method`Gio`.File.query_writable_namespaces] to discover the settable attributes
     * of a particular file at runtime.
     *
     * The direct accessors, such as [method`Gio`.FileInfo.get_name], are slightly more
     * optimized than the generic attribute accessors, such as
     * [method`Gio`.FileInfo.get_attribute_byte_string].This optimization will matter
     * only if calling the API in a tight loop.
     *
     * It is an error to call these accessors without specifying their required file
     * attributes when creating the `GFileInfo`. Use
     * [method`Gio`.FileInfo.has_attribute] or [method`Gio`.FileInfo.list_attributes]
     * to check what attributes are specified for a `GFileInfo`.
     *
     * [struct`Gio`.FileAttributeMatcher] allows for searching through a `GFileInfo`
     * for attributes.
     */
    class FileInfo extends GObject.Object {
        static $gtype: GObject.GType<FileInfo>;

        // Constructors

        constructor(properties?: Partial<FileInfo.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): FileInfo;

        // Methods

        /**
         * Clears the status information from `info`.
         */
        clear_status(): void;
        /**
         * First clears all of the [GFileAttribute][gio-GFileAttribute] of `dest_info,`
         * and then copies all of the file attributes from `src_info` to `dest_info`.
         * @param dest_info destination to copy attributes to.
         */
        copy_into(dest_info: FileInfo): void;
        /**
         * Duplicates a file info structure.
         * @returns a duplicate #GFileInfo of @other.
         */
        dup(): FileInfo;
        /**
         * Gets the access time of the current `info` and returns it as a
         * #GDateTime.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_ACCESS. If %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC is
         * provided, the resulting #GDateTime will additionally have microsecond
         * precision.
         *
         * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC must
         * be queried separately using g_file_info_get_attribute_uint32().
         * @returns access time, or %NULL if unknown
         */
        get_access_date_time(): GLib.DateTime | null;
        /**
         * Gets the value of an attribute, formatted as a string.
         * This escapes things as needed to make the string valid
         * UTF-8.
         * @param attribute a file attribute key.
         * @returns a UTF-8 string associated with the given @attribute, or    %NULL if the attribute wasnt set.    When you're done with the string it must be freed with g_free().
         */
        get_attribute_as_string(attribute: string): string | null;
        /**
         * Gets the value of a boolean attribute. If the attribute does not
         * contain a boolean value, %FALSE will be returned.
         * @param attribute a file attribute key.
         * @returns the boolean value contained within the attribute.
         */
        get_attribute_boolean(attribute: string): boolean;
        /**
         * Gets the value of a byte string attribute. If the attribute does
         * not contain a byte string, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a byte string, or %NULL otherwise.
         */
        get_attribute_byte_string(attribute: string): string | null;
        /**
         * Gets the attribute type, value and status for an attribute key.
         * @param attribute a file attribute key
         * @returns %TRUE if @info has an attribute named @attribute,      %FALSE otherwise.
         */
        get_attribute_data(attribute: string): [boolean, FileAttributeType | null, any, FileAttributeStatus | null];
        /**
         * Gets the value of a byte string attribute as a file path.
         *
         * If the attribute does not contain a byte string, `NULL` will be returned.
         *
         * This function is meant to be used by language bindings that have specific
         * handling for Unix paths.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a file path, or %NULL otherwise.
         */
        get_attribute_file_path(attribute: string): string | null;
        /**
         * Gets a signed 32-bit integer contained within the attribute. If the
         * attribute does not contain a signed 32-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns a signed 32-bit integer from the attribute.
         */
        get_attribute_int32(attribute: string): number;
        /**
         * Gets a signed 64-bit integer contained within the attribute. If the
         * attribute does not contain a signed 64-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns a signed 64-bit integer from the attribute.
         */
        get_attribute_int64(attribute: string): number;
        /**
         * Gets the value of a #GObject attribute. If the attribute does
         * not contain a #GObject, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns a #GObject associated with the given @attribute, or %NULL otherwise.
         */
        get_attribute_object<T = GObject.Object>(attribute: string): T;
        /**
         * Gets the attribute status for an attribute key.
         * @param attribute a file attribute key
         * @returns a #GFileAttributeStatus for the given @attribute, or    %G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.
         */
        get_attribute_status(attribute: string): FileAttributeStatus;
        /**
         * Gets the value of a string attribute. If the attribute does
         * not contain a string, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a UTF-8 string, or %NULL otherwise.
         */
        get_attribute_string(attribute: string): string | null;
        /**
         * Gets the value of a stringv attribute. If the attribute does
         * not contain a stringv, %NULL will be returned.
         * @param attribute a file attribute key.
         * @returns the contents of the @attribute value as a stringv, or %NULL otherwise. Do not free. These returned strings are UTF-8.
         */
        get_attribute_stringv(attribute: string): string[] | null;
        /**
         * Gets the attribute type for an attribute key.
         * @param attribute a file attribute key.
         * @returns a #GFileAttributeType for the given @attribute, or %G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.
         */
        get_attribute_type(attribute: string): FileAttributeType;
        /**
         * Gets an unsigned 32-bit integer contained within the attribute. If the
         * attribute does not contain an unsigned 32-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns an unsigned 32-bit integer from the attribute.
         */
        get_attribute_uint32(attribute: string): number;
        /**
         * Gets a unsigned 64-bit integer contained within the attribute. If the
         * attribute does not contain an unsigned 64-bit integer, or is invalid,
         * 0 will be returned.
         * @param attribute a file attribute key.
         * @returns a unsigned 64-bit integer from the attribute.
         */
        get_attribute_uint64(attribute: string): number;
        /**
         * Gets the file's content type.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
         * @returns a string containing the file's content type, or %NULL if unknown.
         */
        get_content_type(): string | null;
        /**
         * Gets the creation time of the current `info` and returns it as a
         * #GDateTime.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_CREATED. If %G_FILE_ATTRIBUTE_TIME_CREATED_USEC is
         * provided, the resulting #GDateTime will additionally have microsecond
         * precision.
         *
         * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC must
         * be queried separately using g_file_info_get_attribute_uint32().
         * @returns creation time, or %NULL if unknown
         */
        get_creation_date_time(): GLib.DateTime | null;
        /**
         * Returns the #GDateTime representing the deletion date of the file, as
         * available in %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
         * %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.
         * @returns a #GDateTime, or %NULL.
         */
        get_deletion_date(): GLib.DateTime | null;
        /**
         * Gets a display name for a file. This is guaranteed to always be set.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
         * @returns a string containing the display name.
         */
        get_display_name(): string;
        /**
         * Gets the edit name for a file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
         * @returns a string containing the edit name.
         */
        get_edit_name(): string;
        /**
         * Gets the [entity tag](iface.File.html#entity-tags) for a given
         * #GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_ETAG_VALUE.
         * @returns a string containing the value of the "etag:value" attribute.
         */
        get_etag(): string | null;
        /**
         * Gets a file's type (whether it is a regular file, symlink, etc).
         * This is different from the file's content type, see g_file_info_get_content_type().
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_TYPE.
         * @returns a #GFileType for the given file.
         */
        get_file_type(): FileType;
        /**
         * Gets the icon for a file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_ICON.
         * @returns #GIcon for the given @info.
         */
        get_icon(): Icon | null;
        /**
         * Checks if a file is a backup file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
         * @returns %TRUE if file is a backup file, %FALSE otherwise.
         */
        get_is_backup(): boolean;
        /**
         * Checks if a file is hidden.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
         * @returns %TRUE if the file is a hidden file, %FALSE otherwise.
         */
        get_is_hidden(): boolean;
        /**
         * Checks if a file is a symlink.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
         * @returns %TRUE if the given @info is a symlink.
         */
        get_is_symlink(): boolean;
        /**
         * Gets the modification time of the current `info` and returns it as a
         * #GDateTime.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
         * provided, the resulting #GDateTime will additionally have microsecond
         * precision.
         *
         * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC must
         * be queried separately using g_file_info_get_attribute_uint32().
         * @returns modification time, or %NULL if unknown
         */
        get_modification_date_time(): GLib.DateTime | null;
        /**
         * Gets the modification time of the current `info` and sets it
         * in `result`.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
         * provided it will be used too.
         */
        get_modification_time(): GLib.TimeVal;
        /**
         * Gets the name for a file. This is guaranteed to always be set.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_NAME.
         * @returns a string containing the file name.
         */
        get_name(): string;
        /**
         * Gets the file's size (in bytes). The size is retrieved through the value of
         * the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
         * from #guint64 to #goffset before returning the result.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SIZE.
         * @returns a #goffset containing the file's size (in bytes).
         */
        get_size(): number;
        /**
         * Gets the value of the sort_order attribute from the #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
         * @returns a #gint32 containing the value of the "standard::sort_order" attribute.
         */
        get_sort_order(): number;
        /**
         * Gets the symbolic icon for a file.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
         * @returns #GIcon for the given @info.
         */
        get_symbolic_icon(): Icon | null;
        /**
         * Gets the symlink target for a given #GFileInfo.
         *
         * It is an error to call this if the #GFileInfo does not contain
         * %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
         * @returns a string containing the symlink target.
         */
        get_symlink_target(): string | null;
        /**
         * Checks if a file info structure has an attribute named `attribute`.
         * @param attribute a file attribute key.
         * @returns %TRUE if @info has an attribute named @attribute,     %FALSE otherwise.
         */
        has_attribute(attribute: string): boolean;
        /**
         * Checks if a file info structure has an attribute in the
         * specified `name_space`.
         * @param name_space a file attribute namespace.
         * @returns %TRUE if @info has an attribute in @name_space,     %FALSE otherwise.
         */
        has_namespace(name_space: string): boolean;
        /**
         * Lists the file info structure's attributes.
         * @param name_space a file attribute key's namespace, or %NULL to list   all attributes.
         * @returns a null-terminated array of strings of all of the possible attribute types for the given @name_space, or %NULL on error.
         */
        list_attributes(name_space?: string | null): string[] | null;
        /**
         * Removes all cases of `attribute` from `info` if it exists.
         * @param attribute a file attribute key.
         */
        remove_attribute(attribute: string): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_ACCESS and
         * %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC attributes in the file info to the
         * given date/time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC will be cleared.
         * @param atime a #GDateTime.
         */
        set_access_date_time(atime: GLib.DateTime): void;
        /**
         * Sets the `attribute` to contain the given value, if possible. To unset the
         * attribute, use %G_FILE_ATTRIBUTE_TYPE_INVALID for `type`.
         * @param attribute a file attribute key.
         * @param type a #GFileAttributeType
         * @param value_p pointer to the value
         */
        set_attribute(attribute: string, type: FileAttributeType, value_p: any): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a boolean value.
         */
        set_attribute_boolean(attribute: string, attr_value: boolean): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a byte string.
         */
        set_attribute_byte_string(attribute: string, attr_value: string): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         *
         * This function is meant to be used by language bindings that have specific
         * handling for Unix paths.
         * @param attribute a file attribute key.
         * @param attr_value a file path.
         */
        set_attribute_file_path(attribute: string, attr_value: string): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a signed 32-bit integer
         */
        set_attribute_int32(attribute: string, attr_value: number): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute attribute name to set.
         * @param attr_value int64 value to set attribute to.
         */
        set_attribute_int64(attribute: string, attr_value: number): void;
        /**
         * Sets `mask` on `info` to match specific attribute types.
         * @param mask a #GFileAttributeMatcher.
         */
        set_attribute_mask(mask: FileAttributeMatcher): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a #GObject.
         */
        set_attribute_object(attribute: string, attr_value: GObject.Object): void;
        /**
         * Sets the attribute status for an attribute key. This is only
         * needed by external code that implement g_file_set_attributes_from_info()
         * or similar functions.
         *
         * The attribute must exist in `info` for this to work. Otherwise %FALSE
         * is returned and `info` is unchanged.
         * @param attribute a file attribute key
         * @param status a #GFileAttributeStatus
         * @returns %TRUE if the status was changed, %FALSE if the key was not set.
         */
        set_attribute_status(attribute: string, status: FileAttributeStatus): boolean;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value a UTF-8 string.
         */
        set_attribute_string(attribute: string, attr_value: string): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         *
         * Sinze: 2.22
         * @param attribute a file attribute key
         * @param attr_value a %NULL   terminated array of UTF-8 strings.
         */
        set_attribute_stringv(attribute: string, attr_value: string[]): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value an unsigned 32-bit integer.
         */
        set_attribute_uint32(attribute: string, attr_value: number): void;
        /**
         * Sets the `attribute` to contain the given `attr_value,`
         * if possible.
         * @param attribute a file attribute key.
         * @param attr_value an unsigned 64-bit integer.
         */
        set_attribute_uint64(attribute: string, attr_value: number): void;
        /**
         * Sets the content type attribute for a given #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
         * @param content_type a content type. See [GContentType][gio-GContentType]
         */
        set_content_type(content_type: string): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_CREATED and
         * %G_FILE_ATTRIBUTE_TIME_CREATED_USEC attributes in the file info to the
         * given date/time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC will be cleared.
         * @param creation_time a #GDateTime.
         */
        set_creation_date_time(creation_time: GLib.DateTime): void;
        /**
         * Sets the display name for the current #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
         * @param display_name a string containing a display name.
         */
        set_display_name(display_name: string): void;
        /**
         * Sets the edit name for the current file.
         * See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
         * @param edit_name a string containing an edit name.
         */
        set_edit_name(edit_name: string): void;
        /**
         * Sets the file type in a #GFileInfo to `type`.
         * See %G_FILE_ATTRIBUTE_STANDARD_TYPE.
         * @param type a #GFileType.
         */
        set_file_type(type: FileType): void;
        /**
         * Sets the icon for a given #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_ICON.
         * @param icon a #GIcon.
         */
        set_icon(icon: Icon): void;
        /**
         * Sets the "is_hidden" attribute in a #GFileInfo according to `is_hidden`.
         * See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
         * @param is_hidden a #gboolean.
         */
        set_is_hidden(is_hidden: boolean): void;
        /**
         * Sets the "is_symlink" attribute in a #GFileInfo according to `is_symlink`.
         * See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
         * @param is_symlink a #gboolean.
         */
        set_is_symlink(is_symlink: boolean): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
         * given date/time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
         * @param mtime a #GDateTime.
         */
        set_modification_date_time(mtime: GLib.DateTime): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
         * given time value.
         *
         * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
         * @param mtime a #GTimeVal.
         */
        set_modification_time(mtime: GLib.TimeVal): void;
        /**
         * Sets the name attribute for the current #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_NAME.
         * @param name a string containing a name.
         */
        set_name(name: string): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
         * to the given size.
         * @param size a #goffset containing the file's size.
         */
        set_size(size: number): void;
        /**
         * Sets the sort order attribute in the file info structure. See
         * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
         * @param sort_order a sort order integer.
         */
        set_sort_order(sort_order: number): void;
        /**
         * Sets the symbolic icon for a given #GFileInfo.
         * See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
         * @param icon a #GIcon.
         */
        set_symbolic_icon(icon: Icon): void;
        /**
         * Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
         * to the given symlink target.
         * @param symlink_target a static string containing a path to a symlink target.
         */
        set_symlink_target(symlink_target: string): void;
        /**
         * Unsets a mask set by g_file_info_set_attribute_mask(), if one
         * is set.
         */
        unset_attribute_mask(): void;
    }

    module FileInputStream {
        // Constructor properties interface

        interface ConstructorProps extends InputStream.ConstructorProps, Seekable.ConstructorProps {}
    }

    /**
     * `GFileInputStream` provides input streams that take their
     * content from a file.
     *
     * `GFileInputStream` implements [iface`Gio`.Seekable], which allows the input
     * stream to jump to arbitrary positions in the file, provided the
     * filesystem of the file allows it. To find the position of a file
     * input stream, use [method`Gio`.Seekable.tell]. To find out if a file input
     * stream supports seeking, use [vfunc`Gio`.Seekable.can_seek].
     * To position a file input stream, use [vfunc`Gio`.Seekable.seek].
     */
    class FileInputStream extends InputStream implements Seekable {
        static $gtype: GObject.GType<FileInputStream>;

        // Constructors

        constructor(properties?: Partial<FileInputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        vfunc_can_seek(): boolean;
        /**
         * Queries a file input stream the given `attributes`. This function blocks
         * while querying the stream. For the asynchronous (non-blocking) version
         * of this function, see g_file_input_stream_query_info_async(). While the
         * stream is blocked, the stream will set the pending flag internally, and
         * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Queries the stream information asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_file_input_stream_query_info_finish()
         * to get the result of the operation.
         *
         * For the synchronous version of this function,
         * see g_file_input_stream_query_info().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous info query operation.
         * @param result a #GAsyncResult.
         */
        vfunc_query_info_finish(result: AsyncResult): FileInfo;
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        vfunc_tell(): number;

        // Methods

        /**
         * Queries a file input stream the given `attributes`. This function blocks
         * while querying the stream. For the asynchronous (non-blocking) version
         * of this function, see g_file_input_stream_query_info_async(). While the
         * stream is blocked, the stream will set the pending flag internally, and
         * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo, or %NULL on error.
         */
        query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Queries the stream information asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_file_input_stream_query_info_finish()
         * to get the result of the operation.
         *
         * For the synchronous version of this function,
         * see g_file_input_stream_query_info().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous info query operation.
         * @param result a #GAsyncResult.
         * @returns #GFileInfo.
         */
        query_info_finish(result: AsyncResult): FileInfo;

        // Inherited methods
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module FileMonitor {
        // Signal callback interfaces

        interface Changed {
            (file: File, other_file: File | null, event_type: FileMonitorEvent): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            cancelled: boolean;
            rate_limit: number;
            rateLimit: number;
        }
    }

    /**
     * Monitors a file or directory for changes.
     *
     * To obtain a `GFileMonitor` for a file or directory, use
     * [method`Gio`.File.monitor], [method`Gio`.File.monitor_file], or
     * [method`Gio`.File.monitor_directory].
     *
     * To get informed about changes to the file or directory you are
     * monitoring, connect to the [signal`Gio`.FileMonitor::changed] signal. The
     * signal will be emitted in the thread-default main context (see
     * [method`GLib`.MainContext.push_thread_default]) of the thread that the monitor
     * was created in (though if the global default main context is blocked, this
     * may cause notifications to be blocked even if the thread-default
     * context is still running).
     */
    abstract class FileMonitor extends GObject.Object {
        static $gtype: GObject.GType<FileMonitor>;

        // Properties

        /**
         * Whether the monitor has been cancelled.
         */
        get cancelled(): boolean;
        /**
         * The limit of the monitor to watch for changes, in milliseconds.
         */
        get rate_limit(): number;
        set rate_limit(val: number);
        /**
         * The limit of the monitor to watch for changes, in milliseconds.
         */
        get rateLimit(): number;
        set rateLimit(val: number);

        // Constructors

        constructor(properties?: Partial<FileMonitor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'changed',
            callback: (_source: this, file: File, other_file: File | null, event_type: FileMonitorEvent) => void,
        ): number;
        connect_after(
            signal: 'changed',
            callback: (_source: this, file: File, other_file: File | null, event_type: FileMonitorEvent) => void,
        ): number;
        emit(signal: 'changed', file: File, other_file: File | null, event_type: FileMonitorEvent): void;

        // Virtual methods

        /**
         * Cancels a file monitor.
         */
        vfunc_cancel(): boolean;
        vfunc_changed(file: File, other_file: File, event_type: FileMonitorEvent): void;

        // Methods

        /**
         * Cancels a file monitor.
         * @returns always %TRUE
         */
        cancel(): boolean;
        /**
         * Emits the #GFileMonitor::changed signal if a change
         * has taken place. Should be called from file monitor
         * implementations only.
         *
         * Implementations are responsible to call this method from the
         * [thread-default main context][g-main-context-push-thread-default] of the
         * thread that the monitor was created in.
         * @param child a #GFile.
         * @param other_file a #GFile.
         * @param event_type a set of #GFileMonitorEvent flags.
         */
        emit_event(child: File, other_file: File, event_type: FileMonitorEvent): void;
        /**
         * Returns whether the monitor is canceled.
         * @returns %TRUE if monitor is canceled. %FALSE otherwise.
         */
        is_cancelled(): boolean;
        /**
         * Sets the rate limit to which the `monitor` will report
         * consecutive change events to the same file.
         * @param limit_msecs a non-negative integer with the limit in milliseconds     to poll for changes
         */
        set_rate_limit(limit_msecs: number): void;
    }

    module FileOutputStream {
        // Constructor properties interface

        interface ConstructorProps extends OutputStream.ConstructorProps, Seekable.ConstructorProps {}
    }

    /**
     * `GFileOutputStream` provides output streams that write their
     * content to a file.
     *
     * `GFileOutputStream` implements [iface`Gio`.Seekable], which allows the output
     * stream to jump to arbitrary positions in the file and to truncate
     * the file, provided the filesystem of the file supports these
     * operations.
     *
     * To find the position of a file output stream, use [method`Gio`.Seekable.tell].
     * To find out if a file output stream supports seeking, use
     * [method`Gio`.Seekable.can_seek].To position a file output stream, use
     * [method`Gio`.Seekable.seek]. To find out if a file output stream supports
     * truncating, use [method`Gio`.Seekable.can_truncate]. To truncate a file output
     * stream, use [method`Gio`.Seekable.truncate].
     */
    class FileOutputStream extends OutputStream implements Seekable {
        static $gtype: GObject.GType<FileOutputStream>;

        // Constructors

        constructor(properties?: Partial<FileOutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        vfunc_can_seek(): boolean;
        vfunc_can_truncate(): boolean;
        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         */
        vfunc_get_etag(): string | null;
        /**
         * Queries a file output stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_output_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). In
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_output_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_output_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the   request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finalizes the asynchronous query started
         * by g_file_output_stream_query_info_async().
         * @param result a #GAsyncResult.
         */
        vfunc_query_info_finish(result: AsyncResult): FileInfo;
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        vfunc_tell(): number;
        vfunc_truncate_fn(size: number, cancellable?: Cancellable | null): boolean;

        // Methods

        /**
         * Gets the entity tag for the file when it has been written.
         * This must be called after the stream has been written
         * and closed, as the etag can change while writing.
         * @returns the entity tag for the stream.
         */
        get_etag(): string | null;
        /**
         * Queries a file output stream for the given `attributes`.
         * This function blocks while querying the stream. For the asynchronous
         * version of this function, see g_file_output_stream_query_info_async().
         * While the stream is blocked, the stream will set the pending flag
         * internally, and any other operations on the stream will fail with
         * %G_IO_ERROR_PENDING.
         *
         * Can fail if the stream was already closed (with `error` being set to
         * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
         * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
         * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). In
         * all cases of failure, %NULL will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
         * be returned.
         * @param attributes a file attribute query string.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GFileInfo for the @stream, or %NULL on error.
         */
        query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously queries the `stream` for a #GFileInfo. When completed,
         * `callback` will be called with a #GAsyncResult which can be used to
         * finish the operation with g_file_output_stream_query_info_finish().
         *
         * For the synchronous version of this function, see
         * g_file_output_stream_query_info().
         * @param attributes a file attribute query string.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the   request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback callback to call when the request is satisfied
         */
        query_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finalizes the asynchronous query started
         * by g_file_output_stream_query_info_async().
         * @param result a #GAsyncResult.
         * @returns A #GFileInfo for the finished query.
         */
        query_info_finish(result: AsyncResult): FileInfo;

        // Inherited methods
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module FilenameCompleter {
        // Signal callback interfaces

        interface GotCompletionData {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * Completes partial file and directory names given a partial string by
     * looking in the file system for clues. Can return a list of possible
     * completion strings for widget implementations.
     */
    class FilenameCompleter extends GObject.Object {
        static $gtype: GObject.GType<FilenameCompleter>;

        // Constructors

        constructor(properties?: Partial<FilenameCompleter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): FilenameCompleter;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'got-completion-data', callback: (_source: this) => void): number;
        connect_after(signal: 'got-completion-data', callback: (_source: this) => void): number;
        emit(signal: 'got-completion-data'): void;

        // Virtual methods

        vfunc_got_completion_data(): void;

        // Methods

        /**
         * Obtains a completion for `initial_text` from `completer`.
         * @param initial_text text to be completed.
         * @returns a completed string, or %NULL if no     completion exists. This string is not owned by GIO, so remember to g_free()     it when finished.
         */
        get_completion_suffix(initial_text: string): string | null;
        /**
         * Gets an array of completion strings for a given initial text.
         * @param initial_text text to be completed.
         * @returns array of strings with possible completions for @initial_text. This array must be freed by g_strfreev() when finished.
         */
        get_completions(initial_text: string): string[];
        /**
         * If `dirs_only` is %TRUE, `completer` will only
         * complete directory names, and not file names.
         * @param dirs_only a #gboolean.
         */
        set_dirs_only(dirs_only: boolean): void;
    }

    module FilterInputStream {
        // Constructor properties interface

        interface ConstructorProps extends InputStream.ConstructorProps {
            base_stream: InputStream;
            baseStream: InputStream;
            close_base_stream: boolean;
            closeBaseStream: boolean;
        }
    }

    /**
     * Base class for input stream implementations that perform some
     * kind of filtering operation on a base stream. Typical examples
     * of filtering operations are character set conversion, compression
     * and byte order flipping.
     */
    abstract class FilterInputStream extends InputStream {
        static $gtype: GObject.GType<FilterInputStream>;

        // Properties

        /**
         * The underlying base stream on which the I/O ops will be done.
         */
        get base_stream(): InputStream;
        /**
         * The underlying base stream on which the I/O ops will be done.
         */
        get baseStream(): InputStream;
        /**
         * Whether the base stream should be closed when the filter stream is closed.
         */
        get close_base_stream(): boolean;
        set close_base_stream(val: boolean);
        /**
         * Whether the base stream should be closed when the filter stream is closed.
         */
        get closeBaseStream(): boolean;
        set closeBaseStream(val: boolean);

        // Constructors

        constructor(properties?: Partial<FilterInputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Gets the base stream for the filter stream.
         * @returns a #GInputStream.
         */
        get_base_stream(): InputStream;
        /**
         * Returns whether the base stream will be closed when `stream` is
         * closed.
         * @returns %TRUE if the base stream will be closed.
         */
        get_close_base_stream(): boolean;
        /**
         * Sets whether the base stream will be closed when `stream` is closed.
         * @param close_base %TRUE to close the base stream.
         */
        set_close_base_stream(close_base: boolean): void;
    }

    module FilterOutputStream {
        // Constructor properties interface

        interface ConstructorProps extends OutputStream.ConstructorProps {
            base_stream: OutputStream;
            baseStream: OutputStream;
            close_base_stream: boolean;
            closeBaseStream: boolean;
        }
    }

    /**
     * Base class for output stream implementations that perform some
     * kind of filtering operation on a base stream. Typical examples
     * of filtering operations are character set conversion, compression
     * and byte order flipping.
     */
    abstract class FilterOutputStream extends OutputStream {
        static $gtype: GObject.GType<FilterOutputStream>;

        // Properties

        get base_stream(): OutputStream;
        get baseStream(): OutputStream;
        /**
         * Whether the base stream should be closed when the filter stream is closed.
         */
        get close_base_stream(): boolean;
        /**
         * Whether the base stream should be closed when the filter stream is closed.
         */
        get closeBaseStream(): boolean;

        // Constructors

        constructor(properties?: Partial<FilterOutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Gets the base stream for the filter stream.
         * @returns a #GOutputStream.
         */
        get_base_stream(): OutputStream;
        /**
         * Returns whether the base stream will be closed when `stream` is
         * closed.
         * @returns %TRUE if the base stream will be closed.
         */
        get_close_base_stream(): boolean;
        /**
         * Sets whether the base stream will be closed when `stream` is closed.
         * @param close_base %TRUE to close the base stream.
         */
        set_close_base_stream(close_base: boolean): void;
    }

    module IOModule {
        // Constructor properties interface

        interface ConstructorProps extends GObject.TypeModule.ConstructorProps, GObject.TypePlugin.ConstructorProps {}
    }

    /**
     * Provides an interface and default functions for loading and unloading
     * modules. This is used internally to make GIO extensible, but can also
     * be used by others to implement module loading.
     */
    class IOModule extends GObject.TypeModule implements GObject.TypePlugin {
        static $gtype: GObject.GType<IOModule>;

        // Constructors

        constructor(properties?: Partial<IOModule.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](filename: string): IOModule;

        // Static methods

        /**
         * Optional API for GIO modules to implement.
         *
         * Should return a list of all the extension points that may be
         * implemented in this module.
         *
         * This method will not be called in normal use, however it may be
         * called when probing existing modules and recording which extension
         * points that this model is used for. This means we won't have to
         * load and initialize this module unless its needed.
         *
         * If this function is not implemented by the module the module will
         * always be loaded, initialized and then unloaded on application
         * startup so that it can register its extension points during init.
         *
         * Note that a module need not actually implement all the extension
         * points that g_io_module_query() returns, since the exact list of
         * extension may depend on runtime issues. However all extension
         * points actually implemented must be returned by g_io_module_query()
         * (if defined).
         *
         * When installing a module that implements g_io_module_query() you must
         * run gio-querymodules in order to build the cache files required for
         * lazy loading.
         *
         * Since 2.56, this function should be named `g_io_<modulename>_query`, where
         * `modulename` is the plugins filename with the `lib` or `libgio` prefix and
         * everything after the first dot removed, and with `-` replaced with `_`
         * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
         * Using the new symbol names avoids name clashes when building modules
         * statically. The old symbol names continue to be supported, but cannot be used
         * for static builds.
         */
        static query(): string[];

        // Inherited methods
        /**
         * Calls the `complete_interface_info` function from the
         * #GTypePluginClass of `plugin`. There should be no need to use this
         * function outside of the GObject type system itself.
         * @param instance_type the #GType of an instantiatable type to which the interface  is added
         * @param interface_type the #GType of the interface whose info is completed
         * @param info the #GInterfaceInfo to fill in
         */
        complete_interface_info(
            instance_type: GObject.GType,
            interface_type: GObject.GType,
            info: GObject.InterfaceInfo,
        ): void;
        /**
         * Calls the `complete_type_info` function from the #GTypePluginClass of `plugin`.
         * There should be no need to use this function outside of the GObject
         * type system itself.
         * @param g_type the #GType whose info is completed
         * @param info the #GTypeInfo struct to fill in
         * @param value_table the #GTypeValueTable to fill in
         */
        complete_type_info(g_type: GObject.GType, info: GObject.TypeInfo, value_table: GObject.TypeValueTable): void;
        /**
         * Calls the `unuse_plugin` function from the #GTypePluginClass of
         * `plugin`.  There should be no need to use this function outside of
         * the GObject type system itself.
         */
        unuse(): void;
        /**
         * Calls the `use_plugin` function from the #GTypePluginClass of
         * `plugin`.  There should be no need to use this function outside of
         * the GObject type system itself.
         */
        use(): void;
        // Conflicted with GObject.TypeModule.use
        use(...args: never[]): any;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module IOStream {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            closed: boolean;
            input_stream: InputStream;
            inputStream: InputStream;
            output_stream: OutputStream;
            outputStream: OutputStream;
        }
    }

    /**
     * `GIOStream` represents an object that has both read and write streams.
     * Generally the two streams act as separate input and output streams,
     * but they share some common resources and state. For instance, for
     * seekable streams, both streams may use the same position.
     *
     * Examples of `GIOStream` objects are [class`Gio`.SocketConnection], which represents
     * a two-way network connection; and [class`Gio`.FileIOStream], which represents a
     * file handle opened in read-write mode.
     *
     * To do the actual reading and writing you need to get the substreams
     * with [method`Gio`.IOStream.get_input_stream] and
     * [method`Gio`.IOStream.get_output_stream].
     *
     * The `GIOStream` object owns the input and the output streams, not the other
     * way around, so keeping the substreams alive will not keep the `GIOStream`
     * object alive. If the `GIOStream` object is freed it will be closed, thus
     * closing the substreams, so even if the substreams stay alive they will
     * always return `G_IO_ERROR_CLOSED` for all operations.
     *
     * To close a stream use [method`Gio`.IOStream.close] which will close the common
     * stream object and also the individual substreams. You can also close
     * the substreams themselves. In most cases this only marks the
     * substream as closed, so further I/O on it fails but common state in the
     * `GIOStream` may still be open. However, some streams may support
     * half-closed states where one direction of the stream is actually shut down.
     *
     * Operations on `GIOStream`s cannot be started while another operation on the
     * `GIOStream` or its substreams is in progress. Specifically, an application can
     * read from the [class`Gio`.InputStream] and write to the
     * [class`Gio`.OutputStream] simultaneously (either in separate threads, or as
     * asynchronous operations in the same thread), but an application cannot start
     * any `GIOStream` operation while there is a `GIOStream`, `GInputStream` or
     * `GOutputStream` operation in progress, and an application cant start any
     * `GInputStream` or `GOutputStream` operation while there is a `GIOStream`
     * operation in progress.
     *
     * This is a product of individual stream operations being associated with a
     * given [type`GLib`.MainContext] (the thread-default context at the time the
     * operation was started), rather than entire streams being associated with a
     * single `GMainContext`.
     *
     * GIO may run operations on `GIOStream`s from other (worker) threads, and this
     * may be exposed to application code in the behaviour of wrapper streams, such
     * as [class`Gio`.BufferedInputStream] or [class`Gio`.TlsConnection]. With such
     * wrapper APIs, application code may only run operations on the base (wrapped)
     * stream when the wrapper stream is idle. Note that the semantics of such
     * operations may not be well-defined due to the state the wrapper stream leaves
     * the base stream in (though they are guaranteed not to crash).
     */
    abstract class IOStream extends GObject.Object {
        static $gtype: GObject.GType<IOStream>;

        // Properties

        /**
         * Whether the stream is closed.
         */
        get closed(): boolean;
        /**
         * The [class`Gio`.InputStream] to read from.
         */
        get input_stream(): InputStream;
        /**
         * The [class`Gio`.InputStream] to read from.
         */
        get inputStream(): InputStream;
        /**
         * The [class`Gio`.OutputStream] to write to.
         */
        get output_stream(): OutputStream;
        /**
         * The [class`Gio`.OutputStream] to write to.
         */
        get outputStream(): OutputStream;

        // Constructors

        constructor(properties?: Partial<IOStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Finishes an asynchronous io stream splice operation.
         * @param result a #GAsyncResult.
         */
        static splice_finish(result: AsyncResult): boolean;

        // Virtual methods

        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_io_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_io_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes a stream.
         * @param result a #GAsyncResult
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Gets the input stream for this object. This is used
         * for reading.
         */
        vfunc_get_input_stream(): InputStream;
        /**
         * Gets the output stream for this object. This is used for
         * writing.
         */
        vfunc_get_output_stream(): OutputStream;

        // Methods

        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it. This will also
         * close the individual input and output streams, if they are not already
         * closed.
         *
         * Once the stream is closed, all other operations will return
         * %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
         * return an error.
         *
         * Closing a stream will automatically flush any outstanding buffers
         * in the stream.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file
         * descriptor) open after the stream is closed. See the documentation for
         * the individual stream for details.
         *
         * On failure the first error that happened will be reported, but the
         * close operation will finish as much as possible. A stream that failed
         * to close will still return %G_IO_ERROR_CLOSED for all operations.
         * Still, it is important to check and report the error to the user,
         * otherwise there might be a loss of data as all data might not be written.
         *
         * If `cancellable` is not NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but some streams
         * can use a faster close that doesn't block to e.g. check errors.
         *
         * The default implementation of this method just calls close on the
         * individual input/output streams.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_io_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_io_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes a stream.
         * @param result a #GAsyncResult
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Gets the input stream for this object. This is used
         * for reading.
         * @returns a #GInputStream, owned by the #GIOStream. Do not free.
         */
        get_input_stream(): InputStream;
        /**
         * Gets the output stream for this object. This is used for
         * writing.
         * @returns a #GOutputStream, owned by the #GIOStream. Do not free.
         */
        get_output_stream(): OutputStream;
        /**
         * Checks if a stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if a stream is closed.
         * @returns %TRUE if the stream is closed.
         */
        is_closed(): boolean;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Asynchronously splice the output stream of `stream1` to the input stream of
         * `stream2`, and splice the output stream of `stream2` to the input stream of
         * `stream1`.
         *
         * When the operation is finished `callback` will be called.
         * You can then call g_io_stream_splice_finish() to get the
         * result of the operation.
         * @param stream2 a #GIOStream.
         * @param flags a set of #GIOStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        splice_async(
            stream2: IOStream,
            flags: IOStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
    }

    module InetAddress {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            bytes: any;
            family: SocketFamily;
            is_any: boolean;
            isAny: boolean;
            is_link_local: boolean;
            isLinkLocal: boolean;
            is_loopback: boolean;
            isLoopback: boolean;
            is_mc_global: boolean;
            isMcGlobal: boolean;
            is_mc_link_local: boolean;
            isMcLinkLocal: boolean;
            is_mc_node_local: boolean;
            isMcNodeLocal: boolean;
            is_mc_org_local: boolean;
            isMcOrgLocal: boolean;
            is_mc_site_local: boolean;
            isMcSiteLocal: boolean;
            is_multicast: boolean;
            isMulticast: boolean;
            is_site_local: boolean;
            isSiteLocal: boolean;
        }
    }

    /**
     * `GInetAddress` represents an IPv4 or IPv6 internet address. Use
     * [method`Gio`.Resolver.lookup_by_name] or
     * [method`Gio`.Resolver.lookup_by_name_async] to look up the `GInetAddress` for
     * a hostname. Use [method`Gio`.Resolver.lookup_by_address] or
     * [method`Gio`.Resolver.lookup_by_address_async] to look up the hostname for a
     * `GInetAddress`.
     *
     * To actually connect to a remote host, you will need a
     * [class`Gio`.InetSocketAddress] (which includes a `GInetAddress` as well as a
     * port number).
     */
    class InetAddress extends GObject.Object {
        static $gtype: GObject.GType<InetAddress>;

        // Properties

        /**
         * The raw address data.
         */
        get bytes(): any;
        /**
         * The address family (IPv4 or IPv6).
         */
        get family(): SocketFamily;
        /**
         * Whether this is the "any" address for its family.
         * See g_inet_address_get_is_any().
         */
        get is_any(): boolean;
        /**
         * Whether this is the "any" address for its family.
         * See g_inet_address_get_is_any().
         */
        get isAny(): boolean;
        /**
         * Whether this is a link-local address.
         * See g_inet_address_get_is_link_local().
         */
        get is_link_local(): boolean;
        /**
         * Whether this is a link-local address.
         * See g_inet_address_get_is_link_local().
         */
        get isLinkLocal(): boolean;
        /**
         * Whether this is the loopback address for its family.
         * See g_inet_address_get_is_loopback().
         */
        get is_loopback(): boolean;
        /**
         * Whether this is the loopback address for its family.
         * See g_inet_address_get_is_loopback().
         */
        get isLoopback(): boolean;
        /**
         * Whether this is a global multicast address.
         * See g_inet_address_get_is_mc_global().
         */
        get is_mc_global(): boolean;
        /**
         * Whether this is a global multicast address.
         * See g_inet_address_get_is_mc_global().
         */
        get isMcGlobal(): boolean;
        /**
         * Whether this is a link-local multicast address.
         * See g_inet_address_get_is_mc_link_local().
         */
        get is_mc_link_local(): boolean;
        /**
         * Whether this is a link-local multicast address.
         * See g_inet_address_get_is_mc_link_local().
         */
        get isMcLinkLocal(): boolean;
        /**
         * Whether this is a node-local multicast address.
         * See g_inet_address_get_is_mc_node_local().
         */
        get is_mc_node_local(): boolean;
        /**
         * Whether this is a node-local multicast address.
         * See g_inet_address_get_is_mc_node_local().
         */
        get isMcNodeLocal(): boolean;
        /**
         * Whether this is an organization-local multicast address.
         * See g_inet_address_get_is_mc_org_local().
         */
        get is_mc_org_local(): boolean;
        /**
         * Whether this is an organization-local multicast address.
         * See g_inet_address_get_is_mc_org_local().
         */
        get isMcOrgLocal(): boolean;
        /**
         * Whether this is a site-local multicast address.
         * See g_inet_address_get_is_mc_site_local().
         */
        get is_mc_site_local(): boolean;
        /**
         * Whether this is a site-local multicast address.
         * See g_inet_address_get_is_mc_site_local().
         */
        get isMcSiteLocal(): boolean;
        /**
         * Whether this is a multicast address.
         * See g_inet_address_get_is_multicast().
         */
        get is_multicast(): boolean;
        /**
         * Whether this is a multicast address.
         * See g_inet_address_get_is_multicast().
         */
        get isMulticast(): boolean;
        /**
         * Whether this is a site-local address.
         * See g_inet_address_get_is_loopback().
         */
        get is_site_local(): boolean;
        /**
         * Whether this is a site-local address.
         * See g_inet_address_get_is_loopback().
         */
        get isSiteLocal(): boolean;

        // Constructors

        constructor(properties?: Partial<InetAddress.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_any(family: SocketFamily): InetAddress;

        static new_from_bytes(bytes: Uint8Array | string, family: SocketFamily): InetAddress;

        static new_from_string(string: string): InetAddress;

        static new_loopback(family: SocketFamily): InetAddress;

        // Virtual methods

        /**
         * Converts `address` to string form.
         */
        vfunc_to_string(): string;

        // Methods

        /**
         * Checks if two #GInetAddress instances are equal, e.g. the same address.
         * @param other_address Another #GInetAddress.
         * @returns %TRUE if @address and @other_address are equal, %FALSE otherwise.
         */
        equal(other_address: InetAddress): boolean;
        /**
         * Gets `address'`s family
         * @returns @address's family
         */
        get_family(): SocketFamily;
        /**
         * Tests whether `address` is the "any" address for its family.
         * @returns %TRUE if @address is the "any" address for its family.
         */
        get_is_any(): boolean;
        /**
         * Tests whether `address` is a link-local address (that is, if it
         * identifies a host on a local network that is not connected to the
         * Internet).
         * @returns %TRUE if @address is a link-local address.
         */
        get_is_link_local(): boolean;
        /**
         * Tests whether `address` is the loopback address for its family.
         * @returns %TRUE if @address is the loopback address for its family.
         */
        get_is_loopback(): boolean;
        /**
         * Tests whether `address` is a global multicast address.
         * @returns %TRUE if @address is a global multicast address.
         */
        get_is_mc_global(): boolean;
        /**
         * Tests whether `address` is a link-local multicast address.
         * @returns %TRUE if @address is a link-local multicast address.
         */
        get_is_mc_link_local(): boolean;
        /**
         * Tests whether `address` is a node-local multicast address.
         * @returns %TRUE if @address is a node-local multicast address.
         */
        get_is_mc_node_local(): boolean;
        /**
         * Tests whether `address` is an organization-local multicast address.
         * @returns %TRUE if @address is an organization-local multicast address.
         */
        get_is_mc_org_local(): boolean;
        /**
         * Tests whether `address` is a site-local multicast address.
         * @returns %TRUE if @address is a site-local multicast address.
         */
        get_is_mc_site_local(): boolean;
        /**
         * Tests whether `address` is a multicast address.
         * @returns %TRUE if @address is a multicast address.
         */
        get_is_multicast(): boolean;
        /**
         * Tests whether `address` is a site-local address such as 10.0.0.1
         * (that is, the address identifies a host on a local network that can
         * not be reached directly from the Internet, but which may have
         * outgoing Internet connectivity via a NAT or firewall).
         * @returns %TRUE if @address is a site-local address.
         */
        get_is_site_local(): boolean;
        /**
         * Gets the size of the native raw binary address for `address`. This
         * is the size of the data that you get from g_inet_address_to_bytes().
         * @returns the number of bytes used for the native version of @address.
         */
        get_native_size(): number;
        /**
         * Converts `address` to string form.
         * @returns a representation of @address as a string, which should be freed after use.
         */
        to_string(): string;
    }

    module InetAddressMask {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Initable.ConstructorProps {
            address: InetAddress;
            family: SocketFamily;
            length: number;
        }
    }

    /**
     * `GInetAddressMask` represents a range of IPv4 or IPv6 addresses
     * described by a base address and a length indicating how many bits
     * of the base address are relevant for matching purposes. These are
     * often given in string form. For example, `10.0.0.0/8`, or `fe80::/10`.
     */
    class InetAddressMask extends GObject.Object implements Initable {
        static $gtype: GObject.GType<InetAddressMask>;

        // Properties

        /**
         * The base address.
         */
        get address(): InetAddress;
        set address(val: InetAddress);
        /**
         * The address family (IPv4 or IPv6).
         */
        get family(): SocketFamily;
        /**
         * The prefix length, in bytes.
         */
        get length(): number;
        set length(val: number);

        // Constructors

        constructor(properties?: Partial<InetAddressMask.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](addr: InetAddress, length: number): InetAddressMask;

        static new_from_string(mask_string: string): InetAddressMask;

        // Methods

        /**
         * Tests if `mask` and `mask2` are the same mask.
         * @param mask2 another #GInetAddressMask
         * @returns whether @mask and @mask2 are the same mask
         */
        equal(mask2: InetAddressMask): boolean;
        /**
         * Gets `mask'`s base address
         * @returns @mask's base address
         */
        get_address(): InetAddress;
        /**
         * Gets the #GSocketFamily of `mask'`s address
         * @returns the #GSocketFamily of @mask's address
         */
        get_family(): SocketFamily;
        /**
         * Gets `mask'`s length
         * @returns @mask's length
         */
        get_length(): number;
        /**
         * Tests if `address` falls within the range described by `mask`.
         * @param address a #GInetAddress
         * @returns whether @address falls within the range described by @mask.
         */
        matches(address: InetAddress): boolean;
        /**
         * Converts `mask` back to its corresponding string form.
         * @returns a string corresponding to @mask.
         */
        to_string(): string;

        // Inherited methods
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module InetSocketAddress {
        // Constructor properties interface

        interface ConstructorProps extends SocketAddress.ConstructorProps, SocketConnectable.ConstructorProps {
            address: InetAddress;
            flowinfo: number;
            port: number;
            scope_id: number;
            scopeId: number;
        }
    }

    /**
     * An IPv4 or IPv6 socket address. That is, the combination of a
     * [class`Gio`.InetAddress] and a port number.
     *
     * In UNIX terms, `GInetSocketAddress` corresponds to a
     * [`struct sockaddr_in` or `struct sockaddr_in6`](man:sockaddr(3type)).
     */
    class InetSocketAddress extends SocketAddress implements SocketConnectable {
        static $gtype: GObject.GType<InetSocketAddress>;

        // Properties

        /**
         * The address.
         */
        get address(): InetAddress;
        /**
         * The `sin6_flowinfo` field, for IPv6 addresses.
         */
        get flowinfo(): number;
        /**
         * The port.
         */
        get port(): number;
        /**
         * The `sin6_scope_id` field, for IPv6 addresses.
         */
        get scope_id(): number;
        /**
         * The `sin6_scope_id` field, for IPv6 addresses.
         */
        get scopeId(): number;

        // Constructors

        constructor(properties?: Partial<InetSocketAddress.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](address: InetAddress, port: number): InetSocketAddress;

        static new_from_string(address: string, port: number): InetSocketAddress;

        // Methods

        /**
         * Gets `address'`s #GInetAddress.
         * @returns the #GInetAddress for @address, which must be g_object_ref()'d if it will be stored
         */
        get_address(): InetAddress;
        /**
         * Gets the `sin6_flowinfo` field from `address,`
         * which must be an IPv6 address.
         * @returns the flowinfo field
         */
        get_flowinfo(): number;
        /**
         * Gets `address'`s port.
         * @returns the port for @address
         */
        get_port(): number;
        /**
         * Gets the `sin6_scope_id` field from `address,`
         * which must be an IPv6 address.
         * @returns the scope id field
         */
        get_scope_id(): number;

        // Inherited methods
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         */
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module InputStream {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GInputStream` is a base class for implementing streaming input.
     *
     * It has functions to read from a stream ([method`Gio`.InputStream.read]),
     * to close a stream ([method`Gio`.InputStream.close]) and to skip some content
     * ([method`Gio`.InputStream.skip]).
     *
     * To copy the content of an input stream to an output stream without
     * manually handling the reads and writes, use [method`Gio`.OutputStream.splice].
     *
     * See the documentation for [class`Gio`.IOStream] for details of thread safety
     * of streaming APIs.
     *
     * All of these functions have async variants too.
     */
    abstract class InputStream extends GObject.Object {
        static $gtype: GObject.GType<InputStream>;

        // Constructors

        constructor(properties?: Partial<InputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array | null;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         */
        vfunc_read_finish(result: AsyncResult): number;
        vfunc_read_fn(buffer: any | null, count: number, cancellable?: Cancellable | null): number;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         */
        vfunc_skip_finish(result: AsyncResult): number;

        // Methods

        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but some streams
         * can use a faster close that doesn't block to e.g. check errors.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         * @returns %TRUE if the stream was closed successfully.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Checks if an input stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an input stream is closed.
         * @returns %TRUE if the stream is closed.
         */
        is_closed(): boolean;
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * If count is zero returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * The returned `buffer` is not a nul-terminated string, it can contain nul bytes
         * at any position, and this function doesn't nul-terminate the `buffer`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes read, or -1 on error, or 0 on end of file.
         */
        read(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * This function is similar to g_input_stream_read(), except it tries to
         * read as many bytes as requested, only stopping on an error or end of stream.
         *
         * On a successful read of `count` bytes, or if we reached the end of the
         * stream,  %TRUE is returned, and `bytes_read` is set to the number of bytes
         * read into `buffer`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all(cancellable?: Cancellable | null): [boolean, Uint8Array, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the
         * buffer starting at `buffer`.
         *
         * This is the asynchronous equivalent of g_input_stream_read_all().
         *
         * Call g_input_stream_read_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_all_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Finishes an asynchronous stream read operation started with
         * g_input_stream_read_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Like g_input_stream_read(), this tries to read `count` bytes from
         * the stream in a blocking fashion. However, rather than reading into
         * a user-supplied buffer, this will create a new #GBytes containing
         * the data that was read. This may be easier to use from language
         * bindings.
         *
         * If count is zero, returns a zero-length #GBytes and does nothing. A
         * value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, a new #GBytes is returned. It is not an error if the
         * size of this object is not the same as the requested size, as it
         * can happen e.g. near the end of a file. A zero-length #GBytes is
         * returned on end of file (or if `count` is zero), but never
         * otherwise.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error %NULL is returned and `error` is set accordingly.
         * @param count maximum number of bytes that will be read from the stream. Common values include 4096 and 8192.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a new #GBytes, or %NULL on error
         */
        read_bytes(count: number, cancellable?: Cancellable | null): GLib.Bytes;
        /**
         * Request an asynchronous read of `count` bytes from the stream into a
         * new #GBytes. When the operation is finished `callback` will be
         * called. You can then call g_input_stream_read_bytes_finish() to get the
         * result of the operation.
         *
         * During an async request no other sync and async calls are allowed
         * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the new #GBytes will be passed to the callback. It is
         * not an error if this is smaller than the requested size, as it can
         * happen e.g. near the end of a file, but generally we try to read as
         * many bytes as requested. Zero is returned on end of file (or if
         * `count` is zero), but never otherwise.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_bytes_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream read-into-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns the newly-allocated #GBytes, or %NULL on error
         */
        read_bytes_finish(result: AsyncResult): GLib.Bytes;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         * @returns number of bytes read in, or -1 on error, or 0 on end of file.
         */
        read_finish(result: AsyncResult): number;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes skipped, or -1 on error
         */
        skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         * @returns the size of the bytes skipped, or `-1` on error.
         */
        skip_finish(result: AsyncResult): number;
    }

    module ListStore {
        // Constructor properties interface

        interface ConstructorProps<A extends GObject.Object = GObject.Object>
            extends GObject.Object.ConstructorProps,
                ListModel.ConstructorProps {
            item_type: GObject.GType;
            itemType: GObject.GType;
            n_items: number;
            nItems: number;
        }
    }

    /**
     * `GListStore` is a simple implementation of [iface`Gio`.ListModel] that stores
     * all items in memory.
     *
     * It provides insertions, deletions, and lookups in logarithmic time
     * with a fast path for the common case of iterating the list linearly.
     */
    class ListStore<A extends GObject.Object = GObject.Object> extends GObject.Object implements ListModel<A> {
        static $gtype: GObject.GType<ListStore>;

        // Properties

        /**
         * The type of items contained in this list store. Items must be
         * subclasses of #GObject.
         */
        get item_type(): GObject.GType;
        /**
         * The type of items contained in this list store. Items must be
         * subclasses of #GObject.
         */
        get itemType(): GObject.GType;
        /**
         * The number of items contained in this list store.
         */
        get n_items(): number;
        /**
         * The number of items contained in this list store.
         */
        get nItems(): number;

        // Fields

        [Symbol.iterator]: () => IterableIterator<A>;

        // Constructors

        constructor(properties?: Partial<ListStore.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](item_type: GObject.GType): ListStore;

        // Methods

        /**
         * Appends `item` to `store`. `item` must be of type #GListStore:item-type.
         *
         * This function takes a ref on `item`.
         *
         * Use g_list_store_splice() to append multiple items at the same time
         * efficiently.
         * @param item the new item
         */
        append(item: A): void;
        /**
         * Looks up the given `item` in the list store by looping over the items until
         * the first occurrence of `item`. If `item` was not found, then `position` will
         * not be set, and this method will return %FALSE.
         *
         * If you need to compare the two items with a custom comparison function, use
         * g_list_store_find_with_equal_func() with a custom #GEqualFunc instead.
         * @param item an item
         * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
         */
        find(item: A): [boolean, number];
        /**
         * Looks up the given `item` in the list store by looping over the items and
         * comparing them with `equal_func` until the first occurrence of `item` which
         * matches. If `item` was not found, then `position` will not be set, and this
         * method will return %FALSE.
         *
         * `item` is always passed as second parameter to `equal_func`.
         *
         * Since GLib 2.76 it is possible to pass `NULL` for `item`.
         * @param item an item
         * @param equal_func A custom equality check function
         * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
         */
        find_with_equal_func(item: A | null, equal_func: GLib.EqualFunc): [boolean, number];
        /**
         * Like g_list_store_find_with_equal_func() but with an additional `user_data`
         * that is passed to `equal_func`.
         *
         * `item` is always passed as second parameter to `equal_func`.
         *
         * Since GLib 2.76 it is possible to pass `NULL` for `item`.
         * @param item an item
         * @param equal_func A custom equality check function
         * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
         */
        find_with_equal_func_full(item: A | null, equal_func: GLib.EqualFuncFull): [boolean, number];
        /**
         * Inserts `item` into `store` at `position`. `item` must be of type
         * #GListStore:item-type or derived from it. `position` must be smaller
         * than the length of the list, or equal to it to append.
         *
         * This function takes a ref on `item`.
         *
         * Use g_list_store_splice() to insert multiple items at the same time
         * efficiently.
         * @param position the position at which to insert the new item
         * @param item the new item
         */
        insert(position: number, item: A): void;
        /**
         * Inserts `item` into `store` at a position to be determined by the
         * `compare_func`.
         *
         * The list must already be sorted before calling this function or the
         * result is undefined.  Usually you would approach this by only ever
         * inserting items by way of this function.
         *
         * This function takes a ref on `item`.
         * @param item the new item
         * @param compare_func pairwise comparison function for sorting
         * @returns the position at which @item was inserted
         */
        insert_sorted(item: A, compare_func: GLib.CompareDataFunc): number;
        /**
         * Removes the item from `store` that is at `position`. `position` must be
         * smaller than the current length of the list.
         *
         * Use g_list_store_splice() to remove multiple items at the same time
         * efficiently.
         * @param position the position of the item that is to be removed
         */
        remove(position: number): void;
        /**
         * Removes all items from `store`.
         */
        remove_all(): void;
        /**
         * Sort the items in `store` according to `compare_func`.
         * @param compare_func pairwise comparison function for sorting
         */
        sort(compare_func: GLib.CompareDataFunc): void;
        /**
         * Changes `store` by removing `n_removals` items and adding `n_additions`
         * items to it. `additions` must contain `n_additions` items of type
         * #GListStore:item-type.  %NULL is not permitted.
         *
         * This function is more efficient than g_list_store_insert() and
         * g_list_store_remove(), because it only emits
         * #GListModel::items-changed once for the change.
         *
         * This function takes a ref on each item in `additions`.
         *
         * The parameters `position` and `n_removals` must be correct (ie:
         * `position` + `n_removals` must be less than or equal to the length of
         * the list at the time this function is called).
         * @param position the position at which to make the change
         * @param n_removals the number of items to remove
         * @param additions the items to add
         */
        splice(position: number, n_removals: number, additions: A[]): void;

        // Inherited methods
        /**
         * Gets the type of the items in `list`.
         *
         * All items returned from g_list_model_get_item() are of the type
         * returned by this function, or a subtype, or if the type is an
         * interface, they are an implementation of that interface.
         *
         * The item type of a #GListModel can not change during the life of the
         * model.
         * @returns the #GType of the items contained in @list.
         */
        get_item_type(): GObject.GType;
        /**
         * Gets the number of items in `list`.
         *
         * Depending on the model implementation, calling this function may be
         * less efficient than iterating the list with increasing values for
         * `position` until g_list_model_get_item() returns %NULL.
         * @returns the number of items in @list.
         */
        get_n_items(): number;
        /**
         * Get the item at `position`.
         *
         * If `position` is greater than the number of items in `list,` %NULL is
         * returned.
         *
         * %NULL is never returned for an index that is smaller than the length
         * of the list.
         *
         * This function is meant to be used by language bindings in place
         * of g_list_model_get_item().
         *
         * See also: g_list_model_get_n_items()
         * @param position the position of the item to fetch
         * @returns the object at @position.
         */
        get_item(position: number): A | null;
        /**
         * Emits the #GListModel::items-changed signal on `list`.
         *
         * This function should only be called by classes implementing
         * #GListModel. It has to be called after the internal representation
         * of `list` has been updated, because handlers connected to this signal
         * might query the new state of the list.
         *
         * Implementations must only make changes to the model (as visible to
         * its consumer) in places that will not cause problems for that
         * consumer.  For models that are driven directly by a write API (such
         * as #GListStore), changes can be reported in response to uses of that
         * API.  For models that represent remote data, changes should only be
         * made from a fresh mainloop dispatch.  It is particularly not
         * permitted to make changes in response to a call to the #GListModel
         * consumer API.
         *
         * Stated another way: in general, it is assumed that code making a
         * series of accesses to the model via the API, without returning to the
         * mainloop, and without calling other code, will continue to view the
         * same contents of the model.
         * @param position the position at which @list changed
         * @param removed the number of items removed
         * @param added the number of items added
         */
        items_changed(position: number, removed: number, added: number): void;
        /**
         * Get the item at `position`. If `position` is greater than the number of
         * items in `list,` %NULL is returned.
         *
         * %NULL is never returned for an index that is smaller than the length
         * of the list.  See g_list_model_get_n_items().
         *
         * The same #GObject instance may not appear more than once in a #GListModel.
         * @param position the position of the item to fetch
         */
        vfunc_get_item(position: number): A | null;
        /**
         * Gets the type of the items in `list`.
         *
         * All items returned from g_list_model_get_item() are of the type
         * returned by this function, or a subtype, or if the type is an
         * interface, they are an implementation of that interface.
         *
         * The item type of a #GListModel can not change during the life of the
         * model.
         */
        vfunc_get_item_type(): GObject.GType;
        /**
         * Gets the number of items in `list`.
         *
         * Depending on the model implementation, calling this function may be
         * less efficient than iterating the list with increasing values for
         * `position` until g_list_model_get_item() returns %NULL.
         */
        vfunc_get_n_items(): number;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module MemoryInputStream {
        // Constructor properties interface

        interface ConstructorProps
            extends InputStream.ConstructorProps,
                PollableInputStream.ConstructorProps,
                Seekable.ConstructorProps {}
    }

    /**
     * `GMemoryInputStream` is a class for using arbitrary
     * memory chunks as input for GIO streaming input operations.
     *
     * As of GLib 2.34, `GMemoryInputStream` implements
     * [iface`Gio`.PollableInputStream].
     */
    class MemoryInputStream extends InputStream implements PollableInputStream, Seekable {
        static $gtype: GObject.GType<MemoryInputStream>;

        // Constructors

        constructor(properties?: Partial<MemoryInputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): MemoryInputStream;

        static new_from_bytes(bytes: GLib.Bytes | Uint8Array): MemoryInputStream;

        static new_from_data(data: Uint8Array | string, destroy?: GLib.DestroyNotify | null): MemoryInputStream;

        // Methods

        /**
         * Appends `bytes` to data that can be read from the input stream.
         * @param bytes input data
         */
        add_bytes(bytes: GLib.Bytes | Uint8Array): void;
        /**
         * Appends `data` to data that can be read from the input stream
         * @param data input data
         * @param destroy function that is called to free @data, or %NULL
         */
        add_data(data: Uint8Array | string, destroy?: GLib.DestroyNotify | null): void;

        // Inherited methods
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
         */
        is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_read_nonblocking(): [number, Uint8Array | null];
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Tests if the stream supports the #GSeekableIface.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but some streams
         * can use a faster close that doesn't block to e.g. check errors.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         * @returns %TRUE if the stream was closed successfully.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Checks if an input stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an input stream is closed.
         * @returns %TRUE if the stream is closed.
         */
        is_closed(): boolean;
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * If count is zero returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * The returned `buffer` is not a nul-terminated string, it can contain nul bytes
         * at any position, and this function doesn't nul-terminate the `buffer`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes read, or -1 on error, or 0 on end of file.
         */
        read(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * This function is similar to g_input_stream_read(), except it tries to
         * read as many bytes as requested, only stopping on an error or end of stream.
         *
         * On a successful read of `count` bytes, or if we reached the end of the
         * stream,  %TRUE is returned, and `bytes_read` is set to the number of bytes
         * read into `buffer`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all(cancellable?: Cancellable | null): [boolean, Uint8Array, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the
         * buffer starting at `buffer`.
         *
         * This is the asynchronous equivalent of g_input_stream_read_all().
         *
         * Call g_input_stream_read_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_all_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Finishes an asynchronous stream read operation started with
         * g_input_stream_read_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Like g_input_stream_read(), this tries to read `count` bytes from
         * the stream in a blocking fashion. However, rather than reading into
         * a user-supplied buffer, this will create a new #GBytes containing
         * the data that was read. This may be easier to use from language
         * bindings.
         *
         * If count is zero, returns a zero-length #GBytes and does nothing. A
         * value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, a new #GBytes is returned. It is not an error if the
         * size of this object is not the same as the requested size, as it
         * can happen e.g. near the end of a file. A zero-length #GBytes is
         * returned on end of file (or if `count` is zero), but never
         * otherwise.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error %NULL is returned and `error` is set accordingly.
         * @param count maximum number of bytes that will be read from the stream. Common values include 4096 and 8192.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a new #GBytes, or %NULL on error
         */
        read_bytes(count: number, cancellable?: Cancellable | null): GLib.Bytes;
        /**
         * Request an asynchronous read of `count` bytes from the stream into a
         * new #GBytes. When the operation is finished `callback` will be
         * called. You can then call g_input_stream_read_bytes_finish() to get the
         * result of the operation.
         *
         * During an async request no other sync and async calls are allowed
         * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the new #GBytes will be passed to the callback. It is
         * not an error if this is smaller than the requested size, as it can
         * happen e.g. near the end of a file, but generally we try to read as
         * many bytes as requested. Zero is returned on end of file (or if
         * `count` is zero), but never otherwise.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_bytes_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream read-into-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns the newly-allocated #GBytes, or %NULL on error
         */
        read_bytes_finish(result: AsyncResult): GLib.Bytes;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         * @returns number of bytes read in, or -1 on error, or 0 on end of file.
         */
        read_finish(result: AsyncResult): number;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes skipped, or -1 on error
         */
        skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         * @returns the size of the bytes skipped, or `-1` on error.
         */
        skip_finish(result: AsyncResult): number;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array | null;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         */
        vfunc_read_finish(result: AsyncResult): number;
        vfunc_read_fn(buffer: any | null, count: number, cancellable?: Cancellable | null): number;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         */
        vfunc_skip_finish(result: AsyncResult): number;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module MemoryOutputStream {
        // Constructor properties interface

        interface ConstructorProps
            extends OutputStream.ConstructorProps,
                PollableOutputStream.ConstructorProps,
                Seekable.ConstructorProps {
            data: any;
            data_size: number;
            dataSize: number;
            size: number;
        }
    }

    /**
     * `GMemoryOutputStream` is a class for using arbitrary
     * memory chunks as output for GIO streaming output operations.
     *
     * As of GLib 2.34, `GMemoryOutputStream` trivially implements
     * [iface`Gio`.PollableOutputStream]: it always polls as ready.
     */
    class MemoryOutputStream extends OutputStream implements PollableOutputStream, Seekable {
        static $gtype: GObject.GType<MemoryOutputStream>;

        // Properties

        /**
         * Pointer to buffer where data will be written.
         */
        get data(): any;
        /**
         * Size of data written to the buffer.
         */
        get data_size(): number;
        /**
         * Size of data written to the buffer.
         */
        get dataSize(): number;
        /**
         * Current size of the data buffer.
         */
        get size(): number;

        // Constructors

        constructor(properties?: Partial<MemoryOutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_resizable(): MemoryOutputStream;

        // Methods

        /**
         * Gets any loaded data from the `ostream`.
         *
         * Note that the returned pointer may become invalid on the next
         * write or truncate operation on the stream.
         * @returns pointer to the stream's data, or %NULL if the data    has been stolen
         */
        get_data(): any | null;
        /**
         * Returns the number of bytes from the start up to including the last
         * byte written in the stream that has not been truncated away.
         * @returns the number of bytes written to the stream
         */
        get_data_size(): number;
        /**
         * Gets the size of the currently allocated data area (available from
         * g_memory_output_stream_get_data()).
         *
         * You probably don't want to use this function on resizable streams.
         * See g_memory_output_stream_get_data_size() instead.  For resizable
         * streams the size returned by this function is an implementation
         * detail and may be change at any time in response to operations on the
         * stream.
         *
         * If the stream is fixed-sized (ie: no realloc was passed to
         * g_memory_output_stream_new()) then this is the maximum size of the
         * stream and further writes will return %G_IO_ERROR_NO_SPACE.
         *
         * In any case, if you want the number of bytes currently written to the
         * stream, use g_memory_output_stream_get_data_size().
         * @returns the number of bytes allocated for the data buffer
         */
        get_size(): number;
        /**
         * Returns data from the `ostream` as a #GBytes. `ostream` must be
         * closed before calling this function.
         * @returns the stream's data
         */
        steal_as_bytes(): GLib.Bytes;
        /**
         * Gets any loaded data from the `ostream`. Ownership of the data
         * is transferred to the caller; when no longer needed it must be
         * freed using the free function set in `ostream'`s
         * #GMemoryOutputStream:destroy-function property.
         *
         * `ostream` must be closed before calling this function.
         * @returns the stream's data, or %NULL if it has previously    been stolen
         */
        steal_data(): any | null;

        // Inherited methods
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
         */
        is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
         */
        writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         */
        vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         */
        vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Tests if the stream supports the #GSeekableIface.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Closing a stream will automatically flush any outstanding buffers in the
         * stream.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user, otherwise
         * there might be a loss of data as all data might not be written.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but there some streams
         * can use a faster close that doesn't block to e.g. check errors. On
         * cancellation (as with any error) there is no guarantee that all written
         * data will reach the target.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on error
         */
        flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
         */
        flush_finish(result: AsyncResult): boolean;
        /**
         * Checks if an output stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an output stream has already been closed.
         * @returns %TRUE if @stream is closed. %FALSE otherwise.
         */
        is_closed(): boolean;
        /**
         * Checks if an output stream is being closed. This can be
         * used inside e.g. a flush implementation to see if the
         * flush (or other i/o operation) is called from within
         * the closing operation.
         * @returns %TRUE if @stream is being closed. %FALSE otherwise.
         */
        is_closing(): boolean;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
         */
        splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
         */
        splice_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * This function is similar to g_output_stream_write(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of `count` bytes, %TRUE is returned, and `bytes_written`
         * is set to `count`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all(buffer: Uint8Array | string, cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_write_all().
         *
         * Call g_output_stream_write_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called.
         * @param buffer the buffer containing the data to write
         * @param io_priority the io priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_all_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_write_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * A wrapper function for g_output_stream_write() which takes a
         * #GBytes as input.  This can be more convenient for use by language
         * bindings or in other cases where the refcounted nature of #GBytes
         * is helpful over a bare pointer interface.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write().  If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         * @param bytes the #GBytes to write
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write_bytes(bytes: GLib.Bytes | Uint8Array, cancellable?: Cancellable | null): number;
        /**
         * This function is similar to g_output_stream_write_async(), but
         * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
         * this allows the stream to avoid taking a copy of the data.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write_async(). If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write_bytes().
         * @param bytes The bytes to write
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        write_bytes_async(
            bytes: GLib.Bytes | Uint8Array,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write-from-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_bytes_finish(result: AsyncResult): number;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_finish(result: AsyncResult): number;
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * This function is similar to g_output_stream_writev(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of all `n_vectors` vectors, %TRUE is returned, and
         * `bytes_written` is set to the sum of all the sizes of `vectors`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C. If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         *
         * The content of the individual elements of `vectors` might be changed by this
         * function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_writev_all().
         *
         * Call g_output_stream_writev_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called. The content of the individual elements
         * of `vectors` might be changed by this function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_all_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_writev_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_writev_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_finish(result: AsyncResult): [boolean, number];
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         */
        vfunc_flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         */
        vfunc_flush_finish(result: AsyncResult): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         */
        vfunc_splice_finish(result: AsyncResult): number;
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_write_async(
            buffer: Uint8Array | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         */
        vfunc_write_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         */
        vfunc_write_fn(buffer?: Uint8Array | null, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         */
        vfunc_writev_finish(result: AsyncResult): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         */
        vfunc_writev_fn(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Menu {
        // Constructor properties interface

        interface ConstructorProps extends MenuModel.ConstructorProps {}
    }

    /**
     * `GMenu` is a simple implementation of [class`Gio`.MenuModel].
     * You populate a `GMenu` by adding [class`Gio`.MenuItem] instances to it.
     *
     * There are some convenience functions to allow you to directly
     * add items (avoiding [class`Gio`.MenuItem]) for the common cases. To add
     * a regular item, use [method`Gio`.Menu.insert]. To add a section, use
     * [method`Gio`.Menu.insert_section]. To add a submenu, use
     * [method`Gio`.Menu.insert_submenu].
     */
    class Menu extends MenuModel {
        static $gtype: GObject.GType<Menu>;

        // Constructors

        constructor(properties?: Partial<Menu.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Menu;

        // Methods

        /**
         * Convenience function for appending a normal menu item to the end of
         * `menu`.  Combine g_menu_item_new() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         */
        append(label?: string | null, detailed_action?: string | null): void;
        /**
         * Appends `item` to the end of `menu`.
         *
         * See g_menu_insert_item() for more information.
         * @param item a #GMenuItem to append
         */
        append_item(item: MenuItem): void;
        /**
         * Convenience function for appending a section menu item to the end of
         * `menu`.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
         * more flexible alternative.
         * @param label the section label, or %NULL
         * @param section a #GMenuModel with the items of the section
         */
        append_section(label: string | null, section: MenuModel): void;
        /**
         * Convenience function for appending a submenu menu item to the end of
         * `menu`.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
         * more flexible alternative.
         * @param label the section label, or %NULL
         * @param submenu a #GMenuModel with the items of the submenu
         */
        append_submenu(label: string | null, submenu: MenuModel): void;
        /**
         * Marks `menu` as frozen.
         *
         * After the menu is frozen, it is an error to attempt to make any
         * changes to it.  In effect this means that the #GMenu API must no
         * longer be used.
         *
         * This function causes g_menu_model_is_mutable() to begin returning
         * %FALSE, which has some positive performance implications.
         */
        freeze(): void;
        /**
         * Convenience function for inserting a normal menu item into `menu`.
         * Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
         * alternative.
         * @param position the position at which to insert the item
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         */
        insert(position: number, label?: string | null, detailed_action?: string | null): void;
        /**
         * Inserts `item` into `menu`.
         *
         * The "insertion" is actually done by copying all of the attribute and
         * link values of `item` and using them to form a new item within `menu`.
         * As such, `item` itself is not really inserted, but rather, a menu item
         * that is exactly the same as the one presently described by `item`.
         *
         * This means that `item` is essentially useless after the insertion
         * occurs.  Any changes you make to it are ignored unless it is inserted
         * again (at which point its updated values will be copied).
         *
         * You should probably just free `item` once you're done.
         *
         * There are many convenience functions to take care of common cases.
         * See g_menu_insert(), g_menu_insert_section() and
         * g_menu_insert_submenu() as well as "prepend" and "append" variants of
         * each of these functions.
         * @param position the position at which to insert the item
         * @param item the #GMenuItem to insert
         */
        insert_item(position: number, item: MenuItem): void;
        /**
         * Convenience function for inserting a section menu item into `menu`.
         * Combine g_menu_item_new_section() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param position the position at which to insert the item
         * @param label the section label, or %NULL
         * @param section a #GMenuModel with the items of the section
         */
        insert_section(position: number, label: string | null, section: MenuModel): void;
        /**
         * Convenience function for inserting a submenu menu item into `menu`.
         * Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param position the position at which to insert the item
         * @param label the section label, or %NULL
         * @param submenu a #GMenuModel with the items of the submenu
         */
        insert_submenu(position: number, label: string | null, submenu: MenuModel): void;
        /**
         * Convenience function for prepending a normal menu item to the start
         * of `menu`.  Combine g_menu_item_new() and g_menu_insert_item() for a more
         * flexible alternative.
         * @param label the section label, or %NULL
         * @param detailed_action the detailed action string, or %NULL
         */
        prepend(label?: string | null, detailed_action?: string | null): void;
        /**
         * Prepends `item` to the start of `menu`.
         *
         * See g_menu_insert_item() for more information.
         * @param item a #GMenuItem to prepend
         */
        prepend_item(item: MenuItem): void;
        /**
         * Convenience function for prepending a section menu item to the start
         * of `menu`.  Combine g_menu_item_new_section() and g_menu_insert_item() for
         * a more flexible alternative.
         * @param label the section label, or %NULL
         * @param section a #GMenuModel with the items of the section
         */
        prepend_section(label: string | null, section: MenuModel): void;
        /**
         * Convenience function for prepending a submenu menu item to the start
         * of `menu`.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
         * a more flexible alternative.
         * @param label the section label, or %NULL
         * @param submenu a #GMenuModel with the items of the submenu
         */
        prepend_submenu(label: string | null, submenu: MenuModel): void;
        /**
         * Removes an item from the menu.
         *
         * `position` gives the index of the item to remove.
         *
         * It is an error if position is not in range the range from 0 to one
         * less than the number of items in the menu.
         *
         * It is not possible to remove items by identity since items are added
         * to the menu simply by copying their links and attributes (ie:
         * identity of the item itself is not preserved).
         * @param position the position of the item to remove
         */
        remove(position: number): void;
        /**
         * Removes all items in the menu.
         */
        remove_all(): void;
    }

    module MenuAttributeIter {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * #GMenuAttributeIter is an opaque structure type.  You must access it
     * using the functions below.
     */
    abstract class MenuAttributeIter extends GObject.Object {
        static $gtype: GObject.GType<MenuAttributeIter>;

        // Constructors

        constructor(properties?: Partial<MenuAttributeIter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * This function combines g_menu_attribute_iter_next() with
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) attribute.
         * If that fails, then %FALSE is returned and there are no other
         * effects.
         *
         * If successful, `name` and `value` are set to the name and value of the
         * attribute that has just been advanced to.  At this point,
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
         * return the same values again.
         *
         * The value returned in `name` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_variant_unref() when it is no longer in use.
         */
        vfunc_get_next(): [boolean, string, GLib.Variant | null];

        // Methods

        /**
         * Gets the name of the attribute at the current iterator position, as
         * a string.
         *
         * The iterator is not advanced.
         * @returns the name of the attribute
         */
        get_name(): string;
        /**
         * This function combines g_menu_attribute_iter_next() with
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) attribute.
         * If that fails, then %FALSE is returned and there are no other
         * effects.
         *
         * If successful, `name` and `value` are set to the name and value of the
         * attribute that has just been advanced to.  At this point,
         * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
         * return the same values again.
         *
         * The value returned in `name` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_variant_unref() when it is no longer in use.
         * @returns %TRUE on success, or %FALSE if there is no additional     attribute
         */
        get_next(): [boolean, string, GLib.Variant | null];
        /**
         * Gets the value of the attribute at the current iterator position.
         *
         * The iterator is not advanced.
         * @returns the value of the current attribute
         */
        get_value(): GLib.Variant;
        /**
         * Attempts to advance the iterator to the next (possibly first)
         * attribute.
         *
         * %TRUE is returned on success, or %FALSE if there are no more
         * attributes.
         *
         * You must call this function when you first acquire the iterator
         * to advance it to the first attribute (and determine if the first
         * attribute exists at all).
         * @returns %TRUE on success, or %FALSE when there are no more attributes
         */
        next(): boolean;
    }

    module MenuItem {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * #GMenuItem is an opaque structure type.  You must access it using the
     * functions below.
     */
    class MenuItem extends GObject.Object {
        static $gtype: GObject.GType<MenuItem>;

        // Constructors

        constructor(properties?: Partial<MenuItem.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](label?: string | null, detailed_action?: string | null): MenuItem;

        static new_from_model(model: MenuModel, item_index: number): MenuItem;

        static new_section(label: string | null, section: MenuModel): MenuItem;

        static new_submenu(label: string | null, submenu: MenuModel): MenuItem;

        // Methods

        /**
         * Queries the named `attribute` on `menu_item`.
         *
         * If `expected_type` is specified and the attribute does not have this
         * type, %NULL is returned.  %NULL is also returned if the attribute
         * simply does not exist.
         * @param attribute the attribute name to query
         * @param expected_type the expected type of the attribute
         * @returns the attribute value, or %NULL
         */
        get_attribute_value(attribute: string, expected_type?: GLib.VariantType | null): GLib.Variant | null;
        /**
         * Queries the named `link` on `menu_item`.
         * @param link the link name to query
         * @returns the link, or %NULL
         */
        get_link(link: string): MenuModel | null;
        /**
         * Sets or unsets the "action" and "target" attributes of `menu_item`.
         *
         * If `action` is %NULL then both the "action" and "target" attributes
         * are unset (and `target_value` is ignored).
         *
         * If `action` is non-%NULL then the "action" attribute is set.  The
         * "target" attribute is then set to the value of `target_value` if it is
         * non-%NULL or unset otherwise.
         *
         * Normal menu items (ie: not submenu, section or other custom item
         * types) are expected to have the "action" attribute set to identify
         * the action that they are associated with.  The state type of the
         * action help to determine the disposition of the menu item.  See
         * #GAction and #GActionGroup for an overview of actions.
         *
         * In general, clicking on the menu item will result in activation of
         * the named action with the "target" attribute given as the parameter
         * to the action invocation.  If the "target" attribute is not set then
         * the action is invoked with no parameter.
         *
         * If the action has no state then the menu item is usually drawn as a
         * plain menu item (ie: with no additional decoration).
         *
         * If the action has a boolean state then the menu item is usually drawn
         * as a toggle menu item (ie: with a checkmark or equivalent
         * indication).  The item should be marked as 'toggled' or 'checked'
         * when the boolean state is %TRUE.
         *
         * If the action has a string state then the menu item is usually drawn
         * as a radio menu item (ie: with a radio bullet or equivalent
         * indication).  The item should be marked as 'selected' when the string
         * state is equal to the value of the `target` property.
         *
         * See g_menu_item_set_action_and_target() or
         * g_menu_item_set_detailed_action() for two equivalent calls that are
         * probably more convenient for most uses.
         * @param action the name of the action for this item
         * @param target_value a #GVariant to use as the action target
         */
        set_action_and_target_value(action?: string | null, target_value?: GLib.Variant | null): void;
        /**
         * Sets or unsets an attribute on `menu_item`.
         *
         * The attribute to set or unset is specified by `attribute`. This
         * can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
         * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
         * attribute name.
         * Attribute names are restricted to lowercase characters, numbers
         * and '-'. Furthermore, the names must begin with a lowercase character,
         * must not end with a '-', and must not contain consecutive dashes.
         *
         * must consist only of lowercase
         * ASCII characters, digits and '-'.
         *
         * If `value` is non-%NULL then it is used as the new value for the
         * attribute.  If `value` is %NULL then the attribute is unset. If
         * the `value` #GVariant is floating, it is consumed.
         *
         * See also g_menu_item_set_attribute() for a more convenient way to do
         * the same.
         * @param attribute the attribute to set
         * @param value a #GVariant to use as the value, or %NULL
         */
        set_attribute_value(attribute: string, value?: GLib.Variant | null): void;
        /**
         * Sets the "action" and possibly the "target" attribute of `menu_item`.
         *
         * The format of `detailed_action` is the same format parsed by
         * g_action_parse_detailed_name().
         *
         * See g_menu_item_set_action_and_target() or
         * g_menu_item_set_action_and_target_value() for more flexible (but
         * slightly less convenient) alternatives.
         *
         * See also g_menu_item_set_action_and_target_value() for a description of
         * the semantics of the action and target attributes.
         * @param detailed_action the "detailed" action string
         */
        set_detailed_action(detailed_action: string): void;
        /**
         * Sets (or unsets) the icon on `menu_item`.
         *
         * This call is the same as calling g_icon_serialize() and using the
         * result as the value to g_menu_item_set_attribute_value() for
         * %G_MENU_ATTRIBUTE_ICON.
         *
         * This API is only intended for use with "noun" menu items; things like
         * bookmarks or applications in an "Open With" menu.  Don't use it on
         * menu items corresponding to verbs (eg: stock icons for 'Save' or
         * 'Quit').
         *
         * If `icon` is %NULL then the icon is unset.
         * @param icon a #GIcon, or %NULL
         */
        set_icon(icon: Icon): void;
        /**
         * Sets or unsets the "label" attribute of `menu_item`.
         *
         * If `label` is non-%NULL it is used as the label for the menu item.  If
         * it is %NULL then the label attribute is unset.
         * @param label the label to set, or %NULL to unset
         */
        set_label(label?: string | null): void;
        /**
         * Creates a link from `menu_item` to `model` if non-%NULL, or unsets it.
         *
         * Links are used to establish a relationship between a particular menu
         * item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
         * associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
         * is used to create a section. Other types of link can be used, but there
         * is no guarantee that clients will be able to make sense of them.
         * Link types are restricted to lowercase characters, numbers
         * and '-'. Furthermore, the names must begin with a lowercase character,
         * must not end with a '-', and must not contain consecutive dashes.
         * @param link type of link to establish or unset
         * @param model the #GMenuModel to link to (or %NULL to unset)
         */
        set_link(link: string, model?: MenuModel | null): void;
        /**
         * Sets or unsets the "section" link of `menu_item` to `section`.
         *
         * The effect of having one menu appear as a section of another is
         * exactly as it sounds: the items from `section` become a direct part of
         * the menu that `menu_item` is added to.  See g_menu_item_new_section()
         * for more information about what it means for a menu item to be a
         * section.
         * @param section a #GMenuModel, or %NULL
         */
        set_section(section?: MenuModel | null): void;
        /**
         * Sets or unsets the "submenu" link of `menu_item` to `submenu`.
         *
         * If `submenu` is non-%NULL, it is linked to.  If it is %NULL then the
         * link is unset.
         *
         * The effect of having one menu appear as a submenu of another is
         * exactly as it sounds.
         * @param submenu a #GMenuModel, or %NULL
         */
        set_submenu(submenu?: MenuModel | null): void;
    }

    module MenuLinkIter {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * #GMenuLinkIter is an opaque structure type.  You must access it using
     * the functions below.
     */
    abstract class MenuLinkIter extends GObject.Object {
        static $gtype: GObject.GType<MenuLinkIter>;

        // Constructors

        constructor(properties?: Partial<MenuLinkIter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * This function combines g_menu_link_iter_next() with
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) link.
         * If that fails, then %FALSE is returned and there are no other effects.
         *
         * If successful, `out_link` and `value` are set to the name and #GMenuModel
         * of the link that has just been advanced to.  At this point,
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
         * same values again.
         *
         * The value returned in `out_link` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_object_unref() when it is no longer in use.
         */
        vfunc_get_next(): [boolean, string, MenuModel | null];

        // Methods

        /**
         * Gets the name of the link at the current iterator position.
         *
         * The iterator is not advanced.
         * @returns the type of the link
         */
        get_name(): string;
        /**
         * This function combines g_menu_link_iter_next() with
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
         *
         * First the iterator is advanced to the next (possibly first) link.
         * If that fails, then %FALSE is returned and there are no other effects.
         *
         * If successful, `out_link` and `value` are set to the name and #GMenuModel
         * of the link that has just been advanced to.  At this point,
         * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
         * same values again.
         *
         * The value returned in `out_link` remains valid for as long as the iterator
         * remains at the current position.  The value returned in `value` must
         * be unreffed using g_object_unref() when it is no longer in use.
         * @returns %TRUE on success, or %FALSE if there is no additional link
         */
        get_next(): [boolean, string, MenuModel | null];
        /**
         * Gets the linked #GMenuModel at the current iterator position.
         *
         * The iterator is not advanced.
         * @returns the #GMenuModel that is linked to
         */
        get_value(): MenuModel;
        /**
         * Attempts to advance the iterator to the next (possibly first)
         * link.
         *
         * %TRUE is returned on success, or %FALSE if there are no more links.
         *
         * You must call this function when you first acquire the iterator to
         * advance it to the first link (and determine if the first link exists
         * at all).
         * @returns %TRUE on success, or %FALSE when there are no more links
         */
        next(): boolean;
    }

    module MenuModel {
        // Signal callback interfaces

        interface ItemsChanged {
            (position: number, removed: number, added: number): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GMenuModel` represents the contents of a menu  an ordered list of
     * menu items. The items are associated with actions, which can be
     * activated through them. Items can be grouped in sections, and may
     * have submenus associated with them. Both items and sections usually
     * have some representation data, such as labels or icons. The type of
     * the associated action (ie whether it is stateful, and what kind of
     * state it has) can influence the representation of the item.
     *
     * The conceptual model of menus in `GMenuModel` is hierarchical:
     * sections and submenus are again represented by `GMenuModel`s.
     * Menus themselves do not define their own roles. Rather, the role
     * of a particular `GMenuModel` is defined by the item that references
     * it (or, in the case of the root menu, is defined by the context
     * in which it is used).
     *
     * As an example, consider the visible portions of this menu:
     *
     * ## An example menu
     *
     * ![](menu-example.png)
     *
     * There are 8 menus visible in the screenshot: one menubar, two
     * submenus and 5 sections:
     *
     * - the toplevel menubar (containing 4 items)
     * - the View submenu (containing 3 sections)
     * - the first section of the View submenu (containing 2 items)
     * - the second section of the View submenu (containing 1 item)
     * - the final section of the View submenu (containing 1 item)
     * - the Highlight Mode submenu (containing 2 sections)
     * - the Sources section (containing 2 items)
     * - the Markup section (containing 2 items)
     *
     * The [example](#a-menu-example) illustrates the conceptual connection between
     * these 8 menus. Each large block in the figure represents a menu and the
     * smaller blocks within the large block represent items in that menu. Some
     * items contain references to other menus.
     *
     * ## A menu example
     *
     * ![](menu-model.png)
     *
     * Notice that the separators visible in the [example](#an-example-menu)
     * appear nowhere in the [menu model](#a-menu-example). This is because
     * separators are not explicitly represented in the menu model. Instead,
     * a separator is inserted between any two non-empty sections of a menu.
     * Section items can have labels just like any other item. In that case,
     * a display system may show a section header instead of a separator.
     *
     * The motivation for this abstract model of application controls is
     * that modern user interfaces tend to make these controls available
     * outside the application. Examples include global menus, jumplists,
     * dash boards, etc. To support such uses, it is necessary to export
     * information about actions and their representation in menus, which
     * is exactly what the action group exporter and the menu model exporter do for
     * [iface`Gio`.ActionGroup] and [class`Gio`.MenuModel]. The client-side
     * counterparts to make use of the exported information are
     * [class`Gio`.DBusActionGroup] and [class`Gio`.DBusMenuModel].
     *
     * The API of `GMenuModel` is very generic, with iterators for the
     * attributes and links of an item, see
     * [method`Gio`.MenuModel.iterate_item_attributes] and
     * [method`Gio`.MenuModel.iterate_item_links]. The standard attributes and
     * link types have predefined names: `G_MENU_ATTRIBUTE_LABEL`,
     * `G_MENU_ATTRIBUTE_ACTION`, `G_MENU_ATTRIBUTE_TARGET`, `G_MENU_LINK_SECTION`
     * and `G_MENU_LINK_SUBMENU`.
     *
     * Items in a `GMenuModel` represent active controls if they refer to
     * an action that can get activated when the user interacts with the
     * menu item. The reference to the action is encoded by the string ID
     * in the `G_MENU_ATTRIBUTE_ACTION` attribute. An action ID uniquely
     * identifies an action in an action group. Which action group(s) provide
     * actions depends on the context in which the menu model is used.
     * E.g. when the model is exported as the application menu of a
     * [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
     * actions can be application-wide or window-specific (and thus come from
     * two different action groups). By convention, the application-wide actions
     * have names that start with `app.`, while the names of window-specific
     * actions start with `win.`.
     *
     * While a wide variety of stateful actions is possible, the following
     * is the minimum that is expected to be supported by all users of exported
     * menu information:
     * - an action with no parameter type and no state
     * - an action with no parameter type and boolean state
     * - an action with string parameter type and string state
     *
     * ## Stateless
     *
     * A stateless action typically corresponds to an ordinary menu item.
     *
     * Selecting such a menu item will activate the action (with no parameter).
     *
     * ## Boolean State
     *
     * An action with a boolean state will most typically be used with a toggle
     * or switch menu item. The state can be set directly, but activating the
     * action (with no parameter) results in the state being toggled.
     *
     * Selecting a toggle menu item will activate the action. The menu item should
     * be rendered as checked when the state is true.
     *
     * ## String Parameter and State
     *
     * Actions with string parameters and state will most typically be used to
     * represent an enumerated choice over the items available for a group of
     * radio menu items. Activating the action with a string parameter is
     * equivalent to setting that parameter as the state.
     *
     * Radio menu items, in addition to being associated with the action, will
     * have a target value. Selecting that menu item will result in activation
     * of the action with the target value as the parameter. The menu item should
     * be rendered as selected when the state of the action is equal to the
     * target value of the menu item.
     */
    abstract class MenuModel extends GObject.Object {
        static $gtype: GObject.GType<MenuModel>;

        // Constructors

        constructor(properties?: Partial<MenuModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'items-changed',
            callback: (_source: this, position: number, removed: number, added: number) => void,
        ): number;
        connect_after(
            signal: 'items-changed',
            callback: (_source: this, position: number, removed: number, added: number) => void,
        ): number;
        emit(signal: 'items-changed', position: number, removed: number, added: number): void;

        // Virtual methods

        /**
         * Queries the item at position `item_index` in `model` for the attribute
         * specified by `attribute`.
         *
         * If `expected_type` is non-%NULL then it specifies the expected type of
         * the attribute.  If it is %NULL then any type will be accepted.
         *
         * If the attribute exists and matches `expected_type` (or if the
         * expected type is unspecified) then the value is returned.
         *
         * If the attribute does not exist, or does not match the expected type
         * then %NULL is returned.
         * @param item_index the index of the item
         * @param attribute the attribute to query
         * @param expected_type the expected type of the attribute, or     %NULL
         */
        vfunc_get_item_attribute_value(
            item_index: number,
            attribute: string,
            expected_type?: GLib.VariantType | null,
        ): GLib.Variant | null;
        /**
         * Gets all the attributes associated with the item in the menu model.
         * @param item_index The #GMenuItem to query
         */
        vfunc_get_item_attributes(item_index: number): GLib.HashTable<string, GLib.Variant>;
        /**
         * Queries the item at position `item_index` in `model` for the link
         * specified by `link`.
         *
         * If the link exists, the linked #GMenuModel is returned.  If the link
         * does not exist, %NULL is returned.
         * @param item_index the index of the item
         * @param link the link to query
         */
        vfunc_get_item_link(item_index: number, link: string): MenuModel | null;
        /**
         * Gets all the links associated with the item in the menu model.
         * @param item_index The #GMenuItem to query
         */
        vfunc_get_item_links(item_index: number): GLib.HashTable<string, MenuModel>;
        /**
         * Query the number of items in `model`.
         */
        vfunc_get_n_items(): number;
        /**
         * Queries if `model` is mutable.
         *
         * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
         * signal. Consumers of the model may make optimisations accordingly.
         */
        vfunc_is_mutable(): boolean;
        /**
         * Creates a #GMenuAttributeIter to iterate over the attributes of
         * the item at position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @param item_index the index of the item
         */
        vfunc_iterate_item_attributes(item_index: number): MenuAttributeIter;
        /**
         * Creates a #GMenuLinkIter to iterate over the links of the item at
         * position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @param item_index the index of the item
         */
        vfunc_iterate_item_links(item_index: number): MenuLinkIter;

        // Methods

        /**
         * Queries the item at position `item_index` in `model` for the attribute
         * specified by `attribute`.
         *
         * If `expected_type` is non-%NULL then it specifies the expected type of
         * the attribute.  If it is %NULL then any type will be accepted.
         *
         * If the attribute exists and matches `expected_type` (or if the
         * expected type is unspecified) then the value is returned.
         *
         * If the attribute does not exist, or does not match the expected type
         * then %NULL is returned.
         * @param item_index the index of the item
         * @param attribute the attribute to query
         * @param expected_type the expected type of the attribute, or     %NULL
         * @returns the value of the attribute
         */
        get_item_attribute_value(
            item_index: number,
            attribute: string,
            expected_type?: GLib.VariantType | null,
        ): GLib.Variant | null;
        /**
         * Queries the item at position `item_index` in `model` for the link
         * specified by `link`.
         *
         * If the link exists, the linked #GMenuModel is returned.  If the link
         * does not exist, %NULL is returned.
         * @param item_index the index of the item
         * @param link the link to query
         * @returns the linked #GMenuModel, or %NULL
         */
        get_item_link(item_index: number, link: string): MenuModel | null;
        /**
         * Query the number of items in `model`.
         * @returns the number of items
         */
        get_n_items(): number;
        /**
         * Queries if `model` is mutable.
         *
         * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
         * signal. Consumers of the model may make optimisations accordingly.
         * @returns %TRUE if the model is mutable (ie: "items-changed" may be     emitted).
         */
        is_mutable(): boolean;
        /**
         * Requests emission of the #GMenuModel::items-changed signal on `model`.
         *
         * This function should never be called except by #GMenuModel
         * subclasses.  Any other calls to this function will very likely lead
         * to a violation of the interface of the model.
         *
         * The implementation should update its internal representation of the
         * menu before emitting the signal.  The implementation should further
         * expect to receive queries about the new state of the menu (and
         * particularly added menu items) while signal handlers are running.
         *
         * The implementation must dispatch this call directly from a mainloop
         * entry and not in response to calls -- particularly those from the
         * #GMenuModel API.  Said another way: the menu must not change while
         * user code is running without returning to the mainloop.
         * @param position the position of the change
         * @param removed the number of items removed
         * @param added the number of items added
         */
        items_changed(position: number, removed: number, added: number): void;
        /**
         * Creates a #GMenuAttributeIter to iterate over the attributes of
         * the item at position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @param item_index the index of the item
         * @returns a new #GMenuAttributeIter
         */
        iterate_item_attributes(item_index: number): MenuAttributeIter;
        /**
         * Creates a #GMenuLinkIter to iterate over the links of the item at
         * position `item_index` in `model`.
         *
         * You must free the iterator with g_object_unref() when you are done.
         * @param item_index the index of the item
         * @returns a new #GMenuLinkIter
         */
        iterate_item_links(item_index: number): MenuLinkIter;
    }

    module MountOperation {
        // Signal callback interfaces

        interface Aborted {
            (): void;
        }

        interface AskPassword {
            (message: string, default_user: string, default_domain: string, flags: AskPasswordFlags): void;
        }

        interface AskQuestion {
            (message: string, choices: string[]): void;
        }

        interface Reply {
            (result: MountOperationResult): void;
        }

        interface ShowProcesses {
            (message: string, processes: GLib.Pid[], choices: string[]): void;
        }

        interface ShowUnmountProgress {
            (message: string, time_left: number, bytes_left: number): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            anonymous: boolean;
            choice: number;
            domain: string;
            is_tcrypt_hidden_volume: boolean;
            isTcryptHiddenVolume: boolean;
            is_tcrypt_system_volume: boolean;
            isTcryptSystemVolume: boolean;
            password: string;
            password_save: PasswordSave;
            passwordSave: PasswordSave;
            pim: number;
            username: string;
        }
    }

    /**
     * `GMountOperation` provides a mechanism for interacting with the user.
     * It can be used for authenticating mountable operations, such as loop
     * mounting files, hard drive partitions or server locations. It can
     * also be used to ask the user questions or show a list of applications
     * preventing unmount or eject operations from completing.
     *
     * Note that `GMountOperation` is used for more than just [iface`Gio`.Mount]
     * objects  for example it is also used in [method`Gio`.Drive.start] and
     * [method`Gio`.Drive.stop].
     *
     * Users should instantiate a subclass of this that implements all the
     * various callbacks to show the required dialogs, such as
     * [`GtkMountOperation`](https://docs.gtk.org/gtk4/class.MountOperation.html).
     * If no user interaction is desired (for example when automounting
     * filesystems at login time), usually `NULL` can be passed, see each method
     * taking a `GMountOperation` for details.
     *
     * Throughout the API, the term TCRYPT is used to mean compatible with TrueCrypt and VeraCrypt.
     * [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
     * encrypting file containers, partitions or whole disks, typically used with Windows.
     * [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
     * improvements and auditing fixes.
     */
    class MountOperation extends GObject.Object {
        static $gtype: GObject.GType<MountOperation>;

        // Properties

        /**
         * Whether to use an anonymous user when authenticating.
         */
        get anonymous(): boolean;
        set anonymous(val: boolean);
        /**
         * The index of the user's choice when a question is asked during the
         * mount operation. See the #GMountOperation::ask-question signal.
         */
        get choice(): number;
        set choice(val: number);
        /**
         * The domain to use for the mount operation.
         */
        get domain(): string;
        set domain(val: string);
        /**
         * Whether the device to be unlocked is a TCRYPT hidden volume.
         * See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
         */
        get is_tcrypt_hidden_volume(): boolean;
        set is_tcrypt_hidden_volume(val: boolean);
        /**
         * Whether the device to be unlocked is a TCRYPT hidden volume.
         * See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
         */
        get isTcryptHiddenVolume(): boolean;
        set isTcryptHiddenVolume(val: boolean);
        /**
         * Whether the device to be unlocked is a TCRYPT system volume.
         * In this context, a system volume is a volume with a bootloader
         * and operating system installed. This is only supported for Windows
         * operating systems. For further documentation, see
         * [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
         */
        get is_tcrypt_system_volume(): boolean;
        set is_tcrypt_system_volume(val: boolean);
        /**
         * Whether the device to be unlocked is a TCRYPT system volume.
         * In this context, a system volume is a volume with a bootloader
         * and operating system installed. This is only supported for Windows
         * operating systems. For further documentation, see
         * [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
         */
        get isTcryptSystemVolume(): boolean;
        set isTcryptSystemVolume(val: boolean);
        /**
         * The password that is used for authentication when carrying out
         * the mount operation.
         */
        get password(): string;
        set password(val: string);
        /**
         * Determines if and how the password information should be saved.
         */
        get password_save(): PasswordSave;
        set password_save(val: PasswordSave);
        /**
         * Determines if and how the password information should be saved.
         */
        get passwordSave(): PasswordSave;
        set passwordSave(val: PasswordSave);
        /**
         * The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
         * [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html).
         */
        get pim(): number;
        set pim(val: number);
        /**
         * The user name that is used for authentication when carrying out
         * the mount operation.
         */
        get username(): string;
        set username(val: string);

        // Constructors

        constructor(properties?: Partial<MountOperation.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): MountOperation;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'aborted', callback: (_source: this) => void): number;
        connect_after(signal: 'aborted', callback: (_source: this) => void): number;
        emit(signal: 'aborted'): void;
        connect(
            signal: 'ask-password',
            callback: (
                _source: this,
                message: string,
                default_user: string,
                default_domain: string,
                flags: AskPasswordFlags,
            ) => void,
        ): number;
        connect_after(
            signal: 'ask-password',
            callback: (
                _source: this,
                message: string,
                default_user: string,
                default_domain: string,
                flags: AskPasswordFlags,
            ) => void,
        ): number;
        emit(
            signal: 'ask-password',
            message: string,
            default_user: string,
            default_domain: string,
            flags: AskPasswordFlags,
        ): void;
        connect(signal: 'ask-question', callback: (_source: this, message: string, choices: string[]) => void): number;
        connect_after(
            signal: 'ask-question',
            callback: (_source: this, message: string, choices: string[]) => void,
        ): number;
        emit(signal: 'ask-question', message: string, choices: string[]): void;
        connect(signal: 'reply', callback: (_source: this, result: MountOperationResult) => void): number;
        connect_after(signal: 'reply', callback: (_source: this, result: MountOperationResult) => void): number;
        emit(signal: 'reply', result: MountOperationResult): void;
        connect(
            signal: 'show-processes',
            callback: (_source: this, message: string, processes: GLib.Pid[], choices: string[]) => void,
        ): number;
        connect_after(
            signal: 'show-processes',
            callback: (_source: this, message: string, processes: GLib.Pid[], choices: string[]) => void,
        ): number;
        emit(signal: 'show-processes', message: string, processes: GLib.Pid[], choices: string[]): void;
        connect(
            signal: 'show-unmount-progress',
            callback: (_source: this, message: string, time_left: number, bytes_left: number) => void,
        ): number;
        connect_after(
            signal: 'show-unmount-progress',
            callback: (_source: this, message: string, time_left: number, bytes_left: number) => void,
        ): number;
        emit(signal: 'show-unmount-progress', message: string, time_left: number, bytes_left: number): void;

        // Virtual methods

        vfunc_aborted(): void;
        vfunc_ask_password(
            message: string,
            default_user: string,
            default_domain: string,
            flags: AskPasswordFlags,
        ): void;
        /**
         * Virtual implementation of #GMountOperation::ask-question.
         * @param message string containing a message to display to the user
         * @param choices an array of    strings for each possible choice
         */
        vfunc_ask_question(message: string, choices: string[]): void;
        /**
         * Emits the #GMountOperation::reply signal.
         * @param result a #GMountOperationResult
         */
        vfunc_reply(result: MountOperationResult): void;
        /**
         * Virtual implementation of #GMountOperation::show-processes.
         * @param message string containing a message to display to the user
         * @param processes an array of #GPid for processes blocking    the operation
         * @param choices an array of    strings for each possible choice
         */
        vfunc_show_processes(message: string, processes: GLib.Pid[], choices: string[]): void;
        vfunc_show_unmount_progress(message: string, time_left: number, bytes_left: number): void;

        // Methods

        /**
         * Check to see whether the mount operation is being used
         * for an anonymous user.
         * @returns %TRUE if mount operation is anonymous.
         */
        get_anonymous(): boolean;
        /**
         * Gets a choice from the mount operation.
         * @returns an integer containing an index of the user's choice from the choice's list, or `0`.
         */
        get_choice(): number;
        /**
         * Gets the domain of the mount operation.
         * @returns a string set to the domain.
         */
        get_domain(): string | null;
        /**
         * Check to see whether the mount operation is being used
         * for a TCRYPT hidden volume.
         * @returns %TRUE if mount operation is for hidden volume.
         */
        get_is_tcrypt_hidden_volume(): boolean;
        /**
         * Check to see whether the mount operation is being used
         * for a TCRYPT system volume.
         * @returns %TRUE if mount operation is for system volume.
         */
        get_is_tcrypt_system_volume(): boolean;
        /**
         * Gets a password from the mount operation.
         * @returns a string containing the password within @op.
         */
        get_password(): string | null;
        /**
         * Gets the state of saving passwords for the mount operation.
         * @returns a #GPasswordSave flag.
         */
        get_password_save(): PasswordSave;
        /**
         * Gets a PIM from the mount operation.
         * @returns The VeraCrypt PIM within @op.
         */
        get_pim(): number;
        /**
         * Get the user name from the mount operation.
         * @returns a string containing the user name.
         */
        get_username(): string | null;
        /**
         * Emits the #GMountOperation::reply signal.
         * @param result a #GMountOperationResult
         */
        reply(result: MountOperationResult): void;
        /**
         * Sets the mount operation to use an anonymous user if `anonymous` is %TRUE.
         * @param anonymous boolean value.
         */
        set_anonymous(anonymous: boolean): void;
        /**
         * Sets a default choice for the mount operation.
         * @param choice an integer.
         */
        set_choice(choice: number): void;
        /**
         * Sets the mount operation's domain.
         * @param domain the domain to set.
         */
        set_domain(domain?: string | null): void;
        /**
         * Sets the mount operation to use a hidden volume if `hidden_volume` is %TRUE.
         * @param hidden_volume boolean value.
         */
        set_is_tcrypt_hidden_volume(hidden_volume: boolean): void;
        /**
         * Sets the mount operation to use a system volume if `system_volume` is %TRUE.
         * @param system_volume boolean value.
         */
        set_is_tcrypt_system_volume(system_volume: boolean): void;
        /**
         * Sets the mount operation's password to `password`.
         * @param password password to set.
         */
        set_password(password?: string | null): void;
        /**
         * Sets the state of saving passwords for the mount operation.
         * @param save a set of #GPasswordSave flags.
         */
        set_password_save(save: PasswordSave): void;
        /**
         * Sets the mount operation's PIM to `pim`.
         * @param pim an unsigned integer.
         */
        set_pim(pim: number): void;
        /**
         * Sets the user name within `op` to `username`.
         * @param username input username.
         */
        set_username(username?: string | null): void;
    }

    module NativeSocketAddress {
        // Constructor properties interface

        interface ConstructorProps extends SocketAddress.ConstructorProps, SocketConnectable.ConstructorProps {}
    }

    /**
     * A socket address of some unknown native type.
     *
     * This corresponds to a general `struct sockaddr` of a type not otherwise
     * handled by GLib.
     */
    class NativeSocketAddress extends SocketAddress implements SocketConnectable {
        static $gtype: GObject.GType<NativeSocketAddress>;

        // Constructors

        constructor(properties?: Partial<NativeSocketAddress.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](_native: any | null, len: number): NativeSocketAddress;

        // Inherited methods
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         */
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module NativeVolumeMonitor {
        // Constructor properties interface

        interface ConstructorProps extends VolumeMonitor.ConstructorProps {}
    }

    abstract class NativeVolumeMonitor extends VolumeMonitor {
        static $gtype: GObject.GType<NativeVolumeMonitor>;

        // Constructors

        constructor(properties?: Partial<NativeVolumeMonitor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    module NetworkAddress {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, SocketConnectable.ConstructorProps {
            hostname: string;
            port: number;
            scheme: string;
        }
    }

    /**
     * `GNetworkAddress` provides an easy way to resolve a hostname and
     * then attempt to connect to that host, handling the possibility of
     * multiple IP addresses and multiple address families.
     *
     * The enumeration results of resolved addresses *may* be cached as long
     * as this object is kept alive which may have unexpected results if
     * alive for too long.
     *
     * See [iface`Gio`.SocketConnectable] for an example of using the connectable
     * interface.
     */
    class NetworkAddress extends GObject.Object implements SocketConnectable {
        static $gtype: GObject.GType<NetworkAddress>;

        // Properties

        /**
         * Hostname to resolve.
         */
        get hostname(): string;
        /**
         * Network port.
         */
        get port(): number;
        /**
         * URI scheme.
         */
        get scheme(): string;

        // Constructors

        constructor(properties?: Partial<NetworkAddress.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](hostname: string, port: number): NetworkAddress;

        static new_loopback(port: number): NetworkAddress;

        // Static methods

        /**
         * Creates a new #GSocketConnectable for connecting to the given
         * `hostname` and `port`. May fail and return %NULL in case
         * parsing `host_and_port` fails.
         *
         * `host_and_port` may be in any of a number of recognised formats; an IPv6
         * address, an IPv4 address, or a domain name (in which case a DNS
         * lookup is performed). Quoting with [] is supported for all address
         * types. A port override may be specified in the usual way with a
         * colon.
         *
         * If no port is specified in `host_and_port` then `default_port` will be
         * used as the port number to connect to.
         *
         * In general, `host_and_port` is expected to be provided by the user
         * (allowing them to give the hostname, and a port override if necessary)
         * and `default_port` is expected to be provided by the application.
         *
         * (The port component of `host_and_port` can also be specified as a
         * service name rather than as a numeric port, but this functionality
         * is deprecated, because it depends on the contents of /etc/services,
         * which is generally quite sparse on platforms other than Linux.)
         * @param host_and_port the hostname and optionally a port
         * @param default_port the default port if not in @host_and_port
         */
        static parse(host_and_port: string, default_port: number): NetworkAddress;
        /**
         * Creates a new #GSocketConnectable for connecting to the given
         * `uri`. May fail and return %NULL in case parsing `uri` fails.
         *
         * Using this rather than g_network_address_new() or
         * g_network_address_parse() allows #GSocketClient to determine
         * when to use application-specific proxy protocols.
         * @param uri the hostname and optionally a port
         * @param default_port The default port if none is found in the URI
         */
        static parse_uri(uri: string, default_port: number): NetworkAddress;

        // Methods

        /**
         * Gets `addr'`s hostname. This might be either UTF-8 or ASCII-encoded,
         * depending on what `addr` was created with.
         * @returns @addr's hostname
         */
        get_hostname(): string;
        /**
         * Gets `addr'`s port number
         * @returns @addr's port (which may be 0)
         */
        get_port(): number;
        /**
         * Gets `addr'`s scheme
         * @returns @addr's scheme (%NULL if not built from URI)
         */
        get_scheme(): string | null;

        // Inherited methods
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         */
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module NetworkService {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, SocketConnectable.ConstructorProps {
            domain: string;
            protocol: string;
            scheme: string;
            service: string;
        }
    }

    /**
     * Like [class`Gio`.NetworkAddress] does with hostnames, `GNetworkService`
     * provides an easy way to resolve a SRV record, and then attempt to
     * connect to one of the hosts that implements that service, handling
     * service priority/weighting, multiple IP addresses, and multiple
     * address families.
     *
     * See [struct`Gio`.SrvTarget] for more information about SRV records, and see
     * [iface`Gio`.SocketConnectable] for an example of using the connectable
     * interface.
     */
    class NetworkService extends GObject.Object implements SocketConnectable {
        static $gtype: GObject.GType<NetworkService>;

        // Properties

        /**
         * Network domain, for example `example.com`.
         */
        get domain(): string;
        /**
         * Network protocol, for example `tcp`.
         */
        get protocol(): string;
        /**
         * Network scheme (default is to use service).
         */
        get scheme(): string;
        set scheme(val: string);
        /**
         * Service name, for example `ldap`.
         */
        get service(): string;

        // Constructors

        constructor(properties?: Partial<NetworkService.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](service: string, protocol: string, domain: string): NetworkService;

        // Methods

        /**
         * Gets the domain that `srv` serves. This might be either UTF-8 or
         * ASCII-encoded, depending on what `srv` was created with.
         * @returns @srv's domain name
         */
        get_domain(): string;
        /**
         * Gets `srv'`s protocol name (eg, "tcp").
         * @returns @srv's protocol name
         */
        get_protocol(): string;
        /**
         * Gets the URI scheme used to resolve proxies. By default, the service name
         * is used as scheme.
         * @returns @srv's scheme name
         */
        get_scheme(): string;
        /**
         * Gets `srv'`s service name (eg, "ldap").
         * @returns @srv's service name
         */
        get_service(): string;
        /**
         * Set's the URI scheme used to resolve proxies. By default, the service name
         * is used as scheme.
         * @param scheme a URI scheme
         */
        set_scheme(scheme: string): void;

        // Inherited methods
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         */
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Notification {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GNotification` is a mechanism for creating a notification to be shown
     * to the user  typically as a pop-up notification presented by the
     * desktop environment shell.
     *
     * The key difference between `GNotification` and other similar APIs is
     * that, if supported by the desktop environment, notifications sent
     * with `GNotification` will persist after the application has exited,
     * and even across system reboots.
     *
     * Since the user may click on a notification while the application is
     * not running, applications using `GNotification` should be able to be
     * started as a D-Bus service, using [class`Gio`.Application].
     *
     * In order for `GNotification` to work, the application must have installed
     * a `.desktop` file. For example:
     * ```
     * [Desktop Entry]
     * Name=Test Application
     * Comment=Description of what Test Application does
     * Exec=gnome-test-application
     * Icon=org.gnome.TestApplication
     * Terminal=false
     * Type=Application
     * Categories=GNOME;GTK;TestApplication Category;
     * StartupNotify=true
     * DBusActivatable=true
     * X-GNOME-UsesNotifications=true
     * ```
     *
     * The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
     * that this application uses notifications, so it can be listed in the
     * Control Centers Notifications panel.
     *
     * The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
     * where `org.gnome.TestApplication` is the ID passed to
     * [ctor`Gio`.Application.new].
     *
     * User interaction with a notification (either the default action, or
     * buttons) must be associated with actions on the application (ie:
     * `app.` actions).  It is not possible to route user interaction
     * through the notification itself, because the object will not exist if
     * the application is autostarted as a result of a notification being
     * clicked.
     *
     * A notification can be sent with [method`Gio`.Application.send_notification].
     */
    class Notification extends GObject.Object {
        static $gtype: GObject.GType<Notification>;

        // Constructors

        constructor(properties?: Partial<Notification.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](title: string): Notification;

        // Methods

        /**
         * Adds a button to `notification` that activates the action in
         * `detailed_action` when clicked. That action must be an
         * application-wide action (starting with "app."). If `detailed_action`
         * contains a target, the action will be activated with that target as
         * its parameter.
         *
         * See g_action_parse_detailed_name() for a description of the format
         * for `detailed_action`.
         * @param label label of the button
         * @param detailed_action a detailed action name
         */
        add_button(label: string, detailed_action: string): void;
        /**
         * Adds a button to `notification` that activates `action` when clicked.
         * `action` must be an application-wide action (it must start with "app.").
         *
         * If `target` is non-%NULL, `action` will be activated with `target` as
         * its parameter.
         * @param label label of the button
         * @param action an action name
         * @param target a #GVariant to use as @action's parameter, or %NULL
         */
        add_button_with_target(label: string, action: string, target?: GLib.Variant | null): void;
        /**
         * Sets the body of `notification` to `body`.
         * @param body the new body for @notification, or %NULL
         */
        set_body(body?: string | null): void;
        /**
         * Sets the type of `notification` to `category`. Categories have a main
         * type like `email`, `im` or `device` and can have a detail separated
         * by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
         * helps the notification server to select proper feedback to the user.
         *
         * Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
         * @param category the category for @notification, or %NULL for no category
         */
        set_category(category?: string | null): void;
        /**
         * Sets the default action of `notification` to `detailed_action`. This
         * action is activated when the notification is clicked on.
         *
         * The action in `detailed_action` must be an application-wide action (it
         * must start with "app."). If `detailed_action` contains a target, the
         * given action will be activated with that target as its parameter.
         * See g_action_parse_detailed_name() for a description of the format
         * for `detailed_action`.
         *
         * When no default action is set, the application that the notification
         * was sent on is activated.
         * @param detailed_action a detailed action name
         */
        set_default_action(detailed_action: string): void;
        /**
         * Sets the default action of `notification` to `action`. This action is
         * activated when the notification is clicked on. It must be an
         * application-wide action (start with "app.").
         *
         * If `target` is non-%NULL, `action` will be activated with `target` as
         * its parameter. If `target` is floating, it will be consumed.
         *
         * When no default action is set, the application that the notification
         * was sent on is activated.
         * @param action an action name
         * @param target a #GVariant to use as @action's parameter, or %NULL
         */
        set_default_action_and_target(action: string, target?: GLib.Variant | null): void;
        /**
         * Sets the icon of `notification` to `icon`.
         * @param icon the icon to be shown in @notification, as a #GIcon
         */
        set_icon(icon: Icon): void;
        /**
         * Sets the priority of `notification` to `priority`. See
         * #GNotificationPriority for possible values.
         * @param priority a #GNotificationPriority
         */
        set_priority(priority: NotificationPriority): void;
        /**
         * Sets the title of `notification` to `title`.
         * @param title the new title for @notification
         */
        set_title(title: string): void;
        /**
         * Deprecated in favor of g_notification_set_priority().
         * @param urgent %TRUE if @notification is urgent
         */
        set_urgent(urgent: boolean): void;
    }

    module OutputStream {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GOutputStream` is a base class for implementing streaming output.
     *
     * It has functions to write to a stream ([method`Gio`.OutputStream.write]),
     * to close a stream ([method`Gio`.OutputStream.close]) and to flush pending
     * writes ([method`Gio`.OutputStream.flush]).
     *
     * To copy the content of an input stream to an output stream without
     * manually handling the reads and writes, use [method`Gio`.OutputStream.splice].
     *
     * See the documentation for [class`Gio`.IOStream] for details of thread safety
     * of streaming APIs.
     *
     * All of these functions have async variants too.
     *
     * All classes derived from `GOutputStream` *should* implement synchronous
     * writing, splicing, flushing and closing streams, but *may* implement
     * asynchronous versions.
     */
    abstract class OutputStream extends GObject.Object {
        static $gtype: GObject.GType<OutputStream>;

        // Constructors

        constructor(properties?: Partial<OutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         */
        vfunc_flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         */
        vfunc_flush_finish(result: AsyncResult): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         */
        vfunc_splice_finish(result: AsyncResult): number;
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_write_async(
            buffer: Uint8Array | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         */
        vfunc_write_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         */
        vfunc_write_fn(buffer?: Uint8Array | null, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         */
        vfunc_writev_finish(result: AsyncResult): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         */
        vfunc_writev_fn(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];

        // Methods

        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Closing a stream will automatically flush any outstanding buffers in the
         * stream.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user, otherwise
         * there might be a loss of data as all data might not be written.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but there some streams
         * can use a faster close that doesn't block to e.g. check errors. On
         * cancellation (as with any error) there is no guarantee that all written
         * data will reach the target.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on error
         */
        flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
         */
        flush_finish(result: AsyncResult): boolean;
        /**
         * Checks if an output stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an output stream has already been closed.
         * @returns %TRUE if @stream is closed. %FALSE otherwise.
         */
        is_closed(): boolean;
        /**
         * Checks if an output stream is being closed. This can be
         * used inside e.g. a flush implementation to see if the
         * flush (or other i/o operation) is called from within
         * the closing operation.
         * @returns %TRUE if @stream is being closed. %FALSE otherwise.
         */
        is_closing(): boolean;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
         */
        splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
         */
        splice_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * This function is similar to g_output_stream_write(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of `count` bytes, %TRUE is returned, and `bytes_written`
         * is set to `count`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all(buffer: Uint8Array | string, cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_write_all().
         *
         * Call g_output_stream_write_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called.
         * @param buffer the buffer containing the data to write
         * @param io_priority the io priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_all_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_write_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * A wrapper function for g_output_stream_write() which takes a
         * #GBytes as input.  This can be more convenient for use by language
         * bindings or in other cases where the refcounted nature of #GBytes
         * is helpful over a bare pointer interface.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write().  If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         * @param bytes the #GBytes to write
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write_bytes(bytes: GLib.Bytes | Uint8Array, cancellable?: Cancellable | null): number;
        /**
         * This function is similar to g_output_stream_write_async(), but
         * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
         * this allows the stream to avoid taking a copy of the data.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write_async(). If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write_bytes().
         * @param bytes The bytes to write
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        write_bytes_async(
            bytes: GLib.Bytes | Uint8Array,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write-from-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_bytes_finish(result: AsyncResult): number;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_finish(result: AsyncResult): number;
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * This function is similar to g_output_stream_writev(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of all `n_vectors` vectors, %TRUE is returned, and
         * `bytes_written` is set to the sum of all the sizes of `vectors`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C. If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         *
         * The content of the individual elements of `vectors` might be changed by this
         * function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_writev_all().
         *
         * Call g_output_stream_writev_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called. The content of the individual elements
         * of `vectors` might be changed by this function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_all_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_writev_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_writev_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_finish(result: AsyncResult): [boolean, number];
    }

    module Permission {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            allowed: boolean;
            can_acquire: boolean;
            canAcquire: boolean;
            can_release: boolean;
            canRelease: boolean;
        }
    }

    /**
     * A `GPermission` represents the status of the callers permission to
     * perform a certain action.
     *
     * You can query if the action is currently allowed and if it is
     * possible to acquire the permission so that the action will be allowed
     * in the future.
     *
     * There is also an API to actually acquire the permission and one to
     * release it.
     *
     * As an example, a `GPermission` might represent the ability for the
     * user to write to a [class`Gio`.Settings] object.  This `GPermission` object
     * could then be used to decide if it is appropriate to show a Click here to
     * unlock button in a dialog and to provide the mechanism to invoke
     * when that button is clicked.
     */
    abstract class Permission extends GObject.Object {
        static $gtype: GObject.GType<Permission>;

        // Properties

        /**
         * %TRUE if the caller currently has permission to perform the action that
         * `permission` represents the permission to perform.
         */
        get allowed(): boolean;
        /**
         * %TRUE if it is generally possible to acquire the permission by calling
         * g_permission_acquire().
         */
        get can_acquire(): boolean;
        /**
         * %TRUE if it is generally possible to acquire the permission by calling
         * g_permission_acquire().
         */
        get canAcquire(): boolean;
        /**
         * %TRUE if it is generally possible to release the permission by calling
         * g_permission_release().
         */
        get can_release(): boolean;
        /**
         * %TRUE if it is generally possible to release the permission by calling
         * g_permission_release().
         */
        get canRelease(): boolean;

        // Constructors

        constructor(properties?: Partial<Permission.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  A simple example is
         * that a dialog may appear asking the user to enter their password.
         *
         * You should check with g_permission_get_can_acquire() before calling
         * this function.
         *
         * If the permission is acquired then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_acquire_async() for
         * the non-blocking version.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_acquire(cancellable?: Cancellable | null): boolean;
        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_acquire().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        vfunc_acquire_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Collects the result of attempting to acquire the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_acquire().
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         */
        vfunc_acquire_finish(result: AsyncResult): boolean;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  In most cases the
         * permission will be dropped immediately without further action.
         *
         * You should check with g_permission_get_can_release() before calling
         * this function.
         *
         * If the permission is released then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_release_async() for
         * the non-blocking version.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_release(cancellable?: Cancellable | null): boolean;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_release().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        vfunc_release_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Collects the result of attempting to release the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_release().
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         */
        vfunc_release_finish(result: AsyncResult): boolean;

        // Methods

        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  A simple example is
         * that a dialog may appear asking the user to enter their password.
         *
         * You should check with g_permission_get_can_acquire() before calling
         * this function.
         *
         * If the permission is acquired then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_acquire_async() for
         * the non-blocking version.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the permission was successfully acquired
         */
        acquire(cancellable?: Cancellable | null): boolean;
        /**
         * Attempts to acquire the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_acquire().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        acquire_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Collects the result of attempting to acquire the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_acquire().
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         * @returns %TRUE if the permission was successfully acquired
         */
        acquire_finish(result: AsyncResult): boolean;
        /**
         * Gets the value of the 'allowed' property.  This property is %TRUE if
         * the caller currently has permission to perform the action that
         * `permission` represents the permission to perform.
         * @returns the value of the 'allowed' property
         */
        get_allowed(): boolean;
        /**
         * Gets the value of the 'can-acquire' property.  This property is %TRUE
         * if it is generally possible to acquire the permission by calling
         * g_permission_acquire().
         * @returns the value of the 'can-acquire' property
         */
        get_can_acquire(): boolean;
        /**
         * Gets the value of the 'can-release' property.  This property is %TRUE
         * if it is generally possible to release the permission by calling
         * g_permission_release().
         * @returns the value of the 'can-release' property
         */
        get_can_release(): boolean;
        /**
         * This function is called by the #GPermission implementation to update
         * the properties of the permission.  You should never call this
         * function except from a #GPermission implementation.
         *
         * GObject notify signals are generated, as appropriate.
         * @param allowed the new value for the 'allowed' property
         * @param can_acquire the new value for the 'can-acquire' property
         * @param can_release the new value for the 'can-release' property
         */
        impl_update(allowed: boolean, can_acquire: boolean, can_release: boolean): void;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * The precise method by which this happens depends on the permission
         * and the underlying authentication mechanism.  In most cases the
         * permission will be dropped immediately without further action.
         *
         * You should check with g_permission_get_can_release() before calling
         * this function.
         *
         * If the permission is released then %TRUE is returned.  Otherwise,
         * %FALSE is returned and `error` is set appropriately.
         *
         * This call is blocking, likely for a very long time (in the case that
         * user interaction is required).  See g_permission_release_async() for
         * the non-blocking version.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the permission was successfully released
         */
        release(cancellable?: Cancellable | null): boolean;
        /**
         * Attempts to release the permission represented by `permission`.
         *
         * This is the first half of the asynchronous version of
         * g_permission_release().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback the #GAsyncReadyCallback to call when done
         */
        release_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Collects the result of attempting to release the permission
         * represented by `permission`.
         *
         * This is the second half of the asynchronous version of
         * g_permission_release().
         * @param result the #GAsyncResult given to the #GAsyncReadyCallback
         * @returns %TRUE if the permission was successfully released
         */
        release_finish(result: AsyncResult): boolean;
    }

    module PropertyAction {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Action.ConstructorProps {
            enabled: boolean;
            invert_boolean: boolean;
            invertBoolean: boolean;
            name: string;
            object: GObject.Object;
            parameter_type: GLib.VariantType;
            parameterType: GLib.VariantType;
            property_name: string;
            propertyName: string;
            state: GLib.Variant;
            state_type: GLib.VariantType;
            stateType: GLib.VariantType;
        }
    }

    /**
     * A `GPropertyAction` is a way to get a [iface`Gio`.Action] with a state value
     * reflecting and controlling the value of a [class`GObject`.Object] property.
     *
     * The state of the action will correspond to the value of the property.
     * Changing it will change the property (assuming the requested value
     * matches the requirements as specified in the [type`GObject`.ParamSpec]).
     *
     * Only the most common types are presently supported.  Booleans are
     * mapped to booleans, strings to strings, signed/unsigned integers to
     * int32/uint32 and floats and doubles to doubles.
     *
     * If the property is an enum then the state will be string-typed and
     * conversion will automatically be performed between the enum value and
     * nick string as per the [type`GObject`.EnumValue] table.
     *
     * Flags types are not currently supported.
     *
     * Properties of object types, boxed types and pointer types are not
     * supported and probably never will be.
     *
     * Properties of [type`GLib`.Variant] types are not currently supported.
     *
     * If the property is boolean-valued then the action will have a `NULL`
     * parameter type, and activating the action (with no parameter) will
     * toggle the value of the property.
     *
     * In all other cases, the parameter type will correspond to the type of
     * the property.
     *
     * The general idea here is to reduce the number of locations where a
     * particular piece of state is kept (and therefore has to be synchronised
     * between). `GPropertyAction` does not have a separate state that is kept
     * in sync with the property value  its state is the property value.
     *
     * For example, it might be useful to create a [iface`Gio`.Action] corresponding
     * to the `visible-child-name` property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html)
     * so that the current page can be switched from a menu.  The active radio
     * indication in the menu is then directly determined from the active page of
     * the `GtkStack`.
     *
     * An anti-example would be binding the `active-id` property on a
     * [`GtkComboBox`](https://docs.gtk.org/gtk4/class.ComboBox.html). This is
     * because the state of the combo box itself is probably uninteresting and is
     * actually being used to control something else.
     *
     * Another anti-example would be to bind to the `visible-child-name`
     * property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html) if
     * this value is actually stored in [class`Gio`.Settings].  In that case, the
     * real source of the value is* [class`Gio`.Settings].  If you want
     * a [iface`Gio`.Action] to control a setting stored in [class`Gio`.Settings],
     * see [method`Gio`.Settings.create_action] instead, and possibly combine its
     * use with [method`Gio`.Settings.bind].
     */
    class PropertyAction extends GObject.Object implements Action {
        static $gtype: GObject.GType<PropertyAction>;

        // Properties

        /**
         * If `action` is currently enabled.
         *
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        get enabled(): boolean;
        /**
         * If %TRUE, the state of the action will be the negation of the
         * property value, provided the property is boolean.
         */
        get invert_boolean(): boolean;
        /**
         * If %TRUE, the state of the action will be the negation of the
         * property value, provided the property is boolean.
         */
        get invertBoolean(): boolean;
        /**
         * The name of the action.  This is mostly meaningful for identifying
         * the action once it has been added to a #GActionMap.
         */
        get name(): string;
        /**
         * The object to wrap a property on.
         *
         * The object must be a non-%NULL #GObject with properties.
         */
        set object(val: GObject.Object);
        /**
         * The type of the parameter that must be given when activating the
         * action.
         */
        get parameter_type(): GLib.VariantType;
        /**
         * The type of the parameter that must be given when activating the
         * action.
         */
        get parameterType(): GLib.VariantType;
        /**
         * The name of the property to wrap on the object.
         *
         * The property must exist on the passed-in object and it must be
         * readable and writable (and not construct-only).
         */
        set property_name(val: string);
        /**
         * The name of the property to wrap on the object.
         *
         * The property must exist on the passed-in object and it must be
         * readable and writable (and not construct-only).
         */
        set propertyName(val: string);
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        get state(): GLib.Variant;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless.
         */
        get state_type(): GLib.VariantType;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless.
         */
        get stateType(): GLib.VariantType;

        // Constructors

        constructor(properties?: Partial<PropertyAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](name: string, object: GObject.Object, property_name: string): PropertyAction;

        // Inherited methods
        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @returns whether the action is enabled
         */
        get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         * @returns the name of the action
         */
        get_name(): string;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         * @returns the parameter type
         */
        get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the current state of the action
         */
        get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the state range hint
         */
        get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         * @returns the state type, if the action is stateful
         */
        get_state_type(): GLib.VariantType | null;
        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        vfunc_activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        vfunc_change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         */
        vfunc_get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         */
        vfunc_get_name(): string;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         */
        vfunc_get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         */
        vfunc_get_state_type(): GLib.VariantType | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ProxyAddress {
        // Constructor properties interface

        interface ConstructorProps extends InetSocketAddress.ConstructorProps, SocketConnectable.ConstructorProps {
            destination_hostname: string;
            destinationHostname: string;
            destination_port: number;
            destinationPort: number;
            destination_protocol: string;
            destinationProtocol: string;
            password: string;
            protocol: string;
            uri: string;
            username: string;
        }
    }

    /**
     * A [class`Gio`.InetSocketAddress] representing a connection via a proxy server.
     */
    class ProxyAddress extends InetSocketAddress implements SocketConnectable {
        static $gtype: GObject.GType<ProxyAddress>;

        // Properties

        /**
         * The proxy destination hostname.
         */
        get destination_hostname(): string;
        /**
         * The proxy destination hostname.
         */
        get destinationHostname(): string;
        /**
         * The proxy destination port.
         */
        get destination_port(): number;
        /**
         * The proxy destination port.
         */
        get destinationPort(): number;
        /**
         * The protocol being spoke to the destination host, or %NULL if
         * the #GProxyAddress doesn't know.
         */
        get destination_protocol(): string;
        /**
         * The protocol being spoke to the destination host, or %NULL if
         * the #GProxyAddress doesn't know.
         */
        get destinationProtocol(): string;
        /**
         * The proxy password.
         */
        get password(): string;
        /**
         * The proxy protocol.
         */
        get protocol(): string;
        /**
         * The URI string that the proxy was constructed from (or %NULL
         * if the creator didn't specify this).
         */
        get uri(): string;
        /**
         * The proxy username.
         */
        get username(): string;

        // Constructors

        constructor(properties?: Partial<ProxyAddress.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            inetaddr: InetAddress,
            port: number,
            protocol: string,
            dest_hostname: string,
            dest_port: number,
            username?: string | null,
            password?: string | null,
        ): ProxyAddress;
        // Conflicted with Gio.InetSocketAddress.new

        static ['new'](...args: never[]): any;

        // Methods

        /**
         * Gets `proxy'`s destination hostname; that is, the name of the host
         * that will be connected to via the proxy, not the name of the proxy
         * itself.
         * @returns the @proxy's destination hostname
         */
        get_destination_hostname(): string;
        /**
         * Gets `proxy'`s destination port; that is, the port on the
         * destination host that will be connected to via the proxy, not the
         * port number of the proxy itself.
         * @returns the @proxy's destination port
         */
        get_destination_port(): number;
        /**
         * Gets the protocol that is being spoken to the destination
         * server; eg, "http" or "ftp".
         * @returns the @proxy's destination protocol
         */
        get_destination_protocol(): string;
        /**
         * Gets `proxy'`s password.
         * @returns the @proxy's password
         */
        get_password(): string | null;
        /**
         * Gets `proxy'`s protocol. eg, "socks" or "http"
         * @returns the @proxy's protocol
         */
        get_protocol(): string;
        /**
         * Gets the proxy URI that `proxy` was constructed from.
         * @returns the @proxy's URI, or %NULL if unknown
         */
        get_uri(): string | null;
        /**
         * Gets `proxy'`s username.
         * @returns the @proxy's username
         */
        get_username(): string | null;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ProxyAddressEnumerator {
        // Constructor properties interface

        interface ConstructorProps extends SocketAddressEnumerator.ConstructorProps {
            connectable: SocketConnectable;
            default_port: number;
            defaultPort: number;
            proxy_resolver: ProxyResolver;
            proxyResolver: ProxyResolver;
            uri: string;
        }
    }

    /**
     * `GProxyAddressEnumerator` is a wrapper around
     * [class`Gio`.SocketAddressEnumerator] which takes the [class`Gio`.SocketAddress]
     * instances returned by the [class`Gio`.SocketAddressEnumerator]
     * and wraps them in [class`Gio`.ProxyAddress] instances, using the given
     * [property`Gio`.ProxyAddressEnumerator:proxy-resolver].
     *
     * This enumerator will be returned (for example, by
     * [method`Gio`.SocketConnectable.enumerate]) as appropriate when a proxy is
     * configured; there should be no need to manually wrap a
     * [class`Gio`.SocketAddressEnumerator] instance with one.
     */
    class ProxyAddressEnumerator extends SocketAddressEnumerator {
        static $gtype: GObject.GType<ProxyAddressEnumerator>;

        // Properties

        /**
         * The connectable being enumerated.
         */
        get connectable(): SocketConnectable;
        /**
         * The default port to use if #GProxyAddressEnumerator:uri does not
         * specify one.
         */
        get default_port(): number;
        /**
         * The default port to use if #GProxyAddressEnumerator:uri does not
         * specify one.
         */
        get defaultPort(): number;
        /**
         * The proxy resolver to use.
         */
        get proxy_resolver(): ProxyResolver;
        set proxy_resolver(val: ProxyResolver);
        /**
         * The proxy resolver to use.
         */
        get proxyResolver(): ProxyResolver;
        set proxyResolver(val: ProxyResolver);
        /**
         * The destination URI. Use `none://` for a generic socket.
         */
        get uri(): string;

        // Constructors

        constructor(properties?: Partial<ProxyAddressEnumerator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    module Resolver {
        // Signal callback interfaces

        interface Reload {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            timeout: number;
        }
    }

    /**
     * The object that handles DNS resolution. Use [func`Gio`.Resolver.get_default]
     * to get the default resolver.
     *
     * `GResolver` provides cancellable synchronous and asynchronous DNS
     * resolution, for hostnames ([method`Gio`.Resolver.lookup_by_address],
     * [method`Gio`.Resolver.lookup_by_name] and their async variants) and SRV
     * (service) records ([method`Gio`.Resolver.lookup_service]).
     *
     * [class`Gio`.NetworkAddress] and [class`Gio`.NetworkService] provide wrappers
     * around `GResolver` functionality that also implement
     * [iface`Gio`.SocketConnectable], making it easy to connect to a remote
     * host/service.
     *
     * The default resolver (see [func`Gio`.Resolver.get_default]) has a timeout of
     * 30s set on it since GLib 2.78. Earlier versions of GLib did not support
     * resolver timeouts.
     *
     * This is an abstract type; subclasses of it implement different resolvers for
     * different platforms and situations.
     */
    abstract class Resolver extends GObject.Object {
        static $gtype: GObject.GType<Resolver>;

        // Properties

        /**
         * The timeout applied to all resolver lookups, in milliseconds.
         *
         * This may be changed through the lifetime of the #GResolver. The new value
         * will apply to any lookups started after the change, but not to any
         * already-ongoing lookups.
         *
         * If this is `0`, no timeout is applied to lookups.
         *
         * No timeout was applied to lookups before this property was added in
         * GLib 2.78.
         */
        get timeout(): number;
        set timeout(val: number);

        // Constructors

        constructor(properties?: Partial<Resolver.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'reload', callback: (_source: this) => void): number;
        connect_after(signal: 'reload', callback: (_source: this) => void): number;
        emit(signal: 'reload'): void;

        // Static methods

        /**
         * Gets the default #GResolver. You should unref it when you are done
         * with it. #GResolver may use its reference count as a hint about how
         * many threads it should allocate for concurrent DNS resolutions.
         */
        static get_default(): Resolver;

        // Virtual methods

        /**
         * Synchronously reverse-resolves `address` to determine its
         * associated hostname.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup_by_address(address: InetAddress, cancellable?: Cancellable | null): string;
        /**
         * Begins asynchronously reverse-resolving `address` to determine its
         * associated hostname, and eventually calls `callback,` which must
         * call g_resolver_lookup_by_address_finish() to get the final result.
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_by_address_async(
            address: InetAddress,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_by_address_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         */
        vfunc_lookup_by_address_finish(result: AsyncResult): string;
        /**
         * Synchronously resolves `hostname` to determine its associated IP
         * address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
         * the textual form of an IP address (in which case this just becomes
         * a wrapper around g_inet_address_new_from_string()).
         *
         * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
         * #GInetAddress, sorted in order of preference and guaranteed to not
         * contain duplicates. That is, if using the result to connect to
         * `hostname,` you should attempt to connect to the first address
         * first, then the second if the first fails, etc. If you are using
         * the result to listen on a socket, it is appropriate to add each
         * result using e.g. g_socket_listener_add_address().
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to a
         * value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         *
         * If you are planning to connect to a socket on the resolved IP
         * address, it may be easier to create a #GNetworkAddress and use its
         * #GSocketConnectable interface.
         * @param hostname the hostname to look up
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup_by_name(hostname: string, cancellable?: Cancellable | null): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_by_name_async(
            hostname: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         */
        vfunc_lookup_by_name_finish(result: AsyncResult): InetAddress[];
        /**
         * This differs from g_resolver_lookup_by_name() in that you can modify
         * the lookup behavior with `flags`. For example this can be used to limit
         * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
         * @param hostname the hostname to look up
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup_by_name_with_flags(
            hostname: string,
            flags: ResolverNameLookupFlags,
            cancellable?: Cancellable | null,
        ): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_by_name_with_flags_async(
            hostname: string,
            flags: ResolverNameLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_with_flags_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         */
        vfunc_lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[];
        /**
         * Synchronously performs a DNS record lookup for the given `rrname` and returns
         * a list of records as #GVariant tuples. See #GResolverRecordType for
         * information on what the records contain for each `record_type`.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup_records(
            rrname: string,
            record_type: ResolverRecordType,
            cancellable?: Cancellable | null,
        ): GLib.Variant[];
        /**
         * Begins asynchronously performing a DNS lookup for the given
         * `rrname,` and eventually calls `callback,` which must call
         * g_resolver_lookup_records_finish() to get the final result. See
         * g_resolver_lookup_records() for more details.
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_records_async(
            rrname: string,
            record_type: ResolverRecordType,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_records_async(). Returns a non-empty list of records as
         * #GVariant tuples. See #GResolverRecordType for information on what the
         * records contain.
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         */
        vfunc_lookup_records_finish(result: AsyncResult): GLib.Variant[];
        vfunc_lookup_service_async(
            rrname: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_service_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         */
        vfunc_lookup_service_finish(result: AsyncResult): SrvTarget[];
        vfunc_reload(): void;

        // Methods

        /**
         * Get the timeout applied to all resolver lookups. See #GResolver:timeout.
         * @returns the resolver timeout, in milliseconds, or `0` for no timeout
         */
        get_timeout(): number;
        /**
         * Synchronously reverse-resolves `address` to determine its
         * associated hostname.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @returns a hostname (either ASCII-only, or in ASCII-encoded     form), or %NULL on error.
         */
        lookup_by_address(address: InetAddress, cancellable?: Cancellable | null): string;
        /**
         * Begins asynchronously reverse-resolving `address` to determine its
         * associated hostname, and eventually calls `callback,` which must
         * call g_resolver_lookup_by_address_finish() to get the final result.
         * @param address the address to reverse-resolve
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_by_address_async(
            address: InetAddress,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_by_address_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a hostname (either ASCII-only, or in ASCII-encoded form), or %NULL on error.
         */
        lookup_by_address_finish(result: AsyncResult): string;
        /**
         * Synchronously resolves `hostname` to determine its associated IP
         * address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
         * the textual form of an IP address (in which case this just becomes
         * a wrapper around g_inet_address_new_from_string()).
         *
         * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
         * #GInetAddress, sorted in order of preference and guaranteed to not
         * contain duplicates. That is, if using the result to connect to
         * `hostname,` you should attempt to connect to the first address
         * first, then the second if the first fails, etc. If you are using
         * the result to listen on a socket, it is appropriate to add each
         * result using e.g. g_socket_listener_add_address().
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to a
         * value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         *
         * If you are planning to connect to a socket on the resolved IP
         * address, it may be easier to create a #GNetworkAddress and use its
         * #GSocketConnectable interface.
         * @param hostname the hostname to look up
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
         */
        lookup_by_name(hostname: string, cancellable?: Cancellable | null): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_by_name_async(
            hostname: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        lookup_by_name_finish(result: AsyncResult): InetAddress[];
        /**
         * This differs from g_resolver_lookup_by_name() in that you can modify
         * the lookup behavior with `flags`. For example this can be used to limit
         * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
         * @param hostname the hostname to look up
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
         */
        lookup_by_name_with_flags(
            hostname: string,
            flags: ResolverNameLookupFlags,
            cancellable?: Cancellable | null,
        ): InetAddress[];
        /**
         * Begins asynchronously resolving `hostname` to determine its
         * associated IP address(es), and eventually calls `callback,` which
         * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
         * See g_resolver_lookup_by_name() for more details.
         * @param hostname the hostname to look up the address of
         * @param flags extra #GResolverNameLookupFlags for the lookup
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_by_name_with_flags_async(
            hostname: string,
            flags: ResolverNameLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a call to
         * g_resolver_lookup_by_name_with_flags_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
         */
        lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[];
        /**
         * Synchronously performs a DNS record lookup for the given `rrname` and returns
         * a list of records as #GVariant tuples. See #GResolverRecordType for
         * information on what the records contain for each `record_type`.
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
         */
        lookup_records(
            rrname: string,
            record_type: ResolverRecordType,
            cancellable?: Cancellable | null,
        ): GLib.Variant[];
        /**
         * Begins asynchronously performing a DNS lookup for the given
         * `rrname,` and eventually calls `callback,` which must call
         * g_resolver_lookup_records_finish() to get the final result. See
         * g_resolver_lookup_records() for more details.
         * @param rrname the DNS name to look up the record for
         * @param record_type the type of DNS record to look up
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_records_async(
            rrname: string,
            record_type: ResolverRecordType,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_records_async(). Returns a non-empty list of records as
         * #GVariant tuples. See #GResolverRecordType for information on what the
         * records contain.
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
         */
        lookup_records_finish(result: AsyncResult): GLib.Variant[];
        /**
         * Synchronously performs a DNS SRV lookup for the given `service` and
         * `protocol` in the given `domain` and returns an array of #GSrvTarget.
         * `domain` may be an ASCII-only or UTF-8 hostname. Note also that the
         * `service` and `protocol` arguments do not include the leading underscore
         * that appears in the actual DNS entry.
         *
         * On success, g_resolver_lookup_service() will return a non-empty #GList of
         * #GSrvTarget, sorted in order of preference. (That is, you should
         * attempt to connect to the first target first, then the second if
         * the first fails, etc.)
         *
         * If the DNS resolution fails, `error` (if non-%NULL) will be set to
         * a value from #GResolverError and %NULL will be returned.
         *
         * If `cancellable` is non-%NULL, it can be used to cancel the
         * operation, in which case `error` (if non-%NULL) will be set to
         * %G_IO_ERROR_CANCELLED.
         *
         * If you are planning to connect to the service, it is usually easier
         * to create a #GNetworkService and use its #GSocketConnectable
         * interface.
         * @param service the service type to look up (eg, "ldap")
         * @param protocol the networking protocol to use for @service (eg, "tcp")
         * @param domain the DNS domain to look up the service in
         * @param cancellable a #GCancellable, or %NULL
         * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. You must free each of the targets and the list when you are done with it. (You can use g_resolver_free_targets() to do this.)
         */
        lookup_service(
            service: string,
            protocol: string,
            domain: string,
            cancellable?: Cancellable | null,
        ): SrvTarget[];
        /**
         * Begins asynchronously performing a DNS SRV lookup for the given
         * `service` and `protocol` in the given `domain,` and eventually calls
         * `callback,` which must call g_resolver_lookup_service_finish() to
         * get the final result. See g_resolver_lookup_service() for more
         * details.
         * @param service the service type to look up (eg, "ldap")
         * @param protocol the networking protocol to use for @service (eg, "tcp")
         * @param domain the DNS domain to look up the service in
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_service_async(
            service: string,
            protocol: string,
            domain: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Retrieves the result of a previous call to
         * g_resolver_lookup_service_async().
         *
         * If the DNS resolution failed, `error` (if non-%NULL) will be set to
         * a value from #GResolverError. If the operation was cancelled,
         * `error` will be set to %G_IO_ERROR_CANCELLED.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more details.
         */
        lookup_service_finish(result: AsyncResult): SrvTarget[];
        /**
         * Sets `resolver` to be the application's default resolver (reffing
         * `resolver,` and unreffing the previous default resolver, if any).
         * Future calls to g_resolver_get_default() will return this resolver.
         *
         * This can be used if an application wants to perform any sort of DNS
         * caching or "pinning"; it can implement its own #GResolver that
         * calls the original default resolver for DNS operations, and
         * implements its own cache policies on top of that, and then set
         * itself as the default resolver for all later code to use.
         */
        set_default(): void;
        /**
         * Set the timeout applied to all resolver lookups. See #GResolver:timeout.
         * @param timeout_ms timeout in milliseconds, or `0` for no timeouts
         */
        set_timeout(timeout_ms: number): void;
    }

    module Settings {
        // Signal callback interfaces

        interface ChangeEvent {
            (keys?: GLib.Quark[] | null): boolean;
        }

        interface Changed {
            (key: string): void;
        }

        interface WritableChangeEvent {
            (key: number): boolean;
        }

        interface WritableChanged {
            (key: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            backend: SettingsBackend;
            delay_apply: boolean;
            delayApply: boolean;
            has_unapplied: boolean;
            hasUnapplied: boolean;
            path: string;
            schema: string;
            schema_id: string;
            schemaId: string;
            settings_schema: SettingsSchema;
            settingsSchema: SettingsSchema;
        }
    }

    /**
     * The `GSettings` class provides a convenient API for storing and retrieving
     * application settings.
     *
     * Reads and writes can be considered to be non-blocking.  Reading
     * settings with `GSettings` is typically extremely fast: on
     * approximately the same order of magnitude (but slower than) a
     * [struct`GLib`.HashTable] lookup.  Writing settings is also extremely fast in
     * terms of time to return to your application, but can be extremely expensive
     * for other threads and other processes.  Many settings backends
     * (including dconf) have lazy initialisation which means in the common
     * case of the user using their computer without modifying any settings
     * a lot of work can be avoided.  For dconf, the D-Bus service doesnt
     * even need to be started in this case.  For this reason, you should
     * only ever modify `GSettings` keys in response to explicit user action.
     * Particular care should be paid to ensure that modifications are not
     * made during startup  for example, when setting the initial value
     * of preferences widgets.  The built-in [method`Gio`.Settings.bind]
     * functionality is careful not to write settings in response to notify signals
     * as a result of modifications that it makes to widgets.
     *
     * When creating a `GSettings` instance, you have to specify a schema
     * that describes the keys in your settings and their types and default
     * values, as well as some other information.
     *
     * Normally, a schema has a fixed path that determines where the settings
     * are stored in the conceptual global tree of settings. However, schemas
     * can also be [relocatable](#relocatable-schemas), i.e. not equipped with
     * a fixed path. This is
     * useful e.g. when the schema describes an account, and you want to be
     * able to store a arbitrary number of accounts.
     *
     * Paths must start with and end with a forward slash character (`/`)
     * and must not contain two sequential slash characters.  Paths should
     * be chosen based on a domain name associated with the program or
     * library to which the settings belong.  Examples of paths are
     * `/org/gtk/settings/file-chooser/` and `/ca/desrt/dconf-editor/`.
     * Paths should not start with `/apps/`, `/desktop/` or `/system/` as
     * they often did in GConf.
     *
     * Unlike other configuration systems (like GConf), GSettings does not
     * restrict keys to basic types like strings and numbers. GSettings stores
     * values as [struct`GLib`.Variant], and allows any [type`GLib`.VariantType] for
     * keys. Key names are restricted to lowercase characters, numbers and `-`.
     * Furthermore, the names must begin with a lowercase character, must not end
     * with a `-`, and must not contain consecutive dashes.
     *
     * Similar to GConf, the default values in GSettings schemas can be
     * localized, but the localized values are stored in gettext catalogs
     * and looked up with the domain that is specified in the
     * `gettext-domain` attribute of the `<schemalist>` or `<schema>`
     * elements and the category that is specified in the `l10n` attribute of
     * the `<default>` element. The string which is translated includes all text in
     * the `<default>` element, including any surrounding quotation marks.
     *
     * The `l10n` attribute must be set to `messages` or `time`, and sets the
     * [locale category for
     * translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
     * The `messages` category should be used by default; use `time` for
     * translatable date or time formats. A translation comment can be added as an
     * XML comment immediately above the `<default>` element  it is recommended to
     * add these comments to aid translators understand the meaning and
     * implications of the default value. An optional translation `context`
     * attribute can be set on the `<default>` element to disambiguate multiple
     * defaults which use the same string.
     *
     * For example:
     * ```xml
     *  <!-- Translators: A list of words which are not allowed to be typed, in
     *       GVariant serialization syntax.
     *       See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
     *  <default l10n='messages' context='Banned words'>['bad', 'words']</default>
     * ```
     *
     * Translations of default values must remain syntactically valid serialized
     * [struct`GLib`.Variant]s (e.g. retaining any surrounding quotation marks) or
     * runtime errors will occur.
     *
     * GSettings uses schemas in a compact binary form that is created
     * by the [`glib-compile-schemas`](glib-compile-schemas.html)
     * utility. The input is a schema description in an XML format.
     *
     * A DTD for the gschema XML format can be found here:
     * [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
     *
     * The [`glib-compile-schemas`](glib-compile-schemas.html) tool expects schema
     * files to have the extension `.gschema.xml`.
     *
     * At runtime, schemas are identified by their ID (as specified in the
     * `id` attribute of the `<schema>` element). The convention for schema
     * IDs is to use a dotted name, similar in style to a D-Bus bus name,
     * e.g. `org.gnome.SessionManager`. In particular, if the settings are
     * for a specific service that owns a D-Bus bus name, the D-Bus bus name
     * and schema ID should match. For schemas which deal with settings not
     * associated with one named application, the ID should not use
     * StudlyCaps, e.g. `org.gnome.font-rendering`.
     *
     * In addition to [struct`GLib`.Variant] types, keys can have types that have
     * enumerated types. These can be described by a `<choice>`,
     * `<enum>` or `<flags>` element, as seen in the
     * second example below. The underlying type of such a key
     * is string, but you can use [method`Gio`.Settings.get_enum],
     * [method`Gio`.Settings.set_enum], [method`Gio`.Settings.get_flags],
     * [method`Gio`.Settings.set_flags] access the numeric values corresponding to
     * the string value of enum and flags keys.
     *
     * An example for default value:
     * ```xml
     * <schemalist>
     *   <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
     *
     *     <key name="greeting" type="s">
     *       <default l10n="messages">"Hello, earthlings"</default>
     *       <summary>A greeting</summary>
     *       <description>
     *         Greeting of the invading martians
     *       </description>
     *     </key>
     *
     *     <key name="box" type="(ii)">
     *       <default>(20,30)</default>
     *     </key>
     *
     *     <key name="empty-string" type="s">
     *       <default>""</default>
     *       <summary>Empty strings have to be provided in GVariant form</summary>
     *     </key>
     *
     *   </schema>
     * </schemalist>
     * ```
     *
     * An example for ranges, choices and enumerated types:
     * ```xml
     * <schemalist>
     *
     *   <enum id="org.gtk.Test.myenum">
     *     <value nick="first" value="1"/>
     *     <value nick="second" value="2"/>
     *   </enum>
     *
     *   <flags id="org.gtk.Test.myflags">
     *     <value nick="flag1" value="1"/>
     *     <value nick="flag2" value="2"/>
     *     <value nick="flag3" value="4"/>
     *   </flags>
     *
     *   <schema id="org.gtk.Test">
     *
     *     <key name="key-with-range" type="i">
     *       <range min="1" max="100"/>
     *       <default>10</default>
     *     </key>
     *
     *     <key name="key-with-choices" type="s">
     *       <choices>
     *         <choice value='Elisabeth'/>
     *         <choice value='Annabeth'/>
     *         <choice value='Joe'/>
     *       </choices>
     *       <aliases>
     *         <alias value='Anna' target='Annabeth'/>
     *         <alias value='Beth' target='Elisabeth'/>
     *       </aliases>
     *       <default>'Joe'</default>
     *     </key>
     *
     *     <key name='enumerated-key' enum='org.gtk.Test.myenum'>
     *       <default>'first'</default>
     *     </key>
     *
     *     <key name='flags-key' flags='org.gtk.Test.myflags'>
     *       <default>["flag1","flag2"]</default>
     *     </key>
     *   </schema>
     * </schemalist>
     * ```
     *
     * ## Vendor overrides
     *
     * Default values are defined in the schemas that get installed by
     * an application. Sometimes, it is necessary for a vendor or distributor
     * to adjust these defaults. Since patching the XML source for the schema
     * is inconvenient and error-prone,
     * [`glib-compile-schemas`](glib-compile-schemas.html) reads so-called vendor
     * override files. These are keyfiles in the same directory as the XML
     * schema sources which can override default values. The schema ID serves
     * as the group name in the key file, and the values are expected in
     * serialized [struct`GLib`.Variant] form, as in the following example:
     * ```
     * [org.gtk.Example]
     * key1='string'
     * key2=1.5
     * ```
     *
     * `glib-compile-schemas` expects schema files to have the extension
     * `.gschema.override`.
     *
     * ## Binding
     *
     * A very convenient feature of GSettings lets you bind [class`GObject`.Object]
     * properties directly to settings, using [method`Gio`.Settings.bind]. Once a
     * [class`GObject`.Object] property has been bound to a setting, changes on
     * either side are automatically propagated to the other side. GSettings handles
     * details like mapping between [class`GObject`.Object] and [struct`GLib`.Variant]
     * types, and preventing infinite cycles.
     *
     * This makes it very easy to hook up a preferences dialog to the
     * underlying settings. To make this even more convenient, GSettings
     * looks for a boolean property with the name `sensitivity` and
     * automatically binds it to the writability of the bound setting.
     * If this magic gets in the way, it can be suppressed with the
     * `G_SETTINGS_BIND_NO_SENSITIVITY` flag.
     *
     * ## Relocatable schemas
     *
     * A relocatable schema is one with no `path` attribute specified on its
     * `<schema>` element. By using [ctor`Gio`.Settings.new_with_path], a `GSettings`
     * object can be instantiated for a relocatable schema, assigning a path to the
     * instance. Paths passed to [ctor`Gio`.Settings.new_with_path] will typically be
     * constructed dynamically from a constant prefix plus some form of instance
     * identifier; but they must still be valid GSettings paths. Paths could also
     * be constant and used with a globally installed schema originating from a
     * dependency library.
     *
     * For example, a relocatable schema could be used to store geometry information
     * for different windows in an application. If the schema ID was
     * `org.foo.MyApp.Window`, it could be instantiated for paths
     * `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
     * `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
     * they can be specified as `<child>` elements in the parent schema, e.g.:
     * ```xml
     * <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
     *   <child name="main" schema="org.foo.MyApp.Window"/>
     * </schema>
     * ```
     *
     * ## Build system integration
     *
     * GSettings comes with autotools integration to simplify compiling and
     * installing schemas. To add GSettings support to an application, add the
     * following to your `configure.ac`:
     * ```
     * GLIB_GSETTINGS
     * ```
     *
     * In the appropriate `Makefile.am`, use the following snippet to compile and
     * install the named schema:
     * ```
     * gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
     * EXTRA_DIST = $(gsettings_SCHEMAS)
     *
     * `GSETTINGS_RULES@`
     * ```
     *
     * No changes are needed to the build system to mark a schema XML file for
     * translation. Assuming it sets the `gettext-domain` attribute, a schema may
     * be marked for translation by adding it to `POTFILES.in`, assuming gettext
     * 0.19 is in use (the preferred method for translation):
     * ```
     * data/org.foo.MyApp.gschema.xml
     * ```
     *
     * Alternatively, if intltool 0.50.1 is in use:
     * ```
     * [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
     * ```
     *
     * GSettings will use gettext to look up translations for the `<summary>` and
     * `<description>` elements, and also any `<default>` elements which have a
     * `l10n` attribute set. Translations must not be included in the `.gschema.xml`
     * file by the build system, for example by using intltool XML rules with a
     * `.gschema.xml.in` template.
     *
     * If an enumerated type defined in a C header file is to be used in a GSettings
     * schema, it can either be defined manually using an `<enum>` element in the
     * schema XML, or it can be extracted automatically from the C header. This
     * approach is preferred, as it ensures the two representations are always
     * synchronised. To do so, add the following to the relevant `Makefile.am`:
     * ```
     * gsettings_ENUM_NAMESPACE = org.foo.MyApp
     * gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
     * ```
     *
     * `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
     * which are specified in `gsettings_ENUM_FILES`. This will generate a
     * `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
     * automatically included in the schema compilation, install and uninstall
     * rules. It should not be committed to version control or included in
     * `EXTRA_DIST`.
     */
    class Settings extends GObject.Object {
        static $gtype: GObject.GType<Settings>;

        // Properties

        /**
         * The name of the context that the settings are stored in.
         */
        get backend(): SettingsBackend;
        /**
         * Whether the #GSettings object is in 'delay-apply' mode. See
         * g_settings_delay() for details.
         */
        get delay_apply(): boolean;
        /**
         * Whether the #GSettings object is in 'delay-apply' mode. See
         * g_settings_delay() for details.
         */
        get delayApply(): boolean;
        /**
         * If this property is %TRUE, the #GSettings object has outstanding
         * changes that will be applied when g_settings_apply() is called.
         */
        get has_unapplied(): boolean;
        /**
         * If this property is %TRUE, the #GSettings object has outstanding
         * changes that will be applied when g_settings_apply() is called.
         */
        get hasUnapplied(): boolean;
        /**
         * The path within the backend where the settings are stored.
         */
        get path(): string;
        /**
         * The name of the schema that describes the types of keys
         * for this #GSettings object.
         *
         * The type of this property is *not* #GSettingsSchema.
         * #GSettingsSchema has only existed since version 2.32 and
         * unfortunately this name was used in previous versions to refer to
         * the schema ID rather than the schema itself.  Take care to use the
         * 'settings-schema' property if you wish to pass in a
         * #GSettingsSchema.
         */
        get schema(): string;
        /**
         * The name of the schema that describes the types of keys
         * for this #GSettings object.
         */
        get schema_id(): string;
        /**
         * The name of the schema that describes the types of keys
         * for this #GSettings object.
         */
        get schemaId(): string;
        /**
         * The #GSettingsSchema describing the types of keys for this
         * #GSettings object.
         *
         * Ideally, this property would be called 'schema'.  #GSettingsSchema
         * has only existed since version 2.32, however, and before then the
         * 'schema' property was used to refer to the ID of the schema rather
         * than the schema itself.  Take care.
         */
        get settings_schema(): SettingsSchema;
        /**
         * The #GSettingsSchema describing the types of keys for this
         * #GSettings object.
         *
         * Ideally, this property would be called 'schema'.  #GSettingsSchema
         * has only existed since version 2.32, however, and before then the
         * 'schema' property was used to refer to the ID of the schema rather
         * than the schema itself.  Take care.
         */
        get settingsSchema(): SettingsSchema;

        // Fields

        _realInit: (...args: any[]) => any;
        _realMethods: typeof Settings.prototype;
        _keys: string[];
        _children: string[];

        // Constructors

        constructor(properties?: Partial<Settings.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](schema_id: string): Settings;

        static new_full(schema: SettingsSchema, backend?: SettingsBackend | null, path?: string | null): Settings;

        static new_with_backend(schema_id: string, backend: SettingsBackend): Settings;

        static new_with_backend_and_path(schema_id: string, backend: SettingsBackend, path: string): Settings;

        static new_with_path(schema_id: string, path: string): Settings;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'change-event', callback: (_source: this, keys: GLib.Quark[] | null) => boolean): number;
        connect_after(signal: 'change-event', callback: (_source: this, keys: GLib.Quark[] | null) => boolean): number;
        emit(signal: 'change-event', keys?: GLib.Quark[] | null): void;
        connect(signal: 'changed', callback: (_source: this, key: string) => void): number;
        connect_after(signal: 'changed', callback: (_source: this, key: string) => void): number;
        emit(signal: 'changed', key: string): void;
        connect(signal: 'writable-change-event', callback: (_source: this, key: number) => boolean): number;
        connect_after(signal: 'writable-change-event', callback: (_source: this, key: number) => boolean): number;
        emit(signal: 'writable-change-event', key: number): void;
        connect(signal: 'writable-changed', callback: (_source: this, key: string) => void): number;
        connect_after(signal: 'writable-changed', callback: (_source: this, key: string) => void): number;
        emit(signal: 'writable-changed', key: string): void;

        // Static methods

        /**
         * Deprecated.
         */
        static list_relocatable_schemas(): string[];
        /**
         * Deprecated.
         */
        static list_schemas(): string[];
        /**
         * Ensures that all pending operations are complete for the default backend.
         *
         * Writes made to a #GSettings are handled asynchronously.  For this
         * reason, it is very unlikely that the changes have it to disk by the
         * time g_settings_set() returns.
         *
         * This call will block until all of the writes have made it to the
         * backend.  Since the mainloop is not running, no change notifications
         * will be dispatched during this call (but some may be queued by the
         * time the call is done).
         */
        static sync(): void;
        /**
         * Removes an existing binding for `property` on `object`.
         *
         * Note that bindings are automatically removed when the
         * object is finalized, so it is rarely necessary to call this
         * function.
         * @param object the object
         * @param property the property whose binding is removed
         */
        static unbind(object: GObject.Object, property: string): void;

        // Virtual methods

        vfunc_change_event(keys: GLib.Quark, n_keys: number): boolean;
        vfunc_changed(key: string): void;
        vfunc_writable_change_event(key: GLib.Quark): boolean;
        vfunc_writable_changed(key: string): void;

        // Methods

        /**
         * Applies any changes that have been made to the settings.  This
         * function does nothing unless `settings` is in 'delay-apply' mode;
         * see g_settings_delay().  In the normal case settings are always
         * applied immediately.
         */
        apply(): void;
        /**
         * Create a binding between the `key` in the `settings` object
         * and the property `property` of `object`.
         *
         * The binding uses the default GIO mapping functions to map
         * between the settings and property values. These functions
         * handle booleans, numeric types and string types in a
         * straightforward way. Use g_settings_bind_with_mapping() if
         * you need a custom mapping, or map between types that are not
         * supported by the default mapping functions.
         *
         * Unless the `flags` include %G_SETTINGS_BIND_NO_SENSITIVITY, this
         * function also establishes a binding between the writability of
         * `key` and the "sensitive" property of `object` (if `object` has
         * a boolean property by that name). See g_settings_bind_writable()
         * for more details about writable bindings.
         *
         * Note that the lifecycle of the binding is tied to `object,`
         * and that you can have only one binding per object property.
         * If you bind the same property twice on the same object, the second
         * binding overrides the first one.
         * @param key the key to bind
         * @param object a #GObject
         * @param property the name of the property to bind
         * @param flags flags for the binding
         */
        bind(key: string, object: GObject.Object, property: string, flags: SettingsBindFlags): void;
        /**
         * Create a binding between the writability of `key` in the
         * `settings` object and the property `property` of `object`.
         * The property must be boolean; "sensitive" or "visible"
         * properties of widgets are the most likely candidates.
         *
         * Writable bindings are always uni-directional; changes of the
         * writability of the setting will be propagated to the object
         * property, not the other way.
         *
         * When the `inverted` argument is %TRUE, the binding inverts the
         * value as it passes from the setting to the object, i.e. `property`
         * will be set to %TRUE if the key is not writable.
         *
         * Note that the lifecycle of the binding is tied to `object,`
         * and that you can have only one binding per object property.
         * If you bind the same property twice on the same object, the second
         * binding overrides the first one.
         * @param key the key to bind
         * @param object a #GObject
         * @param property the name of a boolean property to bind
         * @param inverted whether to 'invert' the value
         */
        bind_writable(key: string, object: GObject.Object, property: string, inverted: boolean): void;
        /**
         * Creates a #GAction corresponding to a given #GSettings key.
         *
         * The action has the same name as the key.
         *
         * The value of the key becomes the state of the action and the action
         * is enabled when the key is writable.  Changing the state of the
         * action results in the key being written to.  Changes to the value or
         * writability of the key cause appropriate change notifications to be
         * emitted for the action.
         *
         * For boolean-valued keys, action activations take no parameter and
         * result in the toggling of the value.  For all other types,
         * activations take the new value for the key (which must have the
         * correct type).
         * @param key the name of a key in @settings
         * @returns a new #GAction
         */
        create_action(key: string): Action;
        /**
         * Changes the #GSettings object into 'delay-apply' mode. In this
         * mode, changes to `settings` are not immediately propagated to the
         * backend, but kept locally until g_settings_apply() is called.
         */
        delay(): void;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for booleans.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a boolean type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a boolean
         */
        get_boolean(key: string): boolean;
        /**
         * Creates a child settings object which has a base path of
         * `base-path/`name``, where `base-path` is the base path of
         * `settings`.
         *
         * The schema for the child settings object must have been declared
         * in the schema of `settings` using a `<child>` element.
         *
         * The created child settings object will inherit the #GSettings:delay-apply
         * mode from `settings`.
         * @param name the name of the child schema
         * @returns a 'child' settings object
         */
        get_child(name: string): Settings;
        /**
         * Gets the "default value" of a key.
         *
         * This is the value that would be read if g_settings_reset() were to be
         * called on the key.
         *
         * Note that this may be a different value than returned by
         * g_settings_schema_key_get_default_value() if the system administrator
         * has provided a default value.
         *
         * Comparing the return values of g_settings_get_default_value() and
         * g_settings_get_value() is not sufficient for determining if a value
         * has been set because the user may have explicitly set the value to
         * something that happens to be equal to the default.  The difference
         * here is that if the default changes in the future, the user's key
         * will still be set.
         *
         * This function may be useful for adding an indication to a UI of what
         * the default value was before the user set it.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings`.
         * @param key the key to get the default value for
         * @returns the default value
         */
        get_default_value<T extends string = any>(key: string): GLib.Variant<T> | null;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for doubles.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a 'double' type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a double
         */
        get_double(key: string): number;
        /**
         * Gets the value that is stored in `settings` for `key` and converts it
         * to the enum value that it represents.
         *
         * In order to use this function the type of the value must be a string
         * and it must be marked in the schema file as an enumerated type.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as an enumerated type.
         *
         * If the value stored in the configuration database is not a valid
         * value for the enumerated type then this function will return the
         * default value.
         * @param key the key to get the value for
         * @returns the enum value
         */
        get_enum(key: string): number;
        /**
         * Gets the value that is stored in `settings` for `key` and converts it
         * to the flags value that it represents.
         *
         * In order to use this function the type of the value must be an array
         * of strings and it must be marked in the schema file as a flags type.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as a flags type.
         *
         * If the value stored in the configuration database is not a valid
         * value for the flags type then this function will return the default
         * value.
         * @param key the key to get the value for
         * @returns the flags value
         */
        get_flags(key: string): number;
        /**
         * Returns whether the #GSettings object has any unapplied
         * changes.  This can only be the case if it is in 'delayed-apply' mode.
         * @returns %TRUE if @settings has unapplied changes
         */
        get_has_unapplied(): boolean;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 32-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int32 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns an integer
         */
        get_int(key: string): number;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 64-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int64 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a 64-bit integer
         */
        get_int64(key: string): number;
        /**
         * Gets the value that is stored at `key` in `settings,` subject to
         * application-level validation/mapping.
         *
         * You should use this function when the application needs to perform
         * some processing on the value of the key (for example, parsing).  The
         * `mapping` function performs that processing.  If the function
         * indicates that the processing was unsuccessful (due to a parse error,
         * for example) then the mapping is tried again with another value.
         *
         * This allows a robust 'fall back to defaults' behaviour to be
         * implemented somewhat automatically.
         *
         * The first value that is tried is the user's setting for the key.  If
         * the mapping function fails to map this value, other values may be
         * tried in an unspecified order (system or site defaults, translated
         * schema default values, untranslated schema default values, etc).
         *
         * If the mapping function fails for all possible values, one additional
         * attempt is made: the mapping function is called with a %NULL value.
         * If the mapping function still indicates failure at this point then
         * the application will be aborted.
         *
         * The result parameter for the `mapping` function is pointed to a
         * #gpointer which is initially set to %NULL.  The same pointer is given
         * to each invocation of `mapping`.  The final value of that #gpointer is
         * what is returned by this function.  %NULL is valid; it is returned
         * just as any other value would be.
         * @param key the key to get the value for
         * @param mapping the function to map the value in the           settings database to the value used by the application
         * @returns the result, which may be %NULL
         */
        get_mapped(key: string, mapping: SettingsGetMapping): any | null;
        /**
         * Queries the range of a key.
         * @param key the key to query the range of
         */
        get_range(key: string): GLib.Variant;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for strings.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a string type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a newly-allocated string
         */
        get_string(key: string): string;
        /**
         * A convenience variant of g_settings_get() for string arrays.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having an array of strings type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a newly-allocated, %NULL-terminated array of strings, the value that is stored at @key in @settings.
         */
        get_strv(key: string): string[];
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 32-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint32 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns an unsigned integer
         */
        get_uint(key: string): number;
        /**
         * Gets the value that is stored at `key` in `settings`.
         *
         * A convenience variant of g_settings_get() for 64-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint64 type in the schema for `settings`.
         * @param key the key to get the value for
         * @returns a 64-bit unsigned integer
         */
        get_uint64(key: string): number;
        /**
         * Checks the "user value" of a key, if there is one.
         *
         * The user value of a key is the last value that was set by the user.
         *
         * After calling g_settings_reset() this function should always return
         * %NULL (assuming something is not wrong with the system
         * configuration).
         *
         * It is possible that g_settings_get_value() will return a different
         * value than this function.  This can happen in the case that the user
         * set a value for a key that was subsequently locked down by the system
         * administrator -- this function will return the user's old value.
         *
         * This function may be useful for adding a "reset" option to a UI or
         * for providing indication that a particular value has been changed.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings`.
         * @param key the key to get the user value for
         * @returns the user's value, if set
         */
        get_user_value<T extends string = any>(key: string): GLib.Variant<T> | null;
        /**
         * Gets the value that is stored in `settings` for `key`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings`.
         * @param key the key to get the value for
         * @returns a new #GVariant
         */
        get_value<T extends string = any>(key: string): GLib.Variant<T>;
        /**
         * Finds out if a key can be written or not
         * @param name the name of a key
         * @returns %TRUE if the key @name is writable
         */
        is_writable(name: string): boolean;
        /**
         * Gets the list of children on `settings`.
         *
         * The list is exactly the list of strings for which it is not an error
         * to call g_settings_get_child().
         *
         * There is little reason to call this function from "normal" code, since
         * you should already know what children are in your schema. This function
         * may still be useful there for introspection reasons, however.
         *
         * You should free the return value with g_strfreev() when you are done
         * with it.
         * @returns a list of the children    on @settings, in no defined order
         */
        list_children(): string[];
        /**
         * Introspects the list of keys on `settings`.
         *
         * You should probably not be calling this function from "normal" code
         * (since you should already know what keys are in your schema).  This
         * function is intended for introspection reasons.
         *
         * You should free the return value with g_strfreev() when you are done
         * with it.
         * @returns a list    of the keys on @settings, in no defined order
         */
        list_keys(): string[];
        /**
         * Checks if the given `value` is of the correct type and within the
         * permitted range for `key`.
         * @param key the key to check
         * @param value the value to check
         * @returns %TRUE if @value is valid for @key
         */
        range_check(key: string, value: GLib.Variant): boolean;
        /**
         * Resets `key` to its default value.
         *
         * This call resets the key, as much as possible, to its default value.
         * That might be the value specified in the schema or the one set by the
         * administrator.
         * @param key the name of a key
         */
        reset(key: string): void;
        /**
         * Reverts all non-applied changes to the settings.  This function
         * does nothing unless `settings` is in 'delay-apply' mode; see
         * g_settings_delay().  In the normal case settings are always applied
         * immediately.
         *
         * Change notifications will be emitted for affected keys.
         */
        revert(): void;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for booleans.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a boolean type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_boolean(key: string, value: boolean): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for doubles.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a 'double' type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_double(key: string, value: number): boolean;
        /**
         * Looks up the enumerated type nick for `value` and writes it to `key,`
         * within `settings`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as an enumerated type, or for
         * `value` not to be a valid value for the named type.
         *
         * After performing the write, accessing `key` directly with
         * g_settings_get_string() will return the 'nick' associated with
         * `value`.
         * @param key a key, within @settings
         * @param value an enumerated value
         * @returns %TRUE, if the set succeeds
         */
        set_enum(key: string, value: number): boolean;
        /**
         * Looks up the flags type nicks for the bits specified by `value,` puts
         * them in an array of strings and writes the array to `key,` within
         * `settings`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or is not marked as a flags type, or for `value`
         * to contain any bits that are not value for the named type.
         *
         * After performing the write, accessing `key` directly with
         * g_settings_get_strv() will return an array of 'nicks'; one for each
         * bit in `value`.
         * @param key a key, within @settings
         * @param value a flags value
         * @returns %TRUE, if the set succeeds
         */
        set_flags(key: string, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 32-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int32 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_int(key: string, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 64-bit integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a int64 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_int64(key: string, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for strings.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a string type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_string(key: string, value: string): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for string arrays.  If
         * `value` is %NULL, then `key` is set to be the empty array.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having an array of strings type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to, or %NULL
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_strv(key: string, value?: string[] | null): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 32-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint32 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_uint(key: string, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * A convenience variant of g_settings_set() for 64-bit unsigned
         * integers.
         *
         * It is a programmer error to give a `key` that isn't specified as
         * having a uint64 type in the schema for `settings`.
         * @param key the name of the key to set
         * @param value the value to set it to
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_uint64(key: string, value: number): boolean;
        /**
         * Sets `key` in `settings` to `value`.
         *
         * It is a programmer error to give a `key` that isn't contained in the
         * schema for `settings` or for `value` to have the incorrect type, per
         * the schema.
         *
         * If `value` is floating then this function consumes the reference.
         * @param key the name of the key to set
         * @param value a #GVariant of the correct type
         * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
         */
        set_value(key: string, value: GLib.Variant): boolean;
    }

    module SettingsBackend {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * The `GSettingsBackend` interface defines a generic interface for
     * non-strictly-typed data that is stored in a hierarchy. To implement
     * an alternative storage backend for [class`Gio`.Settings], you need to
     * implement the `GSettingsBackend` interface and then make it implement the
     * extension point `G_SETTINGS_BACKEND_EXTENSION_POINT_NAME`.
     *
     * The interface defines methods for reading and writing values, a
     * method for determining if writing of certain values will fail
     * (lockdown) and a change notification mechanism.
     *
     * The semantics of the interface are very precisely defined and
     * implementations must carefully adhere to the expectations of
     * callers that are documented on each of the interface methods.
     *
     * Some of the `GSettingsBackend` functions accept or return a
     * [struct`GLib`.Tree]. These trees always have strings as keys and
     * [struct`GLib`.Variant] as values.
     *
     * The `GSettingsBackend` API is exported to allow third-party
     * implementations, but does not carry the same stability guarantees
     * as the public GIO API. For this reason, you have to define the
     * C preprocessor symbol `G_SETTINGS_ENABLE_BACKEND` before including
     * `gio/gsettingsbackend.h`.
     */
    abstract class SettingsBackend extends GObject.Object {
        static $gtype: GObject.GType<SettingsBackend>;

        // Constructors

        constructor(properties?: Partial<SettingsBackend.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Calculate the longest common prefix of all keys in a tree and write
         * out an array of the key names relative to that prefix and,
         * optionally, the value to store at each of those keys.
         *
         * You must free the value returned in `path,` `keys` and `values` using
         * g_free().  You should not attempt to free or unref the contents of
         * `keys` or `values`.
         * @param tree a #GTree containing the changes
         */
        static flatten_tree(tree: GLib.Tree): [string, string[], GLib.Variant[] | null];
        /**
         * Returns the default #GSettingsBackend. It is possible to override
         * the default by setting the `GSETTINGS_BACKEND` environment variable
         * to the name of a settings backend.
         *
         * The user gets a reference to the backend.
         */
        static get_default(): SettingsBackend;

        // Virtual methods

        /**
         * virtual method to get if a key is writable
         * @param key
         */
        vfunc_get_writable(key: string): boolean;
        /**
         * virtual method to read a key's value
         * @param key
         * @param expected_type
         * @param default_value
         */
        vfunc_read(key: string, expected_type: GLib.VariantType, default_value: boolean): GLib.Variant;
        /**
         * virtual method to read user's key value
         * @param key
         * @param expected_type
         */
        vfunc_read_user_value(key: string, expected_type: GLib.VariantType): GLib.Variant;
        /**
         * virtual method to reset state
         * @param key
         * @param origin_tag
         */
        vfunc_reset(key: string, origin_tag?: any | null): void;
        /**
         * virtual method to subscribe to key changes
         * @param name
         */
        vfunc_subscribe(name: string): void;
        /**
         * virtual method to sync state
         */
        vfunc_sync(): void;
        /**
         * virtual method to unsubscribe to key changes
         * @param name
         */
        vfunc_unsubscribe(name: string): void;
        /**
         * virtual method to change key's value
         * @param key
         * @param value
         * @param origin_tag
         */
        vfunc_write(key: string, value: GLib.Variant, origin_tag?: any | null): boolean;
        /**
         * virtual method to change a tree of keys
         * @param tree
         * @param origin_tag
         */
        vfunc_write_tree(tree: GLib.Tree, origin_tag?: any | null): boolean;

        // Methods

        /**
         * Signals that a single key has possibly changed.  Backend
         * implementations should call this if a key has possibly changed its
         * value.
         *
         * `key` must be a valid key (ie starting with a slash, not containing
         * '//', and not ending with a slash).
         *
         * The implementation must call this function during any call to
         * g_settings_backend_write(), before the call returns (except in the
         * case that no keys are actually changed and it cares to detect this
         * fact).  It may not rely on the existence of a mainloop for
         * dispatching the signal later.
         *
         * The implementation may call this function at any other time it likes
         * in response to other events (such as changes occurring outside of the
         * program).  These calls may originate from a mainloop or may originate
         * in response to any other action (including from calls to
         * g_settings_backend_write()).
         *
         * In the case that this call is in response to a call to
         * g_settings_backend_write() then `origin_tag` must be set to the same
         * value that was passed to that call.
         * @param key the name of the key
         * @param origin_tag the origin tag
         */
        changed(key: string, origin_tag?: any | null): void;
        /**
         * This call is a convenience wrapper.  It gets the list of changes from
         * `tree,` computes the longest common prefix and calls
         * g_settings_backend_changed().
         * @param tree a #GTree containing the changes
         * @param origin_tag the origin tag
         */
        changed_tree(tree: GLib.Tree, origin_tag?: any | null): void;
        /**
         * Signals that a list of keys have possibly changed.  Backend
         * implementations should call this if keys have possibly changed their
         * values.
         *
         * `path` must be a valid path (ie starting and ending with a slash and
         * not containing '//').  Each string in `items` must form a valid key
         * name when `path` is prefixed to it (ie: each item must not start or
         * end with '/' and must not contain '//').
         *
         * The meaning of this signal is that any of the key names resulting
         * from the contatenation of `path` with each item in `items` may have
         * changed.
         *
         * The same rules for when notifications must occur apply as per
         * g_settings_backend_changed().  These two calls can be used
         * interchangeably if exactly one item has changed (although in that
         * case g_settings_backend_changed() is definitely preferred).
         *
         * For efficiency reasons, the implementation should strive for `path` to
         * be as long as possible (ie: the longest common prefix of all of the
         * keys that were changed) but this is not strictly required.
         * @param path the path containing the changes
         * @param items the %NULL-terminated list of changed keys
         * @param origin_tag the origin tag
         */
        keys_changed(path: string, items: string[], origin_tag?: any | null): void;
        /**
         * Signals that all keys below a given path may have possibly changed.
         * Backend implementations should call this if an entire path of keys
         * have possibly changed their values.
         *
         * `path` must be a valid path (ie starting and ending with a slash and
         * not containing '//').
         *
         * The meaning of this signal is that any of the key which has a name
         * starting with `path` may have changed.
         *
         * The same rules for when notifications must occur apply as per
         * g_settings_backend_changed().  This call might be an appropriate
         * reasponse to a 'reset' call but implementations are also free to
         * explicitly list the keys that were affected by that call if they can
         * easily do so.
         *
         * For efficiency reasons, the implementation should strive for `path` to
         * be as long as possible (ie: the longest common prefix of all of the
         * keys that were changed) but this is not strictly required.  As an
         * example, if this function is called with the path of "/" then every
         * single key in the application will be notified of a possible change.
         * @param path the path containing the changes
         * @param origin_tag the origin tag
         */
        path_changed(path: string, origin_tag?: any | null): void;
        /**
         * Signals that the writability of all keys below a given path may have
         * changed.
         *
         * Since GSettings performs no locking operations for itself, this call
         * will always be made in response to external events.
         * @param path the name of the path
         */
        path_writable_changed(path: string): void;
        /**
         * Signals that the writability of a single key has possibly changed.
         *
         * Since GSettings performs no locking operations for itself, this call
         * will always be made in response to external events.
         * @param key the name of the key
         */
        writable_changed(key: string): void;
    }

    module SimpleAction {
        // Signal callback interfaces

        interface Activate {
            (parameter?: GLib.Variant | null): void;
        }

        interface ChangeState {
            (value?: GLib.Variant | null): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Action.ConstructorProps {
            enabled: boolean;
            name: string;
            parameter_type: GLib.VariantType;
            parameterType: GLib.VariantType;
            state: GLib.Variant;
            state_type: GLib.VariantType;
            stateType: GLib.VariantType;
        }
    }

    /**
     * A `GSimpleAction` is the obvious simple implementation of the
     * [iface`Gio`.Action] interface. This is the easiest way to create an action for
     * purposes of adding it to a [class`Gio`.SimpleActionGroup].
     */
    class SimpleAction extends GObject.Object implements Action {
        static $gtype: GObject.GType<SimpleAction>;

        // Properties

        /**
         * If `action` is currently enabled.
         *
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        get enabled(): boolean;
        set enabled(val: boolean);
        /**
         * The name of the action. This is mostly meaningful for identifying
         * the action once it has been added to a #GSimpleActionGroup.
         */
        get name(): string;
        /**
         * The type of the parameter that must be given when activating the
         * action.
         */
        get parameter_type(): GLib.VariantType;
        /**
         * The type of the parameter that must be given when activating the
         * action.
         */
        get parameterType(): GLib.VariantType;
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        get state(): GLib.Variant;
        set state(val: GLib.Variant);
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless.
         */
        get state_type(): GLib.VariantType;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless.
         */
        get stateType(): GLib.VariantType;

        // Constructors

        constructor(properties?: Partial<SimpleAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](name: string, parameter_type?: GLib.VariantType | null): SimpleAction;

        static new_stateful(name: string, parameter_type: GLib.VariantType | null, state: GLib.Variant): SimpleAction;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'activate', callback: (_source: this, parameter: GLib.Variant | null) => void): number;
        connect_after(signal: 'activate', callback: (_source: this, parameter: GLib.Variant | null) => void): number;
        emit(signal: 'activate', parameter?: GLib.Variant | null): void;
        connect(signal: 'change-state', callback: (_source: this, value: GLib.Variant | null) => void): number;
        connect_after(signal: 'change-state', callback: (_source: this, value: GLib.Variant | null) => void): number;
        emit(signal: 'change-state', value?: GLib.Variant | null): void;

        // Methods

        /**
         * Sets the action as enabled or not.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         *
         * This should only be called by the implementor of the action.  Users
         * of the action should not attempt to modify its enabled flag.
         * @param enabled whether the action is enabled
         */
        set_enabled(enabled: boolean): void;
        /**
         * Sets the state of the action.
         *
         * This directly updates the 'state' property to the given value.
         *
         * This should only be called by the implementor of the action.  Users
         * of the action should not attempt to directly modify the 'state'
         * property.  Instead, they should call g_action_change_state() to
         * request the change.
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new #GVariant for the state
         */
        set_state(value: GLib.Variant): void;
        /**
         * Sets the state hint for the action.
         *
         * See g_action_get_state_hint() for more information about
         * action state hints.
         * @param state_hint a #GVariant representing the state hint
         */
        set_state_hint(state_hint?: GLib.Variant | null): void;

        // Inherited methods
        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @returns whether the action is enabled
         */
        get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         * @returns the name of the action
         */
        get_name(): string;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         * @returns the parameter type
         */
        get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the current state of the action
         */
        get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the state range hint
         */
        get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         * @returns the state type, if the action is stateful
         */
        get_state_type(): GLib.VariantType | null;
        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        vfunc_activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        vfunc_change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         */
        vfunc_get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         */
        vfunc_get_name(): string;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         */
        vfunc_get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         */
        vfunc_get_state_type(): GLib.VariantType | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module SimpleActionGroup {
        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                ActionGroup.ConstructorProps,
                ActionMap.ConstructorProps {}
    }

    /**
     * `GSimpleActionGroup` is a hash table filled with [iface`Gio`.Action] objects,
     * implementing the [iface`Gio`.ActionGroup] and [iface`Gio`.ActionMap]
     * interfaces.
     */
    class SimpleActionGroup extends GObject.Object implements ActionGroup, ActionMap {
        static $gtype: GObject.GType<SimpleActionGroup>;

        // Constructors

        constructor(properties?: Partial<SimpleActionGroup.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): SimpleActionGroup;

        // Methods

        /**
         * A convenience function for creating multiple #GSimpleAction instances
         * and adding them to the action group.
         * @param entries a pointer to the first item in           an array of #GActionEntry structs
         * @param user_data the user data for signal connections
         */
        add_entries(entries: ActionEntry[], user_data?: any | null): void;
        /**
         * Adds an action to the action group.
         *
         * If the action group already contains an action with the same name as
         * `action` then the old action is dropped from the group.
         *
         * The action group takes its own reference on `action`.
         * @param action a #GAction
         */
        insert(action: Action): void;
        /**
         * Looks up the action with the name `action_name` in the group.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        lookup(action_name: string): Action;
        /**
         * Removes the named action from the action group.
         *
         * If no action of this name is in the group then nothing happens.
         * @param action_name the name of the action
         */
        remove(action_name: string): void;

        // Inherited methods
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         * @returns whether or not the action is currently enabled
         */
        get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         * @returns the parameter type
         */
        get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the current state of the action
         */
        get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the state range hint
         */
        get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         * @returns the state type, if the action is stateful
         */
        get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         * @returns whether the named action exists
         */
        has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         * @returns a %NULL-terminated array of the names of the actions in the group
         */
        list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         * @returns %TRUE if the action exists, else %FALSE
         */
        query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         */
        vfunc_has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         */
        vfunc_list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         */
        vfunc_query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        add_action(action: Action): void;
        /**
         * A convenience function for creating multiple #GSimpleAction instances
         * and adding them to a #GActionMap.
         *
         * Each action is constructed as per one #GActionEntry.
         *
         *
         * ```c
         * static void
         * activate_quit (GSimpleAction *simple,
         *                GVariant      *parameter,
         *                gpointer       user_data)
         * {
         *   exit (0);
         * }
         *
         * static void
         * activate_print_string (GSimpleAction *simple,
         *                        GVariant      *parameter,
         *                        gpointer       user_data)
         * {
         *   g_print ("%s\n", g_variant_get_string (parameter, NULL));
         * }
         *
         * static GActionGroup *
         * create_action_group (void)
         * {
         *   const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         *   };
         *   GSimpleActionGroup *group;
         *
         *   group = g_simple_action_group_new ();
         *   g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
         *
         *   return G_ACTION_GROUP (group);
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         * @param user_data the user data for signal connections
         */
        add_action_entries(entries: ActionEntry[], user_data?: any | null): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        lookup_action(action_name: string): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        remove_action(action_name: string): void;
        /**
         * Remove actions from a #GActionMap. This is meant as the reverse of
         * g_action_map_add_action_entries().
         *
         *
         *
         * ```c
         * static const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         * };
         *
         * void
         * add_actions (GActionMap *map)
         * {
         *   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
         * }
         *
         * void
         * remove_actions (GActionMap *map)
         * {
         *   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         */
        remove_action_entries(entries: ActionEntry[]): void;
        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        vfunc_add_action(action: Action): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         */
        vfunc_lookup_action(action_name: string): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        vfunc_remove_action(action_name: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module SimpleAsyncResult {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, AsyncResult.ConstructorProps {}
    }

    /**
     * As of GLib 2.46, `GSimpleAsyncResult` is deprecated in favor of
     * [class`Gio`.Task], which provides a simpler API.
     *
     * `GSimpleAsyncResult` implements [iface`Gio`.AsyncResult].
     *
     * `GSimpleAsyncResult` handles [type`Gio`.AsyncReadyCallback]s, error
     * reporting, operation cancellation and the final state of an operation,
     * completely transparent to the application. Results can be returned
     * as a pointer e.g. for functions that return data that is collected
     * asynchronously, a boolean value for checking the success or failure
     * of an operation, or a `gssize` for operations which return the number
     * of bytes modified by the operation; all of the simple return cases
     * are covered.
     *
     * Most of the time, an application will not need to know of the details
     * of this API; it is handled transparently, and any necessary operations
     * are handled by [iface`Gio`.AsyncResult]s interface. However, if implementing
     * a new GIO module, for writing language bindings, or for complex
     * applications that need better control of how asynchronous operations
     * are completed, it is important to understand this functionality.
     *
     * `GSimpleAsyncResult`s are tagged with the calling function to ensure
     * that asynchronous functions and their finishing functions are used
     * together correctly.
     *
     * To create a new `GSimpleAsyncResult`, call [ctor`Gio`.SimpleAsyncResult.new].
     * If the result needs to be created for a `GError`, use
     * [ctor`Gio`.SimpleAsyncResult.new_from_error] or
     * [ctor`Gio`.SimpleAsyncResult.new_take_error]. If a `GError` is not available
     * (e.g. the asynchronous operation doesnt take a `GError` argument),
     * but the result still needs to be created for an error condition, use
     * [ctor`Gio`.SimpleAsyncResult.new_error] (or
     * [method`Gio`.SimpleAsyncResult.set_error_va] if your application or binding
     * requires passing a variable argument list directly), and the error can then
     * be propagated through the use of
     * [method`Gio`.SimpleAsyncResult.propagate_error].
     *
     * An asynchronous operation can be made to ignore a cancellation event by
     * calling [method`Gio`.SimpleAsyncResult.set_handle_cancellation] with a
     * `GSimpleAsyncResult` for the operation and `FALSE`. This is useful for
     * operations that are dangerous to cancel, such as close (which would
     * cause a leak if cancelled before being run).
     *
     * `GSimpleAsyncResult` can integrate into GLibs event loop,
     * [type`GLib`.MainLoop], or it can use [type`GLib`.Thread]s.
     * [method`Gio`.SimpleAsyncResult.complete] will finish an I/O task directly
     * from the point where it is called.
     * [method`Gio`.SimpleAsyncResult.complete_in_idle] will finish it from an idle
     * handler in the  thread-default main context (see
     * [method`GLib`.MainContext.push_thread_default]) where the `GSimpleAsyncResult`
     * was created. [method`Gio`.SimpleAsyncResult.run_in_thread] will run the job in
     * a separate thread and then use
     * [method`Gio`.SimpleAsyncResult.complete_in_idle] to deliver the result.
     *
     * To set the results of an asynchronous function,
     * [method`Gio`.SimpleAsyncResult.set_op_res_gpointer],
     * [method`Gio`.SimpleAsyncResult.set_op_res_gboolean], and
     * [method`Gio`.SimpleAsyncResult.set_op_res_gssize]
     * are provided, setting the operation's result to a `gpointer`, `gboolean`, or
     * `gssize`, respectively.
     *
     * Likewise, to get the result of an asynchronous function,
     * [method`Gio`.SimpleAsyncResult.get_op_res_gpointer],
     * [method`Gio`.SimpleAsyncResult.get_op_res_gboolean], and
     * [method`Gio`.SimpleAsyncResult.get_op_res_gssize] are
     * provided, getting the operations result as a `gpointer`, `gboolean`, and
     * `gssize`, respectively.
     *
     * For the details of the requirements implementations must respect, see
     * [iface`Gio`.AsyncResult].  A typical implementation of an asynchronous
     * operation using `GSimpleAsyncResult` looks something like this:
     *
     * ```c
     * static void
     * baked_cb (Cake    *cake,
     *           gpointer user_data)
     * {
     *   // In this example, this callback is not given a reference to the cake,
     *   // so the GSimpleAsyncResult has to take a reference to it.
     *   GSimpleAsyncResult *result = user_data;
     *
     *   if (cake == NULL)
     *     g_simple_async_result_set_error (result,
     *                                      BAKER_ERRORS,
     *                                      BAKER_ERROR_NO_FLOUR,
     *                                      "Go to the supermarket");
     *   else
     *     g_simple_async_result_set_op_res_gpointer (result,
     *                                                g_object_ref (cake),
     *                                                g_object_unref);
     *
     *
     *   // In this example, we assume that baked_cb is called as a callback from
     *   // the mainloop, so it's safe to complete the operation synchronously here.
     *   // If, however, _baker_prepare_cake () might call its callback without
     *   // first returning to the mainloop  inadvisable, but some APIs do so 
     *   // we would need to use g_simple_async_result_complete_in_idle().
     *   g_simple_async_result_complete (result);
     *   g_object_unref (result);
     * }
     *
     * void
     * baker_bake_cake_async (Baker              *self,
     *                        guint               radius,
     *                        GAsyncReadyCallback callback,
     *                        gpointer            user_data)
     * {
     *   GSimpleAsyncResult *simple;
     *   Cake               *cake;
     *
     *   if (radius < 3)
     *     {
     *       g_simple_async_report_error_in_idle (G_OBJECT (self),
     *                                            callback,
     *                                            user_data,
     *                                            BAKER_ERRORS,
     *                                            BAKER_ERROR_TOO_SMALL,
     *                                            "%ucm radius cakes are silly",
     *                                            radius);
     *       return;
     *     }
     *
     *   simple = g_simple_async_result_new (G_OBJECT (self),
     *                                       callback,
     *                                       user_data,
     *                                       baker_bake_cake_async);
     *   cake = _baker_get_cached_cake (self, radius);
     *
     *   if (cake != NULL)
     *     {
     *       g_simple_async_result_set_op_res_gpointer (simple,
     *                                                  g_object_ref (cake),
     *                                                  g_object_unref);
     *       g_simple_async_result_complete_in_idle (simple);
     *       g_object_unref (simple);
     *       // Drop the reference returned by _baker_get_cached_cake();
     *       // the GSimpleAsyncResult has taken its own reference.
     *       g_object_unref (cake);
     *       return;
     *     }
     *
     *   _baker_prepare_cake (self, radius, baked_cb, simple);
     * }
     *
     * Cake *
     * baker_bake_cake_finish (Baker        *self,
     *                         GAsyncResult *result,
     *                         GError      **error)
     * {
     *   GSimpleAsyncResult *simple;
     *   Cake               *cake;
     *
     *   g_return_val_if_fail (g_simple_async_result_is_valid (result,
     *                                                         G_OBJECT (self),
     *                                                         baker_bake_cake_async),
     *                         NULL);
     *
     *   simple = (GSimpleAsyncResult *) result;
     *
     *   if (g_simple_async_result_propagate_error (simple, error))
     *     return NULL;
     *
     *   cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
     *   return g_object_ref (cake);
     * }
     * ```
     */
    class SimpleAsyncResult extends GObject.Object implements AsyncResult {
        static $gtype: GObject.GType<SimpleAsyncResult>;

        // Constructors

        constructor(properties?: Partial<SimpleAsyncResult.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            source_object?: GObject.Object | null,
            callback?: AsyncReadyCallback | null,
            source_tag?: any | null,
        ): SimpleAsyncResult;

        static new_from_error(
            source_object: GObject.Object | null,
            callback: AsyncReadyCallback | null,
            error: GLib.Error,
        ): SimpleAsyncResult;

        // Static methods

        /**
         * Ensures that the data passed to the _finish function of an async
         * operation is consistent.  Three checks are performed.
         *
         * First, `result` is checked to ensure that it is really a
         * #GSimpleAsyncResult.  Second, `source` is checked to ensure that it
         * matches the source object of `result`.  Third, `source_tag` is
         * checked to ensure that it is equal to the `source_tag` argument given
         * to g_simple_async_result_new() (which, by convention, is a pointer
         * to the _async function corresponding to the _finish function from
         * which this function is called).  (Alternatively, if either
         * `source_tag` or `result'`s source tag is %NULL, then the source tag
         * check is skipped.)
         * @param result the #GAsyncResult passed to the _finish function.
         * @param source the #GObject passed to the _finish function.
         * @param source_tag the asynchronous function.
         */
        static is_valid(result: AsyncResult, source?: GObject.Object | null, source_tag?: any | null): boolean;

        // Methods

        /**
         * Completes an asynchronous I/O job immediately. Must be called in
         * the thread where the asynchronous result was to be delivered, as it
         * invokes the callback directly. If you are in a different thread use
         * g_simple_async_result_complete_in_idle().
         *
         * Calling this function takes a reference to `simple` for as long as
         * is needed to complete the call.
         */
        complete(): void;
        /**
         * Completes an asynchronous function in an idle handler in the
         * [thread-default main context][g-main-context-push-thread-default]
         * of the thread that `simple` was initially created in
         * (and re-pushes that context around the invocation of the callback).
         *
         * Calling this function takes a reference to `simple` for as long as
         * is needed to complete the call.
         */
        complete_in_idle(): void;
        /**
         * Gets the operation result boolean from within the asynchronous result.
         * @returns %TRUE if the operation's result was %TRUE, %FALSE     if the operation's result was %FALSE.
         */
        get_op_res_gboolean(): boolean;
        /**
         * Gets a gssize from the asynchronous result.
         * @returns a gssize returned from the asynchronous function.
         */
        get_op_res_gssize(): number;
        /**
         * Propagates an error from within the simple asynchronous result to
         * a given destination.
         *
         * If the #GCancellable given to a prior call to
         * g_simple_async_result_set_check_cancellable() is cancelled then this
         * function will return %TRUE with `dest` set appropriately.
         * @returns %TRUE if the error was propagated to @dest. %FALSE otherwise.
         */
        propagate_error(): boolean;
        /**
         * Sets a #GCancellable to check before dispatching results.
         *
         * This function has one very specific purpose: the provided cancellable
         * is checked at the time of g_simple_async_result_propagate_error() If
         * it is cancelled, these functions will return an "Operation was
         * cancelled" error (%G_IO_ERROR_CANCELLED).
         *
         * Implementors of cancellable asynchronous functions should use this in
         * order to provide a guarantee to their callers that cancelling an
         * async operation will reliably result in an error being returned for
         * that operation (even if a positive result for the operation has
         * already been sent as an idle to the main context to be dispatched).
         *
         * The checking described above is done regardless of any call to the
         * unrelated g_simple_async_result_set_handle_cancellation() function.
         * @param check_cancellable a #GCancellable to check, or %NULL to unset
         */
        set_check_cancellable(check_cancellable?: Cancellable | null): void;
        /**
         * Sets the result from a #GError.
         * @param error #GError.
         */
        set_from_error(error: GLib.Error): void;
        /**
         * Sets whether to handle cancellation within the asynchronous operation.
         *
         * This function has nothing to do with
         * g_simple_async_result_set_check_cancellable().  It only refers to the
         * #GCancellable passed to g_simple_async_result_run_in_thread().
         * @param handle_cancellation a #gboolean.
         */
        set_handle_cancellation(handle_cancellation: boolean): void;
        /**
         * Sets the operation result to a boolean within the asynchronous result.
         * @param op_res a #gboolean.
         */
        set_op_res_gboolean(op_res: boolean): void;
        /**
         * Sets the operation result within the asynchronous result to
         * the given `op_res`.
         * @param op_res a #gssize.
         */
        set_op_res_gssize(op_res: number): void;

        // Inherited methods
        /**
         * Gets the source object from a #GAsyncResult.
         * @returns a new reference to the source    object for the @res, or %NULL if there is none.
         */
        get_source_object<T = GObject.Object>(): T;
        /**
         * Gets the user data from a #GAsyncResult.
         * @returns the user data for @res.
         */
        get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @param source_tag an application-defined tag
         * @returns %TRUE if @res has the indicated @source_tag, %FALSE if   not.
         */
        is_tagged(source_tag?: any | null): boolean;
        /**
         * If `res` is a #GSimpleAsyncResult, this is equivalent to
         * g_simple_async_result_propagate_error(). Otherwise it returns
         * %FALSE.
         *
         * This can be used for legacy error handling in async *_finish()
         * wrapper functions that traditionally handled #GSimpleAsyncResult
         * error returns themselves rather than calling into the virtual method.
         * This should not be used in new code; #GAsyncResult errors that are
         * set by virtual methods should also be extracted by virtual methods,
         * to enable subclasses to chain up correctly.
         * @returns %TRUE if @error is has been filled in with an error from   @res, %FALSE if not.
         */
        legacy_propagate_error(): boolean;
        /**
         * Gets the source object from a #GAsyncResult.
         */
        vfunc_get_source_object<T = GObject.Object>(): T;
        /**
         * Gets the user data from a #GAsyncResult.
         */
        vfunc_get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @param source_tag an application-defined tag
         */
        vfunc_is_tagged(source_tag?: any | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module SimpleIOStream {
        // Constructor properties interface

        interface ConstructorProps extends IOStream.ConstructorProps {
            input_stream: InputStream;
            inputStream: InputStream;
            output_stream: OutputStream;
            outputStream: OutputStream;
        }
    }

    /**
     * `GSimpleIOStream` creates a [class`Gio`.IOStream] from an arbitrary
     * [class`Gio`.InputStream] and [class`Gio`.OutputStream]. This allows any pair of
     * input and output streams to be used with [class`Gio`.IOStream] methods.
     *
     * This is useful when you obtained a [class`Gio`.InputStream] and a
     * [class`Gio`.OutputStream] by other means, for instance creating them with
     * platform specific methods as
     * [`g_unix_input_stream_new()`](../gio-unix/ctor.UnixInputStream.new.html)
     * (from `gio-unix-2.0.pc` / `GioUnix-2.0`), and you want to
     * take advantage of the methods provided by [class`Gio`.IOStream].
     */
    class SimpleIOStream extends IOStream {
        static $gtype: GObject.GType<SimpleIOStream>;

        // Properties

        /**
         * The [class`Gio`.InputStream] to read from.
         */
        get input_stream(): InputStream;
        /**
         * The [class`Gio`.InputStream] to read from.
         */
        get inputStream(): InputStream;
        /**
         * The [class`Gio`.OutputStream] to write to.
         */
        get output_stream(): OutputStream;
        /**
         * The [class`Gio`.OutputStream] to write to.
         */
        get outputStream(): OutputStream;

        // Constructors

        constructor(properties?: Partial<SimpleIOStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](input_stream: InputStream, output_stream: OutputStream): SimpleIOStream;
    }

    module SimplePermission {
        // Constructor properties interface

        interface ConstructorProps extends Permission.ConstructorProps {}
    }

    /**
     * `GSimplePermission` is a trivial implementation of [class`Gio`.Permission]
     * that represents a permission that is either always or never allowed.  The
     * value is given at construction and doesnt change.
     *
     * Calling [method`Gio`.Permission.acquire] or [method`Gio`.Permission.release]
     * on a `GSimplePermission` will result in errors.
     */
    class SimplePermission extends Permission {
        static $gtype: GObject.GType<SimplePermission>;

        // Constructors

        constructor(properties?: Partial<SimplePermission.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](allowed: boolean): SimplePermission;
    }

    module SimpleProxyResolver {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, ProxyResolver.ConstructorProps {
            default_proxy: string;
            defaultProxy: string;
            ignore_hosts: string[];
            ignoreHosts: string[];
        }
    }

    /**
     * `GSimpleProxyResolver` is a simple [iface`Gio`.ProxyResolver] implementation
     * that handles a single default proxy, multiple URI-scheme-specific
     * proxies, and a list of hosts that proxies should not be used for.
     *
     * `GSimpleProxyResolver` is never the default proxy resolver, but it
     * can be used as the base class for another proxy resolver
     * implementation, or it can be created and used manually, such as
     * with [method`Gio`.SocketClient.set_proxy_resolver].
     */
    class SimpleProxyResolver extends GObject.Object implements ProxyResolver {
        static $gtype: GObject.GType<SimpleProxyResolver>;

        // Properties

        /**
         * The default proxy URI that will be used for any URI that doesn't
         * match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
         * of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
         *
         * Note that as a special case, if this URI starts with
         * "socks://", #GSimpleProxyResolver will treat it as referring
         * to all three of the socks5, socks4a, and socks4 proxy types.
         */
        get default_proxy(): string;
        set default_proxy(val: string);
        /**
         * The default proxy URI that will be used for any URI that doesn't
         * match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
         * of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
         *
         * Note that as a special case, if this URI starts with
         * "socks://", #GSimpleProxyResolver will treat it as referring
         * to all three of the socks5, socks4a, and socks4 proxy types.
         */
        get defaultProxy(): string;
        set defaultProxy(val: string);
        /**
         * A list of hostnames and IP addresses that the resolver should
         * allow direct connections to.
         *
         * Entries can be in one of 4 formats:
         *
         * - A hostname, such as "example.com", ".example.com", or
         *   "*.example.com", any of which match "example.com" or
         *   any subdomain of it.
         *
         * - An IPv4 or IPv6 address, such as "192.168.1.1",
         *   which matches only that address.
         *
         * - A hostname or IP address followed by a port, such as
         *   "example.com:80", which matches whatever the hostname or IP
         *   address would match, but only for URLs with the (explicitly)
         *   indicated port. In the case of an IPv6 address, the address
         *   part must appear in brackets: "[::1]:443"
         *
         * - An IP address range, given by a base address and prefix length,
         *   such as "fe80::/10", which matches any address in that range.
         *
         * Note that when dealing with Unicode hostnames, the matching is
         * done against the ASCII form of the name.
         *
         * Also note that hostname exclusions apply only to connections made
         * to hosts identified by name, and IP address exclusions apply only
         * to connections made to hosts identified by address. That is, if
         * example.com has an address of 192.168.1.1, and the :ignore-hosts list
         * contains only "192.168.1.1", then a connection to "example.com"
         * (eg, via a #GNetworkAddress) will use the proxy, and a connection to
         * "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
         *
         * These rules match the "ignore-hosts"/"noproxy" rules most
         * commonly used by other applications.
         */
        get ignore_hosts(): string[];
        set ignore_hosts(val: string[]);
        /**
         * A list of hostnames and IP addresses that the resolver should
         * allow direct connections to.
         *
         * Entries can be in one of 4 formats:
         *
         * - A hostname, such as "example.com", ".example.com", or
         *   "*.example.com", any of which match "example.com" or
         *   any subdomain of it.
         *
         * - An IPv4 or IPv6 address, such as "192.168.1.1",
         *   which matches only that address.
         *
         * - A hostname or IP address followed by a port, such as
         *   "example.com:80", which matches whatever the hostname or IP
         *   address would match, but only for URLs with the (explicitly)
         *   indicated port. In the case of an IPv6 address, the address
         *   part must appear in brackets: "[::1]:443"
         *
         * - An IP address range, given by a base address and prefix length,
         *   such as "fe80::/10", which matches any address in that range.
         *
         * Note that when dealing with Unicode hostnames, the matching is
         * done against the ASCII form of the name.
         *
         * Also note that hostname exclusions apply only to connections made
         * to hosts identified by name, and IP address exclusions apply only
         * to connections made to hosts identified by address. That is, if
         * example.com has an address of 192.168.1.1, and the :ignore-hosts list
         * contains only "192.168.1.1", then a connection to "example.com"
         * (eg, via a #GNetworkAddress) will use the proxy, and a connection to
         * "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
         *
         * These rules match the "ignore-hosts"/"noproxy" rules most
         * commonly used by other applications.
         */
        get ignoreHosts(): string[];
        set ignoreHosts(val: string[]);

        // Constructors

        constructor(properties?: Partial<SimpleProxyResolver.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Creates a new #GSimpleProxyResolver. See
         * #GSimpleProxyResolver:default-proxy and
         * #GSimpleProxyResolver:ignore-hosts for more details on how the
         * arguments are interpreted.
         * @param default_proxy the default proxy to use, eg     "socks://192.168.1.1"
         * @param ignore_hosts an optional list of hosts/IP addresses     to not use a proxy for.
         */
        static ['new'](default_proxy?: string | null, ignore_hosts?: string[] | null): ProxyResolver;

        // Methods

        /**
         * Sets the default proxy on `resolver,` to be used for any URIs that
         * don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
         * via g_simple_proxy_resolver_set_uri_proxy().
         *
         * If `default_proxy` starts with "socks://",
         * #GSimpleProxyResolver will treat it as referring to all three of
         * the socks5, socks4a, and socks4 proxy types.
         * @param default_proxy the default proxy to use
         */
        set_default_proxy(default_proxy?: string | null): void;
        /**
         * Sets the list of ignored hosts.
         *
         * See #GSimpleProxyResolver:ignore-hosts for more details on how the
         * `ignore_hosts` argument is interpreted.
         * @param ignore_hosts %NULL-terminated list of hosts/IP addresses     to not use a proxy for
         */
        set_ignore_hosts(ignore_hosts: string[]): void;
        /**
         * Adds a URI-scheme-specific proxy to `resolver;` URIs whose scheme
         * matches `uri_scheme` (and which don't match
         * #GSimpleProxyResolver:ignore-hosts) will be proxied via `proxy`.
         *
         * As with #GSimpleProxyResolver:default-proxy, if `proxy` starts with
         * "socks://", #GSimpleProxyResolver will treat it
         * as referring to all three of the socks5, socks4a, and socks4 proxy
         * types.
         * @param uri_scheme the URI scheme to add a proxy for
         * @param proxy the proxy to use for @uri_scheme
         */
        set_uri_proxy(uri_scheme: string, proxy: string): void;

        // Inherited methods
        /**
         * Checks if `resolver` can be used on this system. (This is used
         * internally; g_proxy_resolver_get_default() will only return a proxy
         * resolver that returns %TRUE for this method.)
         * @returns %TRUE if @resolver is supported.
         */
        is_supported(): boolean;
        /**
         * Looks into the system proxy configuration to determine what proxy,
         * if any, to use to connect to `uri`. The returned proxy URIs are of
         * the form `<protocol>://[user[:password]`]`host[:port]` or
         * `direct://`, where <protocol> could be http, rtsp, socks
         * or other proxying protocol.
         *
         * If you don't know what network protocol is being used on the
         * socket, you should use `none` as the URI protocol.
         * In this case, the resolver might still return a generic proxy type
         * (such as SOCKS), but would not return protocol-specific proxy types
         * (such as http).
         *
         * `direct://` is used when no proxy is needed.
         * Direct connection should not be attempted unless it is part of the
         * returned array of proxies.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        lookup(uri: string, cancellable?: Cancellable | null): string[];
        /**
         * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
         * details.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_async(uri: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Call this function to obtain the array of proxy URIs when
         * g_proxy_resolver_lookup_async() is complete. See
         * g_proxy_resolver_lookup() for more details.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        lookup_finish(result: AsyncResult): string[];
        /**
         * Checks if `resolver` can be used on this system. (This is used
         * internally; g_proxy_resolver_get_default() will only return a proxy
         * resolver that returns %TRUE for this method.)
         */
        vfunc_is_supported(): boolean;
        /**
         * Looks into the system proxy configuration to determine what proxy,
         * if any, to use to connect to `uri`. The returned proxy URIs are of
         * the form `<protocol>://[user[:password]`]`host[:port]` or
         * `direct://`, where <protocol> could be http, rtsp, socks
         * or other proxying protocol.
         *
         * If you don't know what network protocol is being used on the
         * socket, you should use `none` as the URI protocol.
         * In this case, the resolver might still return a generic proxy type
         * (such as SOCKS), but would not return protocol-specific proxy types
         * (such as http).
         *
         * `direct://` is used when no proxy is needed.
         * Direct connection should not be attempted unless it is part of the
         * returned array of proxies.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup(uri: string, cancellable?: Cancellable | null): string[];
        /**
         * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
         * details.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_async(
            uri: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Call this function to obtain the array of proxy URIs when
         * g_proxy_resolver_lookup_async() is complete. See
         * g_proxy_resolver_lookup() for more details.
         * @param result the result passed to your #GAsyncReadyCallback
         */
        vfunc_lookup_finish(result: AsyncResult): string[];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Socket {
        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                DatagramBased.ConstructorProps,
                Initable.ConstructorProps {
            blocking: boolean;
            broadcast: boolean;
            family: SocketFamily;
            fd: number;
            keepalive: boolean;
            listen_backlog: number;
            listenBacklog: number;
            local_address: SocketAddress;
            localAddress: SocketAddress;
            multicast_loopback: boolean;
            multicastLoopback: boolean;
            multicast_ttl: number;
            multicastTtl: number;
            protocol: SocketProtocol;
            remote_address: SocketAddress;
            remoteAddress: SocketAddress;
            timeout: number;
            ttl: number;
            type: SocketType;
        }
    }

    /**
     * A `GSocket` is a low-level networking primitive. It is a more or less
     * direct mapping of the BSD socket API in a portable GObject based API.
     * It supports both the UNIX socket implementations and winsock2 on Windows.
     *
     * `GSocket` is the platform independent base upon which the higher level
     * network primitives are based. Applications are not typically meant to
     * use it directly, but rather through classes like [class`Gio`.SocketClient],
     * [class`Gio`.SocketService] and [class`Gio`.SocketConnection]. However there may
     * be cases where direct use of `GSocket` is useful.
     *
     * `GSocket` implements the [iface`Gio`.Initable] interface, so if it is manually
     * constructed by e.g. [ctor`GObject`.Object.new] you must call
     * [method`Gio`.Initable.init] and check the results before using the object.
     * This is done automatically in [ctor`Gio`.Socket.new] and
     * [ctor`Gio`.Socket.new_from_fd], so these functions can return `NULL`.
     *
     * Sockets operate in two general modes, blocking or non-blocking. When
     * in blocking mode all operations (which dont take an explicit blocking
     * parameter) block until the requested operation
     * is finished or there is an error. In non-blocking mode all calls that
     * would block return immediately with a `G_IO_ERROR_WOULD_BLOCK` error.
     * To know when a call would successfully run you can call
     * [method`Gio`.Socket.condition_check], or [method`Gio`.Socket.condition_wait].
     * You can also use [method`Gio`.Socket.create_source] and attach it to a
     * [type`GLib`.MainContext] to get callbacks when I/O is possible.
     * Note that all sockets are always set to non blocking mode in the system, and
     * blocking mode is emulated in `GSocket`.
     *
     * When working in non-blocking mode applications should always be able to
     * handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other
     * function said that I/O was possible. This can easily happen in case
     * of a race condition in the application, but it can also happen for other
     * reasons. For instance, on Windows a socket is always seen as writable
     * until a write returns `G_IO_ERROR_WOULD_BLOCK`.
     *
     * `GSocket`s can be either connection oriented or datagram based.
     * For connection oriented types you must first establish a connection by
     * either connecting to an address or accepting a connection from another
     * address. For connectionless socket types the target/source address is
     * specified or received in each I/O operation.
     *
     * All socket file descriptors are set to be close-on-exec.
     *
     * Note that creating a `GSocket` causes the signal `SIGPIPE` to be
     * ignored for the remainder of the program. If you are writing a
     * command-line utility that uses `GSocket`, you may need to take into
     * account the fact that your program will not automatically be killed
     * if it tries to write to `stdout` after it has been closed.
     *
     * Like most other APIs in GLib, `GSocket` is not inherently thread safe. To use
     * a `GSocket` concurrently from multiple threads, you must implement your own
     * locking.
     *
     * ## Nagles algorithm
     *
     * Since GLib 2.80, `GSocket` will automatically set the `TCP_NODELAY` option on
     * all `G_SOCKET_TYPE_STREAM` sockets. This disables
     * [Nagles algorithm](https://en.wikipedia.org/wiki/Nagle%27s_algorithm) as it
     * typically does more harm than good on modern networks.
     *
     * If your application needs Nagles algorithm enabled, call
     * [method`Gio`.Socket.set_option] after constructing a `GSocket` to enable it:
     * ```c
     * socket = g_socket_new (, G_SOCKET_TYPE_STREAM, );
     * if (socket != NULL)
     *   {
     *     g_socket_set_option (socket, IPPROTO_TCP, TCP_NODELAY, FALSE, &local_error);
     *     // handle error if needed
     *   }
     * ```
     */
    class Socket extends GObject.Object implements DatagramBased, Initable {
        static $gtype: GObject.GType<Socket>;

        // Properties

        /**
         * Whether I/O on this socket is blocking.
         */
        get blocking(): boolean;
        set blocking(val: boolean);
        /**
         * Whether the socket should allow sending to broadcast addresses.
         */
        get broadcast(): boolean;
        set broadcast(val: boolean);
        /**
         * The sockets address family.
         */
        get family(): SocketFamily;
        /**
         * The sockets file descriptor.
         */
        get fd(): number;
        /**
         * Whether to keep the connection alive by sending periodic pings.
         */
        get keepalive(): boolean;
        set keepalive(val: boolean);
        /**
         * The number of outstanding connections in the listen queue.
         */
        get listen_backlog(): number;
        set listen_backlog(val: number);
        /**
         * The number of outstanding connections in the listen queue.
         */
        get listenBacklog(): number;
        set listenBacklog(val: number);
        /**
         * The local address the socket is bound to.
         */
        get local_address(): SocketAddress;
        /**
         * The local address the socket is bound to.
         */
        get localAddress(): SocketAddress;
        /**
         * Whether outgoing multicast packets loop back to the local host.
         */
        get multicast_loopback(): boolean;
        set multicast_loopback(val: boolean);
        /**
         * Whether outgoing multicast packets loop back to the local host.
         */
        get multicastLoopback(): boolean;
        set multicastLoopback(val: boolean);
        /**
         * Time-to-live out outgoing multicast packets
         */
        get multicast_ttl(): number;
        set multicast_ttl(val: number);
        /**
         * Time-to-live out outgoing multicast packets
         */
        get multicastTtl(): number;
        set multicastTtl(val: number);
        /**
         * The ID of the protocol to use, or `-1` for unknown.
         */
        get protocol(): SocketProtocol;
        /**
         * The remote address the socket is connected to.
         */
        get remote_address(): SocketAddress;
        /**
         * The remote address the socket is connected to.
         */
        get remoteAddress(): SocketAddress;
        /**
         * The timeout in seconds on socket I/O
         */
        get timeout(): number;
        set timeout(val: number);
        /**
         * Time-to-live for outgoing unicast packets
         */
        get ttl(): number;
        set ttl(val: number);
        /**
         * The sockets type.
         */
        get type(): SocketType;

        // Constructors

        constructor(properties?: Partial<Socket.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](family: SocketFamily, type: SocketType, protocol: SocketProtocol): Socket;

        static new_from_fd(fd: number): Socket;

        // Methods

        /**
         * Accept incoming connections on a connection-based socket. This removes
         * the first outstanding connection request from the listening socket and
         * creates a #GSocket object for it.
         *
         * The `socket` must be bound to a local address with g_socket_bind() and
         * must be listening for incoming connections (g_socket_listen()).
         *
         * If there are no outstanding connections then the operation will block
         * or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
         * To be notified of an incoming connection, wait for the %G_IO_IN condition.
         * @param cancellable a %GCancellable or %NULL
         * @returns a new #GSocket, or %NULL on error.     Free the returned object with g_object_unref().
         */
        accept(cancellable?: Cancellable | null): Socket;
        /**
         * When a socket is created it is attached to an address family, but it
         * doesn't have an address in this family. g_socket_bind() assigns the
         * address (sometimes called name) of the socket.
         *
         * It is generally required to bind to a local address before you can
         * receive connections. (See g_socket_listen() and g_socket_accept() ).
         * In certain situations, you may also want to bind a socket that will be
         * used to initiate connections, though this is not normally required.
         *
         * If `socket` is a TCP socket, then `allow_reuse` controls the setting
         * of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
         * server sockets (sockets that you will eventually call
         * g_socket_accept() on), and %FALSE for client sockets. (Failing to
         * set this flag on a server socket may cause g_socket_bind() to return
         * %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
         * immediately restarted.)
         *
         * If `socket` is a UDP socket, then `allow_reuse` determines whether or
         * not other UDP sockets can be bound to the same address at the same
         * time. In particular, you can have several UDP sockets bound to the
         * same address, and they will all receive all of the multicast and
         * broadcast packets sent to that address. (The behavior of unicast
         * UDP packets to an address with multiple listeners is not defined.)
         * @param address a #GSocketAddress specifying the local address.
         * @param allow_reuse whether to allow reusing this address
         * @returns %TRUE on success, %FALSE on error.
         */
        bind(address: SocketAddress, allow_reuse: boolean): boolean;
        /**
         * Checks and resets the pending connect error for the socket.
         * This is used to check for errors when g_socket_connect() is
         * used in non-blocking mode.
         * @returns %TRUE if no error, %FALSE otherwise, setting @error to the error
         */
        check_connect_result(): boolean;
        /**
         * Closes the socket, shutting down any active connection.
         *
         * Closing a socket does not wait for all outstanding I/O operations
         * to finish, so the caller should not rely on them to be guaranteed
         * to complete even if the close returns with no error.
         *
         * Once the socket is closed, all other operations will return
         * %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
         * return an error.
         *
         * Sockets will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Beware that due to the way that TCP works, it is possible for
         * recently-sent data to be lost if either you close a socket while the
         * %G_IO_IN condition is set, or else if the remote connection tries to
         * send something to you after you close the socket but before it has
         * finished reading all of the data you sent. There is no easy generic
         * way to avoid this problem; the easiest fix is to design the network
         * protocol such that the client will never send data "out of turn".
         * Another solution is for the server to half-close the connection by
         * calling g_socket_shutdown() with only the `shutdown_write` flag set,
         * and then wait for the client to notice this and close its side of the
         * connection, after which the server can safely call g_socket_close().
         * (This is what #GTcpConnection does if you call
         * g_tcp_connection_set_graceful_disconnect(). But of course, this
         * only works if the client will close its connection after the server
         * does.)
         * @returns %TRUE on success, %FALSE on error
         */
        close(): boolean;
        /**
         * Checks on the readiness of `socket` to perform operations.
         * The operations specified in `condition` are checked for and masked
         * against the currently-satisfied conditions on `socket`. The result
         * is returned.
         *
         * Note that on Windows, it is possible for an operation to return
         * %G_IO_ERROR_WOULD_BLOCK even immediately after
         * g_socket_condition_check() has claimed that the socket is ready for
         * writing. Rather than calling g_socket_condition_check() and then
         * writing to the socket if it succeeds, it is generally better to
         * simply try writing to the socket right away, and try again later if
         * the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
         * these conditions will always be set in the output if they are true.
         *
         * This call never blocks.
         * @param condition a #GIOCondition mask to check
         * @returns the @GIOCondition mask of the current state
         */
        condition_check(condition: GLib.IOCondition): GLib.IOCondition;
        /**
         * Waits for up to `timeout_us` microseconds for `condition` to become true
         * on `socket`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if
         * `timeout_us` (or the socket's #GSocket:timeout) is reached before the
         * condition is met, then %FALSE is returned and `error,` if non-%NULL,
         * is set to the appropriate value (%G_IO_ERROR_CANCELLED or
         * %G_IO_ERROR_TIMED_OUT).
         *
         * If you don't want a timeout, use g_socket_condition_wait().
         * (Alternatively, you can pass -1 for `timeout_us`.)
         *
         * Note that although `timeout_us` is in microseconds for consistency with
         * other GLib APIs, this function actually only has millisecond
         * resolution, and the behavior is undefined if `timeout_us` is not an
         * exact number of milliseconds.
         * @param condition a #GIOCondition mask to wait for
         * @param timeout_us the maximum time (in microseconds) to wait, or -1
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        condition_timed_wait(
            condition: GLib.IOCondition,
            timeout_us: number,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Waits for `condition` to become true on `socket`. When the condition
         * is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if the
         * socket has a timeout set and it is reached before the condition is
         * met, then %FALSE is returned and `error,` if non-%NULL, is set to
         * the appropriate value (%G_IO_ERROR_CANCELLED or
         * %G_IO_ERROR_TIMED_OUT).
         *
         * See also g_socket_condition_timed_wait().
         * @param condition a #GIOCondition mask to wait for
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        condition_wait(condition: GLib.IOCondition, cancellable?: Cancellable | null): boolean;
        // Conflicted with Gio.DatagramBased.condition_wait
        condition_wait(...args: never[]): any;
        /**
         * Connect the socket to the specified remote address.
         *
         * For connection oriented socket this generally means we attempt to make
         * a connection to the `address`. For a connection-less socket it sets
         * the default address for g_socket_send() and discards all incoming datagrams
         * from other sources.
         *
         * Generally connection oriented sockets can only connect once, but
         * connection-less sockets can connect multiple times to change the
         * default address.
         *
         * If the connect call needs to do network I/O it will block, unless
         * non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
         * and the user can be notified of the connection finishing by waiting
         * for the G_IO_OUT condition. The result of the connection must then be
         * checked with g_socket_check_connect_result().
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if connected, %FALSE on error.
         */
        connect(address: SocketAddress, cancellable?: Cancellable | null): boolean;
        connect(...args: never[]): any;
        /**
         * Creates a #GSocketConnection subclass of the right type for
         * `socket`.
         * @returns a #GSocketConnection
         */
        connection_factory_create_connection(): SocketConnection;
        /**
         * Get the amount of data pending in the OS input buffer, without blocking.
         *
         * If `socket` is a UDP or SCTP socket, this will return the size of
         * just the next packet, even if additional packets are buffered after
         * that one.
         *
         * Note that on Windows, this function is rather inefficient in the
         * UDP case, and so if you know any plausible upper bound on the size
         * of the incoming packet, it is better to just do a
         * g_socket_receive() with a buffer of that size, rather than calling
         * g_socket_get_available_bytes() first and then doing a receive of
         * exactly the right size.
         * @returns the number of bytes that can be read from the socket without blocking or truncating, or -1 on error.
         */
        get_available_bytes(): number;
        /**
         * Gets the blocking mode of the socket. For details on blocking I/O,
         * see g_socket_set_blocking().
         * @returns %TRUE if blocking I/O is used, %FALSE otherwise.
         */
        get_blocking(): boolean;
        /**
         * Gets the broadcast setting on `socket;` if %TRUE,
         * it is possible to send packets to broadcast
         * addresses.
         * @returns the broadcast setting on @socket
         */
        get_broadcast(): boolean;
        /**
         * Returns the credentials of the foreign process connected to this
         * socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
         * sockets).
         *
         * If this operation isn't supported on the OS, the method fails with
         * the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
         * by reading the %SO_PEERCRED option on the underlying socket.
         *
         * This method can be expected to be available on the following platforms:
         *
         * - Linux since GLib 2.26
         * - OpenBSD since GLib 2.30
         * - Solaris, Illumos and OpenSolaris since GLib 2.40
         * - NetBSD since GLib 2.42
         * - macOS, tvOS, iOS since GLib 2.66
         *
         * Other ways to obtain credentials from a foreign peer includes the
         * #GUnixCredentialsMessage type and
         * g_unix_connection_send_credentials() /
         * g_unix_connection_receive_credentials() functions.
         * @returns %NULL if @error is set, otherwise a #GCredentials object that must be freed with g_object_unref().
         */
        get_credentials(): Credentials;
        /**
         * Gets the socket family of the socket.
         * @returns a #GSocketFamily
         */
        get_family(): SocketFamily;
        /**
         * Returns the underlying OS socket object. On unix this
         * is a socket file descriptor, and on Windows this is
         * a Winsock2 SOCKET handle. This may be useful for
         * doing platform specific or otherwise unusual operations
         * on the socket.
         * @returns the file descriptor of the socket.
         */
        get_fd(): number;
        /**
         * Gets the keepalive mode of the socket. For details on this,
         * see g_socket_set_keepalive().
         * @returns %TRUE if keepalive is active, %FALSE otherwise.
         */
        get_keepalive(): boolean;
        /**
         * Gets the listen backlog setting of the socket. For details on this,
         * see g_socket_set_listen_backlog().
         * @returns the maximum number of pending connections.
         */
        get_listen_backlog(): number;
        /**
         * Try to get the local address of a bound socket. This is only
         * useful if the socket has been bound to a local address,
         * either explicitly or implicitly when connecting.
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_local_address(): SocketAddress;
        /**
         * Gets the multicast loopback setting on `socket;` if %TRUE (the
         * default), outgoing multicast packets will be looped back to
         * multicast listeners on the same host.
         * @returns the multicast loopback setting on @socket
         */
        get_multicast_loopback(): boolean;
        /**
         * Gets the multicast time-to-live setting on `socket;` see
         * g_socket_set_multicast_ttl() for more details.
         * @returns the multicast time-to-live setting on @socket
         */
        get_multicast_ttl(): number;
        /**
         * Gets the value of an integer-valued option on `socket,` as with
         * getsockopt(). (If you need to fetch a  non-integer-valued option,
         * you will need to call getsockopt() directly.)
         *
         * The [<gio/gnetworking.h>][gio-gnetworking.h]
         * header pulls in system headers that will define most of the
         * standard/portable socket options. For unusual socket protocols or
         * platform-dependent options, you may need to include additional
         * headers.
         *
         * Note that even for socket options that are a single byte in size,
         * `value` is still a pointer to a #gint variable, not a #guchar;
         * g_socket_get_option() will handle the conversion internally.
         * @param level the "API level" of the option (eg, `SOL_SOCKET`)
         * @param optname the "name" of the option (eg, `SO_BROADCAST`)
         * @returns success or failure. On failure, @error will be set, and   the system error value (`errno` or WSAGetLastError()) will still   be set to the result of the getsockopt() call.
         */
        get_option(level: number, optname: number): [boolean, number];
        /**
         * Gets the socket protocol id the socket was created with.
         * In case the protocol is unknown, -1 is returned.
         * @returns a protocol id, or -1 if unknown
         */
        get_protocol(): SocketProtocol;
        /**
         * Try to get the remote address of a connected socket. This is only
         * useful for connection oriented sockets that have been connected.
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_remote_address(): SocketAddress;
        /**
         * Gets the socket type of the socket.
         * @returns a #GSocketType
         */
        get_socket_type(): SocketType;
        /**
         * Gets the timeout setting of the socket. For details on this, see
         * g_socket_set_timeout().
         * @returns the timeout in seconds
         */
        get_timeout(): number;
        /**
         * Gets the unicast time-to-live setting on `socket;` see
         * g_socket_set_ttl() for more details.
         * @returns the time-to-live setting on @socket
         */
        get_ttl(): number;
        /**
         * Checks whether a socket is closed.
         * @returns %TRUE if socket is closed, %FALSE otherwise
         */
        is_closed(): boolean;
        /**
         * Check whether the socket is connected. This is only useful for
         * connection-oriented sockets.
         *
         * If using g_socket_shutdown(), this function will return %TRUE until the
         * socket has been shut down for reading and writing. If you do a non-blocking
         * connect, this function will not return %TRUE until after you call
         * g_socket_check_connect_result().
         * @returns %TRUE if socket is connected, %FALSE otherwise.
         */
        is_connected(): boolean;
        /**
         * Registers `socket` to receive multicast messages sent to `group`.
         * `socket` must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
         * been bound to an appropriate interface and port with
         * g_socket_bind().
         *
         * If `iface` is %NULL, the system will automatically pick an interface
         * to bind to based on `group`.
         *
         * If `source_specific` is %TRUE, source-specific multicast as defined
         * in RFC 4604 is used. Note that on older platforms this may fail
         * with a %G_IO_ERROR_NOT_SUPPORTED error.
         *
         * To bind to a given source-specific multicast address, use
         * g_socket_join_multicast_group_ssm() instead.
         * @param group a #GInetAddress specifying the group address to join.
         * @param source_specific %TRUE if source-specific multicast should be used
         * @param iface Name of the interface to use, or %NULL
         * @returns %TRUE on success, %FALSE on error.
         */
        join_multicast_group(group: InetAddress, source_specific: boolean, iface?: string | null): boolean;
        /**
         * Registers `socket` to receive multicast messages sent to `group`.
         * `socket` must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
         * been bound to an appropriate interface and port with
         * g_socket_bind().
         *
         * If `iface` is %NULL, the system will automatically pick an interface
         * to bind to based on `group`.
         *
         * If `source_specific` is not %NULL, use source-specific multicast as
         * defined in RFC 4604. Note that on older platforms this may fail
         * with a %G_IO_ERROR_NOT_SUPPORTED error.
         *
         * Note that this function can be called multiple times for the same
         * `group` with different `source_specific` in order to receive multicast
         * packets from more than one source.
         * @param group a #GInetAddress specifying the group address to join.
         * @param source_specific a #GInetAddress specifying the source-specific multicast address or %NULL to ignore.
         * @param iface Name of the interface to use, or %NULL
         * @returns %TRUE on success, %FALSE on error.
         */
        join_multicast_group_ssm(
            group: InetAddress,
            source_specific?: InetAddress | null,
            iface?: string | null,
        ): boolean;
        /**
         * Removes `socket` from the multicast group defined by `group,` `iface,`
         * and `source_specific` (which must all have the same values they had
         * when you joined the group).
         *
         * `socket` remains bound to its address and port, and can still receive
         * unicast messages after calling this.
         *
         * To unbind to a given source-specific multicast address, use
         * g_socket_leave_multicast_group_ssm() instead.
         * @param group a #GInetAddress specifying the group address to leave.
         * @param source_specific %TRUE if source-specific multicast was used
         * @param iface Interface used
         * @returns %TRUE on success, %FALSE on error.
         */
        leave_multicast_group(group: InetAddress, source_specific: boolean, iface?: string | null): boolean;
        /**
         * Removes `socket` from the multicast group defined by `group,` `iface,`
         * and `source_specific` (which must all have the same values they had
         * when you joined the group).
         *
         * `socket` remains bound to its address and port, and can still receive
         * unicast messages after calling this.
         * @param group a #GInetAddress specifying the group address to leave.
         * @param source_specific a #GInetAddress specifying the source-specific multicast address or %NULL to ignore.
         * @param iface Name of the interface to use, or %NULL
         * @returns %TRUE on success, %FALSE on error.
         */
        leave_multicast_group_ssm(
            group: InetAddress,
            source_specific?: InetAddress | null,
            iface?: string | null,
        ): boolean;
        /**
         * Marks the socket as a server socket, i.e. a socket that is used
         * to accept incoming requests using g_socket_accept().
         *
         * Before calling this the socket must be bound to a local address using
         * g_socket_bind().
         *
         * To set the maximum amount of outstanding clients, use
         * g_socket_set_listen_backlog().
         * @returns %TRUE on success, %FALSE on error.
         */
        listen(): boolean;
        /**
         * Receive data (up to `size` bytes) from a socket. This is mainly used by
         * connection-oriented sockets; it is identical to g_socket_receive_from()
         * with `address` set to %NULL.
         *
         * For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
         * g_socket_receive() will always read either 0 or 1 complete messages from
         * the socket. If the received message is too large to fit in `buffer,` then
         * the data beyond `size` bytes will be discarded, without any explicit
         * indication that this has occurred.
         *
         * For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
         * number of bytes, up to `size`. If more than `size` bytes have been
         * received, the additional data will be returned in future calls to
         * g_socket_receive().
         *
         * If the socket is in blocking mode the call will block until there
         * is some data to receive, the connection is closed, or there is an
         * error. If there is no data available and the socket is in
         * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
         * returned. To be notified when data is available, wait for the
         * %G_IO_IN condition.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Receives data (up to `size` bytes) from a socket.
         *
         * This function is a variant of [method`Gio`.Socket.receive] which returns a
         * [struct`GLib`.Bytes] rather than a plain buffer.
         *
         * Pass `-1` to `timeout_us` to block indefinitely until data is received (or
         * the connection is closed, or there is an error). Pass `0` to use the default
         * timeout from [property`Gio`.Socket:timeout], or pass a positive number to wait
         * for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
         * @param size the number of bytes you want to read from the socket
         * @param timeout_us the timeout to wait for, in microseconds, or `-1` to block   indefinitely
         * @param cancellable a %GCancellable, or `NULL`
         * @returns a bytes buffer containing the   received bytes, or `NULL` on error
         */
        receive_bytes(size: number, timeout_us: number, cancellable?: Cancellable | null): GLib.Bytes;
        /**
         * Receive data (up to `size` bytes) from a socket.
         *
         * This function is a variant of [method`Gio`.Socket.receive_from] which returns
         * a [struct`GLib`.Bytes] rather than a plain buffer.
         *
         * If `address` is non-%NULL then `address` will be set equal to the
         * source address of the received packet.
         *
         * The `address` is owned by the caller.
         *
         * Pass `-1` to `timeout_us` to block indefinitely until data is received (or
         * the connection is closed, or there is an error). Pass `0` to use the default
         * timeout from [property`Gio`.Socket:timeout], or pass a positive number to wait
         * for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
         * @param size the number of bytes you want to read from the socket
         * @param timeout_us the timeout to wait for, in microseconds, or `-1` to block   indefinitely
         * @param cancellable a #GCancellable, or `NULL`
         * @returns a bytes buffer containing the   received bytes, or `NULL` on error
         */
        receive_bytes_from(
            size: number,
            timeout_us: number,
            cancellable?: Cancellable | null,
        ): [GLib.Bytes, SocketAddress | null];
        /**
         * Receive data (up to `size` bytes) from a socket.
         *
         * If `address` is non-%NULL then `address` will be set equal to the
         * source address of the received packet.
         * `address` is owned by the caller.
         *
         * See g_socket_receive() for additional information.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive_from(cancellable?: Cancellable | null): [number, SocketAddress | null, Uint8Array];
        /**
         * Receive data from a socket.  For receiving multiple messages, see
         * g_socket_receive_messages(); for easier use, see
         * g_socket_receive() and g_socket_receive_from().
         *
         * If `address` is non-%NULL then `address` will be set equal to the
         * source address of the received packet.
         * `address` is owned by the caller.
         *
         * `vector` must point to an array of #GInputVector structs and
         * `num_vectors` must be the length of this array.  These structs
         * describe the buffers that received data will be scattered into.
         * If `num_vectors` is -1, then `vectors` is assumed to be terminated
         * by a #GInputVector with a %NULL buffer pointer.
         *
         * As a special case, if `num_vectors` is 0 (in which case, `vectors`
         * may of course be %NULL), then a single byte is received and
         * discarded. This is to facilitate the common practice of sending a
         * single '\0' byte for the purposes of transferring ancillary data.
         *
         * `messages,` if non-%NULL, will be set to point to a newly-allocated
         * array of #GSocketControlMessage instances or %NULL if no such
         * messages was received. These correspond to the control messages
         * received from the kernel, one #GSocketControlMessage per message
         * from the kernel. This array is %NULL-terminated and must be freed
         * by the caller using g_free() after calling g_object_unref() on each
         * element. If `messages` is %NULL, any control messages received will
         * be discarded.
         *
         * `num_messages,` if non-%NULL, will be set to the number of control
         * messages received.
         *
         * If both `messages` and `num_messages` are non-%NULL, then
         * `num_messages` gives the number of #GSocketControlMessage instances
         * in `messages` (ie: not including the %NULL terminator).
         *
         * `flags` is an in/out parameter. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too
         * (and g_socket_receive_message() may pass system-specific flags out).
         * Flags passed in to the parameter affect the receive operation; flags returned
         * out of it are relevant to the specific returned message.
         *
         * As with g_socket_receive(), data may be discarded if `socket` is
         * %G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
         * provide enough buffer space to read a complete message. You can pass
         * %G_SOCKET_MSG_PEEK in `flags` to peek at the current message without
         * removing it from the receive queue, but there is no portable way to find
         * out the length of the message other than by reading it into a
         * sufficiently-large buffer.
         *
         * If the socket is in blocking mode the call will block until there
         * is some data to receive, the connection is closed, or there is an
         * error. If there is no data available and the socket is in
         * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
         * returned. To be notified when data is available, wait for the
         * %G_IO_IN condition.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param vectors an array of #GInputVector structs
         * @param flags a pointer to an int containing #GSocketMsgFlags flags,    which may additionally contain    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive_message(
            vectors: InputVector[],
            flags: number,
            cancellable?: Cancellable | null,
        ): [number, SocketAddress | null, SocketControlMessage[] | null, number];
        /**
         * Receive multiple data messages from `socket` in one go.  This is the most
         * complicated and fully-featured version of this call. For easier use, see
         * g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to. Using
         * multiple #GInputVectors is more memory-efficient than manually copying data
         * out of a single buffer to multiple sources, and more system-call-efficient
         * than making multiple calls to g_socket_receive(), such as in scenarios where
         * a lot of data packets need to be received (e.g. high-bandwidth video
         * streaming over RTP/UDP).
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If #GSocket:blocking is %TRUE the call will block until `num_messages` have
         * been received, or the end of the stream is reached.
         *
         * If #GSocket:blocking is %FALSE the call will return up to `num_messages`
         * without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
         * operating system to be received.
         *
         * In blocking mode, if #GSocket:timeout is positive and is reached before any
         * messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
         * `num_messages` are returned. (Note: This is effectively the
         * behaviour of `MSG_WAITFORONE` with recvmmsg().)
         *
         * To be notified when messages are available, wait for the
         * %G_IO_IN condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
         * previously notified of a %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * operating system will be returned, and subsequent calls to
         * g_socket_receive_messages() will return 0 (with no error set).
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned.
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation,    which may additionally contain    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if in non-blocking     mode, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
         */
        receive_messages(messages: InputMessage[], flags: number, cancellable?: Cancellable | null): number;
        // Conflicted with Gio.DatagramBased.receive_messages
        receive_messages(...args: never[]): any;
        /**
         * This behaves exactly the same as g_socket_receive(), except that
         * the choice of blocking or non-blocking behavior is determined by
         * the `blocking` argument rather than by `socket'`s properties.
         * @param blocking whether to do blocking or non-blocking I/O
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
         */
        receive_with_blocking(blocking: boolean, cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Tries to send `size` bytes from `buffer` on the socket. This is
         * mainly used by connection-oriented sockets; it is identical to
         * g_socket_send_to() with `address` set to %NULL.
         *
         * If the socket is in blocking mode the call will block until there is
         * space for the data in the socket queue. If there is no space available
         * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
         * will be returned. To be notified when space is available, wait for the
         * %G_IO_OUT condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
         * notified of a %G_IO_OUT condition. (On Windows in particular, this is
         * very common due to the way the underlying APIs work.)
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer     containing the data to send.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Send data to `address` on `socket`.  For sending multiple messages see
         * g_socket_send_messages(); for easier use, see
         * g_socket_send() and g_socket_send_to().
         *
         * If `address` is %NULL then the message is sent to the default receiver
         * (set by g_socket_connect()).
         *
         * `vectors` must point to an array of #GOutputVector structs and
         * `num_vectors` must be the length of this array. (If `num_vectors` is -1,
         * then `vectors` is assumed to be terminated by a #GOutputVector with a
         * %NULL buffer pointer.) The #GOutputVector structs describe the buffers
         * that the sent data will be gathered from. Using multiple
         * #GOutputVectors is more memory-efficient than manually copying
         * data from multiple sources into a single buffer, and more
         * network-efficient than making multiple calls to g_socket_send().
         *
         * `messages,` if non-%NULL, is taken to point to an array of `num_messages`
         * #GSocketControlMessage instances. These correspond to the control
         * messages to be sent on the socket.
         * If `num_messages` is -1 then `messages` is treated as a %NULL-terminated
         * array.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * If the socket is in blocking mode the call will block until there is
         * space for the data in the socket queue. If there is no space available
         * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
         * will be returned. To be notified when space is available, wait for the
         * %G_IO_OUT condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
         * notified of a %G_IO_OUT condition. (On Windows in particular, this is
         * very common due to the way the underlying APIs work.)
         *
         * The sum of the sizes of each #GOutputVector in vectors must not be
         * greater than %G_MAXSSIZE. If the message can be larger than this,
         * then it is mandatory to use the g_socket_send_message_with_timeout()
         * function.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param address a #GSocketAddress, or %NULL
         * @param vectors an array of #GOutputVector structs
         * @param messages a pointer to an   array of #GSocketControlMessages, or %NULL.
         * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send_message(
            address: SocketAddress | null,
            vectors: OutputVector[],
            messages: SocketControlMessage[] | null,
            flags: number,
            cancellable?: Cancellable | null,
        ): number;
        /**
         * This behaves exactly the same as g_socket_send_message(), except that
         * the choice of timeout behavior is determined by the `timeout_us` argument
         * rather than by `socket'`s properties.
         *
         * On error %G_POLLABLE_RETURN_FAILED is returned and `error` is set accordingly, or
         * if the socket is currently not writable %G_POLLABLE_RETURN_WOULD_BLOCK is
         * returned. `bytes_written` will contain 0 in both cases.
         * @param address a #GSocketAddress, or %NULL
         * @param vectors an array of #GOutputVector structs
         * @param messages a pointer to an   array of #GSocketControlMessages, or %NULL.
         * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param timeout_us the maximum time (in microseconds) to wait, or -1
         * @param cancellable a %GCancellable or %NULL
         * @returns %G_POLLABLE_RETURN_OK if all data was successfully written, %G_POLLABLE_RETURN_WOULD_BLOCK if the socket is currently not writable, or %G_POLLABLE_RETURN_FAILED if an error happened and @error is set.
         */
        send_message_with_timeout(
            address: SocketAddress | null,
            vectors: OutputVector[],
            messages: SocketControlMessage[] | null,
            flags: number,
            timeout_us: number,
            cancellable?: Cancellable | null,
        ): [PollableReturn, number];
        /**
         * Send multiple data messages from `socket` in one go.  This is the most
         * complicated and fully-featured version of this call. For easier use, see
         * g_socket_send(), g_socket_send_to(), and g_socket_send_message().
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from. Using multiple #GOutputVectors is
         * more memory-efficient than manually copying data from multiple sources
         * into a single buffer, and more network-efficient than making multiple
         * calls to g_socket_send(). Sending multiple messages in one go avoids the
         * overhead of making a lot of syscalls in scenarios where a lot of data
         * packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
         * or where the same data needs to be sent to multiple recipients.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * If the socket is in blocking mode the call will block until there is
         * space for all the data in the socket queue. If there is no space available
         * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
         * will be returned if no data was written at all, otherwise the number of
         * messages sent will be returned. To be notified when space is available,
         * wait for the %G_IO_OUT condition. Note though that you may still receive
         * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
         * notified of a %G_IO_OUT condition. (On Windows in particular, this is
         * very common due to the way the underlying APIs work.)
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned.
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
         * @param cancellable a %GCancellable or %NULL
         * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if the socket is     non-blocking or if @num_messages was larger than UIO_MAXIOV (1024),     in which case the caller may re-try to send the remaining messages.
         */
        send_messages(messages: OutputMessage[], flags: number, cancellable?: Cancellable | null): number;
        // Conflicted with Gio.DatagramBased.send_messages
        send_messages(...args: never[]): any;
        /**
         * Tries to send `size` bytes from `buffer` to `address`. If `address` is
         * %NULL then the message is sent to the default receiver (set by
         * g_socket_connect()).
         *
         * See g_socket_send() for additional information.
         * @param address a #GSocketAddress, or %NULL
         * @param buffer the buffer     containing the data to send.
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send_to(address: SocketAddress | null, buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * This behaves exactly the same as g_socket_send(), except that
         * the choice of blocking or non-blocking behavior is determined by
         * the `blocking` argument rather than by `socket'`s properties.
         * @param buffer the buffer     containing the data to send.
         * @param blocking whether to do blocking or non-blocking I/O
         * @param cancellable a %GCancellable or %NULL
         * @returns Number of bytes written (which may be less than @size), or -1 on error
         */
        send_with_blocking(buffer: Uint8Array | string, blocking: boolean, cancellable?: Cancellable | null): number;
        /**
         * Sets the blocking mode of the socket. In blocking mode
         * all operations (which dont take an explicit blocking parameter) block until
         * they succeed or there is an error. In
         * non-blocking mode all functions return results immediately or
         * with a %G_IO_ERROR_WOULD_BLOCK error.
         *
         * All sockets are created in blocking mode. However, note that the
         * platform level socket is always non-blocking, and blocking mode
         * is a GSocket level feature.
         * @param blocking Whether to use blocking I/O or not.
         */
        set_blocking(blocking: boolean): void;
        /**
         * Sets whether `socket` should allow sending to broadcast addresses.
         * This is %FALSE by default.
         * @param broadcast whether @socket should allow sending to broadcast     addresses
         */
        set_broadcast(broadcast: boolean): void;
        /**
         * Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
         * this flag is set on a socket, the system will attempt to verify that the
         * remote socket endpoint is still present if a sufficiently long period of
         * time passes with no data being exchanged. If the system is unable to
         * verify the presence of the remote endpoint, it will automatically close
         * the connection.
         *
         * This option is only functional on certain kinds of sockets. (Notably,
         * %G_SOCKET_PROTOCOL_TCP sockets.)
         *
         * The exact time between pings is system- and protocol-dependent, but will
         * normally be at least two hours. Most commonly, you would set this flag
         * on a server socket if you want to allow clients to remain idle for long
         * periods of time, but also want to ensure that connections are eventually
         * garbage-collected if clients crash or become unreachable.
         * @param keepalive Value for the keepalive flag
         */
        set_keepalive(keepalive: boolean): void;
        /**
         * Sets the maximum number of outstanding connections allowed
         * when listening on this socket. If more clients than this are
         * connecting to the socket and the application is not handling them
         * on time then the new connections will be refused.
         *
         * Note that this must be called before g_socket_listen() and has no
         * effect if called after that.
         * @param backlog the maximum number of pending connections.
         */
        set_listen_backlog(backlog: number): void;
        /**
         * Sets whether outgoing multicast packets will be received by sockets
         * listening on that multicast address on the same host. This is %TRUE
         * by default.
         * @param loopback whether @socket should receive messages sent to its   multicast groups from the local host
         */
        set_multicast_loopback(loopback: boolean): void;
        /**
         * Sets the time-to-live for outgoing multicast datagrams on `socket`.
         * By default, this is 1, meaning that multicast packets will not leave
         * the local network.
         * @param ttl the time-to-live value for all multicast datagrams on @socket
         */
        set_multicast_ttl(ttl: number): void;
        /**
         * Sets the value of an integer-valued option on `socket,` as with
         * setsockopt(). (If you need to set a non-integer-valued option,
         * you will need to call setsockopt() directly.)
         *
         * The [<gio/gnetworking.h>][gio-gnetworking.h]
         * header pulls in system headers that will define most of the
         * standard/portable socket options. For unusual socket protocols or
         * platform-dependent options, you may need to include additional
         * headers.
         * @param level the "API level" of the option (eg, `SOL_SOCKET`)
         * @param optname the "name" of the option (eg, `SO_BROADCAST`)
         * @param value the value to set the option to
         * @returns success or failure. On failure, @error will be set, and   the system error value (`errno` or WSAGetLastError()) will still   be set to the result of the setsockopt() call.
         */
        set_option(level: number, optname: number, value: number): boolean;
        /**
         * Sets the time in seconds after which I/O operations on `socket` will
         * time out if they have not yet completed.
         *
         * On a blocking socket, this means that any blocking #GSocket
         * operation will time out after `timeout` seconds of inactivity,
         * returning %G_IO_ERROR_TIMED_OUT.
         *
         * On a non-blocking socket, calls to g_socket_condition_wait() will
         * also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
         * created with g_socket_create_source() will trigger after
         * `timeout` seconds of inactivity, with the requested condition
         * set, at which point calling g_socket_receive(), g_socket_send(),
         * g_socket_check_connect_result(), etc, will fail with
         * %G_IO_ERROR_TIMED_OUT.
         *
         * If `timeout` is 0 (the default), operations will never time out
         * on their own.
         *
         * Note that if an I/O operation is interrupted by a signal, this may
         * cause the timeout to be reset.
         * @param timeout the timeout for @socket, in seconds, or 0 for none
         */
        set_timeout(timeout: number): void;
        /**
         * Sets the time-to-live for outgoing unicast packets on `socket`.
         * By default the platform-specific default value is used.
         * @param ttl the time-to-live value for all unicast packets on @socket
         */
        set_ttl(ttl: number): void;
        /**
         * Shut down part or all of a full-duplex connection.
         *
         * If `shutdown_read` is %TRUE then the receiving side of the connection
         * is shut down, and further reading is disallowed.
         *
         * If `shutdown_write` is %TRUE then the sending side of the connection
         * is shut down, and further writing is disallowed.
         *
         * It is allowed for both `shutdown_read` and `shutdown_write` to be %TRUE.
         *
         * One example where it is useful to shut down only one side of a connection is
         * graceful disconnect for TCP connections where you close the sending side,
         * then wait for the other side to close the connection, thus ensuring that the
         * other side saw all sent data.
         * @param shutdown_read whether to shut down the read side
         * @param shutdown_write whether to shut down the write side
         * @returns %TRUE on success, %FALSE on error
         */
        shutdown(shutdown_read: boolean, shutdown_write: boolean): boolean;
        /**
         * Checks if a socket is capable of speaking IPv4.
         *
         * IPv4 sockets are capable of speaking IPv4.  On some operating systems
         * and under some combinations of circumstances IPv6 sockets are also
         * capable of speaking IPv4.  See RFC 3493 section 3.7 for more
         * information.
         *
         * No other types of sockets are currently considered as being capable
         * of speaking IPv4.
         * @returns %TRUE if this socket can be used with IPv4.
         */
        speaks_ipv4(): boolean;

        // Inherited methods
        /**
         * Creates a #GSource that can be attached to a #GMainContext to monitor for
         * the availability of the specified `condition` on the #GDatagramBased. The
         * #GSource keeps a reference to the `datagram_based`.
         *
         * The callback on the source is of the #GDatagramBasedSourceFunc type.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be reported in the callback if they are true.
         *
         * If non-%NULL, `cancellable` can be used to cancel the source, which will
         * cause the source to trigger, reporting the current condition (which is
         * likely 0 unless cancellation happened at the same time as a condition
         * change). You can check for this in the callback using
         * g_cancellable_is_cancelled().
         * @param condition a #GIOCondition mask to monitor
         * @param cancellable a #GCancellable
         * @returns a newly allocated #GSource
         */
        create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks on the readiness of `datagram_based` to perform operations. The
         * operations specified in `condition` are checked for and masked against the
         * currently-satisfied conditions on `datagram_based`. The result is returned.
         *
         * %G_IO_IN will be set in the return value if data is available to read with
         * g_datagram_based_receive_messages(), or if the connection is closed remotely
         * (EOS); and if the datagram_based has not been closed locally using some
         * implementation-specific method (such as g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * %G_IO_OUT will be set if it is expected that at least one byte can be sent
         * using g_datagram_based_send_messages() without blocking. It will not be set
         * if the datagram_based has been closed locally.
         *
         * %G_IO_HUP will be set if the connection has been closed locally.
         *
         * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
         * previously enqueued using g_datagram_based_send_messages().
         *
         * Note that on Windows, it is possible for an operation to return
         * %G_IO_ERROR_WOULD_BLOCK even immediately after
         * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
         * ready for writing. Rather than calling g_datagram_based_condition_check() and
         * then writing to the #GDatagramBased if it succeeds, it is generally better to
         * simply try writing right away, and try again later if the initial attempt
         * returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be set in the output if they are true. Apart from
         * these flags, the output is guaranteed to be masked by `condition`.
         *
         * This call never blocks.
         * @param condition a #GIOCondition mask to check
         */
        vfunc_condition_check(condition: GLib.IOCondition): GLib.IOCondition;
        /**
         * Waits for up to `timeout` microseconds for condition to become true on
         * `datagram_based`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if `timeout` is
         * reached before the condition is met, then %FALSE is returned and `error` is
         * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
         * @param condition a #GIOCondition mask to wait for
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a #GCancellable
         */
        vfunc_condition_wait(condition: GLib.IOCondition, timeout: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a #GSource that can be attached to a #GMainContext to monitor for
         * the availability of the specified `condition` on the #GDatagramBased. The
         * #GSource keeps a reference to the `datagram_based`.
         *
         * The callback on the source is of the #GDatagramBasedSourceFunc type.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be reported in the callback if they are true.
         *
         * If non-%NULL, `cancellable` can be used to cancel the source, which will
         * cause the source to trigger, reporting the current condition (which is
         * likely 0 unless cancellation happened at the same time as a condition
         * change). You can check for this in the callback using
         * g_cancellable_is_cancelled().
         * @param condition a #GIOCondition mask to monitor
         * @param cancellable a #GCancellable
         */
        vfunc_create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
        /**
         * Receive one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to.
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
         * or an error occurs.
         *
         * If `timeout` is 0 the call will return up to `num_messages` without blocking,
         * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
         * to be received.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached
         * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
         * otherwise it will return the number of messages received before timing out.
         * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
         * recvmmsg().)
         *
         * To be notified when messages are available, wait for the %G_IO_IN condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_receive_messages() even if you were previously notified of a
         * %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * underlying receive buffer will be returned, and subsequent calls to
         * g_datagram_based_receive_messages() will return 0 (with no error set).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned. If
         * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
         * other error.
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         */
        vfunc_receive_messages(
            messages: InputMessage[],
            flags: number,
            timeout: number,
            cancellable?: Cancellable | null,
        ): number;
        /**
         * Send one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * The other members of #GOutputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * sent, `cancellable` is cancelled, or an error occurs.
         *
         * If `timeout` is 0 the call will send up to `num_messages` without blocking,
         * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached before any messages are
         * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
         * of messages sent before timing out.
         *
         * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_send_messages() even if you were previously notified of a
         * %G_IO_OUT condition. (On Windows in particular, this is very common due to
         * the way the underlying APIs work.)
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_write` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned. If `cancellable` is
         * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         */
        vfunc_send_messages(
            messages: OutputMessage[],
            flags: number,
            timeout: number,
            cancellable?: Cancellable | null,
        ): number;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module SocketAddress {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, SocketConnectable.ConstructorProps {
            family: SocketFamily;
        }
    }

    /**
     * `GSocketAddress` is the equivalent of
     * [`struct sockaddr`](man:sockaddr(3type)) and its subtypes in the BSD sockets
     * API. This is an abstract class; use [class`Gio`.InetSocketAddress] for
     * internet sockets, or [class`Gio`.UnixSocketAddress] for UNIX domain sockets.
     */
    abstract class SocketAddress extends GObject.Object implements SocketConnectable {
        static $gtype: GObject.GType<SocketAddress>;

        // Properties

        /**
         * The family of the socket address.
         */
        get family(): SocketFamily;

        // Constructors

        constructor(properties?: Partial<SocketAddress.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_from_native(_native: any, len: number): SocketAddress;

        // Virtual methods

        /**
         * Gets the socket family type of `address`.
         */
        vfunc_get_family(): SocketFamily;
        /**
         * Gets the size of `address'`s native struct sockaddr.
         * You can use this to allocate memory to pass to
         * g_socket_address_to_native().
         */
        vfunc_get_native_size(): number;
        /**
         * Converts a #GSocketAddress to a native struct sockaddr, which can
         * be passed to low-level functions like connect() or bind().
         *
         * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
         * is returned. If the address type is not known on the system
         * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
         * @param dest a pointer to a memory location that will contain the native struct sockaddr
         * @param destlen the size of @dest. Must be at least as large as     g_socket_address_get_native_size()
         */
        vfunc_to_native(dest: any | null, destlen: number): boolean;

        // Methods

        /**
         * Gets the socket family type of `address`.
         * @returns the socket family type of @address
         */
        get_family(): SocketFamily;
        /**
         * Gets the size of `address'`s native struct sockaddr.
         * You can use this to allocate memory to pass to
         * g_socket_address_to_native().
         * @returns the size of the native struct sockaddr that     @address represents
         */
        get_native_size(): number;
        /**
         * Converts a #GSocketAddress to a native struct sockaddr, which can
         * be passed to low-level functions like connect() or bind().
         *
         * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
         * is returned. If the address type is not known on the system
         * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
         * @param dest a pointer to a memory location that will contain the native struct sockaddr
         * @param destlen the size of @dest. Must be at least as large as     g_socket_address_get_native_size()
         * @returns %TRUE if @dest was filled in, %FALSE on error
         */
        to_native(dest: any | null, destlen: number): boolean;

        // Inherited methods
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         */
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module SocketAddressEnumerator {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GSocketAddressEnumerator` is an enumerator type for
     * [class`Gio`.SocketAddress] instances. It is returned by enumeration functions
     * such as [method`Gio`.SocketConnectable.enumerate], which returns a
     * `GSocketAddressEnumerator` to list each [class`Gio`.SocketAddress] which could
     * be used to connect to that [iface`Gio`.SocketConnectable].
     *
     * Enumeration is typically a blocking operation, so the asynchronous methods
     * [method`Gio`.SocketAddressEnumerator.next_async] and
     * [method`Gio`.SocketAddressEnumerator.next_finish] should be used where
     * possible.
     *
     * Each `GSocketAddressEnumerator` can only be enumerated once. Once
     * [method`Gio`.SocketAddressEnumerator.next] has returned `NULL`, further
     * enumeration with that `GSocketAddressEnumerator` is not possible, and it can
     * be unreffed.
     */
    abstract class SocketAddressEnumerator extends GObject.Object {
        static $gtype: GObject.GType<SocketAddressEnumerator>;

        // Constructors

        constructor(properties?: Partial<SocketAddressEnumerator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Retrieves the next #GSocketAddress from `enumerator`. Note that this
         * may block for some amount of time. (Eg, a #GNetworkAddress may need
         * to do a DNS lookup before it can return an address.) Use
         * g_socket_address_enumerator_next_async() if you need to avoid
         * blocking.
         *
         * If `enumerator` is expected to yield addresses, but for some reason
         * is unable to (eg, because of a DNS error), then the first call to
         * g_socket_address_enumerator_next() will return an appropriate error
         * in *`error`. However, if the first call to
         * g_socket_address_enumerator_next() succeeds, then any further
         * internal errors (other than `cancellable` being triggered) will be
         * ignored.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_next(cancellable?: Cancellable | null): SocketAddress | null;
        /**
         * Asynchronously retrieves the next #GSocketAddress from `enumerator`
         * and then calls `callback,` which must call
         * g_socket_address_enumerator_next_finish() to get the result.
         *
         * It is an error to call this multiple times before the previous callback has finished.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_next_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Retrieves the result of a completed call to
         * g_socket_address_enumerator_next_async(). See
         * g_socket_address_enumerator_next() for more information about
         * error handling.
         * @param result a #GAsyncResult
         */
        vfunc_next_finish(result: AsyncResult): SocketAddress | null;

        // Methods

        /**
         * Retrieves the next #GSocketAddress from `enumerator`. Note that this
         * may block for some amount of time. (Eg, a #GNetworkAddress may need
         * to do a DNS lookup before it can return an address.) Use
         * g_socket_address_enumerator_next_async() if you need to avoid
         * blocking.
         *
         * If `enumerator` is expected to yield addresses, but for some reason
         * is unable to (eg, because of a DNS error), then the first call to
         * g_socket_address_enumerator_next() will return an appropriate error
         * in *`error`. However, if the first call to
         * g_socket_address_enumerator_next() succeeds, then any further
         * internal errors (other than `cancellable` being triggered) will be
         * ignored.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
         */
        next(cancellable?: Cancellable | null): SocketAddress | null;
        /**
         * Asynchronously retrieves the next #GSocketAddress from `enumerator`
         * and then calls `callback,` which must call
         * g_socket_address_enumerator_next_finish() to get the result.
         *
         * It is an error to call this multiple times before the previous callback has finished.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        next_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Retrieves the result of a completed call to
         * g_socket_address_enumerator_next_async(). See
         * g_socket_address_enumerator_next() for more information about
         * error handling.
         * @param result a #GAsyncResult
         * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
         */
        next_finish(result: AsyncResult): SocketAddress | null;
    }

    module SocketClient {
        // Signal callback interfaces

        interface Event {
            (event: SocketClientEvent, connectable: SocketConnectable, connection?: IOStream | null): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            enable_proxy: boolean;
            enableProxy: boolean;
            family: SocketFamily;
            local_address: SocketAddress;
            localAddress: SocketAddress;
            protocol: SocketProtocol;
            proxy_resolver: ProxyResolver;
            proxyResolver: ProxyResolver;
            timeout: number;
            tls: boolean;
            tls_validation_flags: TlsCertificateFlags;
            tlsValidationFlags: TlsCertificateFlags;
            type: SocketType;
        }
    }

    /**
     * `GSocketClient` is a lightweight high-level utility class for connecting to
     * a network host using a connection oriented socket type.
     *
     * You create a `GSocketClient` object, set any options you want, and then
     * call a sync or async connect operation, which returns a
     * [class`Gio`.SocketConnection] subclass on success.
     *
     * The type of the [class`Gio`.SocketConnection] object returned depends on the
     * type of the underlying socket that is in use. For instance, for a TCP/IP
     * connection it will be a [class`Gio`.TcpConnection].
     *
     * As `GSocketClient` is a lightweight object, you don't need to cache it. You
     * can just create a new one any time you need one.
     */
    class SocketClient extends GObject.Object {
        static $gtype: GObject.GType<SocketClient>;

        // Properties

        /**
         * Enable proxy support.
         */
        get enable_proxy(): boolean;
        set enable_proxy(val: boolean);
        /**
         * Enable proxy support.
         */
        get enableProxy(): boolean;
        set enableProxy(val: boolean);
        /**
         * The address family to use for socket construction.
         */
        get family(): SocketFamily;
        set family(val: SocketFamily);
        /**
         * The local address constructed sockets will be bound to.
         */
        get local_address(): SocketAddress;
        set local_address(val: SocketAddress);
        /**
         * The local address constructed sockets will be bound to.
         */
        get localAddress(): SocketAddress;
        set localAddress(val: SocketAddress);
        /**
         * The protocol to use for socket construction, or `0` for default.
         */
        get protocol(): SocketProtocol;
        set protocol(val: SocketProtocol);
        /**
         * The proxy resolver to use
         */
        get proxy_resolver(): ProxyResolver;
        set proxy_resolver(val: ProxyResolver);
        /**
         * The proxy resolver to use
         */
        get proxyResolver(): ProxyResolver;
        set proxyResolver(val: ProxyResolver);
        /**
         * The I/O timeout for sockets, in seconds, or `0` for none.
         */
        get timeout(): number;
        set timeout(val: number);
        /**
         * Whether to create TLS connections.
         */
        get tls(): boolean;
        set tls(val: boolean);
        /**
         * The TLS validation flags used when creating TLS connections. The
         * default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to the #GSocketClient::event signal, wait for it to be
         * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
         * connect to #GTlsConnection::accept-certificate.
         */
        get tls_validation_flags(): TlsCertificateFlags;
        set tls_validation_flags(val: TlsCertificateFlags);
        /**
         * The TLS validation flags used when creating TLS connections. The
         * default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to the #GSocketClient::event signal, wait for it to be
         * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
         * connect to #GTlsConnection::accept-certificate.
         */
        get tlsValidationFlags(): TlsCertificateFlags;
        set tlsValidationFlags(val: TlsCertificateFlags);
        /**
         * The type to use for socket construction.
         */
        get type(): SocketType;
        set type(val: SocketType);

        // Constructors

        constructor(properties?: Partial<SocketClient.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): SocketClient;

        // Signals

        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect_after(
            signal: 'event',
            callback: (
                _source: this,
                event: SocketClientEvent,
                connectable: SocketConnectable,
                connection: IOStream | null,
            ) => void,
        ): number;
        emit(
            signal: 'event',
            event: SocketClientEvent,
            connectable: SocketConnectable,
            connection?: IOStream | null,
        ): void;

        // Virtual methods

        vfunc_event(event: SocketClientEvent, connectable: SocketConnectable, connection: IOStream): void;

        // Methods

        /**
         * Enable proxy protocols to be handled by the application. When the
         * indicated proxy protocol is returned by the #GProxyResolver,
         * #GSocketClient will consider this protocol as supported but will
         * not try to find a #GProxy instance to handle handshaking. The
         * application must check for this case by calling
         * g_socket_connection_get_remote_address() on the returned
         * #GSocketConnection, and seeing if it's a #GProxyAddress of the
         * appropriate type, to determine whether or not it needs to handle
         * the proxy handshaking itself.
         *
         * This should be used for proxy protocols that are dialects of
         * another protocol such as HTTP proxy. It also allows cohabitation of
         * proxy protocols that are reused between protocols. A good example
         * is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
         * be use as generic socket proxy through the HTTP CONNECT method.
         *
         * When the proxy is detected as being an application proxy, TLS handshake
         * will be skipped. This is required to let the application do the proxy
         * specific handshake.
         * @param protocol The proxy protocol
         */
        add_application_proxy(protocol: string): void;
        /**
         * Tries to resolve the `connectable` and make a network connection to it.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * The type of the #GSocketConnection object returned depends on the type of
         * the underlying socket that is used. For instance, for a TCP/IP connection
         * it will be a #GTcpConnection.
         *
         * The socket created will be the same family as the address that the
         * `connectable` resolves to, unless family is set with g_socket_client_set_family()
         * or indirectly via g_socket_client_set_local_address(). The socket type
         * defaults to %G_SOCKET_TYPE_STREAM but can be set with
         * g_socket_client_set_socket_type().
         *
         * If a local address is specified with g_socket_client_set_local_address() the
         * socket will be bound to this address before connecting.
         * @param connectable a #GSocketConnectable specifying the remote address.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect(connectable: SocketConnectable, cancellable?: Cancellable | null): SocketConnection;
        connect(...args: never[]): any;
        /**
         * This is the asynchronous version of g_socket_client_connect().
         *
         * You may wish to prefer the asynchronous version even in synchronous
         * command line programs because, since 2.60, it implements
         * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
         * recommendations to work around long connection timeouts in networks
         * where IPv6 is broken by performing an IPv4 connection simultaneously
         * without waiting for IPv6 to time out, which is not supported by the
         * synchronous call. (This is not an API guarantee, and may change in
         * the future.)
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_finish() to get
         * the result of the operation.
         * @param connectable a #GSocketConnectable specifying the remote address.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_async(
            connectable: SocketConnectable,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_finish(result: AsyncResult): SocketConnection;
        /**
         * This is a helper function for g_socket_client_connect().
         *
         * Attempts to create a TCP connection to the named host.
         *
         * `host_and_port` may be in any of a number of recognized formats; an IPv6
         * address, an IPv4 address, or a domain name (in which case a DNS
         * lookup is performed).  Quoting with [] is supported for all address
         * types.  A port override may be specified in the usual way with a
         * colon.  Ports may be given as decimal numbers or symbolic names (in
         * which case an /etc/services lookup is performed).
         *
         * If no port override is given in `host_and_port` then `default_port` will be
         * used as the port number to connect to.
         *
         * In general, `host_and_port` is expected to be provided by the user (allowing
         * them to give the hostname, and a port override if necessary) and
         * `default_port` is expected to be provided by the application.
         *
         * In the case that an IP address is given, a single connection
         * attempt is made.  In the case that a name is given, multiple
         * connection attempts may be made, in turn and according to the
         * number of address records in DNS, until a connection succeeds.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * In the event of any failure (DNS error, service not found, no hosts
         * connectable) %NULL is returned and `error` (if non-%NULL) is set
         * accordingly.
         * @param host_and_port the name and optionally port of the host to connect to
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_host(
            host_and_port: string,
            default_port: number,
            cancellable?: Cancellable | null,
        ): SocketConnection;
        /**
         * This is the asynchronous version of g_socket_client_connect_to_host().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_to_host_finish() to get
         * the result of the operation.
         * @param host_and_port the name and optionally the port of the host to connect to
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_to_host_async(
            host_and_port: string,
            default_port: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_to_host_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_host_finish(result: AsyncResult): SocketConnection;
        /**
         * Attempts to create a TCP connection to a service.
         *
         * This call looks up the SRV record for `service` at `domain` for the
         * "tcp" protocol.  It then attempts to connect, in turn, to each of
         * the hosts providing the service until either a connection succeeds
         * or there are no hosts remaining.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * In the event of any failure (DNS error, service not found, no hosts
         * connectable) %NULL is returned and `error` (if non-%NULL) is set
         * accordingly.
         * @param domain a domain name
         * @param service the name of the service to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns a #GSocketConnection if successful, or %NULL on error
         */
        connect_to_service(domain: string, service: string, cancellable?: Cancellable | null): SocketConnection;
        /**
         * This is the asynchronous version of
         * g_socket_client_connect_to_service().
         * @param domain a domain name
         * @param service the name of the service to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_to_service_async(
            domain: string,
            service: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_to_service_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_service_finish(result: AsyncResult): SocketConnection;
        /**
         * This is a helper function for g_socket_client_connect().
         *
         * Attempts to create a TCP connection with a network URI.
         *
         * `uri` may be any valid URI containing an "authority" (hostname/port)
         * component. If a port is not specified in the URI, `default_port`
         * will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
         * (#GSocketClient does not know to automatically assume TLS for
         * certain URI schemes.)
         *
         * Using this rather than g_socket_client_connect() or
         * g_socket_client_connect_to_host() allows #GSocketClient to
         * determine when to use application-specific proxy protocols.
         *
         * Upon a successful connection, a new #GSocketConnection is constructed
         * and returned.  The caller owns this new object and must drop their
         * reference to it when finished with it.
         *
         * In the event of any failure (DNS error, service not found, no hosts
         * connectable) %NULL is returned and `error` (if non-%NULL) is set
         * accordingly.
         * @param uri A network URI
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_uri(uri: string, default_port: number, cancellable?: Cancellable | null): SocketConnection;
        /**
         * This is the asynchronous version of g_socket_client_connect_to_uri().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_client_connect_to_uri_finish() to get
         * the result of the operation.
         * @param uri a network uri
         * @param default_port the default port to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_to_uri_async(
            uri: string,
            default_port: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async connect operation. See g_socket_client_connect_to_uri_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        connect_to_uri_finish(result: AsyncResult): SocketConnection;
        /**
         * Gets the proxy enable state; see g_socket_client_set_enable_proxy()
         * @returns whether proxying is enabled
         */
        get_enable_proxy(): boolean;
        /**
         * Gets the socket family of the socket client.
         *
         * See g_socket_client_set_family() for details.
         * @returns a #GSocketFamily
         */
        get_family(): SocketFamily;
        /**
         * Gets the local address of the socket client.
         *
         * See g_socket_client_set_local_address() for details.
         * @returns a #GSocketAddress or %NULL. Do not free.
         */
        get_local_address(): SocketAddress | null;
        /**
         * Gets the protocol name type of the socket client.
         *
         * See g_socket_client_set_protocol() for details.
         * @returns a #GSocketProtocol
         */
        get_protocol(): SocketProtocol;
        /**
         * Gets the #GProxyResolver being used by `client`. Normally, this will
         * be the resolver returned by g_proxy_resolver_get_default(), but you
         * can override it with g_socket_client_set_proxy_resolver().
         * @returns The #GProxyResolver being used by   @client.
         */
        get_proxy_resolver(): ProxyResolver;
        /**
         * Gets the socket type of the socket client.
         *
         * See g_socket_client_set_socket_type() for details.
         * @returns a #GSocketFamily
         */
        get_socket_type(): SocketType;
        /**
         * Gets the I/O timeout time for sockets created by `client`.
         *
         * See g_socket_client_set_timeout() for details.
         * @returns the timeout in seconds
         */
        get_timeout(): number;
        /**
         * Gets whether `client` creates TLS connections. See
         * g_socket_client_set_tls() for details.
         * @returns whether @client uses TLS
         */
        get_tls(): boolean;
        /**
         * Gets the TLS validation flags used creating TLS connections via
         * `client`.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GSocketClient:tls-validation-flags for more
         * information.
         * @returns the TLS validation flags
         */
        get_tls_validation_flags(): TlsCertificateFlags;
        /**
         * Sets whether or not `client` attempts to make connections via a
         * proxy server. When enabled (the default), #GSocketClient will use a
         * #GProxyResolver to determine if a proxy protocol such as SOCKS is
         * needed, and automatically do the necessary proxy negotiation.
         *
         * See also g_socket_client_set_proxy_resolver().
         * @param enable whether to enable proxies
         */
        set_enable_proxy(enable: boolean): void;
        /**
         * Sets the socket family of the socket client.
         * If this is set to something other than %G_SOCKET_FAMILY_INVALID
         * then the sockets created by this object will be of the specified
         * family.
         *
         * This might be useful for instance if you want to force the local
         * connection to be an ipv4 socket, even though the address might
         * be an ipv6 mapped to ipv4 address.
         * @param family a #GSocketFamily
         */
        set_family(family: SocketFamily): void;
        /**
         * Sets the local address of the socket client.
         * The sockets created by this object will bound to the
         * specified address (if not %NULL) before connecting.
         *
         * This is useful if you want to ensure that the local
         * side of the connection is on a specific port, or on
         * a specific interface.
         * @param address a #GSocketAddress, or %NULL
         */
        set_local_address(address?: SocketAddress | null): void;
        /**
         * Sets the protocol of the socket client.
         * The sockets created by this object will use of the specified
         * protocol.
         *
         * If `protocol` is %G_SOCKET_PROTOCOL_DEFAULT that means to use the default
         * protocol for the socket family and type.
         * @param protocol a #GSocketProtocol
         */
        set_protocol(protocol: SocketProtocol): void;
        /**
         * Overrides the #GProxyResolver used by `client`. You can call this if
         * you want to use specific proxies, rather than using the system
         * default proxy settings.
         *
         * Note that whether or not the proxy resolver is actually used
         * depends on the setting of #GSocketClient:enable-proxy, which is not
         * changed by this function (but which is %TRUE by default)
         * @param proxy_resolver a #GProxyResolver, or %NULL for the   default.
         */
        set_proxy_resolver(proxy_resolver?: ProxyResolver | null): void;
        /**
         * Sets the socket type of the socket client.
         * The sockets created by this object will be of the specified
         * type.
         *
         * It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
         * as GSocketClient is used for connection oriented services.
         * @param type a #GSocketType
         */
        set_socket_type(type: SocketType): void;
        /**
         * Sets the I/O timeout for sockets created by `client`. `timeout` is a
         * time in seconds, or 0 for no timeout (the default).
         *
         * The timeout value affects the initial connection attempt as well,
         * so setting this may cause calls to g_socket_client_connect(), etc,
         * to fail with %G_IO_ERROR_TIMED_OUT.
         * @param timeout the timeout
         */
        set_timeout(timeout: number): void;
        /**
         * Sets whether `client` creates TLS (aka SSL) connections. If `tls` is
         * %TRUE, `client` will wrap its connections in a #GTlsClientConnection
         * and perform a TLS handshake when connecting.
         *
         * Note that since #GSocketClient must return a #GSocketConnection,
         * but #GTlsClientConnection is not a #GSocketConnection, this
         * actually wraps the resulting #GTlsClientConnection in a
         * #GTcpWrapperConnection when returning it. You can use
         * g_tcp_wrapper_connection_get_base_io_stream() on the return value
         * to extract the #GTlsClientConnection.
         *
         * If you need to modify the behavior of the TLS handshake (eg, by
         * setting a client-side certificate to use, or connecting to the
         * #GTlsConnection::accept-certificate signal), you can connect to
         * `client'`s #GSocketClient::event signal and wait for it to be
         * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
         * a chance to see the #GTlsClientConnection before the handshake
         * starts.
         * @param tls whether to use TLS
         */
        set_tls(tls: boolean): void;
        /**
         * Sets the TLS validation flags used when creating TLS connections
         * via `client`. The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GSocketClient:tls-validation-flags for more
         * information.
         * @param flags the validation flags
         */
        set_tls_validation_flags(flags: TlsCertificateFlags): void;
    }

    module SocketConnection {
        // Constructor properties interface

        interface ConstructorProps extends IOStream.ConstructorProps {
            socket: Socket;
        }
    }

    /**
     * `GSocketConnection` is a [class`Gio`.IOStream] for a connected socket. They
     * can be created either by [class`Gio`.SocketClient] when connecting to a host,
     * or by [class`Gio`.SocketListener] when accepting a new client.
     *
     * The type of the `GSocketConnection` object returned from these calls
     * depends on the type of the underlying socket that is in use. For
     * instance, for a TCP/IP connection it will be a [class`Gio`.TcpConnection].
     *
     * Choosing what type of object to construct is done with the socket
     * connection factory, and it is possible for third parties to register
     * custom socket connection types for specific combination of socket
     * family/type/protocol using [func`Gio`.SocketConnection.factory_register_type].
     *
     * To close a `GSocketConnection`, use [method`Gio`.IOStream.close]. Closing both
     * substreams of the [class`Gio`.IOStream] separately will not close the
     * underlying [class`Gio`.Socket].
     */
    class SocketConnection extends IOStream {
        static $gtype: GObject.GType<SocketConnection>;

        // Properties

        /**
         * The underlying [class`Gio`.Socket].
         */
        get socket(): Socket;

        // Constructors

        constructor(properties?: Partial<SocketConnection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Looks up the #GType to be used when creating socket connections on
         * sockets with the specified `family,` `type` and `protocol_id`.
         *
         * If no type is registered, the #GSocketConnection base type is returned.
         * @param family a #GSocketFamily
         * @param type a #GSocketType
         * @param protocol_id a protocol id
         */
        static factory_lookup_type(family: SocketFamily, type: SocketType, protocol_id: number): GObject.GType;
        /**
         * Looks up the #GType to be used when creating socket connections on
         * sockets with the specified `family,` `type` and `protocol`.
         *
         * If no type is registered, the #GSocketConnection base type is returned.
         * @param g_type a #GType, inheriting from %G_TYPE_SOCKET_CONNECTION
         * @param family a #GSocketFamily
         * @param type a #GSocketType
         * @param protocol a protocol id
         */
        static factory_register_type(
            g_type: GObject.GType,
            family: SocketFamily,
            type: SocketType,
            protocol: number,
        ): void;

        // Methods

        /**
         * Connect `connection` to the specified remote address.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect(address: SocketAddress, cancellable?: Cancellable | null): boolean;
        connect(...args: never[]): any;
        /**
         * Asynchronously connect `connection` to the specified remote address.
         *
         * This clears the #GSocket:blocking flag on `connection'`s underlying
         * socket if it is currently set.
         *
         * If #GSocket:timeout is set, the operation will time out and return
         * %G_IO_ERROR_TIMED_OUT after that period. Otherwise, it will continue
         * indefinitely until operating system timeouts (if any) are hit.
         *
         * Use g_socket_connection_connect_finish() to retrieve the result.
         * @param address a #GSocketAddress specifying the remote address.
         * @param cancellable a %GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        connect_async(
            address: SocketAddress,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Gets the result of a g_socket_connection_connect_async() call.
         * @param result the #GAsyncResult
         * @returns %TRUE if the connection succeeded, %FALSE on error
         */
        connect_finish(result: AsyncResult): boolean;
        /**
         * Try to get the local address of a socket connection.
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_local_address(): SocketAddress;
        /**
         * Try to get the remote address of a socket connection.
         *
         * Since GLib 2.40, when used with g_socket_client_connect() or
         * g_socket_client_connect_async(), during emission of
         * %G_SOCKET_CLIENT_CONNECTING, this function will return the remote
         * address that will be used for the connection.  This allows
         * applications to print e.g. "Connecting to example.com
         * (10.42.77.3)...".
         * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
         */
        get_remote_address(): SocketAddress;
        /**
         * Gets the underlying #GSocket object of the connection.
         * This can be useful if you want to do something unusual on it
         * not supported by the #GSocketConnection APIs.
         * @returns a #GSocket or %NULL on error.
         */
        get_socket(): Socket;
        /**
         * Checks if `connection` is connected. This is equivalent to calling
         * g_socket_is_connected() on `connection'`s underlying #GSocket.
         * @returns whether @connection is connected
         */
        is_connected(): boolean;
    }

    module SocketControlMessage {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * A `GSocketControlMessage` is a special-purpose utility message that
     * can be sent to or received from a [class`Gio`.Socket]. These types of
     * messages are often called ancillary data.
     *
     * The message can represent some sort of special instruction to or
     * information from the socket or can represent a special kind of
     * transfer to the peer (for example, sending a file descriptor over
     * a UNIX socket).
     *
     * These messages are sent with [method`Gio`.Socket.send_message] and received
     * with [method`Gio`.Socket.receive_message].
     *
     * To extend the set of control message that can be sent, subclass this
     * class and override the `get_size`, `get_level`, `get_type` and `serialize`
     * methods.
     *
     * To extend the set of control messages that can be received, subclass
     * this class and implement the `deserialize` method. Also, make sure your
     * class is registered with the [type`GObject`.Type] type system before calling
     * [method`Gio`.Socket.receive_message] to read such a message.
     */
    abstract class SocketControlMessage extends GObject.Object {
        static $gtype: GObject.GType<SocketControlMessage>;

        // Constructors

        constructor(properties?: Partial<SocketControlMessage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Tries to deserialize a socket control message of a given
         * `level` and `type`. This will ask all known (to GType) subclasses
         * of #GSocketControlMessage if they can understand this kind
         * of message and if so deserialize it into a #GSocketControlMessage.
         *
         * If there is no implementation for this kind of control message, %NULL
         * will be returned.
         * @param level a socket level
         * @param type a socket control message type for the given @level
         * @param data pointer to the message data
         */
        static deserialize(level: number, type: number, data: Uint8Array | string): SocketControlMessage | null;

        // Virtual methods

        /**
         * Returns the "level" (i.e. the originating protocol) of the control message.
         * This is often SOL_SOCKET.
         */
        vfunc_get_level(): number;
        /**
         * Returns the space required for the control message, not including
         * headers or alignment.
         */
        vfunc_get_size(): number;
        /**
         * gets the protocol specific type of the message.
         */
        vfunc_get_type(): number;
        /**
         * Converts the data in the message to bytes placed in the
         * message.
         *
         * `data` is guaranteed to have enough space to fit the size
         * returned by g_socket_control_message_get_size() on this
         * object.
         * @param data A buffer to write data to
         */
        vfunc_serialize(data: any): void;

        // Methods

        /**
         * Returns the "level" (i.e. the originating protocol) of the control message.
         * This is often SOL_SOCKET.
         * @returns an integer describing the level
         */
        get_level(): number;
        /**
         * Returns the protocol specific type of the control message.
         * For instance, for UNIX fd passing this would be SCM_RIGHTS.
         * @returns an integer describing the type of control message
         */
        get_msg_type(): number;
        /**
         * Returns the space required for the control message, not including
         * headers or alignment.
         * @returns The number of bytes required.
         */
        get_size(): number;
        /**
         * Converts the data in the message to bytes placed in the
         * message.
         *
         * `data` is guaranteed to have enough space to fit the size
         * returned by g_socket_control_message_get_size() on this
         * object.
         * @param data A buffer to write data to
         */
        serialize(data: any): void;
    }

    module SocketListener {
        // Signal callback interfaces

        interface Event {
            (event: SocketListenerEvent, socket: Socket): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            listen_backlog: number;
            listenBacklog: number;
        }
    }

    /**
     * A `GSocketListener` is an object that keeps track of a set
     * of server sockets and helps you accept sockets from any of the
     * socket, either sync or async.
     *
     * Add addresses and ports to listen on using
     * [method`Gio`.SocketListener.add_address] and
     * [method`Gio`.SocketListener.add_inet_port]. These will be listened on until
     * [method`Gio`.SocketListener.close] is called. Dropping your final reference to
     * the `GSocketListener` will not cause [method`Gio`.SocketListener.close] to be
     * called implicitly, as some references to the `GSocketListener` may be held
     * internally.
     *
     * If you want to implement a network server, also look at
     * [class`Gio`.SocketService] and [class`Gio`.ThreadedSocketService] which are
     * subclasses of `GSocketListener` that make this even easier.
     */
    class SocketListener extends GObject.Object {
        static $gtype: GObject.GType<SocketListener>;

        // Properties

        /**
         * The number of outstanding connections in the listen queue.
         */
        get listen_backlog(): number;
        set listen_backlog(val: number);
        /**
         * The number of outstanding connections in the listen queue.
         */
        get listenBacklog(): number;
        set listenBacklog(val: number);

        // Constructors

        constructor(properties?: Partial<SocketListener.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): SocketListener;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'event', callback: (_source: this, event: SocketListenerEvent, socket: Socket) => void): number;
        connect_after(
            signal: 'event',
            callback: (_source: this, event: SocketListenerEvent, socket: Socket) => void,
        ): number;
        emit(signal: 'event', event: SocketListenerEvent, socket: Socket): void;

        // Virtual methods

        /**
         * virtual method called when the set of socket listened to changes
         */
        vfunc_changed(): void;
        vfunc_event(event: SocketListenerEvent, socket: Socket): void;

        // Methods

        /**
         * Blocks waiting for a client to connect to any of the sockets added
         * to the listener. Returns a #GSocketConnection for the socket that was
         * accepted.
         *
         * If `source_object` is not %NULL it will be filled out with the source
         * object specified when the corresponding socket or address was added
         * to the listener.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        accept(cancellable?: Cancellable | null): [SocketConnection, GObject.Object | null];
        /**
         * This is the asynchronous version of g_socket_listener_accept().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_listener_accept_finish()
         * to get the result of the operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        accept_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an async accept operation. See g_socket_listener_accept_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocketConnection on success, %NULL on error.
         */
        accept_finish(result: AsyncResult): [SocketConnection, GObject.Object | null];
        /**
         * Blocks waiting for a client to connect to any of the sockets added
         * to the listener. Returns the #GSocket that was accepted.
         *
         * If you want to accept the high-level #GSocketConnection, not a #GSocket,
         * which is often the case, then you should use g_socket_listener_accept()
         * instead.
         *
         * If `source_object` is not %NULL it will be filled out with the source
         * object specified when the corresponding socket or address was added
         * to the listener.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GSocket on success, %NULL on error.
         */
        accept_socket(cancellable?: Cancellable | null): [Socket, GObject.Object | null];
        /**
         * This is the asynchronous version of g_socket_listener_accept_socket().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_socket_listener_accept_socket_finish()
         * to get the result of the operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback
         */
        accept_socket_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an async accept operation. See g_socket_listener_accept_socket_async()
         * @param result a #GAsyncResult.
         * @returns a #GSocket on success, %NULL on error.
         */
        accept_socket_finish(result: AsyncResult): [Socket, GObject.Object | null];
        /**
         * Creates a socket of type `type` and protocol `protocol,` binds
         * it to `address` and adds it to the set of sockets we're accepting
         * sockets from.
         *
         * Note that adding an IPv6 address, depending on the platform,
         * may or may not result in a listener that also accepts IPv4
         * connections.  For more deterministic behavior, see
         * g_socket_listener_add_inet_port().
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         *
         * If successful and `effective_address` is non-%NULL then it will
         * be set to the address that the binding actually occurred at.  This
         * is helpful for determining the port number that was used for when
         * requesting a binding to port 0 (ie: "any port").  This address, if
         * requested, belongs to the caller and must be freed.
         *
         * Call g_socket_listener_close() to stop listening on `address;` this will not
         * be done automatically when you drop your final reference to `listener,` as
         * references may be held internally.
         * @param address a #GSocketAddress
         * @param type a #GSocketType
         * @param protocol a #GSocketProtocol
         * @param source_object Optional #GObject identifying this source
         * @returns %TRUE on success, %FALSE on error.
         */
        add_address(
            address: SocketAddress,
            type: SocketType,
            protocol: SocketProtocol,
            source_object?: GObject.Object | null,
        ): [boolean, SocketAddress | null];
        /**
         * Listens for TCP connections on any available port number for both
         * IPv6 and IPv4 (if each is available).
         *
         * This is useful if you need to have a socket for incoming connections
         * but don't care about the specific port number.
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         * @param source_object Optional #GObject identifying this source
         * @returns the port number, or 0 in case of failure.
         */
        add_any_inet_port(source_object?: GObject.Object | null): number;
        /**
         * Helper function for g_socket_listener_add_address() that
         * creates a TCP/IP socket listening on IPv4 and IPv6 (if
         * supported) on the specified port on all interfaces.
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         *
         * Call g_socket_listener_close() to stop listening on `port;` this will not
         * be done automatically when you drop your final reference to `listener,` as
         * references may be held internally.
         * @param port an IP port number (non-zero)
         * @param source_object Optional #GObject identifying this source
         * @returns %TRUE on success, %FALSE on error.
         */
        add_inet_port(port: number, source_object?: GObject.Object | null): boolean;
        /**
         * Adds `socket` to the set of sockets that we try to accept
         * new clients from. The socket must be bound to a local
         * address and listened to.
         *
         * `source_object` will be passed out in the various calls
         * to accept to identify this particular source, which is
         * useful if you're listening on multiple addresses and do
         * different things depending on what address is connected to.
         *
         * The `socket` will not be automatically closed when the `listener` is finalized
         * unless the listener held the final reference to the socket. Before GLib 2.42,
         * the `socket` was automatically closed on finalization of the `listener,` even
         * if references to it were held elsewhere.
         * @param socket a listening #GSocket
         * @param source_object Optional #GObject identifying this source
         * @returns %TRUE on success, %FALSE on error.
         */
        add_socket(socket: Socket, source_object?: GObject.Object | null): boolean;
        /**
         * Closes all the sockets in the listener.
         */
        close(): void;
        /**
         * Sets the listen backlog on the sockets in the listener. This must be called
         * before adding any sockets, addresses or ports to the #GSocketListener (for
         * example, by calling g_socket_listener_add_inet_port()) to be effective.
         *
         * See g_socket_set_listen_backlog() for details
         * @param listen_backlog an integer
         */
        set_backlog(listen_backlog: number): void;
    }

    module SocketService {
        // Signal callback interfaces

        interface Incoming {
            (connection: SocketConnection, source_object?: GObject.Object | null): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends SocketListener.ConstructorProps {
            active: boolean;
        }
    }

    /**
     * A `GSocketService` is an object that represents a service that
     * is provided to the network or over local sockets.  When a new
     * connection is made to the service the [signal`Gio`.SocketService::incoming]
     * signal is emitted.
     *
     * A `GSocketService` is a subclass of [class`Gio`.SocketListener] and you need
     * to add the addresses you want to accept connections on with the
     * [class`Gio`.SocketListener] APIs.
     *
     * There are two options for implementing a network service based on
     * `GSocketService`. The first is to create the service using
     * [ctor`Gio`.SocketService.new] and to connect to the
     * [signal`Gio`.SocketService::incoming] signal. The second is to subclass
     * `GSocketService` and override the default signal handler implementation.
     *
     * In either case, the handler must immediately return, or else it
     * will block additional incoming connections from being serviced.
     * If you are interested in writing connection handlers that contain
     * blocking code then see [class`Gio`.ThreadedSocketService].
     *
     * The socket service runs on the main loop of the
     * thread-default context (see
     * [method`GLib`.MainContext.push_thread_default]) of the thread it is
     * created in, and is not threadsafe in general. However, the calls to start and
     * stop the service are thread-safe so these can be used from threads that
     * handle incoming clients.
     */
    class SocketService extends SocketListener {
        static $gtype: GObject.GType<SocketService>;

        // Properties

        /**
         * Whether the service is currently accepting connections.
         */
        get active(): boolean;
        set active(val: boolean);

        // Constructors

        constructor(properties?: Partial<SocketService.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): SocketService;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'incoming',
            callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean,
        ): number;
        connect_after(
            signal: 'incoming',
            callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean,
        ): number;
        emit(signal: 'incoming', connection: SocketConnection, source_object?: GObject.Object | null): void;

        // Virtual methods

        /**
         * signal emitted when new connections are accepted
         * @param connection
         * @param source_object
         */
        vfunc_incoming(connection: SocketConnection, source_object: GObject.Object): boolean;

        // Methods

        /**
         * Check whether the service is active or not. An active
         * service will accept new clients that connect, while
         * a non-active service will let connecting clients queue
         * up until the service is started.
         * @returns %TRUE if the service is active, %FALSE otherwise
         */
        is_active(): boolean;
        /**
         * Restarts the service, i.e. start accepting connections
         * from the added sockets when the mainloop runs. This only needs
         * to be called after the service has been stopped from
         * g_socket_service_stop().
         *
         * This call is thread-safe, so it may be called from a thread
         * handling an incoming client request.
         */
        start(): void;
        /**
         * Stops the service, i.e. stops accepting connections
         * from the added sockets when the mainloop runs.
         *
         * This call is thread-safe, so it may be called from a thread
         * handling an incoming client request.
         *
         * Note that this only stops accepting new connections; it does not
         * close the listening sockets, and you can call
         * g_socket_service_start() again later to begin listening again. To
         * close the listening sockets, call g_socket_listener_close(). (This
         * will happen automatically when the #GSocketService is finalized.)
         *
         * This must be called before calling g_socket_listener_close() as
         * the socket service will start accepting connections immediately
         * when a new socket is added.
         */
        stop(): void;
    }

    module Subprocess {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Initable.ConstructorProps {
            argv: string[];
            flags: SubprocessFlags;
        }
    }

    /**
     * `GSubprocess` allows the creation of and interaction with child
     * processes.
     *
     * Processes can be communicated with using standard GIO-style APIs (ie:
     * [class`Gio`.InputStream], [class`Gio`.OutputStream]). There are GIO-style APIs
     * to wait for process termination (ie: cancellable and with an asynchronous
     * variant).
     *
     * There is an API to force a process to terminate, as well as a
     * race-free API for sending UNIX signals to a subprocess.
     *
     * One major advantage that GIO brings over the core GLib library is
     * comprehensive API for asynchronous I/O, such
     * [method`Gio`.OutputStream.splice_async].  This makes `GSubprocess`
     * significantly more powerful and flexible than equivalent APIs in
     * some other languages such as the `subprocess.py`
     * included with Python.  For example, using `GSubprocess` one could
     * create two child processes, reading standard output from the first,
     * processing it, and writing to the input stream of the second, all
     * without blocking the main loop.
     *
     * A powerful [method`Gio`.Subprocess.communicate] API is provided similar to the
     * `communicate()` method of `subprocess.py`. This enables very easy
     * interaction with a subprocess that has been opened with pipes.
     *
     * `GSubprocess` defaults to tight control over the file descriptors open
     * in the child process, avoiding dangling-FD issues that are caused by
     * a simple `fork()`/`exec()`.  The only open file descriptors in the
     * spawned process are ones that were explicitly specified by the
     * `GSubprocess` API (unless `G_SUBPROCESS_FLAGS_INHERIT_FDS` was
     * specified).
     *
     * `GSubprocess` will quickly reap all child processes as they exit,
     * avoiding zombie processes remaining around for long periods of
     * time.  [method`Gio`.Subprocess.wait] can be used to wait for this to happen,
     * but it will happen even without the call being explicitly made.
     *
     * As a matter of principle, `GSubprocess` has no API that accepts
     * shell-style space-separated strings.  It will, however, match the
     * typical shell behaviour of searching the `PATH` for executables that do
     * not contain a directory separator in their name. By default, the `PATH`
     * of the current process is used.  You can specify
     * `G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP` to use the `PATH` of the
     * launcher environment instead.
     *
     * `GSubprocess` attempts to have a very simple API for most uses (ie:
     * spawning a subprocess with arguments and support for most typical
     * kinds of input and output redirection).  See [ctor`Gio`.Subprocess.new]. The
     * [class`Gio`.SubprocessLauncher] API is provided for more complicated cases
     * (advanced types of redirection, environment variable manipulation,
     * change of working directory, child setup functions, etc).
     *
     * A typical use of `GSubprocess` will involve calling
     * [ctor`Gio`.Subprocess.new], followed by [method`Gio`.Subprocess.wait_async] or
     * [method`Gio`.Subprocess.wait].  After the process exits, the status can be
     * checked using functions such as [method`Gio`.Subprocess.get_if_exited] (which
     * are similar to the familiar `WIFEXITED`-style POSIX macros).
     */
    class Subprocess extends GObject.Object implements Initable {
        static $gtype: GObject.GType<Subprocess>;

        // Properties

        /**
         * Argument vector.
         */
        set argv(val: string[]);
        /**
         * Subprocess flags.
         */
        set flags(val: SubprocessFlags);

        // Constructors

        constructor(properties?: Partial<Subprocess.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](argv: string[], flags: SubprocessFlags): Subprocess;

        // Methods

        /**
         * Communicate with the subprocess until it terminates, and all input
         * and output has been completed.
         *
         * If `stdin_buf` is given, the subprocess must have been created with
         * %G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
         * stdin of the subprocess and the pipe is closed (ie: EOF).
         *
         * At the same time (as not to cause blocking when dealing with large
         * amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
         * %G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
         * streams.  The data that was read is returned in `stdout` and/or
         * the `stderr`.
         *
         * If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
         * `stdout_buf` will contain the data read from stdout.  Otherwise, for
         * subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
         * `stdout_buf` will be set to %NULL.  Similar provisions apply to
         * `stderr_buf` and %G_SUBPROCESS_FLAGS_STDERR_PIPE.
         *
         * As usual, any output variable may be given as %NULL to ignore it.
         *
         * If you desire the stdout and stderr data to be interleaved, create
         * the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
         * %G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
         * in `stdout_buf` and `stderr_buf` will be set to %NULL.
         *
         * In case of any error (including cancellation), %FALSE will be
         * returned with `error` set.  Some or all of the stdin data may have
         * been written.  Any stdout or stderr data that has been read will be
         * discarded. None of the out variables (aside from `error)` will have
         * been set to anything in particular and should not be inspected.
         *
         * In the case that %TRUE is returned, the subprocess has exited and the
         * exit status inspection APIs (eg: g_subprocess_get_if_exited(),
         * g_subprocess_get_exit_status()) may be used.
         *
         * You should not attempt to use any of the subprocess pipes after
         * starting this function, since they may be left in strange states,
         * even if the operation was cancelled.  You should especially not
         * attempt to interact with the pipes while the operation is in progress
         * (either from another thread or if using the asynchronous version).
         * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
         * @param cancellable a #GCancellable
         * @returns %TRUE if successful
         */
        communicate(
            stdin_buf?: GLib.Bytes | null,
            cancellable?: Cancellable | null,
        ): [boolean, GLib.Bytes | null, GLib.Bytes | null];
        /**
         * Asynchronous version of g_subprocess_communicate().  Complete
         * invocation with g_subprocess_communicate_finish().
         * @param stdin_buf Input data, or %NULL
         * @param cancellable Cancellable
         * @param callback Callback
         */
        communicate_async(
            stdin_buf?: GLib.Bytes | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Complete an invocation of g_subprocess_communicate_async().
         * @param result Result
         */
        communicate_finish(result: AsyncResult): [boolean, GLib.Bytes | null, GLib.Bytes | null];
        /**
         * Like g_subprocess_communicate(), but validates the output of the
         * process as UTF-8, and returns it as a regular NUL terminated string.
         *
         * On error, `stdout_buf` and `stderr_buf` will be set to undefined values and
         * should not be used.
         * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
         * @param cancellable a #GCancellable
         */
        communicate_utf8(stdin_buf: string | null, cancellable: Cancellable | null): [boolean, string, string];
        /**
         * Asynchronous version of g_subprocess_communicate_utf8().  Complete
         * invocation with g_subprocess_communicate_utf8_finish().
         * @param stdin_buf Input data, or %NULL
         * @param cancellable Cancellable
         * @param callback Callback
         */
        communicate_utf8_async(
            stdin_buf?: string | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Complete an invocation of g_subprocess_communicate_utf8_async().
         * @param result Result
         */
        communicate_utf8_finish(result: AsyncResult): [boolean, string, string];
        /**
         * Use an operating-system specific method to attempt an immediate,
         * forceful termination of the process.  There is no mechanism to
         * determine whether or not the request itself was successful;
         * however, you can use g_subprocess_wait() to monitor the status of
         * the process after calling this function.
         *
         * On Unix, this function sends %SIGKILL.
         */
        force_exit(): void;
        /**
         * Check the exit status of the subprocess, given that it exited
         * normally.  This is the value passed to the exit() system call or the
         * return value from main.
         *
         * This is equivalent to the system WEXITSTATUS macro.
         *
         * It is an error to call this function before g_subprocess_wait() and
         * unless g_subprocess_get_if_exited() returned %TRUE.
         * @returns the exit status
         */
        get_exit_status(): number;
        /**
         * On UNIX, returns the process ID as a decimal string.
         * On Windows, returns the result of GetProcessId() also as a string.
         * If the subprocess has terminated, this will return %NULL.
         * @returns the subprocess identifier, or %NULL if the subprocess    has terminated
         */
        get_identifier(): string | null;
        /**
         * Check if the given subprocess exited normally (ie: by way of exit()
         * or return from main()).
         *
         * This is equivalent to the system WIFEXITED macro.
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns %TRUE if the case of a normal exit
         */
        get_if_exited(): boolean;
        /**
         * Check if the given subprocess terminated in response to a signal.
         *
         * This is equivalent to the system WIFSIGNALED macro.
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns %TRUE if the case of termination due to a signal
         */
        get_if_signaled(): boolean;
        /**
         * Gets the raw status code of the process, as from waitpid().
         *
         * This value has no particular meaning, but it can be used with the
         * macros defined by the system headers such as WIFEXITED.  It can also
         * be used with g_spawn_check_wait_status().
         *
         * It is more likely that you want to use g_subprocess_get_if_exited()
         * followed by g_subprocess_get_exit_status().
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns the (meaningless) waitpid() exit status from the kernel
         */
        get_status(): number;
        /**
         * Gets the #GInputStream from which to read the stderr output of
         * `subprocess`.
         *
         * The process must have been created with %G_SUBPROCESS_FLAGS_STDERR_PIPE,
         * otherwise %NULL will be returned.
         * @returns the stderr pipe
         */
        get_stderr_pipe(): InputStream | null;
        /**
         * Gets the #GOutputStream that you can write to in order to give data
         * to the stdin of `subprocess`.
         *
         * The process must have been created with %G_SUBPROCESS_FLAGS_STDIN_PIPE and
         * not %G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise %NULL will be returned.
         * @returns the stdout pipe
         */
        get_stdin_pipe(): OutputStream | null;
        /**
         * Gets the #GInputStream from which to read the stdout output of
         * `subprocess`.
         *
         * The process must have been created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
         * otherwise %NULL will be returned.
         * @returns the stdout pipe
         */
        get_stdout_pipe(): InputStream | null;
        /**
         * Checks if the process was "successful".  A process is considered
         * successful if it exited cleanly with an exit status of 0, either by
         * way of the exit() system call or return from main().
         *
         * It is an error to call this function before g_subprocess_wait() has
         * returned.
         * @returns %TRUE if the process exited cleanly with a exit status of 0
         */
        get_successful(): boolean;
        /**
         * Get the signal number that caused the subprocess to terminate, given
         * that it terminated due to a signal.
         *
         * This is equivalent to the system WTERMSIG macro.
         *
         * It is an error to call this function before g_subprocess_wait() and
         * unless g_subprocess_get_if_signaled() returned %TRUE.
         * @returns the signal causing termination
         */
        get_term_sig(): number;
        /**
         * Sends the UNIX signal `signal_num` to the subprocess, if it is still
         * running.
         *
         * This API is race-free.  If the subprocess has terminated, it will not
         * be signalled.
         *
         * This API is not available on Windows.
         * @param signal_num the signal number to send
         */
        send_signal(signal_num: number): void;
        /**
         * Synchronously wait for the subprocess to terminate.
         *
         * After the process terminates you can query its exit status with
         * functions such as g_subprocess_get_if_exited() and
         * g_subprocess_get_exit_status().
         *
         * This function does not fail in the case of the subprocess having
         * abnormal termination.  See g_subprocess_wait_check() for that.
         *
         * Cancelling `cancellable` doesn't kill the subprocess.  Call
         * g_subprocess_force_exit() if it is desirable.
         * @param cancellable a #GCancellable
         * @returns %TRUE on success, %FALSE if @cancellable was cancelled
         */
        wait(cancellable?: Cancellable | null): boolean;
        /**
         * Wait for the subprocess to terminate.
         *
         * This is the asynchronous version of g_subprocess_wait().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback to call when the operation is complete
         */
        wait_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Combines g_subprocess_wait() with g_spawn_check_wait_status().
         * @param cancellable a #GCancellable
         * @returns %TRUE on success, %FALSE if process exited abnormally, or @cancellable was cancelled
         */
        wait_check(cancellable?: Cancellable | null): boolean;
        /**
         * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
         *
         * This is the asynchronous version of g_subprocess_wait_check().
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback to call when the operation is complete
         */
        wait_check_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Collects the result of a previous call to
         * g_subprocess_wait_check_async().
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         * @returns %TRUE if successful, or %FALSE with @error set
         */
        wait_check_finish(result: AsyncResult): boolean;
        /**
         * Collects the result of a previous call to
         * g_subprocess_wait_async().
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         * @returns %TRUE if successful, or %FALSE with @error set
         */
        wait_finish(result: AsyncResult): boolean;

        // Inherited methods
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;
        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module SubprocessLauncher {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            flags: SubprocessFlags;
        }
    }

    /**
     * This class contains a set of options for launching child processes,
     * such as where its standard input and output will be directed, the
     * argument list, the environment, and more.
     *
     * While the [class`Gio`.Subprocess] class has high level functions covering
     * popular cases, use of this class allows access to more advanced
     * options.  It can also be used to launch multiple subprocesses with
     * a similar configuration.
     */
    class SubprocessLauncher extends GObject.Object {
        static $gtype: GObject.GType<SubprocessLauncher>;

        // Properties

        /**
         * [flags`Gio`.SubprocessFlags] for launched processes.
         */
        set flags(val: SubprocessFlags);

        // Constructors

        constructor(properties?: Partial<SubprocessLauncher.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](flags: SubprocessFlags): SubprocessLauncher;

        // Methods

        /**
         * Closes all the file descriptors previously passed to the object with
         * g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
         *
         * After calling this method, any subsequent calls to g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
         * return %G_IO_ERROR_CLOSED. This method is idempotent if
         * called more than once.
         *
         * This function is called automatically when the #GSubprocessLauncher
         * is disposed, but is provided separately so that garbage collected
         * language bindings can call it earlier to guarantee when FDs are closed.
         */
        close(): void;
        /**
         * Returns the value of the environment variable `variable` in the
         * environment of processes launched from this launcher.
         *
         * On UNIX, the returned string can be an arbitrary byte string.
         * On Windows, it will be UTF-8.
         * @param variable the environment variable to get
         * @returns the value of the environment variable,     %NULL if unset
         */
        getenv(variable: string): string | null;
        /**
         * Sets the current working directory that processes will be launched
         * with.
         *
         * By default processes are launched with the current working directory
         * of the launching process at the time of launch.
         * @param cwd the cwd for launched processes
         */
        set_cwd(cwd: string): void;
        /**
         * Replace the entire environment of processes launched from this
         * launcher with the given 'environ' variable.
         *
         * Typically you will build this variable by using g_listenv() to copy
         * the process 'environ' and using the functions g_environ_setenv(),
         * g_environ_unsetenv(), etc.
         *
         * As an alternative, you can use g_subprocess_launcher_setenv(),
         * g_subprocess_launcher_unsetenv(), etc.
         *
         * Pass an empty array to set an empty environment. Pass %NULL to inherit the
         * parent process environment. As of GLib 2.54, the parent process environment
         * will be copied when g_subprocess_launcher_set_environ() is called.
         * Previously, it was copied when the subprocess was executed. This means the
         * copied environment may now be modified (using g_subprocess_launcher_setenv(),
         * etc.) before launching the subprocess.
         *
         * On UNIX, all strings in this array can be arbitrary byte strings.
         * On Windows, they should be in UTF-8.
         * @param env the replacement environment
         */
        set_environ(env: string[]): void;
        /**
         * Sets the flags on the launcher.
         *
         * The default flags are %G_SUBPROCESS_FLAGS_NONE.
         *
         * You may not set flags that specify conflicting options for how to
         * handle a particular stdio stream (eg: specifying both
         * %G_SUBPROCESS_FLAGS_STDIN_PIPE and
         * %G_SUBPROCESS_FLAGS_STDIN_INHERIT).
         *
         * You may also not set a flag that conflicts with a previous call to a
         * function like g_subprocess_launcher_set_stdin_file_path() or
         * g_subprocess_launcher_take_stdout_fd().
         * @param flags #GSubprocessFlags
         */
        set_flags(flags: SubprocessFlags): void;
        /**
         * Sets the file path to use as the stderr for spawned processes.
         *
         * If `path` is %NULL then any previously given path is unset.
         *
         * The file will be created or truncated when the process is spawned, as
         * would be the case if using '2>' at the shell.
         *
         * If you want to send both stdout and stderr to the same file then use
         * %G_SUBPROCESS_FLAGS_STDERR_MERGE.
         *
         * You may not set a stderr file path if a stderr fd is already set or
         * if the launcher flags contain any flags directing stderr elsewhere.
         *
         * This feature is only available on UNIX.
         * @param path a filename or %NULL
         */
        set_stderr_file_path(path?: string | null): void;
        /**
         * Sets the file path to use as the stdin for spawned processes.
         *
         * If `path` is %NULL then any previously given path is unset.
         *
         * The file must exist or spawning the process will fail.
         *
         * You may not set a stdin file path if a stdin fd is already set or if
         * the launcher flags contain any flags directing stdin elsewhere.
         *
         * This feature is only available on UNIX.
         * @param path a filename or %NULL
         */
        set_stdin_file_path(path?: string | null): void;
        /**
         * Sets the file path to use as the stdout for spawned processes.
         *
         * If `path` is %NULL then any previously given path is unset.
         *
         * The file will be created or truncated when the process is spawned, as
         * would be the case if using '>' at the shell.
         *
         * You may not set a stdout file path if a stdout fd is already set or
         * if the launcher flags contain any flags directing stdout elsewhere.
         *
         * This feature is only available on UNIX.
         * @param path a filename or %NULL
         */
        set_stdout_file_path(path?: string | null): void;
        /**
         * Sets the environment variable `variable` in the environment of
         * processes launched from this launcher.
         *
         * On UNIX, both the variable's name and value can be arbitrary byte
         * strings, except that the variable's name cannot contain '='.
         * On Windows, they should be in UTF-8.
         * @param variable the environment variable to set,     must not contain '='
         * @param value the new value for the variable
         * @param overwrite whether to change the variable if it already exists
         */
        setenv(variable: string, value: string, overwrite: boolean): void;
        /**
         * Creates a #GSubprocess given a provided array of arguments.
         * @param argv Command line arguments
         * @returns A new #GSubprocess, or %NULL on error (and @error will be set)
         */
        spawnv(argv: string[]): Subprocess;
        /**
         * Transfer an arbitrary file descriptor from parent process to the
         * child.  This function takes ownership of the `source_fd;` it will be closed
         * in the parent when `self` is freed.
         *
         * By default, all file descriptors from the parent will be closed.
         * This function allows you to create (for example) a custom `pipe()` or
         * `socketpair()` before launching the process, and choose the target
         * descriptor in the child.
         *
         * An example use case is GNUPG, which has a command line argument
         * `--passphrase-fd` providing a file descriptor number where it expects
         * the passphrase to be written.
         * @param source_fd File descriptor in parent process
         * @param target_fd Target descriptor for child process
         */
        take_fd(source_fd: number, target_fd: number): void;
        /**
         * Sets the file descriptor to use as the stderr for spawned processes.
         *
         * If `fd` is -1 then any previously given fd is unset.
         *
         * Note that the default behaviour is to pass stderr through to the
         * stderr of the parent process.
         *
         * The passed `fd` belongs to the #GSubprocessLauncher.  It will be
         * automatically closed when the launcher is finalized.  The file
         * descriptor will also be closed on the child side when executing the
         * spawned process.
         *
         * You may not set a stderr fd if a stderr file path is already set or
         * if the launcher flags contain any flags directing stderr elsewhere.
         *
         * This feature is only available on UNIX.
         * @param fd a file descriptor, or -1
         */
        take_stderr_fd(fd: number): void;
        /**
         * Sets the file descriptor to use as the stdin for spawned processes.
         *
         * If `fd` is -1 then any previously given fd is unset.
         *
         * Note that if your intention is to have the stdin of the calling
         * process inherited by the child then %G_SUBPROCESS_FLAGS_STDIN_INHERIT
         * is a better way to go about doing that.
         *
         * The passed `fd` is noted but will not be touched in the current
         * process.  It is therefore necessary that it be kept open by the
         * caller until the subprocess is spawned.  The file descriptor will
         * also not be explicitly closed on the child side, so it must be marked
         * O_CLOEXEC if that's what you want.
         *
         * You may not set a stdin fd if a stdin file path is already set or if
         * the launcher flags contain any flags directing stdin elsewhere.
         *
         * This feature is only available on UNIX.
         * @param fd a file descriptor, or -1
         */
        take_stdin_fd(fd: number): void;
        /**
         * Sets the file descriptor to use as the stdout for spawned processes.
         *
         * If `fd` is -1 then any previously given fd is unset.
         *
         * Note that the default behaviour is to pass stdout through to the
         * stdout of the parent process.
         *
         * The passed `fd` is noted but will not be touched in the current
         * process.  It is therefore necessary that it be kept open by the
         * caller until the subprocess is spawned.  The file descriptor will
         * also not be explicitly closed on the child side, so it must be marked
         * O_CLOEXEC if that's what you want.
         *
         * You may not set a stdout fd if a stdout file path is already set or
         * if the launcher flags contain any flags directing stdout elsewhere.
         *
         * This feature is only available on UNIX.
         * @param fd a file descriptor, or -1
         */
        take_stdout_fd(fd: number): void;
        /**
         * Removes the environment variable `variable` from the environment of
         * processes launched from this launcher.
         *
         * On UNIX, the variable's name can be an arbitrary byte string not
         * containing '='. On Windows, it should be in UTF-8.
         * @param variable the environment variable to unset,     must not contain '='
         */
        unsetenv(variable: string): void;
    }

    module Task {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, AsyncResult.ConstructorProps {
            completed: boolean;
        }
    }

    /**
     * A `GTask` represents and manages a cancellable task.
     *
     * ## Asynchronous operations
     *
     * The most common usage of `GTask` is as a [iface`Gio`.AsyncResult], to
     * manage data during an asynchronous operation. You call
     * [ctor`Gio`.Task.new] in the start method, followed by
     * [method`Gio`.Task.set_task_data] and the like if you need to keep some
     * additional data associated with the task, and then pass the
     * task object around through your asynchronous operation.
     * Eventually, you will call a method such as
     * [method`Gio`.Task.return_pointer] or [method`Gio`.Task.return_error], which
     * will save the value you give it and then invoke the tasks callback
     * function in the thread-default main context (see
     * [method`GLib`.MainContext.push_thread_default])
     * where it was created (waiting until the next iteration of the main
     * loop first, if necessary). The caller will pass the `GTask` back to
     * the operations finish function (as a [iface`Gio`.AsyncResult]), and you can
     * use [method`Gio`.Task.propagate_pointer] or the like to extract the
     * return value.
     *
     * Using `GTask` requires the thread-default [struct`GLib`.MainContext] from when
     * the `GTask` was constructed to be running at least until the task has
     * completed and its data has been freed.
     *
     * If a `GTask` has been constructed and its callback set, it is an error to
     * not call `g_task_return_*()` on it. GLib will warn at runtime if this happens
     * (since 2.76).
     *
     * Here is an example for using `GTask` as a [iface`Gio`.AsyncResult]:
     * ```c
     * typedef struct {
     *   CakeFrostingType frosting;
     *   char *message;
     * } DecorationData;
     *
     * static void
     * decoration_data_free (DecorationData *decoration)
     * {
     *   g_free (decoration->message);
     *   g_slice_free (DecorationData, decoration);
     * }
     *
     * static void
     * baked_cb (Cake     *cake,
     *           gpointer  user_data)
     * {
     *   GTask *task = user_data;
     *   DecorationData *decoration = g_task_get_task_data (task);
     *   GError *error = NULL;
     *
     *   if (cake == NULL)
     *     {
     *       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
     *                                "Go to the supermarket");
     *       g_object_unref (task);
     *       return;
     *     }
     *
     *   if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
     *     {
     *       g_object_unref (cake);
     *       // g_task_return_error() takes ownership of error
     *       g_task_return_error (task, error);
     *       g_object_unref (task);
     *       return;
     *     }
     *
     *   g_task_return_pointer (task, cake, g_object_unref);
     *   g_object_unref (task);
     * }
     *
     * void
     * baker_bake_cake_async (Baker               *self,
     *                        guint                radius,
     *                        CakeFlavor           flavor,
     *                        CakeFrostingType     frosting,
     *                        const char          *message,
     *                        GCancellable        *cancellable,
     *                        GAsyncReadyCallback  callback,
     *                        gpointer             user_data)
     * {
     *   GTask *task;
     *   DecorationData *decoration;
     *   Cake  *cake;
     *
     *   task = g_task_new (self, cancellable, callback, user_data);
     *   if (radius < 3)
     *     {
     *       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
     *                                "%ucm radius cakes are silly",
     *                                radius);
     *       g_object_unref (task);
     *       return;
     *     }
     *
     *   cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
     *   if (cake != NULL)
     *     {
     *       // _baker_get_cached_cake() returns a reffed cake
     *       g_task_return_pointer (task, cake, g_object_unref);
     *       g_object_unref (task);
     *       return;
     *     }
     *
     *   decoration = g_slice_new (DecorationData);
     *   decoration->frosting = frosting;
     *   decoration->message = g_strdup (message);
     *   g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);
     *
     *   _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
     * }
     *
     * Cake *
     * baker_bake_cake_finish (Baker         *self,
     *                         GAsyncResult  *result,
     *                         GError       **error)
     * {
     *   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
     *
     *   return g_task_propagate_pointer (G_TASK (result), error);
     * }
     * ```
     *
     * ## Chained asynchronous operations
     *
     * `GTask` also tries to simplify asynchronous operations that
     * internally chain together several smaller asynchronous
     * operations. [method`Gio`.Task.get_cancellable], [method`Gio`.Task.get_context],
     * and [method`Gio`.Task.get_priority] allow you to get back the tasks
     * [class`Gio`.Cancellable], [struct`GLib`.MainContext], and
     * [I/O priority](iface.AsyncResult.html#io-priority)
     * when starting a new subtask, so you dont have to keep track
     * of them yourself. [method`Gio`.Task.attach_source] simplifies the case
     * of waiting for a source to fire (automatically using the correct
     * [struct`GLib`.MainContext] and priority).
     *
     * Here is an example for chained asynchronous operations:
     * ```c
     * typedef struct {
     *   Cake *cake;
     *   CakeFrostingType frosting;
     *   char *message;
     * } BakingData;
     *
     * static void
     * decoration_data_free (BakingData *bd)
     * {
     *   if (bd->cake)
     *     g_object_unref (bd->cake);
     *   g_free (bd->message);
     *   g_slice_free (BakingData, bd);
     * }
     *
     * static void
     * decorated_cb (Cake         *cake,
     *               GAsyncResult *result,
     *               gpointer      user_data)
     * {
     *   GTask *task = user_data;
     *   GError *error = NULL;
     *
     *   if (!cake_decorate_finish (cake, result, &error))
     *     {
     *       g_object_unref (cake);
     *       g_task_return_error (task, error);
     *       g_object_unref (task);
     *       return;
     *     }
     *
     *   // baking_data_free() will drop its ref on the cake, so we have to
     *   // take another here to give to the caller.
     *   g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
     *   g_object_unref (task);
     * }
     *
     * static gboolean
     * decorator_ready (gpointer user_data)
     * {
     *   GTask *task = user_data;
     *   BakingData *bd = g_task_get_task_data (task);
     *
     *   cake_decorate_async (bd->cake, bd->frosting, bd->message,
     *                        g_task_get_cancellable (task),
     *                        decorated_cb, task);
     *
     *   return G_SOURCE_REMOVE;
     * }
     *
     * static void
     * baked_cb (Cake     *cake,
     *           gpointer  user_data)
     * {
     *   GTask *task = user_data;
     *   BakingData *bd = g_task_get_task_data (task);
     *   GError *error = NULL;
     *
     *   if (cake == NULL)
     *     {
     *       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
     *                                "Go to the supermarket");
     *       g_object_unref (task);
     *       return;
     *     }
     *
     *   bd->cake = cake;
     *
     *   // Bail out now if the user has already cancelled
     *   if (g_task_return_error_if_cancelled (task))
     *     {
     *       g_object_unref (task);
     *       return;
     *     }
     *
     *   if (cake_decorator_available (cake))
     *     decorator_ready (task);
     *   else
     *     {
     *       GSource *source;
     *
     *       source = cake_decorator_wait_source_new (cake);
     *       // Attach `source` to `task`s GMainContext and have it call
     *       // decorator_ready() when it is ready.
     *       g_task_attach_source (task, source, decorator_ready);
     *       g_source_unref (source);
     *     }
     * }
     *
     * void
     * baker_bake_cake_async (Baker               *self,
     *                        guint                radius,
     *                        CakeFlavor           flavor,
     *                        CakeFrostingType     frosting,
     *                        const char          *message,
     *                        gint                 priority,
     *                        GCancellable        *cancellable,
     *                        GAsyncReadyCallback  callback,
     *                        gpointer             user_data)
     * {
     *   GTask *task;
     *   BakingData *bd;
     *
     *   task = g_task_new (self, cancellable, callback, user_data);
     *   g_task_set_priority (task, priority);
     *
     *   bd = g_slice_new0 (BakingData);
     *   bd->frosting = frosting;
     *   bd->message = g_strdup (message);
     *   g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
     *
     *   _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
     * }
     *
     * Cake *
     * baker_bake_cake_finish (Baker         *self,
     *                         GAsyncResult  *result,
     *                         GError       **error)
     * {
     *   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
     *
     *   return g_task_propagate_pointer (G_TASK (result), error);
     * }
     * ```
     *
     * ## Asynchronous operations from synchronous ones
     *
     * You can use [method`Gio`.Task.run_in_thread] to turn a synchronous
     * operation into an asynchronous one, by running it in a thread.
     * When it completes, the result will be dispatched to the thread-default main
     * context (see [method`GLib`.MainContext.push_thread_default]) where the `GTask`
     * was created.
     *
     * Running a task in a thread:
     * ```c
     * typedef struct {
     *   guint radius;
     *   CakeFlavor flavor;
     *   CakeFrostingType frosting;
     *   char *message;
     * } CakeData;
     *
     * static void
     * cake_data_free (CakeData *cake_data)
     * {
     *   g_free (cake_data->message);
     *   g_slice_free (CakeData, cake_data);
     * }
     *
     * static void
     * bake_cake_thread (GTask         *task,
     *                   gpointer       source_object,
     *                   gpointer       task_data,
     *                   GCancellable  *cancellable)
     * {
     *   Baker *self = source_object;
     *   CakeData *cake_data = task_data;
     *   Cake *cake;
     *   GError *error = NULL;
     *
     *   cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
     *                     cake_data->frosting, cake_data->message,
     *                     cancellable, &error);
     *   if (cake)
     *     g_task_return_pointer (task, cake, g_object_unref);
     *   else
     *     g_task_return_error (task, error);
     * }
     *
     * void
     * baker_bake_cake_async (Baker               *self,
     *                        guint                radius,
     *                        CakeFlavor           flavor,
     *                        CakeFrostingType     frosting,
     *                        const char          *message,
     *                        GCancellable        *cancellable,
     *                        GAsyncReadyCallback  callback,
     *                        gpointer             user_data)
     * {
     *   CakeData *cake_data;
     *   GTask *task;
     *
     *   cake_data = g_slice_new (CakeData);
     *   cake_data->radius = radius;
     *   cake_data->flavor = flavor;
     *   cake_data->frosting = frosting;
     *   cake_data->message = g_strdup (message);
     *   task = g_task_new (self, cancellable, callback, user_data);
     *   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
     *   g_task_run_in_thread (task, bake_cake_thread);
     *   g_object_unref (task);
     * }
     *
     * Cake *
     * baker_bake_cake_finish (Baker         *self,
     *                         GAsyncResult  *result,
     *                         GError       **error)
     * {
     *   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
     *
     *   return g_task_propagate_pointer (G_TASK (result), error);
     * }
     * ```
     *
     * ## Adding cancellability to uncancellable tasks
     *
     * Finally, [method`Gio`.Task.run_in_thread] and
     * [method`Gio`.Task.run_in_thread_sync] can be used to turn an uncancellable
     * operation into a cancellable one. If you call
     * [method`Gio`.Task.set_return_on_cancel], passing `TRUE`, then if the tasks
     * [class`Gio`.Cancellable] is cancelled, it will return control back to the
     * caller immediately, while allowing the task thread to continue running in the
     * background (and simply discarding its result when it finally does finish).
     * Provided that the task thread is careful about how it uses
     * locks and other externally-visible resources, this allows you
     * to make GLib-friendly asynchronous and cancellable
     * synchronous variants of blocking APIs.
     *
     * Cancelling a task:
     * ```c
     * static void
     * bake_cake_thread (GTask         *task,
     *                   gpointer       source_object,
     *                   gpointer       task_data,
     *                   GCancellable  *cancellable)
     * {
     *   Baker *self = source_object;
     *   CakeData *cake_data = task_data;
     *   Cake *cake;
     *   GError *error = NULL;
     *
     *   cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
     *                     cake_data->frosting, cake_data->message,
     *                     &error);
     *   if (error)
     *     {
     *       g_task_return_error (task, error);
     *       return;
     *     }
     *
     *   // If the task has already been cancelled, then we dont want to add
     *   // the cake to the cake cache. Likewise, we dont  want to have the
     *   // task get cancelled in the middle of updating the cache.
     *   // g_task_set_return_on_cancel() will return %TRUE here if it managed
     *   // to disable return-on-cancel, or %FALSE if the task was cancelled
     *   // before it could.
     *   if (g_task_set_return_on_cancel (task, FALSE))
     *     {
     *       // If the caller cancels at this point, their
     *       // GAsyncReadyCallback wont be invoked until we return,
     *       // so we dont have to worry that this code will run at
     *       // the same time as that code does. But if there were
     *       // other functions that might look at the cake cache,
     *       // then wed probably need a GMutex here as well.
     *       baker_add_cake_to_cache (baker, cake);
     *       g_task_return_pointer (task, cake, g_object_unref);
     *     }
     * }
     *
     * void
     * baker_bake_cake_async (Baker               *self,
     *                        guint                radius,
     *                        CakeFlavor           flavor,
     *                        CakeFrostingType     frosting,
     *                        const char          *message,
     *                        GCancellable        *cancellable,
     *                        GAsyncReadyCallback  callback,
     *                        gpointer             user_data)
     * {
     *   CakeData *cake_data;
     *   GTask *task;
     *
     *   cake_data = g_slice_new (CakeData);
     *
     *   ...
     *
     *   task = g_task_new (self, cancellable, callback, user_data);
     *   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
     *   g_task_set_return_on_cancel (task, TRUE);
     *   g_task_run_in_thread (task, bake_cake_thread);
     * }
     *
     * Cake *
     * baker_bake_cake_sync (Baker               *self,
     *                       guint                radius,
     *                       CakeFlavor           flavor,
     *                       CakeFrostingType     frosting,
     *                       const char          *message,
     *                       GCancellable        *cancellable,
     *                       GError             **error)
     * {
     *   CakeData *cake_data;
     *   GTask *task;
     *   Cake *cake;
     *
     *   cake_data = g_slice_new (CakeData);
     *
     *   ...
     *
     *   task = g_task_new (self, cancellable, NULL, NULL);
     *   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
     *   g_task_set_return_on_cancel (task, TRUE);
     *   g_task_run_in_thread_sync (task, bake_cake_thread);
     *
     *   cake = g_task_propagate_pointer (task, error);
     *   g_object_unref (task);
     *   return cake;
     * }
     * ```
     *
     * ## Porting from [class`Gio`.SimpleAsyncResult]
     *
     * `GTask`s API attempts to be simpler than [class`Gio`.SimpleAsyncResult]s
     * in several ways:
     *
     * - You can save task-specific data with [method`Gio`.Task.set_task_data], and
     *   retrieve it later with [method`Gio`.Task.get_task_data]. This replaces the
     *   abuse of [method`Gio`.SimpleAsyncResult.set_op_res_gpointer] for the same
     *   purpose with [class`Gio`.SimpleAsyncResult].
     * - In addition to the task data, `GTask` also keeps track of the
     *   [priority](iface.AsyncResult.html#io-priority), [class`Gio`.Cancellable],
     *   and [struct`GLib`.MainContext] associated with the task, so tasks that
     *   consist of a chain of simpler asynchronous operations will have easy access
     *   to those values when starting each sub-task.
     * - [method`Gio`.Task.return_error_if_cancelled] provides simplified
     *   handling for cancellation. In addition, cancellation
     *   overrides any other `GTask` return value by default, like
     *   [class`Gio`.SimpleAsyncResult] does when
     *   [method`Gio`.SimpleAsyncResult.set_check_cancellable] is called.
     *   (You can use [method`Gio`.Task.set_check_cancellable] to turn off that
     *   behavior.) On the other hand, [method`Gio`.Task.run_in_thread]
     *   guarantees that it will always run your
     *   `task_func`, even if the tasks [class`Gio`.Cancellable]
     *   is already cancelled before the task gets a chance to run;
     *   you can start your `task_func` with a
     *   [method`Gio`.Task.return_error_if_cancelled] check if you need the
     *   old behavior.
     * - The return methods (eg, [method`Gio`.Task.return_pointer])
     *   automatically cause the task to be completed as well, and
     *   there is no need to worry about the complete vs complete in idle
     *   distinction. (`GTask` automatically figures out
     *   whether the tasks callback can be invoked directly, or
     *   if it needs to be sent to another [struct`GLib`.MainContext], or delayed
     *   until the next iteration of the current [struct`GLib`.MainContext].)
     * - The finish functions for `GTask` based operations are generally
     *   much simpler than [class`Gio`.SimpleAsyncResult] ones, normally consisting
     *   of only a single call to [method`Gio`.Task.propagate_pointer] or the like.
     *   Since [method`Gio`.Task.propagate_pointer] steals the return value from
     *   the `GTask`, it is not necessary to juggle pointers around to
     *   prevent it from being freed twice.
     * - With [class`Gio`.SimpleAsyncResult], it was common to call
     *   [method`Gio`.SimpleAsyncResult.propagate_error] from the
     *   `_finish()` wrapper function, and have
     *   virtual method implementations only deal with successful
     *   returns. This behavior is deprecated, because it makes it
     *   difficult for a subclass to chain to a parent classs async
     *   methods. Instead, the wrapper function should just be a
     *   simple wrapper, and the virtual method should call an
     *   appropriate `g_task_propagate_` function.
     *   Note that wrapper methods can now use
     *   [method`Gio`.AsyncResult.legacy_propagate_error] to do old-style
     *   [class`Gio`.SimpleAsyncResult] error-returning behavior, and
     *   [method`Gio`.AsyncResult.is_tagged] to check if a result is tagged as
     *   having come from the `_async()` wrapper
     *   function (for short-circuit results, such as when passing
     *   `0` to [method`Gio`.InputStream.read_async]).
     *
     * ## Thread-safety considerations
     *
     * Due to some infelicities in the API design, there is a
     * thread-safety concern that users of `GTask` have to be aware of:
     *
     * If the `main` thread drops its last reference to the source object
     * or the task data before the task is finalized, then the finalizers
     * of these objects may be called on the worker thread.
     *
     * This is a problem if the finalizers use non-threadsafe API, and
     * can lead to hard-to-debug crashes. Possible workarounds include:
     *
     * - Clear task data in a signal handler for `notify::completed`
     * - Keep iterating a main context in the main thread and defer
     *   dropping the reference to the source object to that main
     *   context when the task is finalized
     */
    class Task extends GObject.Object implements AsyncResult {
        static $gtype: GObject.GType<Task>;

        // Properties

        /**
         * Whether the task has completed, meaning its callback (if set) has been
         * invoked.
         *
         * This can only happen after g_task_return_pointer(),
         * g_task_return_error() or one of the other return functions have been called
         * on the task. However, it is not guaranteed to happen immediately after
         * those functions are called, as the tasks callback may need to be scheduled
         * to run in a different thread.
         *
         * That means it is **not safe** to use this property to track whether a
         * return function has been called on the #GTask. Callers must do that
         * tracking themselves, typically by linking the lifetime of the #GTask to the
         * control flow of their code.
         *
         * This property is guaranteed to change from %FALSE to %TRUE exactly once.
         *
         * The #GObject::notify signal for this change is emitted in the same main
         * context as the tasks callback, immediately after that callback is invoked.
         */
        get completed(): boolean;

        // Constructors

        constructor(properties?: Partial<Task.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            source_object?: GObject.Object | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback | null,
        ): Task;

        // Static methods

        /**
         * Checks that `result` is a #GTask, and that `source_object` is its
         * source object (or that `source_object` is %NULL and `result` has no
         * source object). This can be used in g_return_if_fail() checks.
         * @param result A #GAsyncResult
         * @param source_object the source object   expected to be associated with the task
         */
        static is_valid(result: AsyncResult, source_object?: GObject.Object | null): boolean;
        /**
         * Creates a #GTask and then immediately calls g_task_return_error()
         * on it. Use this in the wrapper function of an asynchronous method
         * when you want to avoid even calling the virtual method. You can
         * then use g_async_result_is_tagged() in the finish method wrapper to
         * check if the result there is tagged as having been created by the
         * wrapper method, and deal with it appropriately if so.
         *
         * See also g_task_report_new_error().
         * @param source_object the #GObject that owns   this task, or %NULL.
         * @param callback a #GAsyncReadyCallback.
         * @param source_tag an opaque pointer indicating the source of this task
         * @param error error to report
         */
        static report_error(
            source_object: GObject.Object | null,
            callback: AsyncReadyCallback<Task> | null,
            source_tag: any | null,
            error: GLib.Error,
        ): void;

        // Methods

        /**
         * Gets `task'`s #GCancellable
         * @returns @task's #GCancellable
         */
        get_cancellable(): Cancellable | null;
        /**
         * Gets `task'`s check-cancellable flag. See
         * g_task_set_check_cancellable() for more details.
         */
        get_check_cancellable(): boolean;
        /**
         * Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
         * the tasks callback is invoked, and will return %FALSE if called from inside
         * the callback.
         * @returns %TRUE if the task has completed, %FALSE otherwise.
         */
        get_completed(): boolean;
        /**
         * Gets the #GMainContext that `task` will return its result in (that
         * is, the context that was the
         * [thread-default main context][g-main-context-push-thread-default]
         * at the point when `task` was created).
         *
         * This will always return a non-%NULL value, even if the task's
         * context is the default #GMainContext.
         * @returns @task's #GMainContext
         */
        get_context(): GLib.MainContext;
        /**
         * Gets `task`s name. See g_task_set_name().
         * @returns @tasks name, or %NULL
         */
        get_name(): string | null;
        /**
         * Gets `task'`s priority
         * @returns @task's priority
         */
        get_priority(): number;
        /**
         * Gets `task'`s return-on-cancel flag. See
         * g_task_set_return_on_cancel() for more details.
         */
        get_return_on_cancel(): boolean;
        /**
         * Gets the source object from `task`. Like
         * g_async_result_get_source_object(), but does not ref the object.
         * @returns @task's source object, or %NULL
         */
        get_source_object<T = GObject.Object>(): T;
        /**
         * Gets `task'`s source tag. See g_task_set_source_tag().
         * @returns @task's source tag
         */
        get_source_tag(): any | null;
        /**
         * Gets `task'`s `task_data`.
         * @returns @task's `task_data`.
         */
        get_task_data(): any | null;
        /**
         * Tests if `task` resulted in an error.
         * @returns %TRUE if the task resulted in an error, %FALSE otherwise.
         */
        had_error(): boolean;
        /**
         * Gets the result of `task` as a #gboolean.
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead return %FALSE and set `error`.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns the task result, or %FALSE on error
         */
        propagate_boolean(): boolean;
        /**
         * Gets the result of `task` as an integer (#gssize).
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead return -1 and set `error`.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns the task result, or -1 on error
         */
        propagate_int(): number;
        /**
         * Gets the result of `task` as a pointer, and transfers ownership
         * of that value to the caller.
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead return %NULL and set `error`.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns the task result, or %NULL on error
         */
        propagate_pointer(): any | null;
        /**
         * Gets the result of `task` as a #GValue, and transfers ownership of
         * that value to the caller. As with g_task_return_value(), this is
         * a generic low-level method; g_task_propagate_pointer() and the like
         * will usually be more useful for C code.
         *
         * If the task resulted in an error, or was cancelled, then this will
         * instead set `error` and return %FALSE.
         *
         * Since this method transfers ownership of the return value (or
         * error) to the caller, you may only call it once.
         * @returns %TRUE if @task succeeded, %FALSE on error.
         */
        propagate_value(): [boolean, unknown];
        /**
         * Sets `task'`s result to `result` and completes the task (see
         * g_task_return_pointer() for more discussion of exactly what this
         * means).
         * @param result the #gboolean result of a task function.
         */
        return_boolean(result: boolean): void;
        /**
         * Sets `task'`s result to `error` (which `task` assumes ownership of)
         * and completes the task (see g_task_return_pointer() for more
         * discussion of exactly what this means).
         *
         * Note that since the task takes ownership of `error,` and since the
         * task may be completed before returning from g_task_return_error(),
         * you cannot assume that `error` is still valid after calling this.
         * Call g_error_copy() on the error if you need to keep a local copy
         * as well.
         *
         * See also [method`Gio`.Task.return_new_error],
         * [method`Gio`.Task.return_new_error_literal].
         * @param error the #GError result of a task function.
         */
        return_error(error: GLib.Error): void;
        /**
         * Checks if `task'`s #GCancellable has been cancelled, and if so, sets
         * `task'`s error accordingly and completes the task (see
         * g_task_return_pointer() for more discussion of exactly what this
         * means).
         * @returns %TRUE if @task has been cancelled, %FALSE if not
         */
        return_error_if_cancelled(): boolean;
        /**
         * Sets `task'`s result to `result` and completes the task (see
         * g_task_return_pointer() for more discussion of exactly what this
         * means).
         * @param result the integer (#gssize) result of a task function.
         */
        return_int(result: number): void;
        /**
         * Sets `task`s result to a new [type`GLib`.Error] created from `domain,` `code,`
         * `message` and completes the task.
         *
         * See [method`Gio`.Task.return_pointer] for more discussion of exactly what
         * completing the task means.
         *
         * See also [method`Gio`.Task.return_new_error].
         * @param domain a #GQuark.
         * @param code an error code.
         * @param message an error message
         */
        return_new_error_literal(domain: GLib.Quark, code: number, message: string): void;
        /**
         * Sets `task'`s result to `result` and completes the task. If `result`
         * is not %NULL, then `result_destroy` will be used to free `result` if
         * the caller does not take ownership of it with
         * g_task_propagate_pointer().
         *
         * "Completes the task" means that for an ordinary asynchronous task
         * it will either invoke the task's callback, or else queue that
         * callback to be invoked in the proper #GMainContext, or in the next
         * iteration of the current #GMainContext. For a task run via
         * g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
         * method will save `result` to be returned to the caller later, but
         * the task will not actually be completed until the #GTaskThreadFunc
         * exits.
         *
         * Note that since the task may be completed before returning from
         * g_task_return_pointer(), you cannot assume that `result` is still
         * valid after calling this, unless you are still holding another
         * reference on it.
         * @param result the pointer result of a task     function
         * @param result_destroy a #GDestroyNotify function.
         */
        return_pointer(result?: any | null, result_destroy?: GLib.DestroyNotify | null): void;
        /**
         * Sets `task'`s result to `result` (by copying it) and completes the task.
         *
         * If `result` is %NULL then a #GValue of type %G_TYPE_POINTER
         * with a value of %NULL will be used for the result.
         *
         * This is a very generic low-level method intended primarily for use
         * by language bindings; for C code, g_task_return_pointer() and the
         * like will normally be much easier to use.
         * @param result the #GValue result of                                      a task function
         */
        return_value(result?: GObject.Value | null): void;
        /**
         * Runs `task_func` in another thread. When `task_func` returns, `task'`s
         * #GAsyncReadyCallback will be invoked in `task'`s #GMainContext.
         *
         * This takes a ref on `task` until the task completes.
         *
         * See #GTaskThreadFunc for more details about how `task_func` is handled.
         *
         * Although GLib currently rate-limits the tasks queued via
         * g_task_run_in_thread(), you should not assume that it will always
         * do this. If you have a very large number of tasks to run (several tens of
         * tasks), but don't want them to all run at once, you should only queue a
         * limited number of them (around ten) at a time.
         *
         * Be aware that if your task depends on other tasks to complete, use of this
         * function could lead to a livelock if the other tasks also use this function
         * and enough of them (around 10) execute in a dependency chain, as that will
         * exhaust the thread pool. If this situation is possible, consider using a
         * separate worker thread or thread pool explicitly, rather than using
         * g_task_run_in_thread().
         * @param task_func a #GTaskThreadFunc
         */
        run_in_thread(task_func: TaskThreadFunc): void;
        /**
         * Runs `task_func` in another thread, and waits for it to return or be
         * cancelled. You can use g_task_propagate_pointer(), etc, afterward
         * to get the result of `task_func`.
         *
         * See #GTaskThreadFunc for more details about how `task_func` is handled.
         *
         * Normally this is used with tasks created with a %NULL
         * `callback`, but note that even if the task does
         * have a callback, it will not be invoked when `task_func` returns.
         * #GTask:completed will be set to %TRUE just before this function returns.
         *
         * Although GLib currently rate-limits the tasks queued via
         * g_task_run_in_thread_sync(), you should not assume that it will
         * always do this. If you have a very large number of tasks to run,
         * but don't want them to all run at once, you should only queue a
         * limited number of them at a time.
         * @param task_func a #GTaskThreadFunc
         */
        run_in_thread_sync(task_func: TaskThreadFunc): void;
        /**
         * Sets or clears `task'`s check-cancellable flag. If this is %TRUE
         * (the default), then g_task_propagate_pointer(), etc, and
         * g_task_had_error() will check the task's #GCancellable first, and
         * if it has been cancelled, then they will consider the task to have
         * returned an "Operation was cancelled" error
         * (%G_IO_ERROR_CANCELLED), regardless of any other error or return
         * value the task may have had.
         *
         * If `check_cancellable` is %FALSE, then the #GTask will not check the
         * cancellable itself, and it is up to `task'`s owner to do this (eg,
         * via g_task_return_error_if_cancelled()).
         *
         * If you are using g_task_set_return_on_cancel() as well, then
         * you must leave check-cancellable set %TRUE.
         * @param check_cancellable whether #GTask will check the state of   its #GCancellable for you.
         */
        set_check_cancellable(check_cancellable: boolean): void;
        /**
         * Sets `task`s name, used in debugging and profiling. The name defaults to
         * %NULL.
         *
         * The task name should describe in a human readable way what the task does.
         * For example, Open file or Connect to network host. It is used to set the
         * name of the #GSource used for idle completion of the task.
         *
         * This function may only be called before the `task` is first used in a thread
         * other than the one it was constructed in. It is called automatically by
         * g_task_set_source_tag() if not called already.
         * @param name a human readable name for the task, or %NULL to unset it
         */
        set_name(name?: string | null): void;
        /**
         * Sets `task'`s priority. If you do not call this, it will default to
         * %G_PRIORITY_DEFAULT.
         *
         * This will affect the priority of #GSources created with
         * g_task_attach_source() and the scheduling of tasks run in threads,
         * and can also be explicitly retrieved later via
         * g_task_get_priority().
         * @param priority the [priority](iface.AsyncResult.html#io-priority) of the request
         */
        set_priority(priority: number): void;
        /**
         * Sets or clears `task'`s return-on-cancel flag. This is only
         * meaningful for tasks run via g_task_run_in_thread() or
         * g_task_run_in_thread_sync().
         *
         * If `return_on_cancel` is %TRUE, then cancelling `task'`s
         * #GCancellable will immediately cause it to return, as though the
         * task's #GTaskThreadFunc had called
         * g_task_return_error_if_cancelled() and then returned.
         *
         * This allows you to create a cancellable wrapper around an
         * uninterruptible function. The #GTaskThreadFunc just needs to be
         * careful that it does not modify any externally-visible state after
         * it has been cancelled. To do that, the thread should call
         * g_task_set_return_on_cancel() again to (atomically) set
         * return-on-cancel %FALSE before making externally-visible changes;
         * if the task gets cancelled before the return-on-cancel flag could
         * be changed, g_task_set_return_on_cancel() will indicate this by
         * returning %FALSE.
         *
         * You can disable and re-enable this flag multiple times if you wish.
         * If the task's #GCancellable is cancelled while return-on-cancel is
         * %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
         * again will cause the task to be cancelled at that point.
         *
         * If the task's #GCancellable is already cancelled before you call
         * g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
         * #GTaskThreadFunc will still be run (for consistency), but the task
         * will also be completed right away.
         * @param return_on_cancel whether the task returns automatically when   it is cancelled.
         * @returns %TRUE if @task's return-on-cancel flag was changed to   match @return_on_cancel. %FALSE if @task has already been   cancelled.
         */
        set_return_on_cancel(return_on_cancel: boolean): boolean;
        /**
         * Sets `task'`s source tag.
         *
         * You can use this to tag a task return
         * value with a particular pointer (usually a pointer to the function
         * doing the tagging) and then later check it using
         * g_task_get_source_tag() (or g_async_result_is_tagged()) in the
         * task's "finish" function, to figure out if the response came from a
         * particular place.
         *
         * A macro wrapper around this function will automatically set the
         * tasks name to the string form of `source_tag` if its not already
         * set, for convenience.
         * @param source_tag an opaque pointer indicating the source of this task
         */
        set_source_tag(source_tag?: any | null): void;
        /**
         * Sets `task`s name, used in debugging and profiling.
         *
         * This is a variant of g_task_set_name() that avoids copying `name`.
         * @param name a human readable name for the task. Must be a string literal
         */
        set_static_name(name?: string | null): void;
        /**
         * Sets `task'`s task data (freeing the existing task data, if any).
         * @param task_data task-specific data
         * @param task_data_destroy #GDestroyNotify for @task_data
         */
        set_task_data(task_data?: any | null, task_data_destroy?: GLib.DestroyNotify | null): void;

        // Inherited methods
        /**
         * Gets the user data from a #GAsyncResult.
         * @returns the user data for @res.
         */
        get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @param source_tag an application-defined tag
         * @returns %TRUE if @res has the indicated @source_tag, %FALSE if   not.
         */
        is_tagged(source_tag?: any | null): boolean;
        /**
         * If `res` is a #GSimpleAsyncResult, this is equivalent to
         * g_simple_async_result_propagate_error(). Otherwise it returns
         * %FALSE.
         *
         * This can be used for legacy error handling in async *_finish()
         * wrapper functions that traditionally handled #GSimpleAsyncResult
         * error returns themselves rather than calling into the virtual method.
         * This should not be used in new code; #GAsyncResult errors that are
         * set by virtual methods should also be extracted by virtual methods,
         * to enable subclasses to chain up correctly.
         * @returns %TRUE if @error is has been filled in with an error from   @res, %FALSE if not.
         */
        legacy_propagate_error(): boolean;
        /**
         * Gets the source object from a #GAsyncResult.
         */
        vfunc_get_source_object<T = GObject.Object>(): T;
        /**
         * Gets the user data from a #GAsyncResult.
         */
        vfunc_get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @param source_tag an application-defined tag
         */
        vfunc_is_tagged(source_tag?: any | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module TcpConnection {
        // Constructor properties interface

        interface ConstructorProps extends SocketConnection.ConstructorProps {
            graceful_disconnect: boolean;
            gracefulDisconnect: boolean;
        }
    }

    /**
     * This is the subclass of [class`Gio`.SocketConnection] that is created
     * for TCP/IP sockets.
     */
    class TcpConnection extends SocketConnection {
        static $gtype: GObject.GType<TcpConnection>;

        // Properties

        /**
         * Whether [method`Gio`.IOStream.close] does a graceful disconnect.
         */
        get graceful_disconnect(): boolean;
        set graceful_disconnect(val: boolean);
        /**
         * Whether [method`Gio`.IOStream.close] does a graceful disconnect.
         */
        get gracefulDisconnect(): boolean;
        set gracefulDisconnect(val: boolean);

        // Constructors

        constructor(properties?: Partial<TcpConnection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Checks if graceful disconnects are used. See
         * g_tcp_connection_set_graceful_disconnect().
         * @returns %TRUE if graceful disconnect is used on close, %FALSE otherwise
         */
        get_graceful_disconnect(): boolean;
        /**
         * This enables graceful disconnects on close. A graceful disconnect
         * means that we signal the receiving end that the connection is terminated
         * and wait for it to close the connection before closing the connection.
         *
         * A graceful disconnect means that we can be sure that we successfully sent
         * all the outstanding data to the other end, or get an error reported.
         * However, it also means we have to wait for all the data to reach the
         * other side and for it to acknowledge this by closing the socket, which may
         * take a while. For this reason it is disabled by default.
         * @param graceful_disconnect Whether to do graceful disconnects or not
         */
        set_graceful_disconnect(graceful_disconnect: boolean): void;
    }

    module TcpWrapperConnection {
        // Constructor properties interface

        interface ConstructorProps extends TcpConnection.ConstructorProps {
            base_io_stream: IOStream;
            baseIoStream: IOStream;
        }
    }

    /**
     * A `GTcpWrapperConnection` can be used to wrap a [class`Gio`.IOStream] that is
     * based on a [class`Gio`.Socket], but which is not actually a
     * [class`Gio`.SocketConnection]. This is used by [class`Gio`.SocketClient] so
     * that it can always return a [class`Gio`.SocketConnection], even when the
     * connection it has actually created is not directly a
     * [class`Gio`.SocketConnection].
     */
    class TcpWrapperConnection extends TcpConnection {
        static $gtype: GObject.GType<TcpWrapperConnection>;

        // Properties

        /**
         * The wrapped [class`Gio`.IOStream].
         */
        get base_io_stream(): IOStream;
        /**
         * The wrapped [class`Gio`.IOStream].
         */
        get baseIoStream(): IOStream;

        // Constructors

        constructor(properties?: Partial<TcpWrapperConnection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](base_io_stream: IOStream, socket: Socket): TcpWrapperConnection;

        // Methods

        /**
         * Gets `conn'`s base #GIOStream
         * @returns @conn's base #GIOStream
         */
        get_base_io_stream(): IOStream;
    }

    module TestDBus {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            flags: TestDBusFlags;
        }
    }

    /**
     * A helper class for testing code which uses D-Bus without touching the users
     * session bus.
     *
     * Note that `GTestDBus` modifies the users environment, calling
     * [`setenv()`](man:setenv(3)). This is not thread-safe, so all `GTestDBus`
     * calls should be completed before threads are spawned, or should have
     * appropriate locking to ensure no access conflicts to environment variables
     * shared between `GTestDBus` and other threads.
     *
     * ## Creating unit tests using `GTestDBus`
     *
     * Testing of D-Bus services can be tricky because normally we only ever run
     * D-Bus services over an existing instance of the D-Bus daemon thus we
     * usually dont activate D-Bus services that are not yet installed into the
     * target system. The `GTestDBus` object makes this easier for us by taking care
     * of the lower level tasks such as running a private D-Bus daemon and looking
     * up uninstalled services in customizable locations, typically in your source
     * code tree.
     *
     * The first thing you will need is a separate service description file for the
     * D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
     * is a good place to put this file.
     *
     * The service file should list your service along with an absolute path to the
     * uninstalled service executable in your source tree. Using autotools we would
     * achieve this by adding a file such as `my-server.service.in` in the services
     * directory and have it processed by configure.
     *
     * ```
     * [D-BUS Service]
     * Name=org.gtk.GDBus.Examples.ObjectManager
     * Exec=`abs_top_builddir@`/gio/tests/gdbus-example-objectmanager-server
     * ```
     *
     * You will also need to indicate this service directory in your test
     * fixtures, so you will need to pass the path while compiling your
     * test cases. Typically this is done with autotools with an added
     * preprocessor flag specified to compile your tests such as:
     *
     * ```
     * -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
     * ```
     *
     * Once you have a service definition file which is local to your source tree,
     * you can proceed to set up a GTest fixture using the `GTestDBus` scaffolding.
     *
     * An example of a test fixture for D-Bus services can be found
     * here:
     * [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)
     *
     * Note that these examples only deal with isolating the D-Bus aspect of your
     * service. To successfully run isolated unit tests on your service you may need
     * some additional modifications to your test case fixture. For example; if your
     * service uses [class`Gio`.Settings] and installs a schema then it is important
     * that your test service not load the schema in the ordinary installed location
     * (chances are that your service and schema files are not yet installed, or
     * worse; there is an older version of the schema file sitting in the install
     * location).
     *
     * Most of the time we can work around these obstacles using the
     * environment. Since the environment is inherited by the D-Bus daemon
     * created by `GTestDBus` and then in turn inherited by any services the
     * D-Bus daemon activates, using the setup routine for your fixture is
     * a practical place to help sandbox your runtime environment. For the
     * rather typical GSettings case we can work around this by setting
     * `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
     * in the above `fixture_setup()` routine.
     *
     * The GSettings schemas need to be locally pre-compiled for this to work. This
     * can be achieved by compiling the schemas locally as a step before running
     * test cases, an autotools setup might do the following in the directory
     * holding schemas:
     *
     * ```
     *     all-am:
     *             $(GLIB_COMPILE_SCHEMAS) .
     *
     *     CLEANFILES += gschemas.compiled
     * ```
     */
    class TestDBus extends GObject.Object {
        static $gtype: GObject.GType<TestDBus>;

        // Properties

        /**
         * #GTestDBusFlags specifying the behaviour of the D-Bus session.
         */
        get flags(): TestDBusFlags;

        // Constructors

        constructor(properties?: Partial<TestDBus.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](flags: TestDBusFlags): TestDBus;

        // Static methods

        /**
         * Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
         * won't use user's session bus.
         *
         * This is useful for unit tests that want to verify behaviour when no session
         * bus is running. It is not necessary to call this if unit test already calls
         * g_test_dbus_up() before acquiring the session bus.
         */
        static unset(): void;

        // Methods

        /**
         * Add a path where dbus-daemon will look up .service files. This can't be
         * called after g_test_dbus_up().
         * @param path path to a directory containing .service files
         */
        add_service_dir(path: string): void;
        /**
         * Stop the session bus started by g_test_dbus_up().
         *
         * This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
         * to be destroyed. This is done to ensure that the next unit test won't get a
         * leaked singleton from this test.
         */
        down(): void;
        /**
         * Get the address on which dbus-daemon is running. If g_test_dbus_up() has not
         * been called yet, %NULL is returned. This can be used with
         * g_dbus_connection_new_for_address().
         * @returns the address of the bus, or %NULL.
         */
        get_bus_address(): string | null;
        /**
         * Get the flags of the #GTestDBus object.
         * @returns the value of #GTestDBus:flags property
         */
        get_flags(): TestDBusFlags;
        /**
         * Stop the session bus started by g_test_dbus_up().
         *
         * Unlike g_test_dbus_down(), this won't verify the #GDBusConnection
         * singleton returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit
         * tests wanting to verify behaviour after the session bus has been stopped
         * can use this function but should still call g_test_dbus_down() when done.
         */
        stop(): void;
        /**
         * Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
         * call, it is safe for unit tests to start sending messages on the session bus.
         *
         * If this function is called from setup callback of g_test_add(),
         * g_test_dbus_down() must be called in its teardown callback.
         *
         * If this function is called from unit test's main(), then g_test_dbus_down()
         * must be called after g_test_run().
         */
        up(): void;
    }

    module ThemedIcon {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Icon.ConstructorProps {
            name: string;
            names: string[];
            use_default_fallbacks: boolean;
            useDefaultFallbacks: boolean;
        }
    }

    /**
     * `GThemedIcon` is an implementation of [iface`Gio`.Icon] that supports icon
     * themes.
     *
     * `GThemedIcon` contains a list of all of the icons present in an icon
     * theme, so that icons can be looked up quickly. `GThemedIcon` does
     * not provide actual pixmaps for icons, just the icon names.
     * Ideally something like [method`Gtk`.IconTheme.choose_icon] should be used to
     * resolve the list of names so that fallback icons work nicely with
     * themes that inherit other themes.
     */
    class ThemedIcon extends GObject.Object implements Icon {
        static $gtype: GObject.GType<ThemedIcon>;

        // Properties

        /**
         * The icon name.
         */
        set name(val: string);
        /**
         * A %NULL-terminated array of icon names.
         */
        get names(): string[];
        /**
         * Whether to use the default fallbacks found by shortening the icon name
         * at '-' characters. If the "names" array has more than one element,
         * ignores any past the first.
         *
         * For example, if the icon name was "gnome-dev-cdrom-audio", the array
         * would become
         *
         * ```c
         * {
         *   "gnome-dev-cdrom-audio",
         *   "gnome-dev-cdrom",
         *   "gnome-dev",
         *   "gnome",
         *   NULL
         * };
         * ```
         *
         */
        get use_default_fallbacks(): boolean;
        /**
         * Whether to use the default fallbacks found by shortening the icon name
         * at '-' characters. If the "names" array has more than one element,
         * ignores any past the first.
         *
         * For example, if the icon name was "gnome-dev-cdrom-audio", the array
         * would become
         *
         * ```c
         * {
         *   "gnome-dev-cdrom-audio",
         *   "gnome-dev-cdrom",
         *   "gnome-dev",
         *   "gnome",
         *   NULL
         * };
         * ```
         *
         */
        get useDefaultFallbacks(): boolean;

        // Constructors

        constructor(properties?: Partial<ThemedIcon.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](iconname: string): ThemedIcon;

        static new_from_names(iconnames: string[]): ThemedIcon;

        static new_with_default_fallbacks(iconname: string): ThemedIcon;

        // Methods

        /**
         * Append a name to the list of icons from within `icon`.
         *
         * Note that doing so invalidates the hash computed by prior calls
         * to g_icon_hash().
         * @param iconname name of icon to append to list of icons from within @icon.
         */
        append_name(iconname: string): void;
        /**
         * Gets the names of icons from within `icon`.
         * @returns a list of icon names.
         */
        get_names(): string[];
        /**
         * Prepend a name to the list of icons from within `icon`.
         *
         * Note that doing so invalidates the hash computed by prior calls
         * to g_icon_hash().
         * @param iconname name of icon to prepend to list of icons from within @icon.
         */
        prepend_name(iconname: string): void;

        // Inherited methods
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @returns a #guint containing a hash for the @icon, suitable for   use in a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        serialize(): GLib.Variant | null;
        /**
         * Generates a textual representation of `icon` that can be used for
         * serialization such as when passing `icon` to a different process or
         * saving it to persistent storage. Use g_icon_new_for_string() to
         * get `icon` back from the returned string.
         *
         * The encoding of the returned string is proprietary to #GIcon except
         * in the following two cases
         *
         * - If `icon` is a #GFileIcon, the returned string is a native path
         *   (such as `/path/to/my icon.png`) without escaping
         *   if the #GFile for `icon` is a native file.  If the file is not
         *   native, the returned string is the result of g_file_get_uri()
         *   (such as `sftp://path/to/my%20icon.png`).
         *
         * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
         *   the encoding is simply the name (such as `network-server`).
         * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
         */
        to_string(): string | null;
        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         */
        vfunc_equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         */
        vfunc_hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         */
        vfunc_serialize(): GLib.Variant | null;
        /**
         * Serializes the `icon` into string tokens.
         * This is can be invoked when g_icon_new_for_string() is called.
         */
        vfunc_to_tokens(): [boolean, string[], number];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ThreadedResolver {
        // Constructor properties interface

        interface ConstructorProps extends Resolver.ConstructorProps {}
    }

    /**
     * #GThreadedResolver is an implementation of #GResolver which calls the libc
     * lookup functions in threads to allow them to run asynchronously.
     */
    class ThreadedResolver extends Resolver {
        static $gtype: GObject.GType<ThreadedResolver>;

        // Constructors

        constructor(properties?: Partial<ThreadedResolver.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    module ThreadedSocketService {
        // Signal callback interfaces

        interface Run {
            (connection: SocketConnection, source_object?: GObject.Object | null): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends SocketService.ConstructorProps {
            max_threads: number;
            maxThreads: number;
        }
    }

    /**
     * A `GThreadedSocketService` is a simple subclass of [class`Gio`.SocketService]
     * that handles incoming connections by creating a worker thread and
     * dispatching the connection to it by emitting the
     * [signal`Gio`.ThreadedSocketService::run signal] in the new thread.
     *
     * The signal handler may perform blocking I/O and need not return
     * until the connection is closed.
     *
     * The service is implemented using a thread pool, so there is a
     * limited amount of threads available to serve incoming requests.
     * The service automatically stops the [class`Gio`.SocketService] from accepting
     * new connections when all threads are busy.
     *
     * As with [class`Gio`.SocketService], you may connect to
     * [signal`Gio`.ThreadedSocketService::run], or subclass and override the default
     * handler.
     */
    class ThreadedSocketService extends SocketService {
        static $gtype: GObject.GType<ThreadedSocketService>;

        // Properties

        /**
         * The maximum number of threads handling clients for this service.
         */
        get max_threads(): number;
        /**
         * The maximum number of threads handling clients for this service.
         */
        get maxThreads(): number;

        // Constructors

        constructor(properties?: Partial<ThreadedSocketService.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](max_threads: number): ThreadedSocketService;
        // Conflicted with Gio.SocketService.new

        static ['new'](...args: never[]): any;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'run',
            callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean,
        ): number;
        connect_after(
            signal: 'run',
            callback: (_source: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean,
        ): number;
        emit(signal: 'run', connection: SocketConnection, source_object?: GObject.Object | null): void;

        // Virtual methods

        vfunc_run(connection: SocketConnection, source_object: GObject.Object): boolean;
    }

    module TlsCertificate {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            certificate: Uint8Array;
            certificate_pem: string;
            certificatePem: string;
            dns_names: any[];
            dnsNames: any[];
            ip_addresses: any[];
            ipAddresses: any[];
            issuer: TlsCertificate;
            issuer_name: string;
            issuerName: string;
            not_valid_after: GLib.DateTime;
            notValidAfter: GLib.DateTime;
            not_valid_before: GLib.DateTime;
            notValidBefore: GLib.DateTime;
            password: string;
            pkcs11_uri: string;
            pkcs11Uri: string;
            pkcs12_data: Uint8Array;
            pkcs12Data: Uint8Array;
            private_key: Uint8Array;
            privateKey: Uint8Array;
            private_key_pem: string;
            privateKeyPem: string;
            private_key_pkcs11_uri: string;
            privateKeyPkcs11Uri: string;
            subject_name: string;
            subjectName: string;
        }
    }

    /**
     * A certificate used for TLS authentication and encryption.
     * This can represent either a certificate only (eg, the certificate
     * received by a client from a server), or the combination of
     * a certificate and a private key (which is needed when acting as a
     * [iface`Gio`.TlsServerConnection]).
     */
    abstract class TlsCertificate extends GObject.Object {
        static $gtype: GObject.GType<TlsCertificate>;

        // Properties

        /**
         * The DER (binary) encoded representation of the certificate.
         * This property and the #GTlsCertificate:certificate-pem property
         * represent the same data, just in different forms.
         */
        get certificate(): Uint8Array;
        /**
         * The PEM (ASCII) encoded representation of the certificate.
         * This property and the #GTlsCertificate:certificate
         * property represent the same data, just in different forms.
         */
        get certificate_pem(): string;
        /**
         * The PEM (ASCII) encoded representation of the certificate.
         * This property and the #GTlsCertificate:certificate
         * property represent the same data, just in different forms.
         */
        get certificatePem(): string;
        /**
         * The DNS names from the certificate's Subject Alternative Names (SANs),
         * %NULL if unavailable.
         */
        get dns_names(): any[];
        /**
         * The DNS names from the certificate's Subject Alternative Names (SANs),
         * %NULL if unavailable.
         */
        get dnsNames(): any[];
        /**
         * The IP addresses from the certificate's Subject Alternative Names (SANs),
         * %NULL if unavailable.
         */
        get ip_addresses(): any[];
        /**
         * The IP addresses from the certificate's Subject Alternative Names (SANs),
         * %NULL if unavailable.
         */
        get ipAddresses(): any[];
        /**
         * A #GTlsCertificate representing the entity that issued this
         * certificate. If %NULL, this means that the certificate is either
         * self-signed, or else the certificate of the issuer is not
         * available.
         *
         * Beware the issuer certificate may not be the same as the
         * certificate that would actually be used to construct a valid
         * certification path during certificate verification.
         * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
         * why an issuer certificate cannot be naively assumed to be part of the
         * the certification path (though GLib's TLS backends may not follow the
         * path building strategies outlined in this RFC). Due to the complexity
         * of certification path building, GLib does not provide any way to know
         * which certification path will actually be used. Accordingly, this
         * property cannot be used to make security-related decisions. Only
         * GLib itself should make security decisions about TLS certificates.
         */
        get issuer(): TlsCertificate;
        /**
         * The issuer from the certificate,
         * %NULL if unavailable.
         */
        get issuer_name(): string;
        /**
         * The issuer from the certificate,
         * %NULL if unavailable.
         */
        get issuerName(): string;
        /**
         * The time at which this cert is no longer valid,
         * %NULL if unavailable.
         */
        get not_valid_after(): GLib.DateTime;
        /**
         * The time at which this cert is no longer valid,
         * %NULL if unavailable.
         */
        get notValidAfter(): GLib.DateTime;
        /**
         * The time at which this cert is considered to be valid,
         * %NULL if unavailable.
         */
        get not_valid_before(): GLib.DateTime;
        /**
         * The time at which this cert is considered to be valid,
         * %NULL if unavailable.
         */
        get notValidBefore(): GLib.DateTime;
        /**
         * An optional password used when constructed with GTlsCertificate:pkcs12-data.
         */
        set password(val: string);
        /**
         * A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * objects containing an X.509 certificate and optionally a private key.
         *
         * If %NULL, the certificate is either not backed by PKCS \#11 or the
         * #GTlsBackend does not support PKCS \#11.
         */
        get pkcs11_uri(): string;
        /**
         * A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * objects containing an X.509 certificate and optionally a private key.
         *
         * If %NULL, the certificate is either not backed by PKCS \#11 or the
         * #GTlsBackend does not support PKCS \#11.
         */
        get pkcs11Uri(): string;
        /**
         * The PKCS #12 formatted data used to construct the object.
         *
         * See also: g_tls_certificate_new_from_pkcs12()
         */
        set pkcs12_data(val: Uint8Array);
        /**
         * The PKCS #12 formatted data used to construct the object.
         *
         * See also: g_tls_certificate_new_from_pkcs12()
         */
        set pkcs12Data(val: Uint8Array);
        /**
         * The DER (binary) encoded representation of the certificate's
         * private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
         * PKCS \#8 format is supported since 2.32; earlier releases only
         * support PKCS \#1. You can use the `openssl rsa` tool to convert
         * PKCS \#8 keys to PKCS \#1.
         *
         * This property (or the #GTlsCertificate:private-key-pem property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI  for example, if it
         * is stored on a smartcard  then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        get private_key(): Uint8Array;
        /**
         * The DER (binary) encoded representation of the certificate's
         * private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
         * PKCS \#8 format is supported since 2.32; earlier releases only
         * support PKCS \#1. You can use the `openssl rsa` tool to convert
         * PKCS \#8 keys to PKCS \#1.
         *
         * This property (or the #GTlsCertificate:private-key-pem property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI  for example, if it
         * is stored on a smartcard  then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        get privateKey(): Uint8Array;
        /**
         * The PEM (ASCII) encoded representation of the certificate's
         * private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * ("`BEGIN RSA PRIVATE KEY`") or unencrypted
         * [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
         * ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
         * earlier releases only support PKCS \#1. You can use the `openssl rsa`
         * tool to convert PKCS \#8 keys to PKCS \#1.
         *
         * This property (or the #GTlsCertificate:private-key property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI - for example, if it
         * is stored on a smartcard - then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        get private_key_pem(): string;
        /**
         * The PEM (ASCII) encoded representation of the certificate's
         * private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * ("`BEGIN RSA PRIVATE KEY`") or unencrypted
         * [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
         * ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
         * earlier releases only support PKCS \#1. You can use the `openssl rsa`
         * tool to convert PKCS \#8 keys to PKCS \#1.
         *
         * This property (or the #GTlsCertificate:private-key property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI - for example, if it
         * is stored on a smartcard - then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        get privateKeyPem(): string;
        /**
         * A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * object containing a private key.
         */
        get private_key_pkcs11_uri(): string;
        /**
         * A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * object containing a private key.
         */
        get privateKeyPkcs11Uri(): string;
        /**
         * The subject from the cert,
         * %NULL if unavailable.
         */
        get subject_name(): string;
        /**
         * The subject from the cert,
         * %NULL if unavailable.
         */
        get subjectName(): string;

        // Constructors

        constructor(properties?: Partial<TlsCertificate.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_from_file(file: string): TlsCertificate;

        static new_from_file_with_password(file: string, password: string): TlsCertificate;

        static new_from_files(cert_file: string, key_file: string): TlsCertificate;

        static new_from_pem(data: string, length: number): TlsCertificate;

        static new_from_pkcs11_uris(pkcs11_uri: string, private_key_pkcs11_uri?: string | null): TlsCertificate;

        static new_from_pkcs12(data: Uint8Array | string, password?: string | null): TlsCertificate;

        // Static methods

        /**
         * Creates one or more #GTlsCertificates from the PEM-encoded
         * data in `file`. If `file` cannot be read or parsed, the function will
         * return %NULL and set `error`. If `file` does not contain any
         * PEM-encoded certificates, this will return an empty list and not
         * set `error`.
         * @param file file containing PEM-encoded certificates to import
         */
        static list_new_from_file(file: string): TlsCertificate[];

        // Virtual methods

        /**
         * This verifies `cert` and returns a set of #GTlsCertificateFlags
         * indicating any problems found with it. This can be used to verify a
         * certificate outside the context of making a connection, or to
         * check a certificate against a CA that is not part of the system
         * CA database.
         *
         * If `cert` is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
         *
         * If `identity` is not %NULL, `cert'`s name(s) will be compared against
         * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
         * value if it does not match. If `identity` is %NULL, that bit will
         * never be set in the return value.
         *
         * If `trusted_ca` is not %NULL, then `cert` (or one of the certificates
         * in its chain) must be signed by it, or else
         * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
         * `trusted_ca` is %NULL, that bit will never be set in the return
         * value.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Because TLS session context is not used, #GTlsCertificate may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         * @param identity the expected peer identity
         * @param trusted_ca the certificate of a trusted authority
         */
        vfunc_verify(identity?: SocketConnectable | null, trusted_ca?: TlsCertificate | null): TlsCertificateFlags;

        // Methods

        /**
         * Gets the value of #GTlsCertificate:dns-names.
         * @returns A #GPtrArray of #GBytes elements, or %NULL if it's not available.
         */
        get_dns_names(): GLib.Bytes[] | null;
        /**
         * Gets the value of #GTlsCertificate:ip-addresses.
         * @returns A #GPtrArray of #GInetAddress elements, or %NULL if it's not available.
         */
        get_ip_addresses(): InetAddress[] | null;
        /**
         * Gets the #GTlsCertificate representing `cert'`s issuer, if known
         * @returns The certificate of @cert's issuer, or %NULL if @cert is self-signed or signed with an unknown certificate.
         */
        get_issuer(): TlsCertificate | null;
        /**
         * Returns the issuer name from the certificate.
         * @returns The issuer name, or %NULL if it's not available.
         */
        get_issuer_name(): string | null;
        /**
         * Returns the time at which the certificate became or will become invalid.
         * @returns The not-valid-after date, or %NULL if it's not available.
         */
        get_not_valid_after(): GLib.DateTime | null;
        /**
         * Returns the time at which the certificate became or will become valid.
         * @returns The not-valid-before date, or %NULL if it's not available.
         */
        get_not_valid_before(): GLib.DateTime | null;
        /**
         * Returns the subject name from the certificate.
         * @returns The subject name, or %NULL if it's not available.
         */
        get_subject_name(): string | null;
        /**
         * Check if two #GTlsCertificate objects represent the same certificate.
         * The raw DER byte data of the two certificates are checked for equality.
         * This has the effect that two certificates may compare equal even if
         * their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
         * #GTlsCertificate:private-key-pem properties differ.
         * @param cert_two second certificate to compare
         * @returns whether the same or not
         */
        is_same(cert_two: TlsCertificate): boolean;
        /**
         * This verifies `cert` and returns a set of #GTlsCertificateFlags
         * indicating any problems found with it. This can be used to verify a
         * certificate outside the context of making a connection, or to
         * check a certificate against a CA that is not part of the system
         * CA database.
         *
         * If `cert` is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
         *
         * If `identity` is not %NULL, `cert'`s name(s) will be compared against
         * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
         * value if it does not match. If `identity` is %NULL, that bit will
         * never be set in the return value.
         *
         * If `trusted_ca` is not %NULL, then `cert` (or one of the certificates
         * in its chain) must be signed by it, or else
         * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
         * `trusted_ca` is %NULL, that bit will never be set in the return
         * value.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Because TLS session context is not used, #GTlsCertificate may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         * @param identity the expected peer identity
         * @param trusted_ca the certificate of a trusted authority
         * @returns the appropriate #GTlsCertificateFlags
         */
        verify(identity?: SocketConnectable | null, trusted_ca?: TlsCertificate | null): TlsCertificateFlags;
    }

    module TlsConnection {
        // Signal callback interfaces

        interface AcceptCertificate {
            (peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends IOStream.ConstructorProps {
            advertised_protocols: string[];
            advertisedProtocols: string[];
            base_io_stream: IOStream;
            baseIoStream: IOStream;
            certificate: TlsCertificate;
            ciphersuite_name: string;
            ciphersuiteName: string;
            database: TlsDatabase;
            interaction: TlsInteraction;
            negotiated_protocol: string;
            negotiatedProtocol: string;
            peer_certificate: TlsCertificate;
            peerCertificate: TlsCertificate;
            peer_certificate_errors: TlsCertificateFlags;
            peerCertificateErrors: TlsCertificateFlags;
            protocol_version: TlsProtocolVersion;
            protocolVersion: TlsProtocolVersion;
            rehandshake_mode: TlsRehandshakeMode;
            rehandshakeMode: TlsRehandshakeMode;
            require_close_notify: boolean;
            requireCloseNotify: boolean;
            use_system_certdb: boolean;
            useSystemCertdb: boolean;
        }
    }

    /**
     * `GTlsConnection` is the base TLS connection class type, which wraps
     * a [class`Gio`.IOStream] and provides TLS encryption on top of it. Its
     * subclasses, [iface`Gio`.TlsClientConnection] and
     * [iface`Gio`.TlsServerConnection], implement client-side and server-side TLS,
     * respectively.
     *
     * For DTLS (Datagram TLS) support, see [iface`Gio`.DtlsConnection].
     */
    abstract class TlsConnection extends IOStream {
        static $gtype: GObject.GType<TlsConnection>;

        // Properties

        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_tls_connection_set_advertised_protocols().
         */
        get advertised_protocols(): string[];
        set advertised_protocols(val: string[]);
        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_tls_connection_set_advertised_protocols().
         */
        get advertisedProtocols(): string[];
        set advertisedProtocols(val: string[]);
        /**
         * The #GIOStream that the connection wraps. The connection holds a reference
         * to this stream, and may run operations on the stream from other threads
         * throughout its lifetime. Consequently, after the #GIOStream has been
         * constructed, application code may only run its own operations on this
         * stream when no #GIOStream operations are running.
         */
        get base_io_stream(): IOStream;
        /**
         * The #GIOStream that the connection wraps. The connection holds a reference
         * to this stream, and may run operations on the stream from other threads
         * throughout its lifetime. Consequently, after the #GIOStream has been
         * constructed, application code may only run its own operations on this
         * stream when no #GIOStream operations are running.
         */
        get baseIoStream(): IOStream;
        /**
         * The connection's certificate; see
         * g_tls_connection_set_certificate().
         */
        get certificate(): TlsCertificate;
        set certificate(val: TlsCertificate);
        /**
         * The name of the TLS ciphersuite in use. See g_tls_connection_get_ciphersuite_name().
         */
        get ciphersuite_name(): string;
        /**
         * The name of the TLS ciphersuite in use. See g_tls_connection_get_ciphersuite_name().
         */
        get ciphersuiteName(): string;
        /**
         * The certificate database to use when verifying this TLS connection.
         * If no certificate database is set, then the default database will be
         * used. See g_tls_backend_get_default_database().
         *
         * When using a non-default database, #GTlsConnection must fall back to using
         * the #GTlsDatabase to perform certificate verification using
         * g_tls_database_verify_chain(), which means certificate verification will
         * not be able to make use of TLS session context. This may be less secure.
         * For example, if you create your own #GTlsDatabase that just wraps the
         * default #GTlsDatabase, you might expect that you have not changed anything,
         * but this is not true because you may have altered the behavior of
         * #GTlsConnection by causing it to use g_tls_database_verify_chain(). See the
         * documentation of g_tls_database_verify_chain() for more details on specific
         * security checks that may not be performed. Accordingly, setting a
         * non-default database is discouraged except for specialty applications with
         * unusual security requirements.
         */
        get database(): TlsDatabase;
        set database(val: TlsDatabase);
        /**
         * A #GTlsInteraction object to be used when the connection or certificate
         * database need to interact with the user. This will be used to prompt the
         * user for passwords where necessary.
         */
        get interaction(): TlsInteraction;
        set interaction(val: TlsInteraction);
        /**
         * The application-layer protocol negotiated during the TLS
         * handshake. See g_tls_connection_get_negotiated_protocol().
         */
        get negotiated_protocol(): string;
        /**
         * The application-layer protocol negotiated during the TLS
         * handshake. See g_tls_connection_get_negotiated_protocol().
         */
        get negotiatedProtocol(): string;
        /**
         * The connection's peer's certificate, after the TLS handshake has
         * completed or failed. Note in particular that this is not yet set
         * during the emission of #GTlsConnection::accept-certificate.
         *
         * (You can watch for a #GObject::notify signal on this property to
         * detect when a handshake has occurred.)
         */
        get peer_certificate(): TlsCertificate;
        /**
         * The connection's peer's certificate, after the TLS handshake has
         * completed or failed. Note in particular that this is not yet set
         * during the emission of #GTlsConnection::accept-certificate.
         *
         * (You can watch for a #GObject::notify signal on this property to
         * detect when a handshake has occurred.)
         */
        get peerCertificate(): TlsCertificate;
        /**
         * The errors noticed while verifying
         * #GTlsConnection:peer-certificate. Normally this should be 0, but
         * it may not be if #GTlsClientConnection:validation-flags is not
         * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
         * #GTlsConnection::accept-certificate overrode the default
         * behavior.
         *
         * GLib guarantees that if certificate verification fails, at least
         * one error will be set, but it does not guarantee that all possible
         * errors will be set. Accordingly, you may not safely decide to
         * ignore any particular type of error. For example, it would be
         * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         */
        get peer_certificate_errors(): TlsCertificateFlags;
        /**
         * The errors noticed while verifying
         * #GTlsConnection:peer-certificate. Normally this should be 0, but
         * it may not be if #GTlsClientConnection:validation-flags is not
         * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
         * #GTlsConnection::accept-certificate overrode the default
         * behavior.
         *
         * GLib guarantees that if certificate verification fails, at least
         * one error will be set, but it does not guarantee that all possible
         * errors will be set. Accordingly, you may not safely decide to
         * ignore any particular type of error. For example, it would be
         * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         */
        get peerCertificateErrors(): TlsCertificateFlags;
        /**
         * The TLS protocol version in use. See g_tls_connection_get_protocol_version().
         */
        get protocol_version(): TlsProtocolVersion;
        /**
         * The TLS protocol version in use. See g_tls_connection_get_protocol_version().
         */
        get protocolVersion(): TlsProtocolVersion;
        /**
         * The rehandshaking mode. See
         * g_tls_connection_set_rehandshake_mode().
         */
        get rehandshake_mode(): TlsRehandshakeMode;
        set rehandshake_mode(val: TlsRehandshakeMode);
        /**
         * The rehandshaking mode. See
         * g_tls_connection_set_rehandshake_mode().
         */
        get rehandshakeMode(): TlsRehandshakeMode;
        set rehandshakeMode(val: TlsRehandshakeMode);
        /**
         * Whether or not proper TLS close notification is required.
         * See g_tls_connection_set_require_close_notify().
         */
        get require_close_notify(): boolean;
        set require_close_notify(val: boolean);
        /**
         * Whether or not proper TLS close notification is required.
         * See g_tls_connection_set_require_close_notify().
         */
        get requireCloseNotify(): boolean;
        set requireCloseNotify(val: boolean);
        /**
         * Whether or not the system certificate database will be used to
         * verify peer certificates. See
         * g_tls_connection_set_use_system_certdb().
         */
        get use_system_certdb(): boolean;
        set use_system_certdb(val: boolean);
        /**
         * Whether or not the system certificate database will be used to
         * verify peer certificates. See
         * g_tls_connection_set_use_system_certdb().
         */
        get useSystemCertdb(): boolean;
        set useSystemCertdb(val: boolean);

        // Constructors

        constructor(properties?: Partial<TlsConnection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'accept-certificate',
            callback: (_source: this, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean,
        ): number;
        connect_after(
            signal: 'accept-certificate',
            callback: (_source: this, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean,
        ): number;
        emit(signal: 'accept-certificate', peer_cert: TlsCertificate, errors: TlsCertificateFlags): void;

        // Virtual methods

        /**
         * Check whether to accept a certificate.
         * @param peer_cert
         * @param errors
         */
        vfunc_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
        /**
         * Retrieve TLS channel binding data (Since: 2.66)
         * @param type
         * @param data
         */
        vfunc_get_binding_data(type: TlsChannelBindingType, data: Uint8Array | string): boolean;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_tls_connection_set_advertised_protocols().
         */
        vfunc_get_negotiated_protocol(): string | null;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting (or after sending a "STARTTLS"-type command),
         * #GTlsConnection will handle this for you automatically when you try
         * to send or receive data on the connection. You can call
         * g_tls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before or
         * after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_tls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * When using a #GTlsConnection created by #GSocketClient, the
         * #GSocketClient performs the initial handshake, so calling this
         * function manually is not recommended.
         *
         * #GTlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_handshake(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_tls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        vfunc_handshake_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_tls_connection_handshake() for more information.
         * @param result a #GAsyncResult.
         */
        vfunc_handshake_finish(result: AsyncResult): boolean;

        // Methods

        /**
         * Used by #GTlsConnection implementations to emit the
         * #GTlsConnection::accept-certificate signal.
         * @param peer_cert the peer's #GTlsCertificate
         * @param errors the problems with @peer_cert
         * @returns %TRUE if one of the signal handlers has returned     %TRUE to accept @peer_cert
         */
        emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
        /**
         * Gets `conn'`s certificate, as set by
         * g_tls_connection_set_certificate().
         * @returns @conn's certificate, or %NULL
         */
        get_certificate(): TlsCertificate | null;
        /**
         * Query the TLS backend for TLS channel binding data of `type` for `conn`.
         *
         * This call retrieves TLS channel binding data as specified in RFC
         * [5056](https://tools.ietf.org/html/rfc5056), RFC
         * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
         * binding data is returned in `data`.  The `data` is resized by the callee
         * using #GByteArray buffer management and will be freed when the `data`
         * is destroyed by g_byte_array_unref(). If `data` is %NULL, it will only
         * check whether TLS backend is able to fetch the data (e.g. whether `type`
         * is supported by the TLS backend). It does not guarantee that the data
         * will be available though.  That could happen if TLS connection does not
         * support `type` or the binding data is not available yet due to additional
         * negotiation or input required.
         * @param type #GTlsChannelBindingType type of data to fetch
         * @returns %TRUE on success, %FALSE otherwise
         */
        get_channel_binding_data(type: TlsChannelBindingType): [boolean, Uint8Array | null];
        /**
         * Returns the name of the current TLS ciphersuite, or %NULL if the
         * connection has not handshaked or has been closed. Beware that the TLS
         * backend may use any of multiple different naming conventions, because
         * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
         * are different from each other and different from the standard, IANA-
         * registered ciphersuite names. The ciphersuite name is intended to be
         * displayed to the user for informative purposes only, and parsing it
         * is not recommended.
         * @returns The name of the current TLS ciphersuite, or %NULL
         */
        get_ciphersuite_name(): string | null;
        /**
         * Gets the certificate database that `conn` uses to verify
         * peer certificates. See g_tls_connection_set_database().
         * @returns the certificate database that @conn uses or %NULL
         */
        get_database(): TlsDatabase | null;
        /**
         * Get the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords. If %NULL is returned, then
         * no user interaction will occur for this connection.
         * @returns The interaction object.
         */
        get_interaction(): TlsInteraction | null;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_tls_connection_set_advertised_protocols().
         * @returns the negotiated protocol, or %NULL
         */
        get_negotiated_protocol(): string | null;
        /**
         * Gets `conn'`s peer's certificate after the handshake has completed
         * or failed. (It is not set during the emission of
         * #GTlsConnection::accept-certificate.)
         * @returns @conn's peer's certificate, or %NULL
         */
        get_peer_certificate(): TlsCertificate | null;
        /**
         * Gets the errors associated with validating `conn'`s peer's
         * certificate, after the handshake has completed or failed. (It is
         * not set during the emission of #GTlsConnection::accept-certificate.)
         *
         * See #GTlsConnection:peer-certificate-errors for more information.
         * @returns @conn's peer's certificate errors
         */
        get_peer_certificate_errors(): TlsCertificateFlags;
        /**
         * Returns the current TLS protocol version, which may be
         * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
         * has been closed, or if the TLS backend has implemented a protocol version
         * that is not a recognized #GTlsProtocolVersion.
         * @returns The current TLS protocol version
         */
        get_protocol_version(): TlsProtocolVersion;
        /**
         * Gets `conn` rehandshaking mode. See
         * g_tls_connection_set_rehandshake_mode() for details.
         * @returns %G_TLS_REHANDSHAKE_SAFELY
         */
        get_rehandshake_mode(): TlsRehandshakeMode;
        /**
         * Tests whether or not `conn` expects a proper TLS close notification
         * when the connection is closed. See
         * g_tls_connection_set_require_close_notify() for details.
         * @returns %TRUE if @conn requires a proper TLS close notification.
         */
        get_require_close_notify(): boolean;
        /**
         * Gets whether `conn` uses the system certificate database to verify
         * peer certificates. See g_tls_connection_set_use_system_certdb().
         * @returns whether @conn uses the system certificate database
         */
        get_use_system_certdb(): boolean;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting (or after sending a "STARTTLS"-type command),
         * #GTlsConnection will handle this for you automatically when you try
         * to send or receive data on the connection. You can call
         * g_tls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before or
         * after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_tls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * When using a #GTlsConnection created by #GSocketClient, the
         * #GSocketClient performs the initial handshake, so calling this
         * function manually is not recommended.
         *
         * #GTlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @param cancellable a #GCancellable, or %NULL
         * @returns success or failure
         */
        handshake(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_tls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        handshake_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_tls_connection_handshake() for more information.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        handshake_finish(result: AsyncResult): boolean;
        /**
         * Sets the list of application-layer protocols to advertise that the
         * caller is willing to speak on this connection. The
         * Application-Layer Protocol Negotiation (ALPN) extension will be
         * used to negotiate a compatible protocol with the peer; use
         * g_tls_connection_get_negotiated_protocol() to find the negotiated
         * protocol after the handshake.  Specifying %NULL for the the value
         * of `protocols` will disable ALPN negotiation.
         *
         * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
         * for a list of registered protocol IDs.
         * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
         */
        set_advertised_protocols(protocols?: string[] | null): void;
        /**
         * This sets the certificate that `conn` will present to its peer
         * during the TLS handshake. For a #GTlsServerConnection, it is
         * mandatory to set this, and that will normally be done at construct
         * time.
         *
         * For a #GTlsClientConnection, this is optional. If a handshake fails
         * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
         * requires a certificate, and if you try connecting again, you should
         * call this method first. You can call
         * g_tls_client_connection_get_accepted_cas() on the failed connection
         * to get a list of Certificate Authorities that the server will
         * accept certificates from.
         *
         * (It is also possible that a server will allow the connection with
         * or without a certificate; in that case, if you don't provide a
         * certificate, you can tell that the server requested one by the fact
         * that g_tls_client_connection_get_accepted_cas() will return
         * non-%NULL.)
         * @param certificate the certificate to use for @conn
         */
        set_certificate(certificate: TlsCertificate): void;
        /**
         * Sets the certificate database that is used to verify peer certificates.
         * This is set to the default database by default. See
         * g_tls_backend_get_default_database(). If set to %NULL, then
         * peer certificate validation will always set the
         * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
         * #GTlsConnection::accept-certificate will always be emitted on
         * client-side connections, unless that bit is not set in
         * #GTlsClientConnection:validation-flags).
         *
         * There are nonintuitive security implications when using a non-default
         * database. See #GTlsConnection:database for details.
         * @param database a #GTlsDatabase
         */
        set_database(database?: TlsDatabase | null): void;
        /**
         * Set the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords.
         *
         * The `interaction` argument will normally be a derived subclass of
         * #GTlsInteraction. %NULL can also be provided if no user interaction
         * should occur for this connection.
         * @param interaction an interaction object, or %NULL
         */
        set_interaction(interaction?: TlsInteraction | null): void;
        /**
         * Since GLib 2.64, changing the rehandshake mode is no longer supported
         * and will have no effect. With TLS 1.3, rehandshaking has been removed from
         * the TLS protocol, replaced by separate post-handshake authentication and
         * rekey operations.
         * @param mode the rehandshaking mode
         */
        set_rehandshake_mode(mode: TlsRehandshakeMode): void;
        /**
         * Sets whether or not `conn` expects a proper TLS close notification
         * before the connection is closed. If this is %TRUE (the default),
         * then `conn` will expect to receive a TLS close notification from its
         * peer before the connection is closed, and will return a
         * %G_TLS_ERROR_EOF error if the connection is closed without proper
         * notification (since this may indicate a network error, or
         * man-in-the-middle attack).
         *
         * In some protocols, the application will know whether or not the
         * connection was closed cleanly based on application-level data
         * (because the application-level data includes a length field, or is
         * somehow self-delimiting); in this case, the close notify is
         * redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
         * in TLS 1.0 it is technically an error, but often done anyway.) You
         * can use g_tls_connection_set_require_close_notify() to tell `conn`
         * to allow an "unannounced" connection close, in which case the close
         * will show up as a 0-length read, as in a non-TLS
         * #GSocketConnection, and it is up to the application to check that
         * the data has been fully received.
         *
         * Note that this only affects the behavior when the peer closes the
         * connection; when the application calls g_io_stream_close() itself
         * on `conn,` this will send a close notification regardless of the
         * setting of this property. If you explicitly want to do an unclean
         * close, you can close `conn'`s #GTlsConnection:base-io-stream rather
         * than closing `conn` itself, but note that this may only be done when no other
         * operations are pending on `conn` or the base I/O stream.
         * @param require_close_notify whether or not to require close notification
         */
        set_require_close_notify(require_close_notify: boolean): void;
        /**
         * Sets whether `conn` uses the system certificate database to verify
         * peer certificates. This is %TRUE by default. If set to %FALSE, then
         * peer certificate validation will always set the
         * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
         * #GTlsConnection::accept-certificate will always be emitted on
         * client-side connections, unless that bit is not set in
         * #GTlsClientConnection:validation-flags).
         * @param use_system_certdb whether to use the system certificate database
         */
        set_use_system_certdb(use_system_certdb: boolean): void;
    }

    module TlsDatabase {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GTlsDatabase` is used to look up certificates and other information
     * from a certificate or key store. It is an abstract base class which
     * TLS library specific subtypes override.
     *
     * A `GTlsDatabase` may be accessed from multiple threads by the TLS backend.
     * All implementations are required to be fully thread-safe.
     *
     * Most common client applications will not directly interact with
     * `GTlsDatabase`. It is used internally by [class`Gio`.TlsConnection].
     */
    abstract class TlsDatabase extends GObject.Object {
        static $gtype: GObject.GType<TlsDatabase>;

        // Constructors

        constructor(properties?: Partial<TlsDatabase.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Create a handle string for the certificate. The database will only be able
         * to create a handle for certificates that originate from the database. In
         * cases where the database cannot create a handle for a certificate, %NULL
         * will be returned.
         *
         * This handle should be stable across various instances of the application,
         * and between applications. If a certificate is modified in the database,
         * then it is not guaranteed that this handle will continue to point to it.
         * @param certificate certificate for which to create a handle.
         */
        vfunc_create_certificate_handle(certificate: TlsCertificate): string | null;
        /**
         * Look up a certificate by its handle.
         *
         * The handle should have been created by calling
         * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
         * the same TLS backend. The handle is designed to remain valid across
         * instantiations of the database.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         *
         * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
         * the lookup operation asynchronously.
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup_certificate_for_handle(
            handle: string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificate | null;
        /**
         * Asynchronously look up a certificate by its handle in the database. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_lookup_certificate_for_handle_async(
            handle: string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous lookup of a certificate by its handle. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         * @param result a #GAsyncResult.
         */
        vfunc_lookup_certificate_for_handle_finish(result: AsyncResult): TlsCertificate;
        /**
         * Look up the issuer of `certificate` in the database. The
         * #GTlsCertificate:issuer property of `certificate` is not modified, and
         * the two certificates are not hooked into a chain.
         *
         * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
         * to perform the lookup operation asynchronously.
         *
         * Beware this function cannot be used to build certification paths. The
         * issuer certificate returned by this function may not be the same as
         * the certificate that would actually be used to construct a valid
         * certification path during certificate verification.
         * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
         * why an issuer certificate cannot be naively assumed to be part of the
         * the certification path (though GLib's TLS backends may not follow the
         * path building strategies outlined in this RFC). Due to the complexity
         * of certification path building, GLib does not provide any way to know
         * which certification path will actually be used when verifying a TLS
         * certificate. Accordingly, this function cannot be used to make
         * security-related decisions. Only GLib itself should make security
         * decisions about TLS certificates.
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup_certificate_issuer(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificate;
        /**
         * Asynchronously look up the issuer of `certificate` in the database. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_lookup_certificate_issuer_async(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous lookup issuer operation. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @param result a #GAsyncResult.
         */
        vfunc_lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate;
        /**
         * Look up certificates issued by this issuer in the database.
         *
         * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
         * the lookup operation asynchronously.
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup_certificates_issued_by(
            issuer_raw_dn: Uint8Array | string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificate[];
        /**
         * Asynchronously look up certificates issued by this issuer in the database. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         *
         * The database may choose to hold a reference to the issuer byte array for the duration
         * of this asynchronous operation. The byte array should not be modified during
         * this time.
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_lookup_certificates_issued_by_async(
            issuer_raw_dn: Uint8Array | string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous lookup of certificates. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         * @param result a #GAsyncResult.
         */
        vfunc_lookup_certificates_issued_by_finish(result: AsyncResult): TlsCertificate[];
        /**
         * Determines the validity of a certificate chain, outside the context
         * of a TLS session.
         *
         * `chain` is a chain of #GTlsCertificate objects each pointing to the next
         * certificate in the chain by its #GTlsCertificate:issuer property.
         *
         * `purpose` describes the purpose (or usage) for which the certificate
         * is being used. Typically `purpose` will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
         * which means that the certificate is being used to authenticate a server
         * (and we are acting as the client).
         *
         * The `identity` is used to ensure the server certificate is valid for
         * the expected peer identity. If the identity does not match the
         * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
         * return value. If `identity` is %NULL, that bit will never be set in
         * the return value. The peer identity may also be used to check for
         * pinned certificates (trust exceptions) in the database. These may
         * override the normal verification process on a host-by-host basis.
         *
         * Currently there are no `flags,` and %G_TLS_DATABASE_VERIFY_NONE should be
         * used.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate at
         * least one problem found. If the function is unable to determine
         * whether `chain` is valid (for example, because `cancellable` is
         * triggered before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set accordingly.
         * `error` is not set when `chain` is successfully analyzed but found to
         * be invalid.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
         * represent the certification path built by #GTlsDatabase during
         * certificate verification by adjusting the #GTlsCertificate:issuer
         * property of each certificate in `chain`. Since GLib 2.48, this no
         * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
         * represent the actual certification path used during certificate
         * verification.
         *
         * Because TLS session context is not used, #GTlsDatabase may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         *
         * The TLS backend may attempt to look up and add missing certificates
         * to the chain. This may involve HTTP requests to download missing
         * certificates.
         *
         * This function can block. Use g_tls_database_verify_chain_async() to
         * perform the verification operation asynchronously.
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_verify_chain(
            chain: TlsCertificate,
            purpose: string,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificateFlags;
        /**
         * Asynchronously determines the validity of a certificate chain after
         * looking up and adding any missing certificates to the chain. See
         * g_tls_database_verify_chain() for more information.
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        vfunc_verify_chain_async(
            chain: TlsCertificate,
            purpose: string,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous verify chain operation. See
         * g_tls_database_verify_chain() for more information.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate
         * the problems found. If the function is unable to determine whether
         * `chain` is valid or not (eg, because `cancellable` is triggered
         * before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set
         * accordingly. `error` is not set when `chain` is successfully analyzed
         * but found to be invalid.
         * @param result a #GAsyncResult.
         */
        vfunc_verify_chain_finish(result: AsyncResult): TlsCertificateFlags;

        // Methods

        /**
         * Create a handle string for the certificate. The database will only be able
         * to create a handle for certificates that originate from the database. In
         * cases where the database cannot create a handle for a certificate, %NULL
         * will be returned.
         *
         * This handle should be stable across various instances of the application,
         * and between applications. If a certificate is modified in the database,
         * then it is not guaranteed that this handle will continue to point to it.
         * @param certificate certificate for which to create a handle.
         * @returns a newly allocated string containing the handle.
         */
        create_certificate_handle(certificate: TlsCertificate): string | null;
        /**
         * Look up a certificate by its handle.
         *
         * The handle should have been created by calling
         * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
         * the same TLS backend. The handle is designed to remain valid across
         * instantiations of the database.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         *
         * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
         * the lookup operation asynchronously.
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_for_handle(
            handle: string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificate | null;
        /**
         * Asynchronously look up a certificate by its handle in the database. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         * @param handle a certificate handle
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        lookup_certificate_for_handle_async(
            handle: string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous lookup of a certificate by its handle. See
         * g_tls_database_lookup_certificate_for_handle() for more information.
         *
         * If the handle is no longer valid, or does not point to a certificate in
         * this database, then %NULL will be returned.
         * @param result a #GAsyncResult.
         * @returns a newly allocated #GTlsCertificate object. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_for_handle_finish(result: AsyncResult): TlsCertificate;
        /**
         * Look up the issuer of `certificate` in the database. The
         * #GTlsCertificate:issuer property of `certificate` is not modified, and
         * the two certificates are not hooked into a chain.
         *
         * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
         * to perform the lookup operation asynchronously.
         *
         * Beware this function cannot be used to build certification paths. The
         * issuer certificate returned by this function may not be the same as
         * the certificate that would actually be used to construct a valid
         * certification path during certificate verification.
         * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
         * why an issuer certificate cannot be naively assumed to be part of the
         * the certification path (though GLib's TLS backends may not follow the
         * path building strategies outlined in this RFC). Due to the complexity
         * of certification path building, GLib does not provide any way to know
         * which certification path will actually be used when verifying a TLS
         * certificate. Accordingly, this function cannot be used to make
         * security-related decisions. Only GLib itself should make security
         * decisions about TLS certificates.
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_issuer(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificate;
        /**
         * Asynchronously look up the issuer of `certificate` in the database. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @param certificate a #GTlsCertificate
         * @param interaction used to interact with the user if necessary
         * @param flags flags which affect the lookup operation
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        lookup_certificate_issuer_async(
            certificate: TlsCertificate,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous lookup issuer operation. See
         * g_tls_database_lookup_certificate_issuer() for more information.
         * @param result a #GAsyncResult.
         * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
         */
        lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate;
        /**
         * Look up certificates issued by this issuer in the database.
         *
         * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
         * the lookup operation asynchronously.
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
         */
        lookup_certificates_issued_by(
            issuer_raw_dn: Uint8Array | string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificate[];
        /**
         * Asynchronously look up certificates issued by this issuer in the database. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         *
         * The database may choose to hold a reference to the issuer byte array for the duration
         * of this asynchronous operation. The byte array should not be modified during
         * this time.
         * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
         * @param interaction used to interact with the user if necessary
         * @param flags Flags which affect the lookup operation.
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        lookup_certificates_issued_by_async(
            issuer_raw_dn: Uint8Array | string,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseLookupFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous lookup of certificates. See
         * g_tls_database_lookup_certificates_issued_by() for more information.
         * @param result a #GAsyncResult.
         * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
         */
        lookup_certificates_issued_by_finish(result: AsyncResult): TlsCertificate[];
        /**
         * Determines the validity of a certificate chain, outside the context
         * of a TLS session.
         *
         * `chain` is a chain of #GTlsCertificate objects each pointing to the next
         * certificate in the chain by its #GTlsCertificate:issuer property.
         *
         * `purpose` describes the purpose (or usage) for which the certificate
         * is being used. Typically `purpose` will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
         * which means that the certificate is being used to authenticate a server
         * (and we are acting as the client).
         *
         * The `identity` is used to ensure the server certificate is valid for
         * the expected peer identity. If the identity does not match the
         * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
         * return value. If `identity` is %NULL, that bit will never be set in
         * the return value. The peer identity may also be used to check for
         * pinned certificates (trust exceptions) in the database. These may
         * override the normal verification process on a host-by-host basis.
         *
         * Currently there are no `flags,` and %G_TLS_DATABASE_VERIFY_NONE should be
         * used.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate at
         * least one problem found. If the function is unable to determine
         * whether `chain` is valid (for example, because `cancellable` is
         * triggered before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set accordingly.
         * `error` is not set when `chain` is successfully analyzed but found to
         * be invalid.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * error will be set in the return value, but it does not guarantee
         * that all possible errors will be set. Accordingly, you may not safely
         * decide to ignore any particular type of error. For example, it would
         * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         *
         * Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
         * represent the certification path built by #GTlsDatabase during
         * certificate verification by adjusting the #GTlsCertificate:issuer
         * property of each certificate in `chain`. Since GLib 2.48, this no
         * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
         * represent the actual certification path used during certificate
         * verification.
         *
         * Because TLS session context is not used, #GTlsDatabase may not
         * perform as many checks on the certificates as #GTlsConnection would.
         * For example, certificate constraints may not be honored, and
         * revocation checks may not be performed. The best way to verify TLS
         * certificates used by a TLS connection is to let #GTlsConnection
         * handle the verification.
         *
         * The TLS backend may attempt to look up and add missing certificates
         * to the chain. This may involve HTTP requests to download missing
         * certificates.
         *
         * This function can block. Use g_tls_database_verify_chain_async() to
         * perform the verification operation asynchronously.
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
         */
        verify_chain(
            chain: TlsCertificate,
            purpose: string,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable?: Cancellable | null,
        ): TlsCertificateFlags;
        /**
         * Asynchronously determines the validity of a certificate chain after
         * looking up and adding any missing certificates to the chain. See
         * g_tls_database_verify_chain() for more information.
         * @param chain a #GTlsCertificate chain
         * @param purpose the purpose that this certificate chain will be used for.
         * @param identity the expected peer identity
         * @param interaction used to interact with the user if necessary
         * @param flags additional verify flags
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the operation completes
         */
        verify_chain_async(
            chain: TlsCertificate,
            purpose: string,
            identity: SocketConnectable | null,
            interaction: TlsInteraction | null,
            flags: TlsDatabaseVerifyFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous verify chain operation. See
         * g_tls_database_verify_chain() for more information.
         *
         * If `chain` is found to be valid, then the return value will be 0. If
         * `chain` is found to be invalid, then the return value will indicate
         * the problems found. If the function is unable to determine whether
         * `chain` is valid or not (eg, because `cancellable` is triggered
         * before it completes) then the return value will be
         * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set
         * accordingly. `error` is not set when `chain` is successfully analyzed
         * but found to be invalid.
         * @param result a #GAsyncResult.
         * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
         */
        verify_chain_finish(result: AsyncResult): TlsCertificateFlags;
    }

    module TlsInteraction {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GTlsInteraction` provides a mechanism for the TLS connection and database
     * code to interact with the user. It can be used to ask the user for passwords.
     *
     * To use a `GTlsInteraction` with a TLS connection use
     * [method`Gio`.TlsConnection.set_interaction].
     *
     * Callers should instantiate a derived class that implements the various
     * interaction methods to show the required dialogs.
     *
     * Callers should use the 'invoke' functions like
     * [method`Gio`.TlsInteraction.invoke_ask_password] to run interaction methods.
     * These functions make sure that the interaction is invoked in the main loop
     * and not in the current thread, if the current thread is not running the
     * main loop.
     *
     * Derived classes can choose to implement whichever interactions methods theyd
     * like to support by overriding those virtual methods in their class
     * initialization function. Any interactions not implemented will return
     * `G_TLS_INTERACTION_UNHANDLED`. If a derived class implements an async method,
     * it must also implement the corresponding finish method.
     */
    class TlsInteraction extends GObject.Object {
        static $gtype: GObject.GType<TlsInteraction>;

        // Constructors

        constructor(properties?: Partial<TlsInteraction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * Run synchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         */
        vfunc_ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         *
         * Certain implementations may not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        vfunc_ask_password_async(
            password: TlsPassword,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Complete an ask password user interaction request. This should be once
         * the g_tls_interaction_ask_password_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
         * to g_tls_interaction_ask_password() will have its password filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @param result the result passed to the callback
         */
        vfunc_ask_password_finish(result: AsyncResult): TlsInteractionResult;
        /**
         * Run synchronous interaction to ask the user to choose a certificate to use
         * with the connection. In general, g_tls_interaction_invoke_request_certificate()
         * should be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. Alternatively the user may
         * abort this certificate request, which will usually abort the TLS connection.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         */
        vfunc_request_certificate(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable?: Cancellable | null,
        ): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a certificate to use with
         * the connection. In general, g_tls_interaction_invoke_request_certificate() should
         * be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. `callback` will be called
         * when the operation completes. Alternatively the user may abort this certificate
         * request, which will usually abort the TLS connection.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        vfunc_request_certificate_async(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Complete a request certificate user interaction request. This should be once
         * the g_tls_interaction_request_certificate_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate_async() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @param result the result passed to the callback
         */
        vfunc_request_certificate_finish(result: AsyncResult): TlsInteractionResult;

        // Methods

        /**
         * Run synchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the ask password interaction.
         */
        ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a password. In general,
         * g_tls_interaction_invoke_ask_password() should be used instead of this
         * function.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         *
         * Certain implementations may not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        ask_password_async(
            password: TlsPassword,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Complete an ask password user interaction request. This should be once
         * the g_tls_interaction_ask_password_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
         * to g_tls_interaction_ask_password() will have its password filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @param result the result passed to the callback
         * @returns The status of the ask password interaction.
         */
        ask_password_finish(result: AsyncResult): TlsInteractionResult;
        /**
         * Invoke the interaction to ask the user for a password. It invokes this
         * interaction in the main loop, specifically the #GMainContext returned by
         * g_main_context_get_thread_default() when the interaction is created. This
         * is called by called by #GTlsConnection or #GTlsDatabase to ask the user
         * for a password.
         *
         * Derived subclasses usually implement a password prompt, although they may
         * also choose to provide a password from elsewhere. The `password` value will
         * be filled in and then `callback` will be called. Alternatively the user may
         * abort this password request, which will usually abort the TLS connection.
         *
         * The implementation can either be a synchronous (eg: modal dialog) or an
         * asynchronous one (eg: modeless dialog). This function will take care of
         * calling which ever one correctly.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param password a #GTlsPassword object
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the ask password interaction.
         */
        invoke_ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
        /**
         * Invoke the interaction to ask the user to choose a certificate to
         * use with the connection. It invokes this interaction in the main
         * loop, specifically the #GMainContext returned by
         * g_main_context_get_thread_default() when the interaction is
         * created. This is called by called by #GTlsConnection when the peer
         * requests a certificate during the handshake.
         *
         * Derived subclasses usually implement a certificate selector,
         * although they may also choose to provide a certificate from
         * elsewhere. Alternatively the user may abort this certificate
         * request, which may or may not abort the TLS connection.
         *
         * The implementation can either be a synchronous (eg: modal dialog) or an
         * asynchronous one (eg: modeless dialog). This function will take care of
         * calling which ever one correctly.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the certificate request interaction.
         */
        invoke_request_certificate(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable?: Cancellable | null,
        ): TlsInteractionResult;
        /**
         * Run synchronous interaction to ask the user to choose a certificate to use
         * with the connection. In general, g_tls_interaction_invoke_request_certificate()
         * should be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. Alternatively the user may
         * abort this certificate request, which will usually abort the TLS connection.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
         * not support immediate cancellation.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @returns The status of the request certificate interaction.
         */
        request_certificate(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable?: Cancellable | null,
        ): TlsInteractionResult;
        /**
         * Run asynchronous interaction to ask the user for a certificate to use with
         * the connection. In general, g_tls_interaction_invoke_request_certificate() should
         * be used instead of this function.
         *
         * Derived subclasses usually implement a certificate selector, although they may
         * also choose to provide a certificate from elsewhere. `callback` will be called
         * when the operation completes. Alternatively the user may abort this certificate
         * request, which will usually abort the TLS connection.
         * @param connection a #GTlsConnection object
         * @param flags flags providing more information about the request
         * @param cancellable an optional #GCancellable cancellation object
         * @param callback will be called when the interaction completes
         */
        request_certificate_async(
            connection: TlsConnection,
            flags: TlsCertificateRequestFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Complete a request certificate user interaction request. This should be once
         * the g_tls_interaction_request_certificate_async() completion callback is called.
         *
         * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
         * passed to g_tls_interaction_request_certificate_async() will have had its
         * #GTlsConnection:certificate filled in.
         *
         * If the interaction is cancelled by the cancellation object, or by the
         * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
         * contains a %G_IO_ERROR_CANCELLED error code.
         * @param result the result passed to the callback
         * @returns The status of the request certificate interaction.
         */
        request_certificate_finish(result: AsyncResult): TlsInteractionResult;
    }

    module TlsPassword {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            description: string;
            flags: TlsPasswordFlags;
            warning: string;
        }
    }

    /**
     * An abstract interface representing a password used in TLS. Often used in
     * user interaction such as unlocking a key storage token.
     */
    class TlsPassword extends GObject.Object {
        static $gtype: GObject.GType<TlsPassword>;

        // Properties

        /**
         * Description of what the password is for.
         */
        get description(): string;
        set description(val: string);
        /**
         * Flags about the password.
         */
        get flags(): TlsPasswordFlags;
        set flags(val: TlsPasswordFlags);
        /**
         * Warning about the password.
         */
        get warning(): string;
        set warning(val: string);

        // Constructors

        constructor(properties?: Partial<TlsPassword.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](flags: TlsPasswordFlags, description: string): TlsPassword;

        // Virtual methods

        /**
         * virtual method for g_tls_password_get_warning() if no
         *  value has been set using g_tls_password_set_warning()
         */
        vfunc_get_default_warning(): string;
        /**
         * Get the password value. If `length` is not %NULL then it will be
         * filled in with the length of the password value. (Note that the
         * password value is not nul-terminated, so you can only pass %NULL
         * for `length` in contexts where you know the password will have a
         * certain fixed length.)
         */
        vfunc_get_value(): Uint8Array;
        /**
         * Provide the value for this password.
         *
         * The `value` will be owned by the password object, and later freed using
         * the `destroy` function callback.
         *
         * Specify the `length,` for a non-nul-terminated password. Pass -1 as
         * `length` if using a nul-terminated password, and `length` will be
         * calculated automatically. (Note that the terminating nul is not
         * considered part of the password in this case.)
         * @param value the value for the password
         * @param destroy a function to use to free the password.
         */
        vfunc_set_value(value: Uint8Array | string, destroy?: GLib.DestroyNotify | null): void;

        // Methods

        /**
         * Get a description string about what the password will be used for.
         * @returns The description of the password.
         */
        get_description(): string;
        /**
         * Get flags about the password.
         * @returns The flags about the password.
         */
        get_flags(): TlsPasswordFlags;
        /**
         * Get the password value. If `length` is not %NULL then it will be
         * filled in with the length of the password value. (Note that the
         * password value is not nul-terminated, so you can only pass %NULL
         * for `length` in contexts where you know the password will have a
         * certain fixed length.)
         * @returns The password value (owned by the password object).
         */
        get_value(): Uint8Array;
        /**
         * Get a user readable translated warning. Usually this warning is a
         * representation of the password flags returned from
         * g_tls_password_get_flags().
         * @returns The warning.
         */
        get_warning(): string;
        /**
         * Set a description string about what the password will be used for.
         * @param description The description of the password
         */
        set_description(description: string): void;
        /**
         * Set flags about the password.
         * @param flags The flags about the password
         */
        set_flags(flags: TlsPasswordFlags): void;
        /**
         * Set the value for this password. The `value` will be copied by the password
         * object.
         *
         * Specify the `length,` for a non-nul-terminated password. Pass -1 as
         * `length` if using a nul-terminated password, and `length` will be
         * calculated automatically. (Note that the terminating nul is not
         * considered part of the password in this case.)
         * @param value the new password value
         */
        set_value(value: Uint8Array | string): void;
        /**
         * Provide the value for this password.
         *
         * The `value` will be owned by the password object, and later freed using
         * the `destroy` function callback.
         *
         * Specify the `length,` for a non-nul-terminated password. Pass -1 as
         * `length` if using a nul-terminated password, and `length` will be
         * calculated automatically. (Note that the terminating nul is not
         * considered part of the password in this case.)
         * @param value the value for the password
         * @param destroy a function to use to free the password.
         */
        set_value_full(value: Uint8Array | string, destroy?: GLib.DestroyNotify | null): void;
        /**
         * Set a user readable translated warning. Usually this warning is a
         * representation of the password flags returned from
         * g_tls_password_get_flags().
         * @param warning The user readable warning
         */
        set_warning(warning: string): void;
    }

    module UnixConnection {
        // Constructor properties interface

        interface ConstructorProps extends SocketConnection.ConstructorProps {}
    }

    /**
     * This is the subclass of [class`Gio`.SocketConnection] that is created
     * for UNIX domain sockets.
     *
     * It contains functions to do some of the UNIX socket specific
     * functionality like passing file descriptors.
     *
     * Since GLib 2.72, `GUnixConnection` is available on all platforms. It requires
     * underlying system support (such as Windows 10 with `AF_UNIX`) at run time.
     *
     * Before GLib 2.72, `<gio/gunixconnection.h>` belonged to the UNIX-specific GIO
     * interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
     * using it. This is no longer necessary since GLib 2.72.
     */
    class UnixConnection extends SocketConnection {
        static $gtype: GObject.GType<UnixConnection>;

        // Constructors

        constructor(properties?: Partial<UnixConnection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Receives credentials from the sending end of the connection.  The
         * sending end has to call g_unix_connection_send_credentials() (or
         * similar) for this to work.
         *
         * As well as reading the credentials this also reads (and discards) a
         * single byte from the stream, as this is required for credentials
         * passing to work on some implementations.
         *
         * This method can be expected to be available on the following platforms:
         *
         * - Linux since GLib 2.26
         * - FreeBSD since GLib 2.26
         * - GNU/kFreeBSD since GLib 2.36
         * - Solaris, Illumos and OpenSolaris since GLib 2.40
         * - GNU/Hurd since GLib 2.40
         *
         * Other ways to exchange credentials with a foreign peer includes the
         * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
         * @param cancellable A #GCancellable or %NULL.
         * @returns Received credentials on success (free with g_object_unref()), %NULL if @error is set.
         */
        receive_credentials(cancellable?: Cancellable | null): Credentials;
        /**
         * Asynchronously receive credentials.
         *
         * For more details, see g_unix_connection_receive_credentials() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_unix_connection_receive_credentials_finish() to get the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        receive_credentials_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an asynchronous receive credentials operation started with
         * g_unix_connection_receive_credentials_async().
         * @param result a #GAsyncResult.
         * @returns a #GCredentials, or %NULL on error.     Free the returned object with g_object_unref().
         */
        receive_credentials_finish(result: AsyncResult): Credentials;
        /**
         * Receives a file descriptor from the sending end of the connection.
         * The sending end has to call g_unix_connection_send_fd() for this
         * to work.
         *
         * As well as reading the fd this also reads a single byte from the
         * stream, as this is required for fd passing to work on some
         * implementations.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a file descriptor on success, -1 on error.
         */
        receive_fd(cancellable?: Cancellable | null): number;
        /**
         * Passes the credentials of the current user the receiving side
         * of the connection. The receiving end has to call
         * g_unix_connection_receive_credentials() (or similar) to accept the
         * credentials.
         *
         * As well as sending the credentials this also writes a single NUL
         * byte to the stream, as this is required for credentials passing to
         * work on some implementations.
         *
         * This method can be expected to be available on the following platforms:
         *
         * - Linux since GLib 2.26
         * - FreeBSD since GLib 2.26
         * - GNU/kFreeBSD since GLib 2.36
         * - Solaris, Illumos and OpenSolaris since GLib 2.40
         * - GNU/Hurd since GLib 2.40
         *
         * Other ways to exchange credentials with a foreign peer includes the
         * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
         * @param cancellable A #GCancellable or %NULL.
         * @returns %TRUE on success, %FALSE if @error is set.
         */
        send_credentials(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously send credentials.
         *
         * For more details, see g_unix_connection_send_credentials() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_unix_connection_send_credentials_finish() to get the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        send_credentials_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an asynchronous send credentials operation started with
         * g_unix_connection_send_credentials_async().
         * @param result a #GAsyncResult.
         * @returns %TRUE if the operation was successful, otherwise %FALSE.
         */
        send_credentials_finish(result: AsyncResult): boolean;
        /**
         * Passes a file descriptor to the receiving side of the
         * connection. The receiving end has to call g_unix_connection_receive_fd()
         * to accept the file descriptor.
         *
         * As well as sending the fd this also writes a single byte to the
         * stream, as this is required for fd passing to work on some
         * implementations.
         * @param fd a file descriptor
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a %TRUE on success, %NULL on error.
         */
        send_fd(fd: number, cancellable?: Cancellable | null): boolean;
    }

    module UnixCredentialsMessage {
        // Constructor properties interface

        interface ConstructorProps extends SocketControlMessage.ConstructorProps {
            credentials: Credentials;
        }
    }

    /**
     * This [class`Gio`.SocketControlMessage] contains a [class`Gio`.Credentials]
     * instance.  It may be sent using [method`Gio`.Socket.send_message] and received
     * using [method`Gio`.Socket.receive_message] over UNIX sockets (ie: sockets in
     * the `G_SOCKET_FAMILY_UNIX` family).
     *
     * For an easier way to send and receive credentials over
     * stream-oriented UNIX sockets, see
     * [method`Gio`.UnixConnection.send_credentials] and
     * [method`Gio`.UnixConnection.receive_credentials]. To receive credentials of
     * a foreign process connected to a socket, use
     * [method`Gio`.Socket.get_credentials].
     *
     * Since GLib 2.72, `GUnixCredentialMessage` is available on all platforms. It
     * requires underlying system support (such as Windows 10 with `AF_UNIX`) at run
     * time.
     *
     * Before GLib 2.72, `<gio/gunixcredentialsmessage.h>` belonged to the UNIX-specific
     * GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
     * when using it. This is no longer necessary since GLib 2.72.
     */
    class UnixCredentialsMessage extends SocketControlMessage {
        static $gtype: GObject.GType<UnixCredentialsMessage>;

        // Properties

        /**
         * The credentials stored in the message.
         */
        get credentials(): Credentials;

        // Constructors

        constructor(properties?: Partial<UnixCredentialsMessage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): UnixCredentialsMessage;

        static new_with_credentials(credentials: Credentials): UnixCredentialsMessage;

        // Static methods

        /**
         * Checks if passing #GCredentials on a #GSocket is supported on this platform.
         */
        static is_supported(): boolean;

        // Methods

        /**
         * Gets the credentials stored in `message`.
         * @returns A #GCredentials instance. Do not free, it is owned by @message.
         */
        get_credentials(): Credentials;
    }

    module UnixFDList {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * A `GUnixFDList` contains a list of file descriptors.  It owns the file
     * descriptors that it contains, closing them when finalized.
     *
     * It may be wrapped in a
     * [`GUnixFDMessage`](../gio-unix/class.UnixFDMessage.html) and sent over a
     * [class`Gio`.Socket] in the `G_SOCKET_FAMILY_UNIX` family by using
     * [method`Gio`.Socket.send_message] and received using
     * [method`Gio`.Socket.receive_message].
     *
     * Before 2.74, `<gio/gunixfdlist.h>` belonged to the UNIX-specific GIO
     * interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
     * using it.
     *
     * Since 2.74, the API is available for Windows.
     */
    class UnixFDList extends GObject.Object {
        static $gtype: GObject.GType<UnixFDList>;

        // Constructors

        constructor(properties?: Partial<UnixFDList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): UnixFDList;

        static new_from_array(fds: number[]): UnixFDList;

        // Methods

        /**
         * Adds a file descriptor to `list`.
         *
         * The file descriptor is duplicated using dup(). You keep your copy
         * of the descriptor and the copy contained in `list` will be closed
         * when `list` is finalized.
         *
         * A possible cause of failure is exceeding the per-process or
         * system-wide file descriptor limit.
         *
         * The index of the file descriptor in the list is returned.  If you use
         * this index with g_unix_fd_list_get() then you will receive back a
         * duplicated copy of the same file descriptor.
         * @param fd a valid open file descriptor
         * @returns the index of the appended fd in case of success, else -1          (and @error is set)
         */
        append(fd: number): number;
        /**
         * Gets a file descriptor out of `list`.
         *
         * `index_` specifies the index of the file descriptor to get.  It is a
         * programmer error for `index_` to be out of range; see
         * g_unix_fd_list_get_length().
         *
         * The file descriptor is duplicated using dup() and set as
         * close-on-exec before being returned.  You must call close() on it
         * when you are done.
         *
         * A possible cause of failure is exceeding the per-process or
         * system-wide file descriptor limit.
         * @param index_ the index into the list
         * @returns the file descriptor, or -1 in case of error
         */
        get(index_: number): number;
        /**
         * Gets the length of `list` (ie: the number of file descriptors
         * contained within).
         * @returns the length of @list
         */
        get_length(): number;
        /**
         * Returns the array of file descriptors that is contained in this
         * object.
         *
         * After this call, the descriptors remain the property of `list`.  The
         * caller must not close them and must not free the array.  The array is
         * valid only until `list` is changed in any way.
         *
         * If `length` is non-%NULL then it is set to the number of file
         * descriptors in the returned array. The returned array is also
         * terminated with -1.
         *
         * This function never returns %NULL. In case there are no file
         * descriptors contained in `list,` an empty array is returned.
         * @returns an array of file     descriptors
         */
        peek_fds(): number[];
        /**
         * Returns the array of file descriptors that is contained in this
         * object.
         *
         * After this call, the descriptors are no longer contained in
         * `list`. Further calls will return an empty list (unless more
         * descriptors have been added).
         *
         * The return result of this function must be freed with g_free().
         * The caller is also responsible for closing all of the file
         * descriptors.  The file descriptors in the array are set to
         * close-on-exec.
         *
         * If `length` is non-%NULL then it is set to the number of file
         * descriptors in the returned array. The returned array is also
         * terminated with -1.
         *
         * This function never returns %NULL. In case there are no file
         * descriptors contained in `list,` an empty array is returned.
         * @returns an array of file     descriptors
         */
        steal_fds(): number[];
    }

    module UnixFDMessage {
        // Constructor properties interface

        interface ConstructorProps extends SocketControlMessage.ConstructorProps {
            fd_list: UnixFDList;
            fdList: UnixFDList;
        }
    }

    /**
     * This [class`Gio`.SocketControlMessage] contains a [class`Gio`.UnixFDList].
     * It may be sent using [method`Gio`.Socket.send_message] and received using
     * [method`Gio`.Socket.receive_message] over UNIX sockets (ie: sockets in the
     * `G_SOCKET_FAMILY_UNIX` family). The file descriptors are copied
     * between processes by the kernel.
     *
     * For an easier way to send and receive file descriptors over
     * stream-oriented UNIX sockets, see [method`Gio`.UnixConnection.send_fd] and
     * [method`Gio`.UnixConnection.receive_fd].
     *
     * Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
     * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
     * file or the `GioUnix-2.0` GIR namespace when using it.
     */
    class UnixFDMessage extends SocketControlMessage {
        static $gtype: GObject.GType<UnixFDMessage>;

        // Properties

        /**
         * The [class`Gio`.UnixFDList] object to send with the message.
         */
        get fd_list(): UnixFDList;
        /**
         * The [class`Gio`.UnixFDList] object to send with the message.
         */
        get fdList(): UnixFDList;

        // Constructors

        constructor(properties?: Partial<UnixFDMessage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): UnixFDMessage;

        static new_with_fd_list(fd_list: UnixFDList): UnixFDMessage;

        // Methods

        /**
         * Adds a file descriptor to `message`.
         *
         * The file descriptor is duplicated using dup(). You keep your copy
         * of the descriptor and the copy contained in `message` will be closed
         * when `message` is finalized.
         *
         * A possible cause of failure is exceeding the per-process or
         * system-wide file descriptor limit.
         * @param fd a valid open file descriptor
         * @returns %TRUE in case of success, else %FALSE (and @error is set)
         */
        append_fd(fd: number): boolean;
        /**
         * Gets the #GUnixFDList contained in `message`.  This function does not
         * return a reference to the caller, but the returned list is valid for
         * the lifetime of `message`.
         * @returns the #GUnixFDList from @message
         */
        get_fd_list(): UnixFDList;
        /**
         * Returns the array of file descriptors that is contained in this
         * object.
         *
         * After this call, the descriptors are no longer contained in
         * `message`. Further calls will return an empty list (unless more
         * descriptors have been added).
         *
         * The return result of this function must be freed with g_free().
         * The caller is also responsible for closing all of the file
         * descriptors.
         *
         * If `length` is non-%NULL then it is set to the number of file
         * descriptors in the returned array. The returned array is also
         * terminated with -1.
         *
         * This function never returns %NULL. In case there are no file
         * descriptors contained in `message,` an empty array is returned.
         * @returns an array of file     descriptors
         */
        steal_fds(): number[];
    }

    module UnixInputStream {
        // Constructor properties interface

        interface ConstructorProps
            extends InputStream.ConstructorProps,
                FileDescriptorBased.ConstructorProps,
                PollableInputStream.ConstructorProps {
            close_fd: boolean;
            closeFd: boolean;
            fd: number;
        }
    }

    /**
     * `GUnixInputStream` implements [class`Gio`.InputStream] for reading from a UNIX
     * file descriptor, including asynchronous operations. (If the file
     * descriptor refers to a socket or pipe, this will use `poll()` to do
     * asynchronous I/O. If it refers to a regular file, it will fall back
     * to doing asynchronous I/O in another thread.)
     *
     * Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
     * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
     * file or the `GioUnix-2.0` GIR namespace when using it.
     */
    class UnixInputStream extends InputStream implements FileDescriptorBased, PollableInputStream {
        static $gtype: GObject.GType<UnixInputStream>;

        // Properties

        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        get close_fd(): boolean;
        set close_fd(val: boolean);
        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        get closeFd(): boolean;
        set closeFd(val: boolean);
        /**
         * The file descriptor that the stream reads from.
         */
        get fd(): number;

        // Constructors

        constructor(properties?: Partial<UnixInputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](fd: number, close_fd: boolean): UnixInputStream;

        // Methods

        /**
         * Returns whether the file descriptor of `stream` will be
         * closed when the stream is closed.
         * @returns %TRUE if the file descriptor is closed when done
         */
        get_close_fd(): boolean;
        /**
         * Return the UNIX file descriptor that the stream reads from.
         * @returns The file descriptor of @stream
         */
        get_fd(): number;
        /**
         * Sets whether the file descriptor of `stream` shall be closed
         * when the stream is closed.
         * @param close_fd %TRUE to close the file descriptor when done
         */
        set_close_fd(close_fd: boolean): void;

        // Inherited methods
        /**
         * Gets the underlying file descriptor.
         */
        vfunc_get_fd(): number;
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
         */
        is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_read_nonblocking(): [number, Uint8Array | null];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but some streams
         * can use a faster close that doesn't block to e.g. check errors.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         * @returns %TRUE if the stream was closed successfully.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Checks if an input stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an input stream is closed.
         * @returns %TRUE if the stream is closed.
         */
        is_closed(): boolean;
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * If count is zero returns zero and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * The returned `buffer` is not a nul-terminated string, it can contain nul bytes
         * at any position, and this function doesn't nul-terminate the `buffer`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes read, or -1 on error, or 0 on end of file.
         */
        read(cancellable?: Cancellable | null): [number, Uint8Array];
        /**
         * Tries to read `count` bytes from the stream into the buffer starting at
         * `buffer`. Will block during this read.
         *
         * This function is similar to g_input_stream_read(), except it tries to
         * read as many bytes as requested, only stopping on an error or end of stream.
         *
         * On a successful read of `count` bytes, or if we reached the end of the
         * stream,  %TRUE is returned, and `bytes_read` is set to the number of bytes
         * read into `buffer`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read().
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all(cancellable?: Cancellable | null): [boolean, Uint8Array, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the
         * buffer starting at `buffer`.
         *
         * This is the asynchronous equivalent of g_input_stream_read_all().
         *
         * Call g_input_stream_read_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_all_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Finishes an asynchronous stream read operation started with
         * g_input_stream_read_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_read` will be set to the number of bytes that were successfully
         * read before the error was encountered.  This functionality is only
         * available from C.  If you need it from another language then you must
         * write your own loop around g_input_stream_read_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        read_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array;
        /**
         * Like g_input_stream_read(), this tries to read `count` bytes from
         * the stream in a blocking fashion. However, rather than reading into
         * a user-supplied buffer, this will create a new #GBytes containing
         * the data that was read. This may be easier to use from language
         * bindings.
         *
         * If count is zero, returns a zero-length #GBytes and does nothing. A
         * value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, a new #GBytes is returned. It is not an error if the
         * size of this object is not the same as the requested size, as it
         * can happen e.g. near the end of a file. A zero-length #GBytes is
         * returned on end of file (or if `count` is zero), but never
         * otherwise.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error %NULL is returned and `error` is set accordingly.
         * @param count maximum number of bytes that will be read from the stream. Common values include 4096 and 8192.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a new #GBytes, or %NULL on error
         */
        read_bytes(count: number, cancellable?: Cancellable | null): GLib.Bytes;
        /**
         * Request an asynchronous read of `count` bytes from the stream into a
         * new #GBytes. When the operation is finished `callback` will be
         * called. You can then call g_input_stream_read_bytes_finish() to get the
         * result of the operation.
         *
         * During an async request no other sync and async calls are allowed
         * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the new #GBytes will be passed to the callback. It is
         * not an error if this is smaller than the requested size, as it can
         * happen e.g. near the end of a file, but generally we try to read as
         * many bytes as requested. Zero is returned on end of file (or if
         * `count` is zero), but never otherwise.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         * @param count the number of bytes that will be read from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_bytes_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream read-into-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns the newly-allocated #GBytes, or %NULL on error
         */
        read_bytes_finish(result: AsyncResult): GLib.Bytes;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         * @returns number of bytes read in, or -1 on error, or 0 on end of file.
         */
        read_finish(result: AsyncResult): number;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns Number of bytes skipped, or -1 on error
         */
        skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         * @returns the size of the bytes skipped, or `-1` on error.
         */
        skip_finish(result: AsyncResult): number;
        /**
         * Requests an asynchronous closes of the stream, releasing resources related to it.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_close_finish() to get the result of the
         * operation.
         *
         * For behaviour details see g_input_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Request an asynchronous read of `count` bytes from the stream into the buffer
         * starting at `buffer`. When the operation is finished `callback` will be called.
         * You can then call g_input_stream_read_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed on `stream,` and will
         * result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes read into the buffer will be passed to the
         * callback. It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to read
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero),  but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value) will
         * be executed before an outstanding request with lower priority. Default
         * priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to implement
         * asynchronicity, so they are optional for inheriting classes. However, if you
         * override one you must override all.
         * @param io_priority the [I/O priority][io-priority] of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): Uint8Array | null;
        /**
         * Finishes an asynchronous stream read operation.
         * @param result a #GAsyncResult.
         */
        vfunc_read_finish(result: AsyncResult): number;
        vfunc_read_fn(buffer: any | null, count: number, cancellable?: Cancellable | null): number;
        /**
         * Tries to skip `count` bytes from the stream. Will block during the operation.
         *
         * This is identical to g_input_stream_read(), from a behaviour standpoint,
         * but the bytes that are skipped are not returned to the user. Some
         * streams have an implementation that is more efficient than reading the data.
         *
         * This function is optional for inherited classes, as the default implementation
         * emulates it using read.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param count the number of bytes that will be skipped from the stream
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_skip(count: number, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous skip of `count` bytes from the stream.
         * When the operation is finished `callback` will be called.
         * You can then call g_input_stream_skip_finish() to get the result
         * of the operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes skipped will be passed to the callback.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. near the end of a file, but generally we try to skip
         * as many bytes as requested. Zero is returned on end of file
         * (or if `count` is zero), but never otherwise.
         *
         * Any outstanding i/o request with higher priority (lower numerical value)
         * will be executed before an outstanding request with lower priority.
         * Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads to
         * implement asynchronicity, so they are optional for inheriting classes.
         * However, if you override one, you must override all.
         * @param count the number of bytes that will be skipped from the stream
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_skip_async(
            count: number,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream skip operation.
         * @param result a #GAsyncResult.
         */
        vfunc_skip_finish(result: AsyncResult): number;
    }

    module UnixMountMonitor {
        // Signal callback interfaces

        interface MountpointsChanged {
            (): void;
        }

        interface MountsChanged {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * Watches #GUnixMounts for changes.
     */
    class UnixMountMonitor extends GObject.Object {
        static $gtype: GObject.GType<UnixMountMonitor>;

        // Constructors

        constructor(properties?: Partial<UnixMountMonitor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): UnixMountMonitor;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'mountpoints-changed', callback: (_source: this) => void): number;
        connect_after(signal: 'mountpoints-changed', callback: (_source: this) => void): number;
        emit(signal: 'mountpoints-changed'): void;
        connect(signal: 'mounts-changed', callback: (_source: this) => void): number;
        connect_after(signal: 'mounts-changed', callback: (_source: this) => void): number;
        emit(signal: 'mounts-changed'): void;

        // Static methods

        /**
         * Gets the #GUnixMountMonitor for the current thread-default main
         * context.
         *
         * The mount monitor can be used to monitor for changes to the list of
         * mounted filesystems as well as the list of mount points (ie: fstab
         * entries).
         *
         * You must only call g_object_unref() on the return value from under
         * the same main context as you called this function.
         */
        static get(): UnixMountMonitor;

        // Methods

        /**
         * This function does nothing.
         *
         * Before 2.44, this was a partially-effective way of controlling the
         * rate at which events would be reported under some uncommon
         * circumstances.  Since `mount_monitor` is a singleton, it also meant
         * that calling this function would have side effects for other users of
         * the monitor.
         * @param limit_msec a integer with the limit in milliseconds to     poll for changes.
         */
        set_rate_limit(limit_msec: number): void;
    }

    module UnixOutputStream {
        // Constructor properties interface

        interface ConstructorProps
            extends OutputStream.ConstructorProps,
                FileDescriptorBased.ConstructorProps,
                PollableOutputStream.ConstructorProps {
            close_fd: boolean;
            closeFd: boolean;
            fd: number;
        }
    }

    /**
     * `GUnixOutputStream` implements [class`Gio`.OutputStream] for writing to a UNIX
     * file descriptor, including asynchronous operations. (If the file
     * descriptor refers to a socket or pipe, this will use `poll()` to do
     * asynchronous I/O. If it refers to a regular file, it will fall back
     * to doing asynchronous I/O in another thread.)
     *
     * Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
     * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
     * file or the `GioUnix-2.0` GIR namespace when using it.
     */
    class UnixOutputStream extends OutputStream implements FileDescriptorBased, PollableOutputStream {
        static $gtype: GObject.GType<UnixOutputStream>;

        // Properties

        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        get close_fd(): boolean;
        set close_fd(val: boolean);
        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        get closeFd(): boolean;
        set closeFd(val: boolean);
        /**
         * The file descriptor that the stream writes to.
         */
        get fd(): number;

        // Constructors

        constructor(properties?: Partial<UnixOutputStream.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](fd: number, close_fd: boolean): UnixOutputStream;

        // Methods

        /**
         * Returns whether the file descriptor of `stream` will be
         * closed when the stream is closed.
         * @returns %TRUE if the file descriptor is closed when done
         */
        get_close_fd(): boolean;
        /**
         * Return the UNIX file descriptor that the stream writes to.
         * @returns The file descriptor of @stream
         */
        get_fd(): number;
        /**
         * Sets whether the file descriptor of `stream` shall be closed
         * when the stream is closed.
         * @param close_fd %TRUE to close the file descriptor when done
         */
        set_close_fd(close_fd: boolean): void;

        // Inherited methods
        /**
         * Gets the underlying file descriptor.
         */
        vfunc_get_fd(): number;
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
         */
        is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
         */
        writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];
        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         */
        vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         */
        vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
        /**
         * Clears the pending flag on `stream`.
         */
        clear_pending(): void;
        /**
         * Closes the stream, releasing resources related to it.
         *
         * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a stream multiple times will not return an error.
         *
         * Closing a stream will automatically flush any outstanding buffers in the
         * stream.
         *
         * Streams will be automatically closed when the last reference
         * is dropped, but you might want to call this function to make sure
         * resources are released as early as possible.
         *
         * Some streams might keep the backing store of the stream (e.g. a file descriptor)
         * open after the stream is closed. See the documentation for the individual
         * stream for details.
         *
         * On failure the first error that happened will be reported, but the close
         * operation will finish as much as possible. A stream that failed to
         * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
         * is important to check and report the error to the user, otherwise
         * there might be a loss of data as all data might not be written.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * Cancelling a close will still leave the stream closed, but there some streams
         * can use a faster close that doesn't block to e.g. check errors. On
         * cancellation (as with any error) there is no guarantee that all written
         * data will reach the target.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on failure
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE on error
         */
        flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
         */
        flush_finish(result: AsyncResult): boolean;
        /**
         * Checks if an output stream has pending actions.
         * @returns %TRUE if @stream has pending actions.
         */
        has_pending(): boolean;
        /**
         * Checks if an output stream has already been closed.
         * @returns %TRUE if @stream is closed. %FALSE otherwise.
         */
        is_closed(): boolean;
        /**
         * Checks if an output stream is being closed. This can be
         * used inside e.g. a flush implementation to see if the
         * flush (or other i/o operation) is called from within
         * the closing operation.
         * @returns %TRUE if @stream is being closed. %FALSE otherwise.
         */
        is_closing(): boolean;
        /**
         * Sets `stream` to have actions pending. If the pending flag is
         * already set or `stream` is closed, it will return %FALSE and set
         * `error`.
         * @returns %TRUE if pending was previously unset and is now set.
         */
        set_pending(): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
         */
        splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
         */
        splice_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * This function is similar to g_output_stream_write(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of `count` bytes, %TRUE is returned, and `bytes_written`
         * is set to `count`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all(buffer: Uint8Array | string, cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_write_all().
         *
         * Call g_output_stream_write_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called.
         * @param buffer the buffer containing the data to write
         * @param io_priority the io priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_all_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_write_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        write_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        write_async(
            buffer: Uint8Array | string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * A wrapper function for g_output_stream_write() which takes a
         * #GBytes as input.  This can be more convenient for use by language
         * bindings or in other cases where the refcounted nature of #GBytes
         * is helpful over a bare pointer interface.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write().  If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         * @param bytes the #GBytes to write
         * @param cancellable optional cancellable object
         * @returns Number of bytes written, or -1 on error
         */
        write_bytes(bytes: GLib.Bytes | Uint8Array, cancellable?: Cancellable | null): number;
        /**
         * This function is similar to g_output_stream_write_async(), but
         * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
         * this allows the stream to avoid taking a copy of the data.
         *
         * However, note that this function may still perform partial writes,
         * just like g_output_stream_write_async(). If that occurs, to continue
         * writing, you will need to create a new #GBytes containing just the
         * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
         * #GBytes instance multiple times potentially can result in duplicated
         * data in the output stream.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write_bytes().
         * @param bytes The bytes to write
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        write_bytes_async(
            bytes: GLib.Bytes | Uint8Array,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write-from-#GBytes operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_bytes_finish(result: AsyncResult): number;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         * @returns a #gssize containing the number of bytes written to the stream.
         */
        write_finish(result: AsyncResult): number;
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * This function is similar to g_output_stream_writev(), except it tries to
         * write as many bytes as requested, only stopping on an error.
         *
         * On a successful write of all `n_vectors` vectors, %TRUE is returned, and
         * `bytes_written` is set to the sum of all the sizes of `vectors`.
         *
         * If there is an error during the operation %FALSE is returned and `error`
         * is set to indicate the error status.
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C. If you need it from another
         * language then you must write your own loop around
         * g_output_stream_write().
         *
         * The content of the individual elements of `vectors` might be changed by this
         * function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_all_finish() to get the result of the
         * operation.
         *
         * This is the asynchronous version of g_output_stream_writev_all().
         *
         * Call g_output_stream_writev_all_finish() to collect the result.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called. The content of the individual elements
         * of `vectors` might be changed by this function.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_all_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream write operation started with
         * g_output_stream_writev_all_async().
         *
         * As a special exception to the normal conventions for functions that
         * use #GError, if this function returns %FALSE (and sets `error)` then
         * `bytes_written` will be set to the number of bytes that were
         * successfully written before the error was encountered.  This
         * functionality is only available from C.  If you need it from another
         * language then you must write your own loop around
         * g_output_stream_writev_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_all_finish(result: AsyncResult): [boolean, number];
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE if there was an error
         */
        writev_finish(result: AsyncResult): [boolean, number];
        /**
         * Requests an asynchronous close of the stream, releasing resources
         * related to it. When the operation is finished `callback` will be
         * called. You can then call g_output_stream_close_finish() to get
         * the result of the operation.
         *
         * For behaviour details see g_output_stream_close().
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         * @param io_priority the io priority of the request.
         * @param cancellable optional cancellable object
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Closes an output stream.
         * @param result a #GAsyncResult.
         */
        vfunc_close_finish(result: AsyncResult): boolean;
        vfunc_close_fn(cancellable?: Cancellable | null): boolean;
        /**
         * Forces a write of all user-space buffered data for the given
         * `stream`. Will block during the operation. Closing the stream will
         * implicitly cause a flush.
         *
         * This function is optional for inherited classes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional cancellable object
         */
        vfunc_flush(cancellable?: Cancellable | null): boolean;
        /**
         * Forces an asynchronous write of all user-space buffered data for
         * the given `stream`.
         * For behaviour details see g_output_stream_flush().
         *
         * When the operation is finished `callback` will be
         * called. You can then call g_output_stream_flush_finish() to get the
         * result of the operation.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_flush_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes flushing an output stream.
         * @param result a GAsyncResult.
         */
        vfunc_flush_finish(result: AsyncResult): boolean;
        /**
         * Splices an input stream into an output stream.
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
        /**
         * Splices a stream asynchronously.
         * When the operation is finished `callback` will be called.
         * You can then call g_output_stream_splice_finish() to get the
         * result of the operation.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_splice().
         * @param source a #GInputStream.
         * @param flags a set of #GOutputStreamSpliceFlags.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_splice_async(
            source: InputStream,
            flags: OutputStreamSpliceFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous stream splice operation.
         * @param result a #GAsyncResult.
         */
        vfunc_splice_finish(result: AsyncResult): number;
        /**
         * Request an asynchronous write of `count` bytes from `buffer` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_write_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * A value of `count` larger than %G_MAXSSIZE will cause a
         * %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_write().
         *
         * Note that no copy of `buffer` will be made, so it must stay valid
         * until `callback` is called. See g_output_stream_write_bytes_async()
         * for a #GBytes version that will automatically hold a reference to
         * the contents (without copying) for the duration of the call.
         * @param buffer the buffer containing the data to write.
         * @param io_priority the io priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_write_async(
            buffer: Uint8Array | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream write operation.
         * @param result a #GAsyncResult.
         */
        vfunc_write_finish(result: AsyncResult): number;
        /**
         * Tries to write `count` bytes from `buffer` into the stream. Will block
         * during the operation.
         *
         * If count is 0, returns 0 and does nothing. A value of `count`
         * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `count` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * On error -1 is returned and `error` is set accordingly.
         * @param buffer the buffer containing the data to write.
         * @param cancellable optional cancellable object
         */
        vfunc_write_fn(buffer?: Uint8Array | null, cancellable?: Cancellable | null): number;
        /**
         * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
         * the stream. When the operation is finished `callback` will be called.
         * You can then call g_output_stream_writev_finish() to get the result of the
         * operation.
         *
         * During an async request no other sync and async calls are allowed,
         * and will result in %G_IO_ERROR_PENDING errors.
         *
         * On success, the number of bytes written will be passed to the
         * `callback`. It is not an error if this is not the same as the
         * requested size, as it can happen e.g. on a partial I/O error,
         * but generally we try to write as many bytes as requested.
         *
         * You are guaranteed that this method will never fail with
         * %G_IO_ERROR_WOULD_BLOCK  if `stream` can't accept more data, the
         * method will just wait until this changes.
         *
         * Any outstanding I/O request with higher priority (lower numerical
         * value) will be executed before an outstanding request with lower
         * priority. Default priority is %G_PRIORITY_DEFAULT.
         *
         * The asynchronous methods have a default fallback that uses threads
         * to implement asynchronicity, so they are optional for inheriting
         * classes. However, if you override one you must override all.
         *
         * For the synchronous, blocking version of this function, see
         * g_output_stream_writev().
         *
         * Note that no copy of `vectors` will be made, so it must stay valid
         * until `callback` is called.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param io_priority the I/O priority of the request.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_writev_async(
            vectors: OutputVector[],
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stream writev operation.
         * @param result a #GAsyncResult.
         */
        vfunc_writev_finish(result: AsyncResult): [boolean, number];
        /**
         * Tries to write the bytes contained in the `n_vectors` `vectors` into the
         * stream. Will block during the operation.
         *
         * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
         * does nothing.
         *
         * On success, the number of bytes written to the stream is returned.
         * It is not an error if this is not the same as the requested size, as it
         * can happen e.g. on a partial I/O error, or if there is not enough
         * storage in the stream. All writes block until at least one byte
         * is written or an error occurs; 0 is never returned (unless
         * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         *
         * Some implementations of g_output_stream_writev() may have limitations on the
         * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
         * are exceeded. For example, when writing to a local file on UNIX platforms,
         * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable optional cancellable object
         */
        vfunc_writev_fn(vectors: OutputVector[], cancellable?: Cancellable | null): [boolean, number];
    }

    module UnixSocketAddress {
        // Constructor properties interface

        interface ConstructorProps extends SocketAddress.ConstructorProps, SocketConnectable.ConstructorProps {
            abstract: boolean;
            address_type: UnixSocketAddressType;
            addressType: UnixSocketAddressType;
            path: string;
            path_as_array: Uint8Array;
            pathAsArray: Uint8Array;
        }
    }

    /**
     * Support for UNIX-domain (also known as local) sockets, corresponding to
     * `struct sockaddr_un`.
     *
     * UNIX domain sockets are generally visible in the filesystem.
     * However, some systems support abstract socket names which are not
     * visible in the filesystem and not affected by the filesystem
     * permissions, visibility, etc. Currently this is only supported
     * under Linux. If you attempt to use abstract sockets on other
     * systems, function calls may return `G_IO_ERROR_NOT_SUPPORTED`
     * errors. You can use [func`Gio`.UnixSocketAddress.abstract_names_supported]
     * to see if abstract names are supported.
     *
     * Since GLib 2.72, `GUnixSocketAddress` is available on all platforms. It
     * requires underlying system support (such as Windows 10 with `AF_UNIX`) at
     * run time.
     *
     * Before GLib 2.72, `<gio/gunixsocketaddress.h>` belonged to the UNIX-specific
     * GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
     * when using it. This is no longer necessary since GLib 2.72.
     */
    class UnixSocketAddress extends SocketAddress implements SocketConnectable {
        static $gtype: GObject.GType<UnixSocketAddress>;

        // Properties

        /**
         * Whether or not this is an abstract address
         */
        get abstract(): boolean;
        /**
         * The type of Unix socket address.
         */
        get address_type(): UnixSocketAddressType;
        /**
         * The type of Unix socket address.
         */
        get addressType(): UnixSocketAddressType;
        /**
         * Unix socket path.
         */
        get path(): string;
        /**
         * Unix socket path, as a byte array.
         */
        get path_as_array(): Uint8Array;
        /**
         * Unix socket path, as a byte array.
         */
        get pathAsArray(): Uint8Array;

        // Constructors

        constructor(properties?: Partial<UnixSocketAddress.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](path: string): UnixSocketAddress;

        static new_abstract(path: number[]): UnixSocketAddress;

        static new_with_type(path: number[], type: UnixSocketAddressType): UnixSocketAddress;

        // Static methods

        /**
         * Checks if abstract UNIX domain socket names are supported.
         */
        static abstract_names_supported(): boolean;

        // Methods

        /**
         * Gets `address'`s type.
         * @returns a #GUnixSocketAddressType
         */
        get_address_type(): UnixSocketAddressType;
        /**
         * Tests if `address` is abstract.
         * @returns %TRUE if the address is abstract, %FALSE otherwise
         */
        get_is_abstract(): boolean;
        /**
         * Gets `address'`s path, or for abstract sockets the "name".
         *
         * Guaranteed to be zero-terminated, but an abstract socket
         * may contain embedded zeros, and thus you should use
         * g_unix_socket_address_get_path_len() to get the true length
         * of this string.
         * @returns the path for @address
         */
        get_path(): string;
        /**
         * Gets the length of `address'`s path.
         *
         * For details, see g_unix_socket_address_get_path().
         * @returns the length of the path
         */
        get_path_len(): number;

        // Inherited methods
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         */
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Vfs {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * Entry point for using GIO functionality.
     */
    class Vfs extends GObject.Object {
        static $gtype: GObject.GType<Vfs>;

        // Constructors

        constructor(properties?: Partial<Vfs.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets the default #GVfs for the system.
         */
        static get_default(): Vfs;
        /**
         * Gets the local #GVfs for the system.
         */
        static get_local(): Vfs;

        // Virtual methods

        vfunc_add_writable_namespaces(list: FileAttributeInfoList): void;
        /**
         * Gets a #GFile for `path`.
         * @param path a string containing a VFS path.
         */
        vfunc_get_file_for_path(path: string): File;
        /**
         * Gets a #GFile for `uri`.
         *
         * This operation never fails, but the returned object
         * might not support any I/O operation if the URI
         * is malformed or if the URI scheme is not supported.
         * @param uri a string containing a URI
         */
        vfunc_get_file_for_uri(uri: string): File;
        /**
         * Gets a list of URI schemes supported by `vfs`.
         */
        vfunc_get_supported_uri_schemes(): string[];
        /**
         * Checks if the VFS is active.
         */
        vfunc_is_active(): boolean;
        vfunc_local_file_add_info(
            filename: string,
            device: number,
            attribute_matcher: FileAttributeMatcher,
            info: FileInfo,
            cancellable?: Cancellable | null,
            extra_data?: any | null,
        ): void;
        vfunc_local_file_moved(source: string, dest: string): void;
        vfunc_local_file_removed(filename: string): void;
        vfunc_local_file_set_attributes(
            filename: string,
            info: FileInfo,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * This operation never fails, but the returned object might
         * not support any I/O operations if the `parse_name` cannot
         * be parsed by the #GVfs module.
         * @param parse_name a string to be parsed by the VFS module.
         */
        vfunc_parse_name(parse_name: string): File;

        // Methods

        /**
         * Gets a #GFile for `path`.
         * @param path a string containing a VFS path.
         * @returns a #GFile.     Free the returned object with g_object_unref().
         */
        get_file_for_path(path: string): File;
        /**
         * Gets a #GFile for `uri`.
         *
         * This operation never fails, but the returned object
         * might not support any I/O operation if the URI
         * is malformed or if the URI scheme is not supported.
         * @param uri a string containing a URI
         * @returns a #GFile.     Free the returned object with g_object_unref().
         */
        get_file_for_uri(uri: string): File;
        /**
         * Gets a list of URI schemes supported by `vfs`.
         * @returns a %NULL-terminated array of strings.     The returned array belongs to GIO and must     not be freed or modified.
         */
        get_supported_uri_schemes(): string[];
        /**
         * Checks if the VFS is active.
         * @returns %TRUE if construction of the @vfs was successful     and it is now active.
         */
        is_active(): boolean;
        /**
         * This operation never fails, but the returned object might
         * not support any I/O operations if the `parse_name` cannot
         * be parsed by the #GVfs module.
         * @param parse_name a string to be parsed by the VFS module.
         * @returns a #GFile for the given @parse_name.     Free the returned object with g_object_unref().
         */
        parse_name(parse_name: string): File;
        /**
         * Registers `uri_func` and `parse_name_func` as the #GFile URI and parse name
         * lookup functions for URIs with a scheme matching `scheme`.
         * Note that `scheme` is registered only within the running application, as
         * opposed to desktop-wide as it happens with GVfs backends.
         *
         * When a #GFile is requested with an URI containing `scheme` (e.g. through
         * g_file_new_for_uri()), `uri_func` will be called to allow a custom
         * constructor. The implementation of `uri_func` should not be blocking, and
         * must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
         *
         * When g_file_parse_name() is called with a parse name obtained from such file,
         * `parse_name_func` will be called to allow the #GFile to be created again. In
         * that case, it's responsibility of `parse_name_func` to make sure the parse
         * name matches what the custom #GFile implementation returned when
         * g_file_get_parse_name() was previously called. The implementation of
         * `parse_name_func` should not be blocking, and must not call
         * g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
         *
         * It's an error to call this function twice with the same scheme. To unregister
         * a custom URI scheme, use g_vfs_unregister_uri_scheme().
         * @param scheme an URI scheme, e.g. "http"
         * @param uri_func a #GVfsFileLookupFunc
         * @param uri_destroy function to be called when unregistering the     URI scheme, or when @vfs is disposed, to free the resources used     by the URI lookup function
         * @param parse_name_func a #GVfsFileLookupFunc
         * @param parse_name_destroy function to be called when unregistering the     URI scheme, or when @vfs is disposed, to free the resources used     by the parse name lookup function
         * @returns %TRUE if @scheme was successfully registered, or %FALSE if a handler     for @scheme already exists.
         */
        register_uri_scheme(
            scheme: string,
            uri_func?: VfsFileLookupFunc | null,
            uri_destroy?: GLib.DestroyNotify | null,
            parse_name_func?: VfsFileLookupFunc | null,
            parse_name_destroy?: GLib.DestroyNotify | null,
        ): boolean;
        /**
         * Unregisters the URI handler for `scheme` previously registered with
         * g_vfs_register_uri_scheme().
         * @param scheme an URI scheme, e.g. "http"
         * @returns %TRUE if @scheme was successfully unregistered, or %FALSE if a     handler for @scheme does not exist.
         */
        unregister_uri_scheme(scheme: string): boolean;
    }

    module VolumeMonitor {
        // Signal callback interfaces

        interface DriveChanged {
            (drive: Drive): void;
        }

        interface DriveConnected {
            (drive: Drive): void;
        }

        interface DriveDisconnected {
            (drive: Drive): void;
        }

        interface DriveEjectButton {
            (drive: Drive): void;
        }

        interface DriveStopButton {
            (drive: Drive): void;
        }

        interface MountAdded {
            (mount: Mount): void;
        }

        interface MountChanged {
            (mount: Mount): void;
        }

        interface MountPreUnmount {
            (mount: Mount): void;
        }

        interface MountRemoved {
            (mount: Mount): void;
        }

        interface VolumeAdded {
            (volume: Volume): void;
        }

        interface VolumeChanged {
            (volume: Volume): void;
        }

        interface VolumeRemoved {
            (volume: Volume): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * `GVolumeMonitor` is for listing the user interesting devices and volumes
     * on the computer. In other words, what a file selector or file manager
     * would show in a sidebar.
     *
     * `GVolumeMonitor` is not
     * thread-default-context aware (see
     * [method`GLib`.MainContext.push_thread_default]), and so should not be used
     * other than from the main thread, with no thread-default-context active.
     *
     * In order to receive updates about volumes and mounts monitored through GVFS,
     * a main loop must be running.
     */
    class VolumeMonitor extends GObject.Object {
        static $gtype: GObject.GType<VolumeMonitor>;

        // Constructors

        constructor(properties?: Partial<VolumeMonitor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'drive-changed', callback: (_source: this, drive: Drive) => void): number;
        connect_after(signal: 'drive-changed', callback: (_source: this, drive: Drive) => void): number;
        emit(signal: 'drive-changed', drive: Drive): void;
        connect(signal: 'drive-connected', callback: (_source: this, drive: Drive) => void): number;
        connect_after(signal: 'drive-connected', callback: (_source: this, drive: Drive) => void): number;
        emit(signal: 'drive-connected', drive: Drive): void;
        connect(signal: 'drive-disconnected', callback: (_source: this, drive: Drive) => void): number;
        connect_after(signal: 'drive-disconnected', callback: (_source: this, drive: Drive) => void): number;
        emit(signal: 'drive-disconnected', drive: Drive): void;
        connect(signal: 'drive-eject-button', callback: (_source: this, drive: Drive) => void): number;
        connect_after(signal: 'drive-eject-button', callback: (_source: this, drive: Drive) => void): number;
        emit(signal: 'drive-eject-button', drive: Drive): void;
        connect(signal: 'drive-stop-button', callback: (_source: this, drive: Drive) => void): number;
        connect_after(signal: 'drive-stop-button', callback: (_source: this, drive: Drive) => void): number;
        emit(signal: 'drive-stop-button', drive: Drive): void;
        connect(signal: 'mount-added', callback: (_source: this, mount: Mount) => void): number;
        connect_after(signal: 'mount-added', callback: (_source: this, mount: Mount) => void): number;
        emit(signal: 'mount-added', mount: Mount): void;
        connect(signal: 'mount-changed', callback: (_source: this, mount: Mount) => void): number;
        connect_after(signal: 'mount-changed', callback: (_source: this, mount: Mount) => void): number;
        emit(signal: 'mount-changed', mount: Mount): void;
        connect(signal: 'mount-pre-unmount', callback: (_source: this, mount: Mount) => void): number;
        connect_after(signal: 'mount-pre-unmount', callback: (_source: this, mount: Mount) => void): number;
        emit(signal: 'mount-pre-unmount', mount: Mount): void;
        connect(signal: 'mount-removed', callback: (_source: this, mount: Mount) => void): number;
        connect_after(signal: 'mount-removed', callback: (_source: this, mount: Mount) => void): number;
        emit(signal: 'mount-removed', mount: Mount): void;
        connect(signal: 'volume-added', callback: (_source: this, volume: Volume) => void): number;
        connect_after(signal: 'volume-added', callback: (_source: this, volume: Volume) => void): number;
        emit(signal: 'volume-added', volume: Volume): void;
        connect(signal: 'volume-changed', callback: (_source: this, volume: Volume) => void): number;
        connect_after(signal: 'volume-changed', callback: (_source: this, volume: Volume) => void): number;
        emit(signal: 'volume-changed', volume: Volume): void;
        connect(signal: 'volume-removed', callback: (_source: this, volume: Volume) => void): number;
        connect_after(signal: 'volume-removed', callback: (_source: this, volume: Volume) => void): number;
        emit(signal: 'volume-removed', volume: Volume): void;

        // Static methods

        /**
         * This function should be called by any #GVolumeMonitor
         * implementation when a new #GMount object is created that is not
         * associated with a #GVolume object. It must be called just before
         * emitting the `mount_added` signal.
         *
         * If the return value is not %NULL, the caller must associate the
         * returned #GVolume object with the #GMount. This involves returning
         * it in its g_mount_get_volume() implementation. The caller must
         * also listen for the "removed" signal on the returned object
         * and give up its reference when handling that signal
         *
         * Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
         * the implementor must take a reference to `mount` and return it in
         * its g_volume_get_mount() implemented. Also, the implementor must
         * listen for the "unmounted" signal on `mount` and give up its
         * reference upon handling that signal.
         *
         * There are two main use cases for this function.
         *
         * One is when implementing a user space file system driver that reads
         * blocks of a block device that is already represented by the native
         * volume monitor (for example a CD Audio file system driver). Such
         * a driver will generate its own #GMount object that needs to be
         * associated with the #GVolume object that represents the volume.
         *
         * The other is for implementing a #GVolumeMonitor whose sole purpose
         * is to return #GVolume objects representing entries in the users
         * "favorite servers" list or similar.
         * @param mount a #GMount object to find a parent for
         */
        static adopt_orphan_mount(mount: Mount): Volume;
        /**
         * Gets the volume monitor used by gio.
         */
        static get(): VolumeMonitor;

        // Virtual methods

        vfunc_drive_changed(drive: Drive): void;
        vfunc_drive_connected(drive: Drive): void;
        vfunc_drive_disconnected(drive: Drive): void;
        vfunc_drive_eject_button(drive: Drive): void;
        vfunc_drive_stop_button(drive: Drive): void;
        /**
         * Gets a list of drives connected to the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         */
        vfunc_get_connected_drives(): Drive[];
        /**
         * Finds a #GMount object by its UUID (see g_mount_get_uuid())
         * @param uuid the UUID to look for
         */
        vfunc_get_mount_for_uuid(uuid: string): Mount | null;
        /**
         * Gets a list of the mounts on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         */
        vfunc_get_mounts(): Mount[];
        /**
         * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
         * @param uuid the UUID to look for
         */
        vfunc_get_volume_for_uuid(uuid: string): Volume | null;
        /**
         * Gets a list of the volumes on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         */
        vfunc_get_volumes(): Volume[];
        vfunc_mount_added(mount: Mount): void;
        vfunc_mount_changed(mount: Mount): void;
        vfunc_mount_pre_unmount(mount: Mount): void;
        vfunc_mount_removed(mount: Mount): void;
        vfunc_volume_added(volume: Volume): void;
        vfunc_volume_changed(volume: Volume): void;
        vfunc_volume_removed(volume: Volume): void;

        // Methods

        /**
         * Gets a list of drives connected to the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns a #GList of connected #GDrive objects.
         */
        get_connected_drives(): Drive[];
        /**
         * Finds a #GMount object by its UUID (see g_mount_get_uuid())
         * @param uuid the UUID to look for
         * @returns a #GMount or %NULL if no such mount is available.     Free the returned object with g_object_unref().
         */
        get_mount_for_uuid(uuid: string): Mount | null;
        /**
         * Gets a list of the mounts on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns a #GList of #GMount objects.
         */
        get_mounts(): Mount[];
        /**
         * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
         * @param uuid the UUID to look for
         * @returns a #GVolume or %NULL if no such volume is available.     Free the returned object with g_object_unref().
         */
        get_volume_for_uuid(uuid: string): Volume | null;
        /**
         * Gets a list of the volumes on the system.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns a #GList of #GVolume objects.
         */
        get_volumes(): Volume[];
    }

    module ZlibCompressor {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Converter.ConstructorProps {
            file_info: FileInfo;
            fileInfo: FileInfo;
            format: ZlibCompressorFormat;
            level: number;
        }
    }

    /**
     * `GZlibCompressor` is an implementation of [iface`Gio`.Converter] that
     * compresses data using zlib.
     */
    class ZlibCompressor extends GObject.Object implements Converter {
        static $gtype: GObject.GType<ZlibCompressor>;

        // Properties

        /**
         * If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
         * %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
         * and modification time from the file info to the GZIP header.
         */
        get file_info(): FileInfo;
        set file_info(val: FileInfo);
        /**
         * If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
         * %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
         * and modification time from the file info to the GZIP header.
         */
        get fileInfo(): FileInfo;
        set fileInfo(val: FileInfo);
        /**
         * The format of the compressed data.
         */
        get format(): ZlibCompressorFormat;
        /**
         * The level of compression from `0` (no compression) to `9` (most
         * compression). `-1` for the default level.
         */
        get level(): number;

        // Constructors

        constructor(properties?: Partial<ZlibCompressor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](format: ZlibCompressorFormat, level: number): ZlibCompressor;

        // Methods

        /**
         * Returns the #GZlibCompressor:file-info property.
         * @returns a #GFileInfo, or %NULL
         */
        get_file_info(): FileInfo | null;
        /**
         * Sets `file_info` in `compressor`. If non-%NULL, and `compressor'`s
         * #GZlibCompressor:format property is %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
         * it will be used to set the file name and modification time in
         * the GZIP header of the compressed data.
         *
         * Note: it is an error to call this function while a compression is in
         * progress; it may only be called immediately after creation of `compressor,`
         * or after resetting it with g_converter_reset().
         * @param file_info a #GFileInfo
         */
        set_file_info(file_info?: FileInfo | null): void;

        // Inherited methods
        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
         */
        convert(
            inbuf: Uint8Array | string,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        reset(): void;
        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         */
        vfunc_convert(
            inbuf: Uint8Array | null,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        vfunc_reset(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ZlibDecompressor {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Converter.ConstructorProps {
            file_info: FileInfo;
            fileInfo: FileInfo;
            format: ZlibCompressorFormat;
        }
    }

    /**
     * `GZlibDecompressor` is an implementation of [iface`Gio`.Converter] that
     * decompresses data compressed with zlib.
     */
    class ZlibDecompressor extends GObject.Object implements Converter {
        static $gtype: GObject.GType<ZlibDecompressor>;

        // Properties

        /**
         * A #GFileInfo containing the information found in the GZIP header
         * of the data stream processed, or %NULL if the header was not yet
         * fully processed, is not present at all, or the compressor's
         * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.
         */
        get file_info(): FileInfo;
        /**
         * A #GFileInfo containing the information found in the GZIP header
         * of the data stream processed, or %NULL if the header was not yet
         * fully processed, is not present at all, or the compressor's
         * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.
         */
        get fileInfo(): FileInfo;
        /**
         * The format of the compressed data.
         */
        get format(): ZlibCompressorFormat;

        // Constructors

        constructor(properties?: Partial<ZlibDecompressor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](format: ZlibCompressorFormat): ZlibDecompressor;

        // Methods

        /**
         * Retrieves the #GFileInfo constructed from the GZIP header data
         * of compressed data processed by `compressor,` or %NULL if `decompressor'`s
         * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
         * or the header data was not fully processed yet, or it not present in the
         * data stream at all.
         * @returns a #GFileInfo, or %NULL
         */
        get_file_info(): FileInfo | null;

        // Inherited methods
        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
         */
        convert(
            inbuf: Uint8Array | string,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        reset(): void;
        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         */
        vfunc_convert(
            inbuf: Uint8Array | null,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        vfunc_reset(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    /**
     * This struct defines a single action.  It is for use with
     * g_action_map_add_action_entries().
     *
     * The order of the items in the structure are intended to reflect
     * frequency of use.  It is permissible to use an incomplete initialiser
     * in order to leave some of the later values as %NULL.  All values
     * after `name` are optional.  Additional optional fields may be added in
     * the future.
     *
     * See g_action_map_add_action_entries() for an example.
     */
    class ActionEntry {
        static $gtype: GObject.GType<ActionEntry>;

        // Fields

        name: string;
        parameter_type: string;
        state: string;

        // Constructors

        constructor(
            properties?: Partial<{
                name: string;
                parameter_type: string;
                state: string;
            }>,
        );
        _init(...args: any[]): void;
    }

    type ActionGroupInterface = typeof ActionGroup;
    type ActionInterface = typeof Action;
    type ActionMapInterface = typeof ActionMap;
    type AppInfoIface = typeof AppInfo;
    type AppLaunchContextClass = typeof AppLaunchContext;
    abstract class AppLaunchContextPrivate {
        static $gtype: GObject.GType<AppLaunchContextPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ApplicationClass = typeof Application;
    type ApplicationCommandLineClass = typeof ApplicationCommandLine;
    abstract class ApplicationCommandLinePrivate {
        static $gtype: GObject.GType<ApplicationCommandLinePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class ApplicationPrivate {
        static $gtype: GObject.GType<ApplicationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AsyncInitableIface = typeof AsyncInitable;
    type AsyncResultIface = typeof AsyncResult;
    type BufferedInputStreamClass = typeof BufferedInputStream;
    abstract class BufferedInputStreamPrivate {
        static $gtype: GObject.GType<BufferedInputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BufferedOutputStreamClass = typeof BufferedOutputStream;
    abstract class BufferedOutputStreamPrivate {
        static $gtype: GObject.GType<BufferedOutputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CancellableClass = typeof Cancellable;
    abstract class CancellablePrivate {
        static $gtype: GObject.GType<CancellablePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CharsetConverterClass = typeof CharsetConverter;
    type ConverterIface = typeof Converter;
    type ConverterInputStreamClass = typeof ConverterInputStream;
    abstract class ConverterInputStreamPrivate {
        static $gtype: GObject.GType<ConverterInputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ConverterOutputStreamClass = typeof ConverterOutputStream;
    abstract class ConverterOutputStreamPrivate {
        static $gtype: GObject.GType<ConverterOutputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CredentialsClass = typeof Credentials;
    /**
     * Information about an annotation.
     */
    class DBusAnnotationInfo {
        static $gtype: GObject.GType<DBusAnnotationInfo>;

        // Fields

        ref_count: number;
        key: string;
        value: string;
        annotations: DBusAnnotationInfo[];

        // Constructors

        constructor(
            properties?: Partial<{
                ref_count: number;
                key: string;
                value: string;
                annotations: DBusAnnotationInfo[];
            }>,
        );
        _init(...args: any[]): void;

        // Static methods

        /**
         * Looks up the value of an annotation.
         *
         * The cost of this function is O(n) in number of annotations.
         * @param annotations A %NULL-terminated array of annotations or %NULL.
         * @param name The name of the annotation to look up.
         */
        static lookup(annotations: DBusAnnotationInfo[] | null, name: string): string | null;

        // Methods

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusAnnotationInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about an argument for a method or a signal.
     */
    class DBusArgInfo {
        static $gtype: GObject.GType<DBusArgInfo>;

        // Fields

        ref_count: number;
        name: string;
        signature: string;
        annotations: DBusAnnotationInfo[];

        // Constructors

        constructor(
            properties?: Partial<{
                ref_count: number;
                name: string;
                signature: string;
                annotations: DBusAnnotationInfo[];
            }>,
        );
        _init(...args: any[]): void;

        // Methods

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusArgInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Struct used in g_dbus_error_register_error_domain().
     */
    class DBusErrorEntry {
        static $gtype: GObject.GType<DBusErrorEntry>;

        // Fields

        error_code: number;
        dbus_error_name: string;

        // Constructors

        constructor(
            properties?: Partial<{
                error_code: number;
                dbus_error_name: string;
            }>,
        );
        _init(...args: any[]): void;
    }

    type DBusInterfaceIface = typeof DBusInterface;
    /**
     * Information about a D-Bus interface.
     */
    class DBusInterfaceInfo {
        static $gtype: GObject.GType<DBusInterfaceInfo>;

        // Fields

        ref_count: number;
        name: string;
        methods: DBusMethodInfo[];
        signals: DBusSignalInfo[];
        annotations: DBusAnnotationInfo[];

        // Constructors

        _init(...args: any[]): void;

        static new_for_xml(info: string): DBusInterfaceInfo;

        // Methods

        /**
         * Builds a lookup-cache to speed up
         * g_dbus_interface_info_lookup_method(),
         * g_dbus_interface_info_lookup_signal() and
         * g_dbus_interface_info_lookup_property().
         *
         * If this has already been called with `info,` the existing cache is
         * used and its use count is increased.
         *
         * Note that `info` cannot be modified until
         * g_dbus_interface_info_cache_release() is called.
         */
        cache_build(): void;
        /**
         * Decrements the usage count for the cache for `info` built by
         * g_dbus_interface_info_cache_build() (if any) and frees the
         * resources used by the cache if the usage count drops to zero.
         */
        cache_release(): void;
        /**
         * Appends an XML representation of `info` (and its children) to `string_builder`.
         *
         * This function is typically used for generating introspection XML
         * documents at run-time for handling the
         * `org.freedesktop.DBus.Introspectable.Introspect`
         * method.
         * @param indent Indentation level.
         * @param string_builder A #GString to to append XML data to.
         */
        generate_xml(indent: number, string_builder: GLib.String): void;
        /**
         * Looks up information about a method.
         *
         * The cost of this function is O(n) in number of methods unless
         * g_dbus_interface_info_cache_build() has been used on `info`.
         * @param name A D-Bus method name (typically in CamelCase)
         * @returns A #GDBusMethodInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_method(name: string): DBusMethodInfo | null;
        /**
         * Looks up information about a property.
         *
         * The cost of this function is O(n) in number of properties unless
         * g_dbus_interface_info_cache_build() has been used on `info`.
         * @param name A D-Bus property name (typically in CamelCase).
         * @returns A #GDBusPropertyInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_property(name: string): DBusPropertyInfo | null;
        /**
         * Looks up information about a signal.
         *
         * The cost of this function is O(n) in number of signals unless
         * g_dbus_interface_info_cache_build() has been used on `info`.
         * @param name A D-Bus signal name (typically in CamelCase)
         * @returns A #GDBusSignalInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_signal(name: string): DBusSignalInfo | null;
        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusInterfaceInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    type DBusInterfaceSkeletonClass = typeof DBusInterfaceSkeleton;
    abstract class DBusInterfaceSkeletonPrivate {
        static $gtype: GObject.GType<DBusInterfaceSkeletonPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Virtual table for handling properties and method calls for a D-Bus
     * interface.
     *
     * Since 2.38, if you want to handle getting/setting D-Bus properties
     * asynchronously, give %NULL as your get_property() or set_property()
     * function. The D-Bus call will be directed to your `method_call` function,
     * with the provided `interface_name` set to "org.freedesktop.DBus.Properties".
     *
     * Ownership of the #GDBusMethodInvocation object passed to the
     * method_call() function is transferred to your handler; you must
     * call one of the methods of #GDBusMethodInvocation to return a reply
     * (possibly empty), or an error. These functions also take ownership
     * of the passed-in invocation object, so unless the invocation
     * object has otherwise been referenced, it will be then be freed.
     * Calling one of these functions may be done within your
     * method_call() implementation but it also can be done at a later
     * point to handle the method asynchronously.
     *
     * The usual checks on the validity of the calls is performed. For
     * `Get` calls, an error is automatically returned if the property does
     * not exist or the permissions do not allow access. The same checks are
     * performed for `Set` calls, and the provided value is also checked for
     * being the correct type.
     *
     * For both `Get` and `Set` calls, the #GDBusMethodInvocation
     * passed to the `method_call` handler can be queried with
     * g_dbus_method_invocation_get_property_info() to get a pointer
     * to the #GDBusPropertyInfo of the property.
     *
     * If you have readable properties specified in your interface info,
     * you must ensure that you either provide a non-%NULL `get_property(`)
     * function or provide implementations of both the `Get` and `GetAll`
     * methods on org.freedesktop.DBus.Properties interface in your `method_call`
     * function. Note that the required return type of the `Get` call is
     * `(v)`, not the type of the property. `GetAll` expects a return value
     * of type `a{sv}`.
     *
     * If you have writable properties specified in your interface info,
     * you must ensure that you either provide a non-%NULL `set_property(`)
     * function or provide an implementation of the `Set` call. If implementing
     * the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
     */
    class DBusInterfaceVTable {
        static $gtype: GObject.GType<DBusInterfaceVTable>;

        // Fields

        method_call: DBusInterfaceMethodCallFunc;
        get_property: DBusInterfaceGetPropertyFunc;
        set_property: DBusInterfaceSetPropertyFunc;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Information about a method on an D-Bus interface.
     */
    class DBusMethodInfo {
        static $gtype: GObject.GType<DBusMethodInfo>;

        // Fields

        ref_count: number;
        name: string;
        in_args: DBusArgInfo[];
        out_args: DBusArgInfo[];
        annotations: DBusAnnotationInfo[];

        // Constructors

        constructor(
            properties?: Partial<{
                ref_count: number;
                name: string;
                in_args: DBusArgInfo[];
                out_args: DBusArgInfo[];
                annotations: DBusAnnotationInfo[];
            }>,
        );
        _init(...args: any[]): void;

        // Methods

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusMethodInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Information about nodes in a remote object hierarchy.
     */
    class DBusNodeInfo {
        static $gtype: GObject.GType<DBusNodeInfo>;

        // Fields

        ref_count: number;
        path: string;
        annotations: DBusAnnotationInfo[];

        // Constructors

        constructor(xml_data: string);
        _init(...args: any[]): void;

        static new_for_xml(xml_data: string): DBusNodeInfo;

        static new_for_xml(info: string): DBusNodeInfo;

        // Methods

        /**
         * Appends an XML representation of `info` (and its children) to `string_builder`.
         *
         * This function is typically used for generating introspection XML documents at run-time for
         * handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
         * @param indent Indentation level.
         * @param string_builder A #GString to to append XML data to.
         */
        generate_xml(indent: number, string_builder: GLib.String): void;
        /**
         * Looks up information about an interface.
         *
         * The cost of this function is O(n) in number of interfaces.
         * @param name A D-Bus interface name.
         * @returns A #GDBusInterfaceInfo or %NULL if not found. Do not free, it is owned by @info.
         */
        lookup_interface(name: string): DBusInterfaceInfo | null;
        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusNodeInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    type DBusObjectIface = typeof DBusObject;
    type DBusObjectManagerClientClass = typeof DBusObjectManagerClient;
    abstract class DBusObjectManagerClientPrivate {
        static $gtype: GObject.GType<DBusObjectManagerClientPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DBusObjectManagerIface = typeof DBusObjectManager;
    type DBusObjectManagerServerClass = typeof DBusObjectManagerServer;
    abstract class DBusObjectManagerServerPrivate {
        static $gtype: GObject.GType<DBusObjectManagerServerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DBusObjectProxyClass = typeof DBusObjectProxy;
    abstract class DBusObjectProxyPrivate {
        static $gtype: GObject.GType<DBusObjectProxyPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DBusObjectSkeletonClass = typeof DBusObjectSkeleton;
    abstract class DBusObjectSkeletonPrivate {
        static $gtype: GObject.GType<DBusObjectSkeletonPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Information about a D-Bus property on a D-Bus interface.
     */
    class DBusPropertyInfo {
        static $gtype: GObject.GType<DBusPropertyInfo>;

        // Fields

        ref_count: number;
        name: string;
        signature: string;
        flags: DBusPropertyInfoFlags;
        annotations: DBusAnnotationInfo[];

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusPropertyInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    type DBusProxyClass = typeof DBusProxy;
    abstract class DBusProxyPrivate {
        static $gtype: GObject.GType<DBusProxyPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Information about a signal on a D-Bus interface.
     */
    class DBusSignalInfo {
        static $gtype: GObject.GType<DBusSignalInfo>;

        // Fields

        ref_count: number;
        name: string;
        args: DBusArgInfo[];
        annotations: DBusAnnotationInfo[];

        // Constructors

        constructor(
            properties?: Partial<{
                ref_count: number;
                name: string;
                args: DBusArgInfo[];
                annotations: DBusAnnotationInfo[];
            }>,
        );
        _init(...args: any[]): void;

        // Methods

        /**
         * If `info` is statically allocated does nothing. Otherwise increases
         * the reference count.
         * @returns The same @info.
         */
        ref(): DBusSignalInfo;
        /**
         * If `info` is statically allocated, does nothing. Otherwise decreases
         * the reference count of `info`. When its reference count drops to 0,
         * the memory used is freed.
         */
        unref(): void;
    }

    /**
     * Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
     */
    class DBusSubtreeVTable {
        static $gtype: GObject.GType<DBusSubtreeVTable>;

        // Fields

        enumerate: DBusSubtreeEnumerateFunc;
        introspect: DBusSubtreeIntrospectFunc;
        dispatch: DBusSubtreeDispatchFunc;

        // Constructors

        _init(...args: any[]): void;
    }

    type DataInputStreamClass = typeof DataInputStream;
    abstract class DataInputStreamPrivate {
        static $gtype: GObject.GType<DataInputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DataOutputStreamClass = typeof DataOutputStream;
    abstract class DataOutputStreamPrivate {
        static $gtype: GObject.GType<DataOutputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DatagramBasedInterface = typeof DatagramBased;
    type DebugControllerDBusClass = typeof DebugControllerDBus;
    type DebugControllerInterface = typeof DebugController;
    type DesktopAppInfoClass = typeof DesktopAppInfo;
    type DesktopAppInfoLookupIface = typeof DesktopAppInfoLookup;
    type DriveIface = typeof Drive;
    type DtlsClientConnectionInterface = typeof DtlsClientConnection;
    type DtlsConnectionInterface = typeof DtlsConnection;
    type DtlsServerConnectionInterface = typeof DtlsServerConnection;
    type EmblemClass = typeof Emblem;
    type EmblemedIconClass = typeof EmblemedIcon;
    abstract class EmblemedIconPrivate {
        static $gtype: GObject.GType<EmblemedIconPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Information about a specific attribute.
     */
    class FileAttributeInfo {
        static $gtype: GObject.GType<FileAttributeInfo>;

        // Fields

        name: string;
        type: FileAttributeType;
        flags: FileAttributeInfoFlags;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Acts as a lightweight registry for possible valid file attributes.
     * The registry stores Key-Value pair formats as #GFileAttributeInfos.
     */
    class FileAttributeInfoList {
        static $gtype: GObject.GType<FileAttributeInfoList>;

        // Fields

        n_infos: number;

        // Constructors

        constructor(
            properties?: Partial<{
                n_infos: number;
            }>,
        );
        _init(...args: any[]): void;

        static ['new'](): FileAttributeInfoList;

        // Methods

        /**
         * Adds a new attribute with `name` to the `list,` setting
         * its `type` and `flags`.
         * @param name the name of the attribute to add.
         * @param type the #GFileAttributeType for the attribute.
         * @param flags #GFileAttributeInfoFlags for the attribute.
         */
        add(name: string, type: FileAttributeType, flags: FileAttributeInfoFlags): void;
        /**
         * Makes a duplicate of a file attribute info list.
         * @returns a copy of the given @list.
         */
        dup(): FileAttributeInfoList;
        /**
         * Gets the file attribute with the name `name` from `list`.
         * @param name the name of the attribute to look up.
         * @returns a #GFileAttributeInfo for the @name, or %NULL if an attribute isn't found.
         */
        lookup(name: string): FileAttributeInfo;
        /**
         * References a file attribute info list.
         * @returns #GFileAttributeInfoList or %NULL on error.
         */
        ref(): FileAttributeInfoList;
        /**
         * Removes a reference from the given `list`. If the reference count
         * falls to zero, the `list` is deleted.
         */
        unref(): void;
    }

    /**
     * Determines if a string matches a file attribute.
     */
    class FileAttributeMatcher {
        static $gtype: GObject.GType<FileAttributeMatcher>;

        // Constructors

        constructor(attributes: string);
        _init(...args: any[]): void;

        static ['new'](attributes: string): FileAttributeMatcher;

        // Methods

        /**
         * Checks if the matcher will match all of the keys in a given namespace.
         * This will always return %TRUE if a wildcard character is in use (e.g. if
         * matcher was created with "standard::*" and `ns` is "standard", or if matcher was created
         * using "*" and namespace is anything.)
         *
         * TODO: this is awkwardly worded.
         * @param ns a string containing a file attribute namespace.
         * @returns %TRUE if the matcher matches all of the entries in the given @ns, %FALSE otherwise.
         */
        enumerate_namespace(ns: string): boolean;
        /**
         * Gets the next matched attribute from a #GFileAttributeMatcher.
         * @returns a string containing the next attribute or, %NULL if no more attribute exist.
         */
        enumerate_next(): string | null;
        /**
         * Checks if an attribute will be matched by an attribute matcher. If
         * the matcher was created with the "*" matching string, this function
         * will always return %TRUE.
         * @param attribute a file attribute key.
         * @returns %TRUE if @attribute matches @matcher. %FALSE otherwise.
         */
        matches(attribute: string): boolean;
        /**
         * Checks if an attribute matcher only matches a given attribute. Always
         * returns %FALSE if "*" was used when creating the matcher.
         * @param attribute a file attribute key.
         * @returns %TRUE if the matcher only matches @attribute. %FALSE otherwise.
         */
        matches_only(attribute: string): boolean;
        /**
         * References a file attribute matcher.
         * @returns a #GFileAttributeMatcher.
         */
        ref(): FileAttributeMatcher;
        /**
         * Subtracts all attributes of `subtract` from `matcher` and returns
         * a matcher that supports those attributes.
         *
         * Note that currently it is not possible to remove a single
         * attribute when the `matcher` matches the whole namespace - or remove
         * a namespace or attribute when the matcher matches everything. This
         * is a limitation of the current implementation, but may be fixed
         * in the future.
         * @param subtract The matcher to subtract
         * @returns A file attribute matcher matching all attributes of     @matcher that are not matched by @subtract
         */
        subtract(subtract?: FileAttributeMatcher | null): FileAttributeMatcher | null;
        /**
         * Prints what the matcher is matching against. The format will be
         * equal to the format passed to g_file_attribute_matcher_new().
         * The output however, might not be identical, as the matcher may
         * decide to use a different order or omit needless parts.
         * @returns a string describing the attributes the matcher matches   against or %NULL if @matcher was %NULL.
         */
        to_string(): string;
        /**
         * Unreferences `matcher`. If the reference count falls below 1,
         * the `matcher` is automatically freed.
         */
        unref(): void;
    }

    type FileDescriptorBasedIface = typeof FileDescriptorBased;
    type FileEnumeratorClass = typeof FileEnumerator;
    abstract class FileEnumeratorPrivate {
        static $gtype: GObject.GType<FileEnumeratorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FileIOStreamClass = typeof FileIOStream;
    abstract class FileIOStreamPrivate {
        static $gtype: GObject.GType<FileIOStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FileIconClass = typeof FileIcon;
    type FileIface = typeof File;
    type FileInfoClass = typeof FileInfo;
    type FileInputStreamClass = typeof FileInputStream;
    abstract class FileInputStreamPrivate {
        static $gtype: GObject.GType<FileInputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FileMonitorClass = typeof FileMonitor;
    abstract class FileMonitorPrivate {
        static $gtype: GObject.GType<FileMonitorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FileOutputStreamClass = typeof FileOutputStream;
    abstract class FileOutputStreamPrivate {
        static $gtype: GObject.GType<FileOutputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FilenameCompleterClass = typeof FilenameCompleter;
    type FilterInputStreamClass = typeof FilterInputStream;
    type FilterOutputStreamClass = typeof FilterOutputStream;
    /**
     * #GIOExtension is an opaque data structure and can only be accessed
     * using the following functions.
     */
    abstract class IOExtension {
        static $gtype: GObject.GType<IOExtension>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Gets the name under which `extension` was registered.
         *
         * Note that the same type may be registered as extension
         * for multiple extension points, under different names.
         * @returns the name of @extension.
         */
        get_name(): string;
        /**
         * Gets the priority with which `extension` was registered.
         * @returns the priority of @extension
         */
        get_priority(): number;
        /**
         * Gets the type associated with `extension`.
         * @returns the type of @extension
         */
        get_type(): GObject.GType;
    }

    /**
     * `GIOExtensionPoint` provides a mechanism for modules to extend the
     * functionality of the library or application that loaded it in an
     * organized fashion.
     *
     * An extension point is identified by a name, and it may optionally
     * require that any implementation must be of a certain type (or derived
     * thereof). Use [func`Gio`.IOExtensionPoint.register] to register an
     * extension point, and [method`Gio`.IOExtensionPoint.set_required_type] to
     * set a required type.
     *
     * A module can implement an extension point by specifying the
     * [type`GObject`.Type] that implements the functionality. Additionally, each
     * implementation of an extension point has a name, and a priority. Use
     * [func`Gio`.IOExtensionPoint.implement] to implement an extension point.
     *
     * ```c
     * GIOExtensionPoint *ep;
     *
     * // Register an extension point
     * ep = g_io_extension_point_register ("my-extension-point");
     * g_io_extension_point_set_required_type (ep, MY_TYPE_EXAMPLE);
     * ```
     *
     * ```c
     * // Implement an extension point
     * G_DEFINE_TYPE (MyExampleImpl, my_example_impl, MY_TYPE_EXAMPLE)
     * g_io_extension_point_implement ("my-extension-point",
     *                                 my_example_impl_get_type (),
     *                                 "my-example",
     *                                 10);
     * ```
     *
     *  It is up to the code that registered the extension point how
     *  it uses the implementations that have been associated with it.
     *  Depending on the use case, it may use all implementations, or
     *  only the one with the highest priority, or pick a specific
     *  one by name.
     *
     *  To avoid opening all modules just to find out what extension
     *  points they implement, GIO makes use of a caching mechanism,
     *  see [gio-querymodules](gio-querymodules.html).
     *  You are expected to run this command after installing a
     *  GIO module.
     *
     *  The `GIO_EXTRA_MODULES` environment variable can be used to
     *  specify additional directories to automatically load modules
     *  from. This environment variable has the same syntax as the
     *  `PATH`. If two modules have the same base name in different
     *  directories, then the latter one will be ignored. If additional
     *  directories are specified GIO will load modules from the built-in
     *  directory last.
     */
    abstract class IOExtensionPoint {
        static $gtype: GObject.GType<IOExtensionPoint>;

        // Constructors

        _init(...args: any[]): void;

        // Static methods

        /**
         * Registers `type` as extension for the extension point with name
         * `extension_point_name`.
         *
         * If `type` has already been registered as an extension for this
         * extension point, the existing #GIOExtension object is returned.
         * @param extension_point_name the name of the extension point
         * @param type the #GType to register as extension
         * @param extension_name the name for the extension
         * @param priority the priority for the extension
         */
        static implement(
            extension_point_name: string,
            type: GObject.GType,
            extension_name: string,
            priority: number,
        ): IOExtension;
        /**
         * Looks up an existing extension point.
         * @param name the name of the extension point
         */
        static lookup(name: string): IOExtensionPoint;
        /**
         * Registers an extension point.
         * @param name The name of the extension point
         */
        static register(name: string): IOExtensionPoint;

        // Methods

        /**
         * Finds a #GIOExtension for an extension point by name.
         * @param name the name of the extension to get
         * @returns the #GIOExtension for @extension_point that has the    given name, or %NULL if there is no extension with that name
         */
        get_extension_by_name(name: string): IOExtension;
        /**
         * Gets a list of all extensions that implement this extension point.
         * The list is sorted by priority, beginning with the highest priority.
         * @returns a #GList of     #GIOExtensions. The list is owned by GIO and should not be     modified.
         */
        get_extensions(): IOExtension[];
        /**
         * Gets the required type for `extension_point`.
         * @returns the #GType that all implementations must have,   or %G_TYPE_INVALID if the extension point has no required type
         */
        get_required_type(): GObject.GType;
        /**
         * Sets the required type for `extension_point` to `type`.
         * All implementations must henceforth have this type.
         * @param type the #GType to require
         */
        set_required_type(type: GObject.GType): void;
    }

    type IOModuleClass = typeof IOModule;
    /**
     * Represents a scope for loading IO modules. A scope can be used for blocking
     * duplicate modules, or blocking a module you don't want to load.
     *
     * The scope can be used with g_io_modules_load_all_in_directory_with_scope()
     * or g_io_modules_scan_all_in_directory_with_scope().
     */
    abstract class IOModuleScope {
        static $gtype: GObject.GType<IOModuleScope>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Block modules with the given `basename` from being loaded when
         * this scope is used with g_io_modules_scan_all_in_directory_with_scope()
         * or g_io_modules_load_all_in_directory_with_scope().
         * @param basename the basename to block
         */
        block(basename: string): void;
        /**
         * Free a module scope.
         */
        free(): void;
    }

    /**
     * Opaque class for defining and scheduling IO jobs.
     */
    abstract class IOSchedulerJob {
        static $gtype: GObject.GType<IOSchedulerJob>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Used from an I/O job to send a callback to be run in the thread
         * that the job was started from, waiting for the result (and thus
         * blocking the I/O job).
         * @param func a #GSourceFunc callback that will be called in the original thread
         * @param notify a #GDestroyNotify for @user_data, or %NULL
         * @returns The return value of @func
         */
        send_to_mainloop(func: GLib.SourceFunc, notify?: GLib.DestroyNotify | null): boolean;
        /**
         * Used from an I/O job to send a callback to be run asynchronously in
         * the thread that the job was started from. The callback will be run
         * when the main loop is available, but at that time the I/O job might
         * have finished. The return value from the callback is ignored.
         *
         * Note that if you are passing the `user_data` from g_io_scheduler_push_job()
         * on to this function you have to ensure that it is not freed before
         * `func` is called, either by passing %NULL as `notify` to
         * g_io_scheduler_push_job() or by using refcounting for `user_data`.
         * @param func a #GSourceFunc callback that will be called in the original thread
         * @param notify a #GDestroyNotify for @user_data, or %NULL
         */
        send_to_mainloop_async(func: GLib.SourceFunc, notify?: GLib.DestroyNotify | null): void;
    }

    abstract class IOStreamAdapter {
        static $gtype: GObject.GType<IOStreamAdapter>;

        // Constructors

        _init(...args: any[]): void;
    }

    type IOStreamClass = typeof IOStream;
    abstract class IOStreamPrivate {
        static $gtype: GObject.GType<IOStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type IconIface = typeof Icon;
    type InetAddressClass = typeof InetAddress;
    type InetAddressMaskClass = typeof InetAddressMask;
    abstract class InetAddressMaskPrivate {
        static $gtype: GObject.GType<InetAddressMaskPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class InetAddressPrivate {
        static $gtype: GObject.GType<InetAddressPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type InetSocketAddressClass = typeof InetSocketAddress;
    abstract class InetSocketAddressPrivate {
        static $gtype: GObject.GType<InetSocketAddressPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type InitableIface = typeof Initable;
    /**
     * Structure used for scatter/gather data input when receiving multiple
     * messages or packets in one go. You generally pass in an array of empty
     * #GInputVectors and the operation will use all the buffers as if they
     * were one buffer, and will set `bytes_received` to the total number of bytes
     * received across all #GInputVectors.
     *
     * This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
     * the POSIX sockets API (see `man 2 recvmmsg`).
     *
     * If `address` is non-%NULL then it is set to the source address the message
     * was received from, and the caller must free it afterwards.
     *
     * If `control_messages` is non-%NULL then it is set to an array of control
     * messages received with the message (if any), and the caller must free it
     * afterwards. `num_control_messages` is set to the number of elements in
     * this array, which may be zero.
     *
     * Flags relevant to this message will be returned in `flags`. For example,
     * `MSG_EOR` or `MSG_TRUNC`.
     */
    class InputMessage {
        static $gtype: GObject.GType<InputMessage>;

        // Fields

        address: SocketAddress;
        vectors: InputVector[];
        num_vectors: number;
        bytes_received: number;
        flags: number;
        control_messages: SocketControlMessage[];
        num_control_messages: number;

        // Constructors

        _init(...args: any[]): void;
    }

    type InputStreamClass = typeof InputStream;
    abstract class InputStreamPrivate {
        static $gtype: GObject.GType<InputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Structure used for scatter/gather data input.
     * You generally pass in an array of #GInputVectors
     * and the operation will store the read data starting in the
     * first buffer, switching to the next as needed.
     */
    class InputVector {
        static $gtype: GObject.GType<InputVector>;

        // Fields

        buffer: any;
        size: number;

        // Constructors

        constructor(
            properties?: Partial<{
                buffer: any;
                size: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type ListModelInterface = typeof ListModel;
    type ListStoreClass = typeof ListStore;
    type LoadableIconIface = typeof LoadableIcon;
    type MemoryInputStreamClass = typeof MemoryInputStream;
    abstract class MemoryInputStreamPrivate {
        static $gtype: GObject.GType<MemoryInputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type MemoryMonitorInterface = typeof MemoryMonitor;
    type MemoryOutputStreamClass = typeof MemoryOutputStream;
    abstract class MemoryOutputStreamPrivate {
        static $gtype: GObject.GType<MemoryOutputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type MenuAttributeIterClass = typeof MenuAttributeIter;
    abstract class MenuAttributeIterPrivate {
        static $gtype: GObject.GType<MenuAttributeIterPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type MenuLinkIterClass = typeof MenuLinkIter;
    abstract class MenuLinkIterPrivate {
        static $gtype: GObject.GType<MenuLinkIterPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type MenuModelClass = typeof MenuModel;
    abstract class MenuModelPrivate {
        static $gtype: GObject.GType<MenuModelPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type MountIface = typeof Mount;
    type MountOperationClass = typeof MountOperation;
    abstract class MountOperationPrivate {
        static $gtype: GObject.GType<MountOperationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type NativeSocketAddressClass = typeof NativeSocketAddress;
    abstract class NativeSocketAddressPrivate {
        static $gtype: GObject.GType<NativeSocketAddressPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type NativeVolumeMonitorClass = typeof NativeVolumeMonitor;
    type NetworkAddressClass = typeof NetworkAddress;
    abstract class NetworkAddressPrivate {
        static $gtype: GObject.GType<NetworkAddressPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type NetworkMonitorInterface = typeof NetworkMonitor;
    type NetworkServiceClass = typeof NetworkService;
    abstract class NetworkServicePrivate {
        static $gtype: GObject.GType<NetworkServicePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Structure used for scatter/gather data output when sending multiple
     * messages or packets in one go. You generally pass in an array of
     * #GOutputVectors and the operation will use all the buffers as if they
     * were one buffer.
     *
     * If `address` is %NULL then the message is sent to the default receiver
     * (as previously set by g_socket_connect()).
     */
    class OutputMessage {
        static $gtype: GObject.GType<OutputMessage>;

        // Fields

        address: SocketAddress;
        vectors: OutputVector;
        num_vectors: number;
        bytes_sent: number;
        control_messages: SocketControlMessage[];
        num_control_messages: number;

        // Constructors

        _init(...args: any[]): void;
    }

    type OutputStreamClass = typeof OutputStream;
    abstract class OutputStreamPrivate {
        static $gtype: GObject.GType<OutputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Structure used for scatter/gather data output.
     * You generally pass in an array of #GOutputVectors
     * and the operation will use all the buffers as if they were
     * one buffer.
     */
    class OutputVector {
        static $gtype: GObject.GType<OutputVector>;

        // Fields

        buffer: any;
        size: number;

        // Constructors

        constructor(
            properties?: Partial<{
                buffer: any;
                size: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type PermissionClass = typeof Permission;
    abstract class PermissionPrivate {
        static $gtype: GObject.GType<PermissionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PollableInputStreamInterface = typeof PollableInputStream;
    type PollableOutputStreamInterface = typeof PollableOutputStream;
    type PowerProfileMonitorInterface = typeof PowerProfileMonitor;
    type ProxyAddressClass = typeof ProxyAddress;
    type ProxyAddressEnumeratorClass = typeof ProxyAddressEnumerator;
    abstract class ProxyAddressEnumeratorPrivate {
        static $gtype: GObject.GType<ProxyAddressEnumeratorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class ProxyAddressPrivate {
        static $gtype: GObject.GType<ProxyAddressPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ProxyInterface = typeof Proxy;
    type ProxyResolverInterface = typeof ProxyResolver;
    type RemoteActionGroupInterface = typeof RemoteActionGroup;
    type ResolverClass = typeof Resolver;
    abstract class ResolverPrivate {
        static $gtype: GObject.GType<ResolverPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Applications and libraries often contain binary or textual data that is
     * really part of the application, rather than user data. For instance
     * [`GtkBuilder`](https://docs.gtk.org/gtk4/class.Builder.html) `.ui` files,
     * splashscreen images, [class`Gio`.Menu] markup XML, CSS files, icons, etc.
     * These are often shipped as files in `$datadir/appname`, or manually
     * included as literal strings in the code.
     *
     * The `GResource` API and the
     * [`glib-compile-resources`](glib-compile-resources.html) program provide a
     * convenient and efficient alternative to this which has some nice properties.
     * You maintain the files as normal files, so its easy to edit them, but during
     * the build the files are combined into a binary bundle that is linked into the
     * executable. This means that loading the resource files are efficient (as they
     * are already in memory, shared with other instances) and simple (no need to
     * check for things like I/O errors or locate the files in the filesystem). It
     * also makes it easier to create relocatable applications.
     *
     * Resource files can also be marked as compressed. Such files will be included
     * in the resource bundle in a compressed form, but will be automatically
     * uncompressed when the resource is used. This is very useful e.g. for larger
     * text files that are parsed once (or rarely) and then thrown away.
     *
     * Resource files can also be marked to be preprocessed, by setting the value of the
     * `preprocess` attribute to a comma-separated list of preprocessing options.
     * The only options currently supported are:
     *
     *  - `xml-stripblanks` which will use the [`xmllint`](man:xmllint(1)) command
     *    to strip ignorable whitespace from the XML file. For this to work,
     *    the `XMLLINT` environment variable must be set to the full path to
     *    the xmllint executable, or xmllint must be in the `PATH`; otherwise
     *    the preprocessing step is skipped.
     *
     *  - `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
     *    `gdk-pixbuf-pixdata` command to convert images to the [`GdkPixdata`](https://docs.gtk.org/gdk-pixbuf/class.Pixdata.html)
     *    format, which allows you to create pixbufs directly using the data inside
     *    the resource file, rather than an (uncompressed) copy of it. For this, the
     *    `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
     *    `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to
     *    the `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will
     *    abort. `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as
     *    `GResource` supports embedding modern image formats just as well. Instead
     *    of using it, embed a PNG or SVG file in your `GResource`.
     *
     *  - `json-stripblanks` which will use the
     *    [`json-glib-format`](man:json-glib-format(1)) command to strip ignorable
     *    whitespace from the JSON file. For this to work, the `JSON_GLIB_FORMAT`
     *    environment variable must be set to the full path to the
     *    `json-glib-format` executable, or it must be in the `PATH`; otherwise the
     *    preprocessing step is skipped. In addition, at least version 1.6 of
     *    `json-glib-format` is required.
     *
     * Resource files will be exported in the `GResource` namespace using the
     * combination of the given `prefix` and the filename from the `file` element.
     * The `alias` attribute can be used to alter the filename to expose them at a
     * different location in the resource namespace. Typically, this is used to
     * include files from a different source directory without exposing the source
     * directory in the resource namespace, as in the example below.
     *
     * Resource bundles are created by the
     * [`glib-compile-resources`](glib-compile-resources.html) program
     * which takes an XML file that describes the bundle, and a set of files that
     * the XML references. These are combined into a binary resource bundle.
     *
     * An example resource description:
     * ```xml
     * <?xml version="1.0" encoding="UTF-8"?>
     * <gresources>
     *   <gresource prefix="/org/gtk/Example">
     *     <file>data/splashscreen.png</file>
     *     <file compressed="true">dialog.ui</file>
     *     <file preprocess="xml-stripblanks">menumarkup.xml</file>
     *     <file alias="example.css">data/example.css</file>
     *   </gresource>
     * </gresources>
     * ```
     *
     * This will create a resource bundle with the following files:
     * ```
     * /org/gtk/Example/data/splashscreen.png
     * /org/gtk/Example/dialog.ui
     * /org/gtk/Example/menumarkup.xml
     * /org/gtk/Example/example.css
     * ```
     *
     * Note that all resources in the process share the same namespace, so use
     * Java-style path prefixes (like in the above example) to avoid conflicts.
     *
     * You can then use [`glib-compile-resources`](glib-compile-resources.html) to
     * compile the XML to a binary bundle that you can load with
     * [func`Gio`.Resource.load]. However, its more common to use the
     * `--generate-source` and `--generate-header` arguments to create a source file
     * and header to link directly into your application.
     * This will generate `get_resource()`, `register_resource()` and
     * `unregister_resource()` functions, prefixed by the `--c-name` argument passed
     * to [`glib-compile-resources`](glib-compile-resources.html). `get_resource()`
     * returns the generated `GResource` object. The register and unregister
     * functions register the resource so its files can be accessed using
     * [func`Gio`.resources_lookup_data].
     *
     * Once a `GResource` has been created and registered all the data in it can be
     * accessed globally in the process by using API calls like
     * [func`Gio`.resources_open_stream] to stream the data or
     * [func`Gio`.resources_lookup_data] to get a direct pointer to the data. You can
     * also use URIs like `resource:///org/gtk/Example/data/splashscreen.png` with
     * [iface`Gio`.File] to access the resource data.
     *
     * Some higher-level APIs, such as [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
     * will automatically load resources from certain well-known paths in the
     * resource namespace as a convenience. See the documentation for those APIs
     * for details.
     *
     * There are two forms of the generated source, the default version uses the
     * compiler support for constructor and destructor functions (where available)
     * to automatically create and register the `GResource` on startup or library
     * load time. If you pass `--manual-register`, two functions to
     * register/unregister the resource are created instead. This requires an
     * explicit initialization call in your application/library, but it works on all
     * platforms, even on the minor ones where constructors are not supported.
     * (Constructor support is available for at least Win32, Mac OS and Linux.)
     *
     * Note that resource data can point directly into the data segment of e.g. a
     * library, so if you are unloading libraries during runtime you need to be very
     * careful with keeping around pointers to data from a resource, as this goes
     * away when the library is unloaded. However, in practice this is not generally
     * a problem, since most resource accesses are for your own resources, and
     * resource data is often used once, during parsing, and then released.
     *
     * # Overlays
     *
     * When debugging a program or testing a change to an installed version, it is
     * often useful to be able to replace resources in the program or library,
     * without recompiling, for debugging or quick hacking and testing purposes.
     * Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment
     * variable to selectively overlay resources with replacements from the
     * filesystem.  It is a `G_SEARCHPATH_SEPARATOR`-separated list of substitutions
     * to perform during resource lookups. It is ignored when running in a setuid
     * process.
     *
     * A substitution has the form
     *
     * ```
     * /org/gtk/libgtk=/home/desrt/gtk-overlay
     * ```
     *
     * The part before the `=` is the resource subpath for which the overlay
     * applies.  The part after is a filesystem path which contains files and
     * subdirectories as you would like to be loaded as resources with the
     * equivalent names.
     *
     * In the example above, if an application tried to load a resource with the
     * resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then `GResource` would check
     * the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was
     * found there, it would be used instead.  This is an overlay, not an outright
     * replacement, which means that if a file is not found at that path, the
     * built-in version will be used instead.  Whiteouts are not currently
     * supported.
     *
     * Substitutions must start with a slash, and must not contain a trailing slash
     * before the `=`.  The path after the slash should ideally be absolute, but
     * this is not strictly required.  It is possible to overlay the location of a
     * single resource with an individual file.
     */
    class Resource {
        static $gtype: GObject.GType<Resource>;

        // Constructors

        constructor(data: GLib.Bytes | Uint8Array);
        _init(...args: any[]): void;

        static new_from_data(data: GLib.Bytes | Uint8Array): Resource;

        // Static methods

        /**
         * Loads a binary resource bundle and creates a #GResource representation of it, allowing
         * you to query it for data.
         *
         * If you want to use this resource in the global resource namespace you need
         * to register it with g_resources_register().
         *
         * If `filename` is empty or the data in it is corrupt,
         * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesnt exist, or
         * there is an error in reading it, an error from g_mapped_file_new() will be
         * returned.
         * @param filename the path of a filename to load, in the GLib filename encoding
         */
        static load(filename: string): Resource;

        // Methods

        /**
         * Registers the resource with the process-global set of resources.
         * Once a resource is registered the files in it can be accessed
         * with the global resource lookup functions like g_resources_lookup_data().
         */
        _register(): void;
        /**
         * Unregisters the resource from the process-global set of resources.
         */
        _unregister(): void;
        /**
         * Returns all the names of children at the specified `path` in the resource.
         * The return result is a %NULL terminated list of strings which should
         * be released with g_strfreev().
         *
         * If `path` is invalid or does not exist in the #GResource,
         * %G_RESOURCE_ERROR_NOT_FOUND will be returned.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns an array of constant strings
         */
        enumerate_children(path: string, lookup_flags: ResourceLookupFlags): string[];
        /**
         * Looks for a file at the specified `path` in the resource and
         * if found returns information about it.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns %TRUE if the file was found. %FALSE if there were errors
         */
        get_info(path: string, lookup_flags: ResourceLookupFlags): [boolean, number, number];
        /**
         * Looks for a file at the specified `path` in the resource and
         * returns a #GBytes that lets you directly access the data in
         * memory.
         *
         * The data is always followed by a zero byte, so you
         * can safely use the data as a C string. However, that byte
         * is not included in the size of the GBytes.
         *
         * For uncompressed resource files this is a pointer directly into
         * the resource bundle, which is typically in some readonly data section
         * in the program binary. For compressed files we allocate memory on
         * the heap and automatically uncompress the data.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns #GBytes or %NULL on error.     Free the returned object with g_bytes_unref()
         */
        lookup_data(path: string, lookup_flags: ResourceLookupFlags): GLib.Bytes;
        /**
         * Looks for a file at the specified `path` in the resource and
         * returns a #GInputStream that lets you read the data.
         *
         * `lookup_flags` controls the behaviour of the lookup.
         * @param path A pathname inside the resource
         * @param lookup_flags A #GResourceLookupFlags
         * @returns #GInputStream or %NULL on error.     Free the returned object with g_object_unref()
         */
        open_stream(path: string, lookup_flags: ResourceLookupFlags): InputStream;
        /**
         * Atomically increments the reference count of `resource` by one. This
         * function is MT-safe and may be called from any thread.
         * @returns The passed in #GResource
         */
        ref(): Resource;
        /**
         * Atomically decrements the reference count of `resource` by one. If the
         * reference count drops to 0, all memory allocated by the resource is
         * released. This function is MT-safe and may be called from any
         * thread.
         */
        unref(): void;
    }

    type SeekableIface = typeof Seekable;
    type SettingsBackendClass = typeof SettingsBackend;
    abstract class SettingsBackendPrivate {
        static $gtype: GObject.GType<SettingsBackendPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SettingsClass = typeof Settings;
    abstract class SettingsPrivate {
        static $gtype: GObject.GType<SettingsPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The [struct`Gio`.SettingsSchemaSource] and `GSettingsSchema` APIs provide a
     * mechanism for advanced control over the loading of schemas and a
     * mechanism for introspecting their content.
     *
     * Plugin loading systems that wish to provide plugins a way to access
     * settings face the problem of how to make the schemas for these
     * settings visible to GSettings.  Typically, a plugin will want to ship
     * the schema along with itself and it won't be installed into the
     * standard system directories for schemas.
     *
     * [struct`Gio`.SettingsSchemaSource] provides a mechanism for dealing with this
     * by allowing the creation of a new schema source from which schemas can
     * be acquired.  This schema source can then become part of the metadata
     * associated with the plugin and queried whenever the plugin requires
     * access to some settings.
     *
     * Consider the following example:
     *
     * ```c
     * typedef struct
     * {
     *    
     *    GSettingsSchemaSource *schema_source;
     *    
     * } Plugin;
     *
     * Plugin *
     * initialise_plugin (const gchar *dir)
     * {
     *   Plugin *plugin;
     *
     *   
     *
     *   plugin->schema_source =
     *     g_settings_schema_source_new_from_directory (dir,
     *       g_settings_schema_source_get_default (), FALSE, NULL);
     *
     *   
     *
     *   return plugin;
     * }
     *
     * 
     *
     * GSettings *
     * plugin_get_settings (Plugin      *plugin,
     *                      const gchar *schema_id)
     * {
     *   GSettingsSchema *schema;
     *
     *   if (schema_id == NULL)
     *     schema_id = plugin->identifier;
     *
     *   schema = g_settings_schema_source_lookup (plugin->schema_source,
     *                                             schema_id, FALSE);
     *
     *   if (schema == NULL)
     *     {
     *        disable the plugin or abort, etc 
     *     }
     *
     *   return g_settings_new_full (schema, NULL, NULL);
     * }
     * ```
     *
     * The code above shows how hooks should be added to the code that
     * initialises (or enables) the plugin to create the schema source and
     * how an API can be added to the plugin system to provide a convenient
     * way for the plugin to access its settings, using the schemas that it
     * ships.
     *
     * From the standpoint of the plugin, it would need to ensure that it
     * ships a gschemas.compiled file as part of itself, and then simply do
     * the following:
     *
     * ```c
     * {
     *   GSettings *settings;
     *   gint some_value;
     *
     *   settings = plugin_get_settings (self, NULL);
     *   some_value = g_settings_get_int (settings, "some-value");
     *   
     * }
     * ```
     *
     * It's also possible that the plugin system expects the schema source
     * files (ie: `.gschema.xml` files) instead of a `gschemas.compiled` file.
     * In that case, the plugin loading system must compile the schemas for
     * itself before attempting to create the settings source.
     */
    abstract class SettingsSchema {
        static $gtype: GObject.GType<SettingsSchema>;

        // Fields

        _realGetKey: typeof SettingsSchema.prototype.get_key;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the ID of `schema`.
         * @returns the ID
         */
        get_id(): string;
        /**
         * Gets the key named `name` from `schema`.
         *
         * It is a programmer error to request a key that does not exist.  See
         * g_settings_schema_list_keys().
         * @param name the name of a key
         * @returns the #GSettingsSchemaKey for @name
         */
        get_key(name: string): SettingsSchemaKey;
        /**
         * Gets the path associated with `schema,` or %NULL.
         *
         * Schemas may be single-instance or relocatable.  Single-instance
         * schemas correspond to exactly one set of keys in the backend
         * database: those located at the path returned by this function.
         *
         * Relocatable schemas can be referenced by other schemas and can
         * therefore describe multiple sets of keys at different locations.  For
         * relocatable schemas, this function will return %NULL.
         * @returns the path of the schema, or %NULL
         */
        get_path(): string | null;
        /**
         * Checks if `schema` has a key named `name`.
         * @param name the name of a key
         * @returns %TRUE if such a key exists
         */
        has_key(name: string): boolean;
        /**
         * Gets the list of children in `schema`.
         *
         * You should free the return value with g_strfreev() when you are done
         * with it.
         * @returns a list of    the children on @settings, in no defined order
         */
        list_children(): string[];
        /**
         * Introspects the list of keys on `schema`.
         *
         * You should probably not be calling this function from "normal" code
         * (since you should already know what keys are in your schema).  This
         * function is intended for introspection reasons.
         * @returns a list   of the keys on @schema, in no defined order
         */
        list_keys(): string[];
        /**
         * Increase the reference count of `schema,` returning a new reference.
         * @returns a new reference to @schema
         */
        ref(): SettingsSchema;
        /**
         * Decrease the reference count of `schema,` possibly freeing it.
         */
        unref(): void;
    }

    /**
     * #GSettingsSchemaKey is an opaque data structure and can only be accessed
     * using the following functions.
     */
    abstract class SettingsSchemaKey {
        static $gtype: GObject.GType<SettingsSchemaKey>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Gets the default value for `key`.
         *
         * Note that this is the default value according to the schema.  System
         * administrator defaults and lockdown are not visible via this API.
         * @returns the default value for the key
         */
        get_default_value(): GLib.Variant;
        /**
         * Gets the description for `key`.
         *
         * If no description has been provided in the schema for `key,` returns
         * %NULL.
         *
         * The description can be one sentence to several paragraphs in length.
         * Paragraphs are delimited with a double newline.  Descriptions can be
         * translated and the value returned from this function is is the
         * current locale.
         *
         * This function is slow.  The summary and description information for
         * the schemas is not stored in the compiled schema database so this
         * function has to parse all of the source XML files in the schema
         * directory.
         * @returns the description for @key, or %NULL
         */
        get_description(): string | null;
        /**
         * Gets the name of `key`.
         * @returns the name of @key.
         */
        get_name(): string;
        /**
         * Queries the range of a key.
         *
         * This function will return a #GVariant that fully describes the range
         * of values that are valid for `key`.
         *
         * The type of #GVariant returned is `(sv)`. The string describes
         * the type of range restriction in effect. The type and meaning of
         * the value contained in the variant depends on the string.
         *
         * If the string is `'type'` then the variant contains an empty array.
         * The element type of that empty array is the expected type of value
         * and all values of that type are valid.
         *
         * If the string is `'enum'` then the variant contains an array
         * enumerating the possible values. Each item in the array is
         * a possible valid value and no other values are valid.
         *
         * If the string is `'flags'` then the variant contains an array. Each
         * item in the array is a value that may appear zero or one times in an
         * array to be used as the value for this key. For example, if the
         * variant contained the array `['x', 'y']` then the valid values for
         * the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
         * `['y', 'x']`.
         *
         * Finally, if the string is `'range'` then the variant contains a pair
         * of like-typed values -- the minimum and maximum permissible values
         * for this key.
         *
         * This information should not be used by normal programs.  It is
         * considered to be a hint for introspection purposes.  Normal programs
         * should already know what is permitted by their own schema.  The
         * format may change in any way in the future -- but particularly, new
         * forms may be added to the possibilities described above.
         *
         * You should free the returned value with g_variant_unref() when it is
         * no longer needed.
         * @returns a #GVariant describing the range
         */
        get_range(): GLib.Variant;
        /**
         * Gets the summary for `key`.
         *
         * If no summary has been provided in the schema for `key,` returns
         * %NULL.
         *
         * The summary is a short description of the purpose of the key; usually
         * one short sentence.  Summaries can be translated and the value
         * returned from this function is is the current locale.
         *
         * This function is slow.  The summary and description information for
         * the schemas is not stored in the compiled schema database so this
         * function has to parse all of the source XML files in the schema
         * directory.
         * @returns the summary for @key, or %NULL
         */
        get_summary(): string | null;
        /**
         * Gets the #GVariantType of `key`.
         * @returns the type of @key
         */
        get_value_type(): GLib.VariantType;
        /**
         * Checks if the given `value` is within the
         * permitted range for `key`.
         *
         * It is a programmer error if `value` is not of the correct type  you
         * must check for this first.
         * @param value the value to check
         * @returns %TRUE if @value is valid for @key
         */
        range_check(value: GLib.Variant): boolean;
        /**
         * Increase the reference count of `key,` returning a new reference.
         * @returns a new reference to @key
         */
        ref(): SettingsSchemaKey;
        /**
         * Decrease the reference count of `key,` possibly freeing it.
         */
        unref(): void;
    }

    /**
     * This is an opaque structure type.  You may not access it directly.
     */
    class SettingsSchemaSource {
        static $gtype: GObject.GType<SettingsSchemaSource>;

        // Constructors

        constructor(directory: string, parent: SettingsSchemaSource | null, trusted: boolean);
        _init(...args: any[]): void;

        static new_from_directory(
            directory: string,
            parent: SettingsSchemaSource | null,
            trusted: boolean,
        ): SettingsSchemaSource;

        // Static methods

        /**
         * Gets the default system schema source.
         *
         * This function is not required for normal uses of #GSettings but it
         * may be useful to authors of plugin management systems or to those who
         * want to introspect the content of schemas.
         *
         * If no schemas are installed, %NULL will be returned.
         *
         * The returned source may actually consist of multiple schema sources
         * from different directories, depending on which directories were given
         * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
         * lookups performed against the default source should probably be done
         * recursively.
         */
        static get_default(): SettingsSchemaSource | null;

        // Methods

        /**
         * Lists the schemas in a given source.
         *
         * If `recursive` is %TRUE then include parent sources.  If %FALSE then
         * only include the schemas from one source (ie: one directory).  You
         * probably want %TRUE.
         *
         * Non-relocatable schemas are those for which you can call
         * g_settings_new().  Relocatable schemas are those for which you must
         * use g_settings_new_with_path().
         *
         * Do not call this function from normal programs.  This is designed for
         * use by database editors, commandline tools, etc.
         * @param recursive if we should recurse
         */
        list_schemas(recursive: boolean): [string[], string[]];
        /**
         * Looks up a schema with the identifier `schema_id` in `source`.
         *
         * This function is not required for normal uses of #GSettings but it
         * may be useful to authors of plugin management systems or to those who
         * want to introspect the content of schemas.
         *
         * If the schema isn't found directly in `source` and `recursive` is %TRUE
         * then the parent sources will also be checked.
         *
         * If the schema isn't found, %NULL is returned.
         * @param schema_id a schema ID
         * @param recursive %TRUE if the lookup should be recursive
         * @returns a new #GSettingsSchema
         */
        lookup(schema_id: string, recursive: boolean): SettingsSchema | null;
        /**
         * Increase the reference count of `source,` returning a new reference.
         * @returns a new reference to @source
         */
        ref(): SettingsSchemaSource;
        /**
         * Decrease the reference count of `source,` possibly freeing it.
         */
        unref(): void;
    }

    type SimpleActionGroupClass = typeof SimpleActionGroup;
    abstract class SimpleActionGroupPrivate {
        static $gtype: GObject.GType<SimpleActionGroupPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SimpleAsyncResultClass = typeof SimpleAsyncResult;
    type SimpleProxyResolverClass = typeof SimpleProxyResolver;
    abstract class SimpleProxyResolverPrivate {
        static $gtype: GObject.GType<SimpleProxyResolverPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SocketAddressClass = typeof SocketAddress;
    type SocketAddressEnumeratorClass = typeof SocketAddressEnumerator;
    type SocketClass = typeof Socket;
    type SocketClientClass = typeof SocketClient;
    abstract class SocketClientPrivate {
        static $gtype: GObject.GType<SocketClientPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SocketConnectableIface = typeof SocketConnectable;
    type SocketConnectionClass = typeof SocketConnection;
    abstract class SocketConnectionPrivate {
        static $gtype: GObject.GType<SocketConnectionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SocketControlMessageClass = typeof SocketControlMessage;
    abstract class SocketControlMessagePrivate {
        static $gtype: GObject.GType<SocketControlMessagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SocketListenerClass = typeof SocketListener;
    abstract class SocketListenerPrivate {
        static $gtype: GObject.GType<SocketListenerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class SocketPrivate {
        static $gtype: GObject.GType<SocketPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SocketServiceClass = typeof SocketService;
    abstract class SocketServicePrivate {
        static $gtype: GObject.GType<SocketServicePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A single target host/port that a network service is running on.
     *
     * SRV (service) records are used by some network protocols to provide
     * service-specific aliasing and load-balancing. For example, XMPP
     * (Jabber) uses SRV records to locate the XMPP server for a domain;
     * rather than connecting directly to example.com or assuming a
     * specific server hostname like xmpp.example.com, an XMPP client
     * would look up the `xmpp-client` SRV record for example.com, and
     * then connect to whatever host was pointed to by that record.
     *
     * You can use [method`Gio`.Resolver.lookup_service] or
     * [method`Gio`.Resolver.lookup_service_async] to find the `GSrvTarget`s
     * for a given service. However, if you are simply planning to connect
     * to the remote service, you can use [class`Gio`.NetworkService]s
     * [iface`Gio`.SocketConnectable] interface and not need to worry about
     * `GSrvTarget` at all.
     */
    class SrvTarget {
        static $gtype: GObject.GType<SrvTarget>;

        // Constructors

        constructor(hostname: string, port: number, priority: number, weight: number);
        _init(...args: any[]): void;

        static ['new'](hostname: string, port: number, priority: number, weight: number): SrvTarget;

        // Methods

        /**
         * Copies `target`
         * @returns a copy of @target
         */
        copy(): SrvTarget;
        /**
         * Frees `target`
         */
        free(): void;
        /**
         * Gets `target'`s hostname (in ASCII form; if you are going to present
         * this to the user, you should use g_hostname_is_ascii_encoded() to
         * check if it contains encoded Unicode segments, and use
         * g_hostname_to_unicode() to convert it if it does.)
         * @returns @target's hostname
         */
        get_hostname(): string;
        /**
         * Gets `target'`s port
         * @returns @target's port
         */
        get_port(): number;
        /**
         * Gets `target'`s priority. You should not need to look at this;
         * #GResolver already sorts the targets according to the algorithm in
         * RFC 2782.
         * @returns @target's priority
         */
        get_priority(): number;
        /**
         * Gets `target'`s weight. You should not need to look at this;
         * #GResolver already sorts the targets according to the algorithm in
         * RFC 2782.
         * @returns @target's weight
         */
        get_weight(): number;
    }

    /**
     * #GStaticResource is an opaque data structure and can only be accessed
     * using the following functions.
     */
    class StaticResource {
        static $gtype: GObject.GType<StaticResource>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Finalized a GResource initialized by g_static_resource_init().
         *
         * This is normally used by code generated by
         * [glib-compile-resources][glib-compile-resources]
         * and is not typically used by other code.
         */
        fini(): void;
        /**
         * Gets the GResource that was registered by a call to g_static_resource_init().
         *
         * This is normally used by code generated by
         * [glib-compile-resources][glib-compile-resources]
         * and is not typically used by other code.
         * @returns a #GResource
         */
        get_resource(): Resource;
        /**
         * Initializes a GResource from static data using a
         * GStaticResource.
         *
         * This is normally used by code generated by
         * [glib-compile-resources][glib-compile-resources]
         * and is not typically used by other code.
         */
        init(): void;
    }

    type TaskClass = typeof Task;
    type TcpConnectionClass = typeof TcpConnection;
    abstract class TcpConnectionPrivate {
        static $gtype: GObject.GType<TcpConnectionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TcpWrapperConnectionClass = typeof TcpWrapperConnection;
    abstract class TcpWrapperConnectionPrivate {
        static $gtype: GObject.GType<TcpWrapperConnectionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ThemedIconClass = typeof ThemedIcon;
    type ThreadedResolverClass = typeof ThreadedResolver;
    type ThreadedSocketServiceClass = typeof ThreadedSocketService;
    abstract class ThreadedSocketServicePrivate {
        static $gtype: GObject.GType<ThreadedSocketServicePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TlsBackendInterface = typeof TlsBackend;
    type TlsCertificateClass = typeof TlsCertificate;
    abstract class TlsCertificatePrivate {
        static $gtype: GObject.GType<TlsCertificatePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TlsClientConnectionInterface = typeof TlsClientConnection;
    type TlsConnectionClass = typeof TlsConnection;
    abstract class TlsConnectionPrivate {
        static $gtype: GObject.GType<TlsConnectionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TlsDatabaseClass = typeof TlsDatabase;
    abstract class TlsDatabasePrivate {
        static $gtype: GObject.GType<TlsDatabasePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TlsFileDatabaseInterface = typeof TlsFileDatabase;
    type TlsInteractionClass = typeof TlsInteraction;
    abstract class TlsInteractionPrivate {
        static $gtype: GObject.GType<TlsInteractionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TlsPasswordClass = typeof TlsPassword;
    abstract class TlsPasswordPrivate {
        static $gtype: GObject.GType<TlsPasswordPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TlsServerConnectionInterface = typeof TlsServerConnection;
    type UnixConnectionClass = typeof UnixConnection;
    abstract class UnixConnectionPrivate {
        static $gtype: GObject.GType<UnixConnectionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type UnixCredentialsMessageClass = typeof UnixCredentialsMessage;
    abstract class UnixCredentialsMessagePrivate {
        static $gtype: GObject.GType<UnixCredentialsMessagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type UnixFDListClass = typeof UnixFDList;
    abstract class UnixFDListPrivate {
        static $gtype: GObject.GType<UnixFDListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type UnixFDMessageClass = typeof UnixFDMessage;
    abstract class UnixFDMessagePrivate {
        static $gtype: GObject.GType<UnixFDMessagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type UnixInputStreamClass = typeof UnixInputStream;
    abstract class UnixInputStreamPrivate {
        static $gtype: GObject.GType<UnixInputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Defines a Unix mount entry (e.g. <filename>/media/cdrom</filename>).
     * This corresponds roughly to a mtab entry.
     */
    abstract class UnixMountEntry {
        static $gtype: GObject.GType<UnixMountEntry>;

        // Constructors

        _init(...args: any[]): void;
    }

    type UnixMountMonitorClass = typeof UnixMountMonitor;
    /**
     * Defines a Unix mount point (e.g. <filename>/dev</filename>).
     * This corresponds roughly to a fstab entry.
     */
    abstract class UnixMountPoint {
        static $gtype: GObject.GType<UnixMountPoint>;

        // Constructors

        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets a #GUnixMountPoint for a given mount path. If `time_read` is set, it
         * will be filled with a unix timestamp for checking if the mount points have
         * changed since with g_unix_mount_points_changed_since().
         *
         * If more mount points have the same mount path, the last matching mount point
         * is returned.
         * @param mount_path path for a possible unix mount point.
         */
        static at(mount_path: string): [UnixMountPoint | null, number];

        // Methods

        /**
         * Compares two unix mount points.
         * @param mount2 a #GUnixMount.
         * @returns 1, 0 or -1 if @mount1 is greater than, equal to, or less than @mount2, respectively.
         */
        compare(mount2: UnixMountPoint): number;
        /**
         * Makes a copy of `mount_point`.
         * @returns a new #GUnixMountPoint
         */
        copy(): UnixMountPoint;
        /**
         * Frees a unix mount point.
         */
        free(): void;
        /**
         * Gets the device path for a unix mount point.
         * @returns a string containing the device path.
         */
        get_device_path(): string;
        /**
         * Gets the file system type for the mount point.
         * @returns a string containing the file system type.
         */
        get_fs_type(): string;
        /**
         * Gets the mount path for a unix mount point.
         * @returns a string containing the mount path.
         */
        get_mount_path(): string;
        /**
         * Gets the options for the mount point.
         * @returns a string containing the options.
         */
        get_options(): string | null;
        /**
         * Guesses whether a Unix mount point can be ejected.
         * @returns %TRUE if @mount_point is deemed to be ejectable.
         */
        guess_can_eject(): boolean;
        /**
         * Guesses the icon of a Unix mount point.
         * @returns a #GIcon
         */
        guess_icon(): Icon;
        /**
         * Guesses the name of a Unix mount point.
         * The result is a translated string.
         * @returns A newly allocated string that must     be freed with g_free()
         */
        guess_name(): string;
        /**
         * Guesses the symbolic icon of a Unix mount point.
         * @returns a #GIcon
         */
        guess_symbolic_icon(): Icon;
        /**
         * Checks if a unix mount point is a loopback device.
         * @returns %TRUE if the mount point is a loopback. %FALSE otherwise.
         */
        is_loopback(): boolean;
        /**
         * Checks if a unix mount point is read only.
         * @returns %TRUE if a mount point is read only.
         */
        is_readonly(): boolean;
        /**
         * Checks if a unix mount point is mountable by the user.
         * @returns %TRUE if the mount point is user mountable.
         */
        is_user_mountable(): boolean;
    }

    type UnixOutputStreamClass = typeof UnixOutputStream;
    abstract class UnixOutputStreamPrivate {
        static $gtype: GObject.GType<UnixOutputStreamPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type UnixSocketAddressClass = typeof UnixSocketAddress;
    abstract class UnixSocketAddressPrivate {
        static $gtype: GObject.GType<UnixSocketAddressPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type VfsClass = typeof Vfs;
    type VolumeIface = typeof Volume;
    type VolumeMonitorClass = typeof VolumeMonitor;
    type ZlibCompressorClass = typeof ZlibCompressor;
    type ZlibDecompressorClass = typeof ZlibDecompressor;
    module Action {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            enabled: boolean;
            name: string;
            parameter_type: GLib.VariantType;
            parameterType: GLib.VariantType;
            state: GLib.Variant;
            state_type: GLib.VariantType;
            stateType: GLib.VariantType;
        }
    }

    export interface ActionNamespace {
        $gtype: GObject.GType<Action>;
        prototype: Action;

        /**
         * Checks if `action_name` is valid.
         *
         * `action_name` is valid if it consists only of alphanumeric characters,
         * plus '-' and '.'.  The empty string is not a valid action name.
         *
         * It is an error to call this function with a non-utf8 `action_name`.
         * `action_name` must not be %NULL.
         * @param action_name a potential action name
         */
        name_is_valid(action_name: string): boolean;
        /**
         * Parses a detailed action name into its separate name and target
         * components.
         *
         * Detailed action names can have three formats.
         *
         * The first format is used to represent an action name with no target
         * value and consists of just an action name containing no whitespace
         * nor the characters `:`, `(` or `)`.  For example: `app.action`.
         *
         * The second format is used to represent an action with a target value
         * that is a non-empty string consisting only of alphanumerics, plus `-`
         * and `.`.  In that case, the action name and target value are
         * separated by a double colon (`::`).  For example:
         * `app.action::target`.
         *
         * The third format is used to represent an action with any type of
         * target value, including strings.  The target value follows the action
         * name, surrounded in parens.  For example: `app.action(42)`.  The
         * target value is parsed using g_variant_parse().  If a tuple-typed
         * value is desired, it must be specified in the same way, resulting in
         * two sets of parens, for example: `app.action((1,2,3))`.  A string
         * target can be specified this way as well: `app.action('target')`.
         * For strings, this third format must be used if target value is
         * empty or contains characters other than alphanumerics, `-` and `.`.
         *
         * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
         * in `action_name` (if a pointer is passed in). A %NULL value may still be
         * returned in `target_value,` as the `detailed_name` may not contain a target.
         *
         * If returned, the #GVariant in `target_value` is guaranteed to not be floating.
         * @param detailed_name a detailed action name
         */
        parse_detailed_name(detailed_name: string): [boolean, string, GLib.Variant | null];
        /**
         * Formats a detailed action name from `action_name` and `target_value`.
         *
         * It is an error to call this function with an invalid action name.
         *
         * This function is the opposite of g_action_parse_detailed_name().
         * It will produce a string that can be parsed back to the `action_name`
         * and `target_value` by that function.
         *
         * See that function for the types of strings that will be printed by
         * this function.
         * @param action_name a valid action name
         * @param target_value a #GVariant target value, or %NULL
         */
        print_detailed_name(action_name: string, target_value?: GLib.Variant | null): string;
    }
    interface Action extends GObject.Object {
        // Properties

        /**
         * If `action` is currently enabled.
         *
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        get enabled(): boolean;
        /**
         * The name of the action.  This is mostly meaningful for identifying
         * the action once it has been added to a #GActionGroup. It is immutable.
         */
        get name(): string;
        /**
         * The type of the parameter that must be given when activating the
         * action. This is immutable, and may be %NULL if no parameter is needed when
         * activating the action.
         */
        get parameter_type(): GLib.VariantType;
        /**
         * The type of the parameter that must be given when activating the
         * action. This is immutable, and may be %NULL if no parameter is needed when
         * activating the action.
         */
        get parameterType(): GLib.VariantType;
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        get state(): GLib.Variant;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless. This is immutable.
         */
        get state_type(): GLib.VariantType;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless. This is immutable.
         */
        get stateType(): GLib.VariantType;

        // Methods

        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @returns whether the action is enabled
         */
        get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         * @returns the name of the action
         */
        get_name(): string;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         * @returns the parameter type
         */
        get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the current state of the action
         */
        get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the state range hint
         */
        get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         * @returns the state type, if the action is stateful
         */
        get_state_type(): GLib.VariantType | null;

        // Virtual methods

        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        vfunc_activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        vfunc_change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         */
        vfunc_get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         */
        vfunc_get_name(): string;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         */
        vfunc_get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         */
        vfunc_get_state_type(): GLib.VariantType | null;
    }

    export const Action: ActionNamespace;

    module ActionGroup {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ActionGroupNamespace {
        $gtype: GObject.GType<ActionGroup>;
        prototype: ActionGroup;
    }
    interface ActionGroup extends GObject.Object {
        // Methods

        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         * @returns whether or not the action is currently enabled
         */
        get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         * @returns the parameter type
         */
        get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the current state of the action
         */
        get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the state range hint
         */
        get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         * @returns the state type, if the action is stateful
         */
        get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         * @returns whether the named action exists
         */
        has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         * @returns a %NULL-terminated array of the names of the actions in the group
         */
        list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         * @returns %TRUE if the action exists, else %FALSE
         */
        query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];

        // Virtual methods

        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         */
        vfunc_has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         */
        vfunc_list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         */
        vfunc_query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
    }

    export const ActionGroup: ActionGroupNamespace;

    module ActionMap {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ActionMapNamespace {
        $gtype: GObject.GType<ActionMap>;
        prototype: ActionMap;
    }
    interface ActionMap extends GObject.Object {
        // Methods

        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        add_action(action: Action): void;
        /**
         * A convenience function for creating multiple #GSimpleAction instances
         * and adding them to a #GActionMap.
         *
         * Each action is constructed as per one #GActionEntry.
         *
         *
         * ```c
         * static void
         * activate_quit (GSimpleAction *simple,
         *                GVariant      *parameter,
         *                gpointer       user_data)
         * {
         *   exit (0);
         * }
         *
         * static void
         * activate_print_string (GSimpleAction *simple,
         *                        GVariant      *parameter,
         *                        gpointer       user_data)
         * {
         *   g_print ("%s\n", g_variant_get_string (parameter, NULL));
         * }
         *
         * static GActionGroup *
         * create_action_group (void)
         * {
         *   const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         *   };
         *   GSimpleActionGroup *group;
         *
         *   group = g_simple_action_group_new ();
         *   g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
         *
         *   return G_ACTION_GROUP (group);
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         * @param user_data the user data for signal connections
         */
        add_action_entries(entries: ActionEntry[], user_data?: any | null): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        lookup_action(action_name: string): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        remove_action(action_name: string): void;
        /**
         * Remove actions from a #GActionMap. This is meant as the reverse of
         * g_action_map_add_action_entries().
         *
         *
         *
         * ```c
         * static const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         * };
         *
         * void
         * add_actions (GActionMap *map)
         * {
         *   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
         * }
         *
         * void
         * remove_actions (GActionMap *map)
         * {
         *   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         */
        remove_action_entries(entries: ActionEntry[]): void;

        // Virtual methods

        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        vfunc_add_action(action: Action): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         */
        vfunc_lookup_action(action_name: string): Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        vfunc_remove_action(action_name: string): void;
    }

    export const ActionMap: ActionMapNamespace;

    module AppInfo {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface AppInfoNamespace {
        $gtype: GObject.GType<AppInfo>;
        prototype: AppInfo;

        /**
         * Creates a new #GAppInfo from the given information.
         *
         * Note that for `commandline,` the quoting rules of the Exec key of the
         * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
         * are applied. For example, if the `commandline` contains
         * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
         * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
         * @param commandline the commandline to use
         * @param application_name the application name, or %NULL to use @commandline
         * @param flags flags that can specify details of the created #GAppInfo
         */
        create_from_commandline(
            commandline: string,
            application_name: string | null,
            flags: AppInfoCreateFlags,
        ): AppInfo;
        /**
         * Gets a list of all of the applications currently registered
         * on this system.
         *
         * For desktop files, this includes applications that have
         * `NoDisplay=true` set or are excluded from display by means
         * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
         * The returned list does not include applications which have
         * the `Hidden` key set.
         */
        get_all(): AppInfo[];
        /**
         * Gets a list of all #GAppInfos for a given content type,
         * including the recommended and fallback #GAppInfos. See
         * g_app_info_get_recommended_for_type() and
         * g_app_info_get_fallback_for_type().
         * @param content_type the content type to find a #GAppInfo for
         */
        get_all_for_type(content_type: string): AppInfo[];
        /**
         * Gets the default #GAppInfo for a given content type.
         * @param content_type the content type to find a #GAppInfo for
         * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
         */
        get_default_for_type(content_type: string, must_support_uris: boolean): AppInfo | null;
        /**
         * Asynchronously gets the default #GAppInfo for a given content type.
         * @param content_type the content type to find a #GAppInfo for
         * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        get_default_for_type_async(
            content_type: string,
            must_support_uris: boolean,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<AppInfo> | null,
        ): void;
        /**
         * Finishes a default #GAppInfo lookup started by
         * g_app_info_get_default_for_type_async().
         *
         * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
         * @param result a #GAsyncResult
         */
        get_default_for_type_finish(result: AsyncResult): AppInfo;
        /**
         * Gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         * @param uri_scheme a string containing a URI scheme.
         */
        get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
        /**
         * Asynchronously gets the default application for handling URIs with
         * the given URI scheme. A URI scheme is the initial part
         * of the URI, up to but not including the ':', e.g. "http",
         * "ftp" or "sip".
         * @param uri_scheme a string containing a URI scheme.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        get_default_for_uri_scheme_async(
            uri_scheme: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<AppInfo> | null,
        ): void;
        /**
         * Finishes a default #GAppInfo lookup started by
         * g_app_info_get_default_for_uri_scheme_async().
         *
         * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
         * @param result a #GAsyncResult
         */
        get_default_for_uri_scheme_finish(result: AsyncResult): AppInfo;
        /**
         * Gets a list of fallback #GAppInfos for a given content type, i.e.
         * those applications which claim to support the given content type
         * by MIME type subclassing and not directly.
         * @param content_type the content type to find a #GAppInfo for
         */
        get_fallback_for_type(content_type: string): AppInfo[];
        /**
         * Gets a list of recommended #GAppInfos for a given content type, i.e.
         * those applications which claim to support the given content type exactly,
         * and not by MIME type subclassing.
         * Note that the first application of the list is the last used one, i.e.
         * the last one for which g_app_info_set_as_last_used_for_type() has been
         * called.
         * @param content_type the content type to find a #GAppInfo for
         */
        get_recommended_for_type(content_type: string): AppInfo[];
        /**
         * Utility function that launches the default application
         * registered to handle the specified uri. Synchronous I/O
         * is done on the uri to detect the type of the file if
         * required.
         *
         * The D-Busactivated applications don't have to be started if your application
         * terminates too soon after this function. To prevent this, use
         * g_app_info_launch_default_for_uri_async() instead.
         * @param uri the uri to show
         * @param context an optional #GAppLaunchContext
         */
        launch_default_for_uri(uri: string, context?: AppLaunchContext | null): boolean;
        /**
         * Async version of g_app_info_launch_default_for_uri().
         *
         * This version is useful if you are interested in receiving
         * error information in the case where the application is
         * sandboxed and the portal may present an application chooser
         * dialog to the user.
         *
         * This is also useful if you want to be sure that the D-Busactivated
         * applications are really started before termination and if you are interested
         * in receiving error information from their activation.
         * @param uri the uri to show
         * @param context an optional #GAppLaunchContext
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        launch_default_for_uri_async(
            uri: string,
            context?: AppLaunchContext | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<AppInfo> | null,
        ): void;
        /**
         * Finishes an asynchronous launch-default-for-uri operation.
         * @param result a #GAsyncResult
         */
        launch_default_for_uri_finish(result: AsyncResult): boolean;
        /**
         * Removes all changes to the type associations done by
         * g_app_info_set_as_default_for_type(),
         * g_app_info_set_as_default_for_extension(),
         * g_app_info_add_supports_type() or
         * g_app_info_remove_supports_type().
         * @param content_type a content type
         */
        reset_type_associations(content_type: string): void;
    }
    interface AppInfo extends GObject.Object {
        // Methods

        /**
         * Adds a content type to the application information to indicate the
         * application is capable of opening files with the given content type.
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        add_supports_type(content_type: string): boolean;
        /**
         * Obtains the information whether the #GAppInfo can be deleted.
         * See g_app_info_delete().
         * @returns %TRUE if @appinfo can be deleted
         */
        can_delete(): boolean;
        /**
         * Checks if a supported content type can be removed from an application.
         * @returns %TRUE if it is possible to remove supported     content types from a given @appinfo, %FALSE if not.
         */
        can_remove_supports_type(): boolean;
        /**
         * Tries to delete a #GAppInfo.
         *
         * On some platforms, there may be a difference between user-defined
         * #GAppInfos which can be deleted, and system-wide ones which cannot.
         * See g_app_info_can_delete().
         * @returns %TRUE if @appinfo has been deleted
         */
        ['delete'](): boolean;
        /**
         * Creates a duplicate of a #GAppInfo.
         * @returns a duplicate of @appinfo.
         */
        dup(): AppInfo;
        /**
         * Checks if two #GAppInfos are equal.
         *
         * Note that the check *may not* compare each individual
         * field, and only does an identity check. In case detecting changes in the
         * contents is needed, program code must additionally compare relevant fields.
         * @param appinfo2 the second #GAppInfo.
         * @returns %TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.
         */
        equal(appinfo2: AppInfo): boolean;
        /**
         * Gets the commandline with which the application will be
         * started.
         * @returns a string containing the @appinfo's commandline,     or %NULL if this information is not available
         */
        get_commandline(): string | null;
        /**
         * Gets a human-readable description of an installed application.
         * @returns a string containing a description of the application @appinfo, or %NULL if none.
         */
        get_description(): string | null;
        /**
         * Gets the display name of the application. The display name is often more
         * descriptive to the user than the name itself.
         * @returns the display name of the application for @appinfo, or the name if no display name is available.
         */
        get_display_name(): string;
        /**
         * Gets the executable's name for the installed application.
         *
         * This is intended to be used for debugging or labelling what program is going
         * to be run. To launch the executable, use g_app_info_launch() and related
         * functions, rather than spawning the return value from this function.
         * @returns a string containing the @appinfo's application binaries name
         */
        get_executable(): string;
        /**
         * Gets the icon for the application.
         * @returns the default #GIcon for @appinfo or %NULL if there is no default icon.
         */
        get_icon(): Icon | null;
        /**
         * Gets the ID of an application. An id is a string that
         * identifies the application. The exact format of the id is
         * platform dependent. For instance, on Unix this is the
         * desktop file id from the xdg menu specification.
         *
         * Note that the returned ID may be %NULL, depending on how
         * the `appinfo` has been constructed.
         * @returns a string containing the application's ID.
         */
        get_id(): string | null;
        /**
         * Gets the installed name of the application.
         * @returns the name of the application for @appinfo.
         */
        get_name(): string;
        /**
         * Retrieves the list of content types that `app_info` claims to support.
         * If this information is not provided by the environment, this function
         * will return %NULL.
         * This function does not take in consideration associations added with
         * g_app_info_add_supports_type(), but only those exported directly by
         * the application.
         * @returns a list of content types.
         */
        get_supported_types(): string[];
        /**
         * Launches the application. Passes `files` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly.
         *
         * To launch the application without arguments pass a %NULL `files` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         *
         * Some URIs can be changed when passed through a GFile (for instance
         * unsupported URIs with strange formats like mailto:), so if you have
         * a textual URI you want to pass in as argument, consider using
         * g_app_info_launch_uris() instead.
         *
         * The launched application inherits the environment of the launching
         * process, but it can be modified with g_app_launch_context_setenv()
         * and g_app_launch_context_unsetenv().
         *
         * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
         * environment variable with the path of the launched desktop file and
         * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
         * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
         * should it be inherited by further processes. The `DISPLAY`,
         * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
         * variables are also set, based on information provided in `context`.
         * @param files a #GList of #GFile objects
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Launches the application. This passes the `uris` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly. If the application only supports
         * one URI per invocation as part of their command-line, multiple instances
         * of the application will be spawned.
         *
         * To launch the application without arguments pass a %NULL `uris` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Async version of g_app_info_launch_uris().
         *
         * The `callback` is invoked immediately after the application launch, but it
         * waits for activation in case of D-Busactivated applications and also provides
         * extended error information for sandboxed applications, see notes for
         * g_app_info_launch_default_for_uri_async().
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        launch_uris_async(
            uris?: string[] | null,
            context?: AppLaunchContext | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a g_app_info_launch_uris_async() operation.
         * @param result a #GAsyncResult
         * @returns %TRUE on successful launch, %FALSE otherwise.
         */
        launch_uris_finish(result: AsyncResult): boolean;
        /**
         * Removes a supported type from an application, if possible.
         * @param content_type a string.
         * @returns %TRUE on success, %FALSE on error.
         */
        remove_supports_type(content_type: string): boolean;
        /**
         * Sets the application as the default handler for the given file extension.
         * @param extension a string containing the file extension     (without the dot).
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_default_for_extension(extension: string): boolean;
        /**
         * Sets the application as the default handler for a given type.
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_default_for_type(content_type: string): boolean;
        /**
         * Sets the application as the last used application for a given type.
         * This will make the application appear as first in the list returned
         * by g_app_info_get_recommended_for_type(), regardless of the default
         * application for that content type.
         * @param content_type the content type.
         * @returns %TRUE on success, %FALSE on error.
         */
        set_as_last_used_for_type(content_type: string): boolean;
        /**
         * Checks if the application info should be shown in menus that
         * list available applications.
         * @returns %TRUE if the @appinfo should be shown, %FALSE otherwise.
         */
        should_show(): boolean;
        /**
         * Checks if the application accepts files as arguments.
         * @returns %TRUE if the @appinfo supports files.
         */
        supports_files(): boolean;
        /**
         * Checks if the application supports reading files and directories from URIs.
         * @returns %TRUE if the @appinfo supports URIs.
         */
        supports_uris(): boolean;

        // Virtual methods

        /**
         * Adds a content type to the application information to indicate the
         * application is capable of opening files with the given content type.
         * @param content_type a string.
         */
        vfunc_add_supports_type(content_type: string): boolean;
        /**
         * Obtains the information whether the #GAppInfo can be deleted.
         * See g_app_info_delete().
         */
        vfunc_can_delete(): boolean;
        /**
         * Checks if a supported content type can be removed from an application.
         */
        vfunc_can_remove_supports_type(): boolean;
        /**
         * Tries to delete a #GAppInfo.
         *
         * On some platforms, there may be a difference between user-defined
         * #GAppInfos which can be deleted, and system-wide ones which cannot.
         * See g_app_info_can_delete().
         */
        vfunc_do_delete(): boolean;
        /**
         * Creates a duplicate of a #GAppInfo.
         */
        vfunc_dup(): AppInfo;
        /**
         * Checks if two #GAppInfos are equal.
         *
         * Note that the check *may not* compare each individual
         * field, and only does an identity check. In case detecting changes in the
         * contents is needed, program code must additionally compare relevant fields.
         * @param appinfo2 the second #GAppInfo.
         */
        vfunc_equal(appinfo2: AppInfo): boolean;
        /**
         * Gets the commandline with which the application will be
         * started.
         */
        vfunc_get_commandline(): string | null;
        /**
         * Gets a human-readable description of an installed application.
         */
        vfunc_get_description(): string | null;
        /**
         * Gets the display name of the application. The display name is often more
         * descriptive to the user than the name itself.
         */
        vfunc_get_display_name(): string;
        /**
         * Gets the executable's name for the installed application.
         *
         * This is intended to be used for debugging or labelling what program is going
         * to be run. To launch the executable, use g_app_info_launch() and related
         * functions, rather than spawning the return value from this function.
         */
        vfunc_get_executable(): string;
        /**
         * Gets the icon for the application.
         */
        vfunc_get_icon(): Icon | null;
        /**
         * Gets the ID of an application. An id is a string that
         * identifies the application. The exact format of the id is
         * platform dependent. For instance, on Unix this is the
         * desktop file id from the xdg menu specification.
         *
         * Note that the returned ID may be %NULL, depending on how
         * the `appinfo` has been constructed.
         */
        vfunc_get_id(): string | null;
        /**
         * Gets the installed name of the application.
         */
        vfunc_get_name(): string;
        /**
         * Retrieves the list of content types that `app_info` claims to support.
         * If this information is not provided by the environment, this function
         * will return %NULL.
         * This function does not take in consideration associations added with
         * g_app_info_add_supports_type(), but only those exported directly by
         * the application.
         */
        vfunc_get_supported_types(): string[];
        /**
         * Launches the application. Passes `files` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly.
         *
         * To launch the application without arguments pass a %NULL `files` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         *
         * Some URIs can be changed when passed through a GFile (for instance
         * unsupported URIs with strange formats like mailto:), so if you have
         * a textual URI you want to pass in as argument, consider using
         * g_app_info_launch_uris() instead.
         *
         * The launched application inherits the environment of the launching
         * process, but it can be modified with g_app_launch_context_setenv()
         * and g_app_launch_context_unsetenv().
         *
         * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
         * environment variable with the path of the launched desktop file and
         * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
         * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
         * should it be inherited by further processes. The `DISPLAY`,
         * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
         * variables are also set, based on information provided in `context`.
         * @param files a #GList of #GFile objects
         * @param context a #GAppLaunchContext or %NULL
         */
        vfunc_launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Launches the application. This passes the `uris` to the launched application
         * as arguments, using the optional `context` to get information
         * about the details of the launcher (like what screen it is on).
         * On error, `error` will be set accordingly. If the application only supports
         * one URI per invocation as part of their command-line, multiple instances
         * of the application will be spawned.
         *
         * To launch the application without arguments pass a %NULL `uris` list.
         *
         * Note that even if the launch is successful the application launched
         * can fail to start if it runs into problems during startup. There is
         * no way to detect this.
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         */
        vfunc_launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
        /**
         * Async version of g_app_info_launch_uris().
         *
         * The `callback` is invoked immediately after the application launch, but it
         * waits for activation in case of D-Busactivated applications and also provides
         * extended error information for sandboxed applications, see notes for
         * g_app_info_launch_default_for_uri_async().
         * @param uris a #GList containing URIs to launch.
         * @param context a #GAppLaunchContext or %NULL
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        vfunc_launch_uris_async(
            uris?: string[] | null,
            context?: AppLaunchContext | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a g_app_info_launch_uris_async() operation.
         * @param result a #GAsyncResult
         */
        vfunc_launch_uris_finish(result: AsyncResult): boolean;
        /**
         * Removes a supported type from an application, if possible.
         * @param content_type a string.
         */
        vfunc_remove_supports_type(content_type: string): boolean;
        /**
         * Sets the application as the default handler for the given file extension.
         * @param extension a string containing the file extension     (without the dot).
         */
        vfunc_set_as_default_for_extension(extension: string): boolean;
        /**
         * Sets the application as the default handler for a given type.
         * @param content_type the content type.
         */
        vfunc_set_as_default_for_type(content_type: string): boolean;
        /**
         * Sets the application as the last used application for a given type.
         * This will make the application appear as first in the list returned
         * by g_app_info_get_recommended_for_type(), regardless of the default
         * application for that content type.
         * @param content_type the content type.
         */
        vfunc_set_as_last_used_for_type(content_type: string): boolean;
        /**
         * Checks if the application info should be shown in menus that
         * list available applications.
         */
        vfunc_should_show(): boolean;
        /**
         * Checks if the application accepts files as arguments.
         */
        vfunc_supports_files(): boolean;
        /**
         * Checks if the application supports reading files and directories from URIs.
         */
        vfunc_supports_uris(): boolean;
    }

    export const AppInfo: AppInfoNamespace;

    module AsyncInitable {
        // Constructor properties interface

        interface ConstructorProps<A extends GObject.Object = GObject.Object> extends GObject.Object.ConstructorProps {}
    }

    export interface AsyncInitableNamespace {
        $gtype: GObject.GType<AsyncInitable>;
        prototype: AsyncInitable;

        /**
         * Helper function for constructing #GAsyncInitable object. This is
         * similar to g_object_newv() but also initializes the object asynchronously.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_new_finish() to get the new object and check
         * for any errors.
         * @param object_type a #GType supporting #GAsyncInitable.
         * @param n_parameters the number of parameters in @parameters
         * @param parameters the parameters to use to construct the object
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the initialization is     finished
         */
        newv_async(
            object_type: GObject.GType,
            n_parameters: number,
            parameters: GObject.Parameter,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<AsyncInitable> | null,
        ): void;
    }
    interface AsyncInitable<A extends GObject.Object = GObject.Object> extends GObject.Object {
        // Methods

        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        init_finish(res: AsyncResult): boolean;
        /**
         * Finishes the async construction for the various g_async_initable_new
         * calls, returning the created object or %NULL on error.
         * @param res the #GAsyncResult from the callback
         * @returns a newly created #GObject,      or %NULL on error. Free with g_object_unref().
         */
        new_finish(res: AsyncResult): A;

        // Virtual methods

        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority][io-priority] of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        vfunc_init_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         */
        vfunc_init_finish(res: AsyncResult): boolean;
    }

    export const AsyncInitable: AsyncInitableNamespace;

    module AsyncResult {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface AsyncResultNamespace {
        $gtype: GObject.GType<AsyncResult>;
        prototype: AsyncResult;
    }
    interface AsyncResult extends GObject.Object {
        // Methods

        /**
         * Gets the source object from a #GAsyncResult.
         * @returns a new reference to the source    object for the @res, or %NULL if there is none.
         */
        get_source_object<T = GObject.Object>(): T;
        /**
         * Gets the user data from a #GAsyncResult.
         * @returns the user data for @res.
         */
        get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @param source_tag an application-defined tag
         * @returns %TRUE if @res has the indicated @source_tag, %FALSE if   not.
         */
        is_tagged(source_tag?: any | null): boolean;
        /**
         * If `res` is a #GSimpleAsyncResult, this is equivalent to
         * g_simple_async_result_propagate_error(). Otherwise it returns
         * %FALSE.
         *
         * This can be used for legacy error handling in async *_finish()
         * wrapper functions that traditionally handled #GSimpleAsyncResult
         * error returns themselves rather than calling into the virtual method.
         * This should not be used in new code; #GAsyncResult errors that are
         * set by virtual methods should also be extracted by virtual methods,
         * to enable subclasses to chain up correctly.
         * @returns %TRUE if @error is has been filled in with an error from   @res, %FALSE if not.
         */
        legacy_propagate_error(): boolean;

        // Virtual methods

        /**
         * Gets the source object from a #GAsyncResult.
         */
        vfunc_get_source_object<T = GObject.Object>(): T;
        /**
         * Gets the user data from a #GAsyncResult.
         */
        vfunc_get_user_data(): any | null;
        /**
         * Checks if `res` has the given `source_tag` (generally a function
         * pointer indicating the function `res` was created by).
         * @param source_tag an application-defined tag
         */
        vfunc_is_tagged(source_tag?: any | null): boolean;
    }

    export const AsyncResult: AsyncResultNamespace;

    module Converter {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ConverterNamespace {
        $gtype: GObject.GType<Converter>;
        prototype: Converter;
    }
    interface Converter extends GObject.Object {
        // Methods

        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
         */
        convert(
            inbuf: Uint8Array | string,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        reset(): void;

        // Virtual methods

        /**
         * This is the main operation used when converting data. It is to be called
         * multiple times in a loop, and each time it will do some work, i.e.
         * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
         * both. If its not possible to do any work an error is returned.
         *
         * Note that a single call may not consume all input (or any input at all).
         * Also a call may produce output even if given no input, due to state stored
         * in the converter producing output.
         *
         * If any data was either produced or consumed, and then an error happens, then
         * only the successful conversion is reported and the error is returned on the
         * next call.
         *
         * A full conversion loop involves calling this method repeatedly, each time
         * giving it new input and space output space. When there is no more input
         * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
         * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
         * each time until all data is consumed and all output is produced, then
         * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
         * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
         * in a decompression converter where the end of data is detectable from the
         * data (and there might even be other data after the end of the compressed data).
         *
         * When some data has successfully been converted `bytes_read` and is set to
         * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
         * how many bytes was written to `outbuf`. If there are more data to output
         * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
         * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
         * then %G_CONVERTER_FINISHED is returned.
         *
         * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
         * Some errors need special handling:
         *
         * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
         * to write the resulting converted data, the application should
         * call the function again with a larger `outbuf` to continue.
         *
         * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
         * input to fully determine what the conversion should produce,
         * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
         * example with an incomplete multibyte sequence when converting text,
         * or when a regexp matches up to the end of the input (and may match
         * further input). It may also happen when `inbuf_size` is zero and
         * there is no more data to produce.
         *
         * When this happens the application should read more input and then
         * call the function again. If further input shows that there is no
         * more data call the function again with the same data but with
         * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
         * to finish as e.g. in the regexp match case (or, to fail again with
         * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
         * input is actually partial).
         *
         * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
         * converter object is in an invalid state where its not allowed
         * to call g_converter_convert() anymore. At this time you can only
         * free the object or call g_converter_reset() to reset it to the
         * initial state.
         *
         * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
         * to try to write out all internal state to the output. The application
         * has to call the function multiple times with the flag set, and when
         * the available input has been consumed and all internal state has
         * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
         * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
         * This is somewhat similar to what happens at the end of the input stream,
         * but done in the middle of the data.
         *
         * This has different meanings for different conversions. For instance
         * in a compression converter it would mean that we flush all the
         * compression state into output such that if you uncompress the
         * compressed data you get back all the input data. Doing this may
         * make the final file larger due to padding though. Another example
         * is a regexp conversion, where if you at the end of the flushed data
         * have a match, but there is also a potential longer match. In the
         * non-flushed case we would ask for more input, but when flushing we
         * treat this as the end of input and do the match.
         *
         * Flushing is not always possible (like if a charset converter flushes
         * at a partial multibyte sequence). Converters are supposed to try
         * to produce as much output as possible and then return an error
         * (typically %G_IO_ERROR_PARTIAL_INPUT).
         * @param inbuf the buffer         containing the data to convert.
         * @param outbuf a    buffer to write converted data in.
         * @param flags a #GConverterFlags controlling the conversion details
         */
        vfunc_convert(
            inbuf: Uint8Array | null,
            outbuf: Uint8Array | string,
            flags: ConverterFlags,
        ): [ConverterResult, number, number];
        /**
         * Resets all internal state in the converter, making it behave
         * as if it was just created. If the converter has any internal
         * state that would produce output then that output is lost.
         */
        vfunc_reset(): void;
    }

    export const Converter: ConverterNamespace;

    module DBusInterface {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DBusInterfaceNamespace {
        $gtype: GObject.GType<DBusInterface>;
        prototype: DBusInterface;
    }
    interface DBusInterface extends GObject.Object {
        // Methods

        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         * @returns A #GDBusObject or %NULL. The returned reference should be freed with g_object_unref().
         */
        get_object(): DBusObject | null;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         * @returns A #GDBusInterfaceInfo. Do not free.
         */
        get_info(): DBusInterfaceInfo;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @param object A #GDBusObject or %NULL.
         */
        set_object(object?: DBusObject | null): void;

        // Virtual methods

        /**
         * Gets the #GDBusObject that `interface_` belongs to, if any.
         */
        vfunc_dup_object(): DBusObject | null;
        /**
         * Gets D-Bus introspection information for the D-Bus interface
         * implemented by `interface_`.
         */
        vfunc_get_info(): DBusInterfaceInfo;
        /**
         * Sets the #GDBusObject for `interface_` to `object`.
         *
         * Note that `interface_` will hold a weak reference to `object`.
         * @param object A #GDBusObject or %NULL.
         */
        vfunc_set_object(object?: DBusObject | null): void;
    }

    export const DBusInterface: DBusInterfaceNamespace;

    module DBusObject {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DBusObjectNamespace {
        $gtype: GObject.GType<DBusObject>;
        prototype: DBusObject;
    }
    interface DBusObject extends GObject.Object {
        // Methods

        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @param interface_name A D-Bus interface name.
         * @returns %NULL if not found, otherwise a   #GDBusInterface that must be freed with g_object_unref().
         */
        get_interface(interface_name: string): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         * @returns A list of #GDBusInterface instances.   The returned list must be freed by g_list_free() after each element has been freed   with g_object_unref().
         */
        get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         * @returns A string owned by @object. Do not free.
         */
        get_object_path(): string;

        // Virtual methods

        /**
         * Gets the D-Bus interface with name `interface_name` associated with
         * `object,` if any.
         * @param interface_name A D-Bus interface name.
         */
        vfunc_get_interface(interface_name: string): DBusInterface | null;
        /**
         * Gets the D-Bus interfaces associated with `object`.
         */
        vfunc_get_interfaces(): DBusInterface[];
        /**
         * Gets the object path for `object`.
         */
        vfunc_get_object_path(): string;
        /**
         * Signal handler for the #GDBusObject::interface-added signal.
         * @param interface_
         */
        vfunc_interface_added(interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObject::interface-removed signal.
         * @param interface_
         */
        vfunc_interface_removed(interface_: DBusInterface): void;
    }

    export const DBusObject: DBusObjectNamespace;

    module DBusObjectManager {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DBusObjectManagerNamespace {
        $gtype: GObject.GType<DBusObjectManager>;
        prototype: DBusObjectManager;
    }
    interface DBusObjectManager extends GObject.Object {
        // Methods

        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         * @returns A #GDBusInterface instance or %NULL. Free   with g_object_unref().
         */
        get_interface(object_path: string, interface_name: string): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @param object_path Object path to look up.
         * @returns A #GDBusObject or %NULL. Free with   g_object_unref().
         */
        get_object(object_path: string): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         * @returns A string owned by @manager. Do not free.
         */
        get_object_path(): string;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         * @returns A list of   #GDBusObject objects. The returned list should be freed with   g_list_free() after each element has been freed with   g_object_unref().
         */
        get_objects(): DBusObject[];

        // Virtual methods

        /**
         * Gets the interface proxy for `interface_name` at `object_path,` if
         * any.
         * @param object_path Object path to look up.
         * @param interface_name D-Bus interface name to look up.
         */
        vfunc_get_interface(object_path: string, interface_name: string): DBusInterface | null;
        /**
         * Gets the #GDBusObject at `object_path,` if any.
         * @param object_path Object path to look up.
         */
        vfunc_get_object(object_path: string): DBusObject | null;
        /**
         * Gets the object path that `manager` is for.
         */
        vfunc_get_object_path(): string;
        /**
         * Gets all #GDBusObject objects known to `manager`.
         */
        vfunc_get_objects(): DBusObject[];
        /**
         * Signal handler for the #GDBusObjectManager::interface-added signal.
         * @param object
         * @param interface_
         */
        vfunc_interface_added(object: DBusObject, interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObjectManager::interface-removed signal.
         * @param object
         * @param interface_
         */
        vfunc_interface_removed(object: DBusObject, interface_: DBusInterface): void;
        /**
         * Signal handler for the #GDBusObjectManager::object-added signal.
         * @param object
         */
        vfunc_object_added(object: DBusObject): void;
        /**
         * Signal handler for the #GDBusObjectManager::object-removed signal.
         * @param object
         */
        vfunc_object_removed(object: DBusObject): void;
    }

    export const DBusObjectManager: DBusObjectManagerNamespace;

    module DatagramBased {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DatagramBasedNamespace {
        $gtype: GObject.GType<DatagramBased>;
        prototype: DatagramBased;
    }
    interface DatagramBased extends GObject.Object {
        // Methods

        /**
         * Checks on the readiness of `datagram_based` to perform operations. The
         * operations specified in `condition` are checked for and masked against the
         * currently-satisfied conditions on `datagram_based`. The result is returned.
         *
         * %G_IO_IN will be set in the return value if data is available to read with
         * g_datagram_based_receive_messages(), or if the connection is closed remotely
         * (EOS); and if the datagram_based has not been closed locally using some
         * implementation-specific method (such as g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * %G_IO_OUT will be set if it is expected that at least one byte can be sent
         * using g_datagram_based_send_messages() without blocking. It will not be set
         * if the datagram_based has been closed locally.
         *
         * %G_IO_HUP will be set if the connection has been closed locally.
         *
         * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
         * previously enqueued using g_datagram_based_send_messages().
         *
         * Note that on Windows, it is possible for an operation to return
         * %G_IO_ERROR_WOULD_BLOCK even immediately after
         * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
         * ready for writing. Rather than calling g_datagram_based_condition_check() and
         * then writing to the #GDatagramBased if it succeeds, it is generally better to
         * simply try writing right away, and try again later if the initial attempt
         * returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be set in the output if they are true. Apart from
         * these flags, the output is guaranteed to be masked by `condition`.
         *
         * This call never blocks.
         * @param condition a #GIOCondition mask to check
         * @returns the #GIOCondition mask of the current state
         */
        condition_check(condition: GLib.IOCondition): GLib.IOCondition;
        /**
         * Waits for up to `timeout` microseconds for condition to become true on
         * `datagram_based`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if `timeout` is
         * reached before the condition is met, then %FALSE is returned and `error` is
         * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
         * @param condition a #GIOCondition mask to wait for
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a #GCancellable
         * @returns %TRUE if the condition was met, %FALSE otherwise
         */
        condition_wait(condition: GLib.IOCondition, timeout: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a #GSource that can be attached to a #GMainContext to monitor for
         * the availability of the specified `condition` on the #GDatagramBased. The
         * #GSource keeps a reference to the `datagram_based`.
         *
         * The callback on the source is of the #GDatagramBasedSourceFunc type.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be reported in the callback if they are true.
         *
         * If non-%NULL, `cancellable` can be used to cancel the source, which will
         * cause the source to trigger, reporting the current condition (which is
         * likely 0 unless cancellation happened at the same time as a condition
         * change). You can check for this in the callback using
         * g_cancellable_is_cancelled().
         * @param condition a #GIOCondition mask to monitor
         * @param cancellable a #GCancellable
         * @returns a newly allocated #GSource
         */
        create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
        /**
         * Receive one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to.
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
         * or an error occurs.
         *
         * If `timeout` is 0 the call will return up to `num_messages` without blocking,
         * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
         * to be received.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached
         * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
         * otherwise it will return the number of messages received before timing out.
         * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
         * recvmmsg().)
         *
         * To be notified when messages are available, wait for the %G_IO_IN condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_receive_messages() even if you were previously notified of a
         * %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * underlying receive buffer will be returned, and subsequent calls to
         * g_datagram_based_receive_messages() will return 0 (with no error set).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned. If
         * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
         * other error.
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if @timeout is     zero or positive, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
         */
        receive_messages(
            messages: InputMessage[],
            flags: number,
            timeout: number,
            cancellable?: Cancellable | null,
        ): number;
        /**
         * Send one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * The other members of #GOutputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * sent, `cancellable` is cancelled, or an error occurs.
         *
         * If `timeout` is 0 the call will send up to `num_messages` without blocking,
         * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached before any messages are
         * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
         * of messages sent before timing out.
         *
         * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_send_messages() even if you were previously notified of a
         * %G_IO_OUT condition. (On Windows in particular, this is very common due to
         * the way the underlying APIs work.)
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_write` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned. If `cancellable` is
         * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if @timeout is zero     or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in     which case the caller may re-try to send the remaining messages.
         */
        send_messages(
            messages: OutputMessage[],
            flags: number,
            timeout: number,
            cancellable?: Cancellable | null,
        ): number;

        // Virtual methods

        /**
         * Checks on the readiness of `datagram_based` to perform operations. The
         * operations specified in `condition` are checked for and masked against the
         * currently-satisfied conditions on `datagram_based`. The result is returned.
         *
         * %G_IO_IN will be set in the return value if data is available to read with
         * g_datagram_based_receive_messages(), or if the connection is closed remotely
         * (EOS); and if the datagram_based has not been closed locally using some
         * implementation-specific method (such as g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * %G_IO_OUT will be set if it is expected that at least one byte can be sent
         * using g_datagram_based_send_messages() without blocking. It will not be set
         * if the datagram_based has been closed locally.
         *
         * %G_IO_HUP will be set if the connection has been closed locally.
         *
         * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
         * previously enqueued using g_datagram_based_send_messages().
         *
         * Note that on Windows, it is possible for an operation to return
         * %G_IO_ERROR_WOULD_BLOCK even immediately after
         * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
         * ready for writing. Rather than calling g_datagram_based_condition_check() and
         * then writing to the #GDatagramBased if it succeeds, it is generally better to
         * simply try writing right away, and try again later if the initial attempt
         * returns %G_IO_ERROR_WOULD_BLOCK.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be set in the output if they are true. Apart from
         * these flags, the output is guaranteed to be masked by `condition`.
         *
         * This call never blocks.
         * @param condition a #GIOCondition mask to check
         */
        vfunc_condition_check(condition: GLib.IOCondition): GLib.IOCondition;
        /**
         * Waits for up to `timeout` microseconds for condition to become true on
         * `datagram_based`. If the condition is met, %TRUE is returned.
         *
         * If `cancellable` is cancelled before the condition is met, or if `timeout` is
         * reached before the condition is met, then %FALSE is returned and `error` is
         * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
         * @param condition a #GIOCondition mask to wait for
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a #GCancellable
         */
        vfunc_condition_wait(condition: GLib.IOCondition, timeout: number, cancellable?: Cancellable | null): boolean;
        /**
         * Creates a #GSource that can be attached to a #GMainContext to monitor for
         * the availability of the specified `condition` on the #GDatagramBased. The
         * #GSource keeps a reference to the `datagram_based`.
         *
         * The callback on the source is of the #GDatagramBasedSourceFunc type.
         *
         * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
         * conditions will always be reported in the callback if they are true.
         *
         * If non-%NULL, `cancellable` can be used to cancel the source, which will
         * cause the source to trigger, reporting the current condition (which is
         * likely 0 unless cancellation happened at the same time as a condition
         * change). You can check for this in the callback using
         * g_cancellable_is_cancelled().
         * @param condition a #GIOCondition mask to monitor
         * @param cancellable a #GCancellable
         */
        vfunc_create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
        /**
         * Receive one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GInputMessage structs and
         * `num_messages` must be the length of this array. Each #GInputMessage
         * contains a pointer to an array of #GInputVector structs describing the
         * buffers that the data received in each message will be written to.
         *
         * `flags` modify how all messages are received. The commonly available
         * arguments for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too. These
         * flags affect the overall receive operation. Flags affecting individual
         * messages are returned in #GInputMessage.flags.
         *
         * The other members of #GInputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
         * or an error occurs.
         *
         * If `timeout` is 0 the call will return up to `num_messages` without blocking,
         * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
         * to be received.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached
         * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
         * otherwise it will return the number of messages received before timing out.
         * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
         * recvmmsg().)
         *
         * To be notified when messages are available, wait for the %G_IO_IN condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_receive_messages() even if you were previously notified of a
         * %G_IO_IN condition.
         *
         * If the remote peer closes the connection, any messages queued in the
         * underlying receive buffer will be returned, and subsequent calls to
         * g_datagram_based_receive_messages() will return 0 (with no error set).
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_read` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be received; otherwise the number of
         * messages successfully received before the error will be returned. If
         * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
         * other error.
         * @param messages an array of #GInputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags for the overall operation
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         */
        vfunc_receive_messages(
            messages: InputMessage[],
            flags: number,
            timeout: number,
            cancellable?: Cancellable | null,
        ): number;
        /**
         * Send one or more data messages from `datagram_based` in one go.
         *
         * `messages` must point to an array of #GOutputMessage structs and
         * `num_messages` must be the length of this array. Each #GOutputMessage
         * contains an address to send the data to, and a pointer to an array of
         * #GOutputVector structs to describe the buffers that the data to be sent
         * for each message will be gathered from.
         *
         * `flags` modify how the message is sent. The commonly available arguments
         * for this are available in the #GSocketMsgFlags enum, but the
         * values there are the same as the system values, and the flags
         * are passed in as-is, so you can pass in system-specific flags too.
         *
         * The other members of #GOutputMessage are treated as described in its
         * documentation.
         *
         * If `timeout` is negative the call will block until `num_messages` have been
         * sent, `cancellable` is cancelled, or an error occurs.
         *
         * If `timeout` is 0 the call will send up to `num_messages` without blocking,
         * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
         *
         * If `timeout` is positive the call will block on the same conditions as if
         * `timeout` were negative. If the timeout is reached before any messages are
         * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
         * of messages sent before timing out.
         *
         * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
         * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
         * g_datagram_based_send_messages() even if you were previously notified of a
         * %G_IO_OUT condition. (On Windows in particular, this is very common due to
         * the way the underlying APIs work.)
         *
         * If the connection is shut down or closed (by calling g_socket_close() or
         * g_socket_shutdown() with `shutdown_write` set, if its a #GSocket, for
         * example), all calls to this function will return %G_IO_ERROR_CLOSED.
         *
         * On error -1 is returned and `error` is set accordingly. An error will only
         * be returned if zero messages could be sent; otherwise the number of messages
         * successfully sent before the error will be returned. If `cancellable` is
         * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
         * @param messages an array of #GOutputMessage structs
         * @param flags an int containing #GSocketMsgFlags flags
         * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
         * @param cancellable a %GCancellable
         */
        vfunc_send_messages(
            messages: OutputMessage[],
            flags: number,
            timeout: number,
            cancellable?: Cancellable | null,
        ): number;
    }

    export const DatagramBased: DatagramBasedNamespace;

    module DebugController {
        // Constructor properties interface

        interface ConstructorProps extends Initable.ConstructorProps {
            debug_enabled: boolean;
            debugEnabled: boolean;
        }
    }

    export interface DebugControllerNamespace {
        $gtype: GObject.GType<DebugController>;
        prototype: DebugController;
    }
    interface DebugController extends Initable {
        // Properties

        /**
         * %TRUE if debug output should be exposed (for example by forwarding it to
         * the journal), %FALSE otherwise.
         */
        get debug_enabled(): boolean;
        set debug_enabled(val: boolean);
        /**
         * %TRUE if debug output should be exposed (for example by forwarding it to
         * the journal), %FALSE otherwise.
         */
        get debugEnabled(): boolean;
        set debugEnabled(val: boolean);

        // Methods

        /**
         * Get the value of #GDebugController:debug-enabled.
         * @returns %TRUE if debug output should be exposed, %FALSE otherwise
         */
        get_debug_enabled(): boolean;
        /**
         * Set the value of #GDebugController:debug-enabled.
         * @param debug_enabled %TRUE if debug output should be exposed, %FALSE otherwise
         */
        set_debug_enabled(debug_enabled: boolean): void;
    }

    export const DebugController: DebugControllerNamespace;

    module DesktopAppInfoLookup {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DesktopAppInfoLookupNamespace {
        $gtype: GObject.GType<DesktopAppInfoLookup>;
        prototype: DesktopAppInfoLookup;
    }
    interface DesktopAppInfoLookup extends GObject.Object {
        // Methods

        /**
         * Gets the default application for launching applications
         * using this URI scheme for a particular #GDesktopAppInfoLookup
         * implementation.
         *
         * The #GDesktopAppInfoLookup interface and this function is used
         * to implement g_app_info_get_default_for_uri_scheme() backends
         * in a GIO module. There is no reason for applications to use it
         * directly. Applications should use g_app_info_get_default_for_uri_scheme().
         * @param uri_scheme a string containing a URI scheme.
         * @returns #GAppInfo for given @uri_scheme or    %NULL on error.
         */
        get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;

        // Virtual methods

        /**
         * Gets the default application for launching applications
         * using this URI scheme for a particular #GDesktopAppInfoLookup
         * implementation.
         *
         * The #GDesktopAppInfoLookup interface and this function is used
         * to implement g_app_info_get_default_for_uri_scheme() backends
         * in a GIO module. There is no reason for applications to use it
         * directly. Applications should use g_app_info_get_default_for_uri_scheme().
         * @param uri_scheme a string containing a URI scheme.
         */
        vfunc_get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
    }

    export const DesktopAppInfoLookup: DesktopAppInfoLookupNamespace;

    module Drive {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DriveNamespace {
        $gtype: GObject.GType<Drive>;
        prototype: Drive;
    }
    interface Drive extends GObject.Object {
        // Methods

        /**
         * Checks if a drive can be ejected.
         * @returns %TRUE if the @drive can be ejected, %FALSE otherwise.
         */
        can_eject(): boolean;
        /**
         * Checks if a drive can be polled for media changes.
         * @returns %TRUE if the @drive can be polled for media changes,     %FALSE otherwise.
         */
        can_poll_for_media(): boolean;
        /**
         * Checks if a drive can be started.
         * @returns %TRUE if the @drive can be started, %FALSE otherwise.
         */
        can_start(): boolean;
        /**
         * Checks if a drive can be started degraded.
         * @returns %TRUE if the @drive can be started degraded, %FALSE otherwise.
         */
        can_start_degraded(): boolean;
        /**
         * Checks if a drive can be stopped.
         * @returns %TRUE if the @drive can be stopped, %FALSE otherwise.
         */
        can_stop(): boolean;
        /**
         * Asynchronously ejects a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_eject_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been ejected successfully,     %FALSE otherwise.
         */
        eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a drive. This is an asynchronous operation, and is
         * finished by calling g_drive_eject_with_operation_finish() with the `drive`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a drive. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive was successfully ejected. %FALSE otherwise.
         */
        eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of identifiers that `drive` has.
         * Use g_drive_get_identifier() to obtain the identifiers
         * themselves.
         * @returns a %NULL-terminated     array of strings containing kinds of identifiers. Use g_strfreev()     to free.
         */
        enumerate_identifiers(): string[];
        /**
         * Gets the icon for `drive`.
         * @returns #GIcon for the @drive.    Free the returned object with g_object_unref().
         */
        get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `drive`. The only
         * identifier currently available is
         * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
         * @param kind the kind of identifier to return
         * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GDrive     doesn't have this kind of identifier.
         */
        get_identifier(kind: string): string | null;
        /**
         * Gets the name of `drive`.
         * @returns a string containing @drive's name. The returned     string should be freed when no longer needed.
         */
        get_name(): string;
        /**
         * Gets the sort key for `drive,` if any.
         * @returns Sorting key for @drive or %NULL if no such key is available.
         */
        get_sort_key(): string | null;
        /**
         * Gets a hint about how a drive can be started/stopped.
         * @returns A value from the #GDriveStartStopType enumeration.
         */
        get_start_stop_type(): DriveStartStopType;
        /**
         * Gets the icon for `drive`.
         * @returns symbolic #GIcon for the @drive.    Free the returned object with g_object_unref().
         */
        get_symbolic_icon(): Icon;
        /**
         * Get a list of mountable volumes for `drive`.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         * @returns #GList containing any #GVolume objects on the given @drive.
         */
        get_volumes(): Volume[];
        /**
         * Checks if the `drive` has media. Note that the OS may not be polling
         * the drive for media changes; see g_drive_is_media_check_automatic()
         * for more details.
         * @returns %TRUE if @drive has media, %FALSE otherwise.
         */
        has_media(): boolean;
        /**
         * Check if `drive` has any mountable volumes.
         * @returns %TRUE if the @drive contains volumes, %FALSE otherwise.
         */
        has_volumes(): boolean;
        /**
         * Checks if `drive` is capable of automatically detecting media changes.
         * @returns %TRUE if the @drive is capable of automatically detecting     media changes, %FALSE otherwise.
         */
        is_media_check_automatic(): boolean;
        /**
         * Checks if the `drive` supports removable media.
         * @returns %TRUE if @drive supports removable media, %FALSE otherwise.
         */
        is_media_removable(): boolean;
        /**
         * Checks if the #GDrive and/or its media is considered removable by the user.
         * See g_drive_is_media_removable().
         * @returns %TRUE if @drive and/or its media is considered removable, %FALSE otherwise.
         */
        is_removable(): boolean;
        /**
         * Asynchronously polls `drive` to see if media has been inserted or removed.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_poll_for_media_finish() to obtain the
         * result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        poll_for_media(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an operation started with g_drive_poll_for_media() on a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been poll_for_mediaed successfully,     %FALSE otherwise.
         */
        poll_for_media_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously starts a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_start_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the start operation.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        start(
            flags: DriveStartFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes starting a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been started successfully,     %FALSE otherwise.
         */
        start_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously stops a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_stop_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the unmount if required for stopping.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        stop(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes stopping a drive.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the drive has been stopped successfully,     %FALSE otherwise.
         */
        stop_finish(result: AsyncResult): boolean;

        // Virtual methods

        /**
         * Checks if a drive can be ejected.
         */
        vfunc_can_eject(): boolean;
        /**
         * Checks if a drive can be polled for media changes.
         */
        vfunc_can_poll_for_media(): boolean;
        /**
         * Checks if a drive can be started.
         */
        vfunc_can_start(): boolean;
        /**
         * Checks if a drive can be started degraded.
         */
        vfunc_can_start_degraded(): boolean;
        /**
         * Checks if a drive can be stopped.
         */
        vfunc_can_stop(): boolean;
        /**
         * Signal emitted when the drive is changed.
         */
        vfunc_changed(): void;
        /**
         * The removed signal that is emitted when the #GDrive have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.
         */
        vfunc_disconnected(): void;
        /**
         * Asynchronously ejects a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_eject_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Signal emitted when the physical eject button (if any) of a drive have been pressed.
         */
        vfunc_eject_button(): void;
        /**
         * Finishes ejecting a drive.
         * @param result a #GAsyncResult.
         */
        vfunc_eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a drive. This is an asynchronous operation, and is
         * finished by calling g_drive_eject_with_operation_finish() with the `drive`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a drive. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         */
        vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of identifiers that `drive` has.
         * Use g_drive_get_identifier() to obtain the identifiers
         * themselves.
         */
        vfunc_enumerate_identifiers(): string[];
        /**
         * Gets the icon for `drive`.
         */
        vfunc_get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `drive`. The only
         * identifier currently available is
         * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
         * @param kind the kind of identifier to return
         */
        vfunc_get_identifier(kind: string): string | null;
        /**
         * Gets the name of `drive`.
         */
        vfunc_get_name(): string;
        /**
         * Gets the sort key for `drive,` if any.
         */
        vfunc_get_sort_key(): string | null;
        /**
         * Gets a hint about how a drive can be started/stopped.
         */
        vfunc_get_start_stop_type(): DriveStartStopType;
        /**
         * Gets the icon for `drive`.
         */
        vfunc_get_symbolic_icon(): Icon;
        /**
         * Get a list of mountable volumes for `drive`.
         *
         * The returned list should be freed with g_list_free(), after
         * its elements have been unreffed with g_object_unref().
         */
        vfunc_get_volumes(): Volume[];
        /**
         * Checks if the `drive` has media. Note that the OS may not be polling
         * the drive for media changes; see g_drive_is_media_check_automatic()
         * for more details.
         */
        vfunc_has_media(): boolean;
        /**
         * Check if `drive` has any mountable volumes.
         */
        vfunc_has_volumes(): boolean;
        /**
         * Checks if `drive` is capable of automatically detecting media changes.
         */
        vfunc_is_media_check_automatic(): boolean;
        /**
         * Checks if the `drive` supports removable media.
         */
        vfunc_is_media_removable(): boolean;
        /**
         * Checks if the #GDrive and/or its media is considered removable by the user.
         * See g_drive_is_media_removable().
         */
        vfunc_is_removable(): boolean;
        /**
         * Asynchronously polls `drive` to see if media has been inserted or removed.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_poll_for_media_finish() to obtain the
         * result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_poll_for_media(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an operation started with g_drive_poll_for_media() on a drive.
         * @param result a #GAsyncResult.
         */
        vfunc_poll_for_media_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously starts a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_start_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the start operation.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_start(
            flags: DriveStartFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes starting a drive.
         * @param result a #GAsyncResult.
         */
        vfunc_start_finish(result: AsyncResult): boolean;
        /**
         * Asynchronously stops a drive.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_drive_stop_finish() to obtain the
         * result of the operation.
         * @param flags flags affecting the unmount if required for stopping.
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_stop(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.
         */
        vfunc_stop_button(): void;
        /**
         * Finishes stopping a drive.
         * @param result a #GAsyncResult.
         */
        vfunc_stop_finish(result: AsyncResult): boolean;
    }

    export const Drive: DriveNamespace;

    module DtlsClientConnection {
        // Constructor properties interface

        interface ConstructorProps extends DatagramBased.ConstructorProps {
            accepted_cas: any[];
            acceptedCas: any[];
            server_identity: SocketConnectable;
            serverIdentity: SocketConnectable;
            validation_flags: TlsCertificateFlags;
            validationFlags: TlsCertificateFlags;
        }
    }

    export interface DtlsClientConnectionNamespace {
        $gtype: GObject.GType<DtlsClientConnection>;
        prototype: DtlsClientConnection;

        /**
         * Creates a new #GDtlsClientConnection wrapping `base_socket` which is
         * assumed to communicate with the server identified by `server_identity`.
         * @param base_socket the #GDatagramBased to wrap
         * @param server_identity the expected identity of the server
         */
        ['new'](base_socket: DatagramBased, server_identity?: SocketConnectable | null): DtlsClientConnection;
    }
    interface DtlsClientConnection extends DatagramBased {
        // Properties

        /**
         * A list of the distinguished names of the Certificate Authorities
         * that the server will accept client certificates signed by. If the
         * server requests a client certificate during the handshake, then
         * this property will be set after the handshake completes.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         */
        get accepted_cas(): any[];
        /**
         * A list of the distinguished names of the Certificate Authorities
         * that the server will accept client certificates signed by. If the
         * server requests a client certificate during the handshake, then
         * this property will be set after the handshake completes.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         */
        get acceptedCas(): any[];
        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         *
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GDtlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GDtlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         *
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        get server_identity(): SocketConnectable;
        set server_identity(val: SocketConnectable);
        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         *
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GDtlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GDtlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         *
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        get serverIdentity(): SocketConnectable;
        set serverIdentity(val: SocketConnectable);
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GDtlsConnection::accept-certificate.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GDtlsConnection::accept-certificate.
         */
        get validation_flags(): TlsCertificateFlags;
        set validation_flags(val: TlsCertificateFlags);
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GDtlsConnection::accept-certificate.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GDtlsConnection::accept-certificate.
         */
        get validationFlags(): TlsCertificateFlags;
        set validationFlags(val: TlsCertificateFlags);

        // Methods

        /**
         * Gets the list of distinguished names of the Certificate Authorities
         * that the server will accept certificates from. This will be set
         * during the TLS handshake if the server requests a certificate.
         * Otherwise, it will be %NULL.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         * @returns the list of CA DNs. You should unref each element with g_byte_array_unref() and then the free the list with g_list_free().
         */
        get_accepted_cas(): GLib.List;
        /**
         * Gets `conn'`s expected server identity
         * @returns a #GSocketConnectable describing the expected server identity, or %NULL if the expected identity is not known.
         */
        get_server_identity(): SocketConnectable;
        /**
         * Gets `conn'`s validation flags
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GDtlsClientConnection:validation-flags for more
         * information.
         * @returns the validation flags
         */
        get_validation_flags(): TlsCertificateFlags;
        /**
         * Sets `conn'`s expected server identity, which is used both to tell
         * servers on virtual hosts which certificate to present, and also
         * to let `conn` know what name to look for in the certificate when
         * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
         * @param identity a #GSocketConnectable describing the expected server identity
         */
        set_server_identity(identity: SocketConnectable): void;
        /**
         * Sets `conn'`s validation flags, to override the default set of
         * checks performed when validating a server certificate. By default,
         * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GDtlsClientConnection:validation-flags for more
         * information.
         * @param flags the #GTlsCertificateFlags to use
         */
        set_validation_flags(flags: TlsCertificateFlags): void;
    }

    export const DtlsClientConnection: DtlsClientConnectionNamespace;

    module DtlsConnection {
        // Constructor properties interface

        interface ConstructorProps extends DatagramBased.ConstructorProps {
            advertised_protocols: string[];
            advertisedProtocols: string[];
            base_socket: DatagramBased;
            baseSocket: DatagramBased;
            certificate: TlsCertificate;
            ciphersuite_name: string;
            ciphersuiteName: string;
            database: TlsDatabase;
            interaction: TlsInteraction;
            negotiated_protocol: string;
            negotiatedProtocol: string;
            peer_certificate: TlsCertificate;
            peerCertificate: TlsCertificate;
            peer_certificate_errors: TlsCertificateFlags;
            peerCertificateErrors: TlsCertificateFlags;
            protocol_version: TlsProtocolVersion;
            protocolVersion: TlsProtocolVersion;
            rehandshake_mode: TlsRehandshakeMode;
            rehandshakeMode: TlsRehandshakeMode;
            require_close_notify: boolean;
            requireCloseNotify: boolean;
        }
    }

    export interface DtlsConnectionNamespace {
        $gtype: GObject.GType<DtlsConnection>;
        prototype: DtlsConnection;
    }
    interface DtlsConnection extends DatagramBased {
        // Properties

        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_dtls_connection_set_advertised_protocols().
         */
        get advertised_protocols(): string[];
        set advertised_protocols(val: string[]);
        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_dtls_connection_set_advertised_protocols().
         */
        get advertisedProtocols(): string[];
        set advertisedProtocols(val: string[]);
        /**
         * The #GDatagramBased that the connection wraps. Note that this may be any
         * implementation of #GDatagramBased, not just a #GSocket.
         */
        get base_socket(): DatagramBased;
        /**
         * The #GDatagramBased that the connection wraps. Note that this may be any
         * implementation of #GDatagramBased, not just a #GSocket.
         */
        get baseSocket(): DatagramBased;
        /**
         * The connection's certificate; see
         * g_dtls_connection_set_certificate().
         */
        get certificate(): TlsCertificate;
        set certificate(val: TlsCertificate);
        /**
         * The name of the DTLS ciphersuite in use. See g_dtls_connection_get_ciphersuite_name().
         */
        get ciphersuite_name(): string;
        /**
         * The name of the DTLS ciphersuite in use. See g_dtls_connection_get_ciphersuite_name().
         */
        get ciphersuiteName(): string;
        /**
         * The certificate database to use when verifying this TLS connection.
         * If no certificate database is set, then the default database will be
         * used. See g_tls_backend_get_default_database().
         *
         * When using a non-default database, #GDtlsConnection must fall back to using
         * the #GTlsDatabase to perform certificate verification using
         * g_tls_database_verify_chain(), which means certificate verification will
         * not be able to make use of TLS session context. This may be less secure.
         * For example, if you create your own #GTlsDatabase that just wraps the
         * default #GTlsDatabase, you might expect that you have not changed anything,
         * but this is not true because you may have altered the behavior of
         * #GDtlsConnection by causing it to use g_tls_database_verify_chain(). See the
         * documentation of g_tls_database_verify_chain() for more details on specific
         * security checks that may not be performed. Accordingly, setting a
         * non-default database is discouraged except for specialty applications with
         * unusual security requirements.
         */
        get database(): TlsDatabase;
        set database(val: TlsDatabase);
        /**
         * A #GTlsInteraction object to be used when the connection or certificate
         * database need to interact with the user. This will be used to prompt the
         * user for passwords where necessary.
         */
        get interaction(): TlsInteraction;
        set interaction(val: TlsInteraction);
        /**
         * The application-layer protocol negotiated during the TLS
         * handshake. See g_dtls_connection_get_negotiated_protocol().
         */
        get negotiated_protocol(): string;
        /**
         * The application-layer protocol negotiated during the TLS
         * handshake. See g_dtls_connection_get_negotiated_protocol().
         */
        get negotiatedProtocol(): string;
        /**
         * The connection's peer's certificate, after the TLS handshake has
         * completed or failed. Note in particular that this is not yet set
         * during the emission of #GDtlsConnection::accept-certificate.
         *
         * (You can watch for a #GObject::notify signal on this property to
         * detect when a handshake has occurred.)
         */
        get peer_certificate(): TlsCertificate;
        /**
         * The connection's peer's certificate, after the TLS handshake has
         * completed or failed. Note in particular that this is not yet set
         * during the emission of #GDtlsConnection::accept-certificate.
         *
         * (You can watch for a #GObject::notify signal on this property to
         * detect when a handshake has occurred.)
         */
        get peerCertificate(): TlsCertificate;
        /**
         * The errors noticed while verifying
         * #GDtlsConnection:peer-certificate. Normally this should be 0, but
         * it may not be if #GDtlsClientConnection:validation-flags is not
         * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
         * #GDtlsConnection::accept-certificate overrode the default
         * behavior.
         *
         * GLib guarantees that if certificate verification fails, at least
         * one error will be set, but it does not guarantee that all possible
         * errors will be set. Accordingly, you may not safely decide to
         * ignore any particular type of error. For example, it would be
         * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         */
        get peer_certificate_errors(): TlsCertificateFlags;
        /**
         * The errors noticed while verifying
         * #GDtlsConnection:peer-certificate. Normally this should be 0, but
         * it may not be if #GDtlsClientConnection:validation-flags is not
         * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
         * #GDtlsConnection::accept-certificate overrode the default
         * behavior.
         *
         * GLib guarantees that if certificate verification fails, at least
         * one error will be set, but it does not guarantee that all possible
         * errors will be set. Accordingly, you may not safely decide to
         * ignore any particular type of error. For example, it would be
         * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
         * expired certificates, because this could potentially be the only
         * error flag set even if other problems exist with the certificate.
         */
        get peerCertificateErrors(): TlsCertificateFlags;
        /**
         * The DTLS protocol version in use. See g_dtls_connection_get_protocol_version().
         */
        get protocol_version(): TlsProtocolVersion;
        /**
         * The DTLS protocol version in use. See g_dtls_connection_get_protocol_version().
         */
        get protocolVersion(): TlsProtocolVersion;
        /**
         * The rehandshaking mode. See
         * g_dtls_connection_set_rehandshake_mode().
         */
        get rehandshake_mode(): TlsRehandshakeMode;
        set rehandshake_mode(val: TlsRehandshakeMode);
        /**
         * The rehandshaking mode. See
         * g_dtls_connection_set_rehandshake_mode().
         */
        get rehandshakeMode(): TlsRehandshakeMode;
        set rehandshakeMode(val: TlsRehandshakeMode);
        /**
         * Whether or not proper TLS close notification is required.
         * See g_dtls_connection_set_require_close_notify().
         */
        get require_close_notify(): boolean;
        set require_close_notify(val: boolean);
        /**
         * Whether or not proper TLS close notification is required.
         * See g_dtls_connection_set_require_close_notify().
         */
        get requireCloseNotify(): boolean;
        set requireCloseNotify(val: boolean);

        // Methods

        /**
         * Close the DTLS connection. This is equivalent to calling
         * g_dtls_connection_shutdown() to shut down both sides of the connection.
         *
         * Closing a #GDtlsConnection waits for all buffered but untransmitted data to
         * be sent before it completes. It then sends a `close_notify` DTLS alert to the
         * peer and may wait for a `close_notify` to be received from the peer. It does
         * not close the underlying #GDtlsConnection:base-socket; that must be closed
         * separately.
         *
         * Once `conn` is closed, all other operations will return %G_IO_ERROR_CLOSED.
         * Closing a #GDtlsConnection multiple times will not return an error.
         *
         * #GDtlsConnections will be automatically closed when the last reference is
         * dropped, but you might want to call this function to make sure resources are
         * released as early as possible.
         *
         * If `cancellable` is cancelled, the #GDtlsConnection may be left
         * partially-closed and any pending untransmitted data may be lost. Call
         * g_dtls_connection_close() again to complete closing the #GDtlsConnection.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE on success, %FALSE otherwise
         */
        close(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
         * more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the close operation is complete
         */
        close_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous TLS close operation. See g_dtls_connection_close()
         * for more information.
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
         */
        close_finish(result: AsyncResult): boolean;
        /**
         * Used by #GDtlsConnection implementations to emit the
         * #GDtlsConnection::accept-certificate signal.
         * @param peer_cert the peer's #GTlsCertificate
         * @param errors the problems with @peer_cert
         * @returns %TRUE if one of the signal handlers has returned     %TRUE to accept @peer_cert
         */
        emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
        /**
         * Gets `conn'`s certificate, as set by
         * g_dtls_connection_set_certificate().
         * @returns @conn's certificate, or %NULL
         */
        get_certificate(): TlsCertificate | null;
        /**
         * Query the TLS backend for TLS channel binding data of `type` for `conn`.
         *
         * This call retrieves TLS channel binding data as specified in RFC
         * [5056](https://tools.ietf.org/html/rfc5056), RFC
         * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
         * binding data is returned in `data`.  The `data` is resized by the callee
         * using #GByteArray buffer management and will be freed when the `data`
         * is destroyed by g_byte_array_unref(). If `data` is %NULL, it will only
         * check whether TLS backend is able to fetch the data (e.g. whether `type`
         * is supported by the TLS backend). It does not guarantee that the data
         * will be available though.  That could happen if TLS connection does not
         * support `type` or the binding data is not available yet due to additional
         * negotiation or input required.
         * @param type #GTlsChannelBindingType type of data to fetch
         * @returns %TRUE on success, %FALSE otherwise
         */
        get_channel_binding_data(type: TlsChannelBindingType): [boolean, Uint8Array | null];
        /**
         * Returns the name of the current DTLS ciphersuite, or %NULL if the
         * connection has not handshaked or has been closed. Beware that the TLS
         * backend may use any of multiple different naming conventions, because
         * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
         * are different from each other and different from the standard, IANA-
         * registered ciphersuite names. The ciphersuite name is intended to be
         * displayed to the user for informative purposes only, and parsing it
         * is not recommended.
         * @returns The name of the current DTLS ciphersuite, or %NULL
         */
        get_ciphersuite_name(): string | null;
        /**
         * Gets the certificate database that `conn` uses to verify
         * peer certificates. See g_dtls_connection_set_database().
         * @returns the certificate database that @conn uses or %NULL
         */
        get_database(): TlsDatabase | null;
        /**
         * Get the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords. If %NULL is returned, then
         * no user interaction will occur for this connection.
         * @returns The interaction object.
         */
        get_interaction(): TlsInteraction | null;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_dtls_connection_set_advertised_protocols().
         * @returns the negotiated protocol, or %NULL
         */
        get_negotiated_protocol(): string | null;
        /**
         * Gets `conn'`s peer's certificate after the handshake has completed
         * or failed. (It is not set during the emission of
         * #GDtlsConnection::accept-certificate.)
         * @returns @conn's peer's certificate, or %NULL
         */
        get_peer_certificate(): TlsCertificate | null;
        /**
         * Gets the errors associated with validating `conn'`s peer's
         * certificate, after the handshake has completed or failed. (It is
         * not set during the emission of #GDtlsConnection::accept-certificate.)
         * @returns @conn's peer's certificate errors
         */
        get_peer_certificate_errors(): TlsCertificateFlags;
        /**
         * Returns the current DTLS protocol version, which may be
         * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
         * has been closed, or if the TLS backend has implemented a protocol version
         * that is not a recognized #GTlsProtocolVersion.
         * @returns The current DTLS protocol version
         */
        get_protocol_version(): TlsProtocolVersion;
        /**
         * Gets `conn` rehandshaking mode. See
         * g_dtls_connection_set_rehandshake_mode() for details.
         * @returns %G_TLS_REHANDSHAKE_SAFELY
         */
        get_rehandshake_mode(): TlsRehandshakeMode;
        /**
         * Tests whether or not `conn` expects a proper TLS close notification
         * when the connection is closed. See
         * g_dtls_connection_set_require_close_notify() for details.
         * @returns %TRUE if @conn requires a proper TLS close notification.
         */
        get_require_close_notify(): boolean;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting, #GDtlsConnection will handle this for you automatically
         * when you try to send or receive data on the connection. You can call
         * g_dtls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before
         * or after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_dtls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * #GDtlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @param cancellable a #GCancellable, or %NULL
         * @returns success or failure
         */
        handshake(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_dtls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        handshake_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_dtls_connection_handshake() for more information.
         * @param result a #GAsyncResult.
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
         */
        handshake_finish(result: AsyncResult): boolean;
        /**
         * Sets the list of application-layer protocols to advertise that the
         * caller is willing to speak on this connection. The
         * Application-Layer Protocol Negotiation (ALPN) extension will be
         * used to negotiate a compatible protocol with the peer; use
         * g_dtls_connection_get_negotiated_protocol() to find the negotiated
         * protocol after the handshake.  Specifying %NULL for the the value
         * of `protocols` will disable ALPN negotiation.
         *
         * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
         * for a list of registered protocol IDs.
         * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
         */
        set_advertised_protocols(protocols?: string[] | null): void;
        /**
         * This sets the certificate that `conn` will present to its peer
         * during the TLS handshake. For a #GDtlsServerConnection, it is
         * mandatory to set this, and that will normally be done at construct
         * time.
         *
         * For a #GDtlsClientConnection, this is optional. If a handshake fails
         * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
         * requires a certificate, and if you try connecting again, you should
         * call this method first. You can call
         * g_dtls_client_connection_get_accepted_cas() on the failed connection
         * to get a list of Certificate Authorities that the server will
         * accept certificates from.
         *
         * (It is also possible that a server will allow the connection with
         * or without a certificate; in that case, if you don't provide a
         * certificate, you can tell that the server requested one by the fact
         * that g_dtls_client_connection_get_accepted_cas() will return
         * non-%NULL.)
         * @param certificate the certificate to use for @conn
         */
        set_certificate(certificate: TlsCertificate): void;
        /**
         * Sets the certificate database that is used to verify peer certificates.
         * This is set to the default database by default. See
         * g_tls_backend_get_default_database(). If set to %NULL, then
         * peer certificate validation will always set the
         * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
         * #GDtlsConnection::accept-certificate will always be emitted on
         * client-side connections, unless that bit is not set in
         * #GDtlsClientConnection:validation-flags).
         *
         * There are nonintuitive security implications when using a non-default
         * database. See #GDtlsConnection:database for details.
         * @param database a #GTlsDatabase
         */
        set_database(database?: TlsDatabase | null): void;
        /**
         * Set the object that will be used to interact with the user. It will be used
         * for things like prompting the user for passwords.
         *
         * The `interaction` argument will normally be a derived subclass of
         * #GTlsInteraction. %NULL can also be provided if no user interaction
         * should occur for this connection.
         * @param interaction an interaction object, or %NULL
         */
        set_interaction(interaction?: TlsInteraction | null): void;
        /**
         * Since GLib 2.64, changing the rehandshake mode is no longer supported
         * and will have no effect. With TLS 1.3, rehandshaking has been removed from
         * the TLS protocol, replaced by separate post-handshake authentication and
         * rekey operations.
         * @param mode the rehandshaking mode
         */
        set_rehandshake_mode(mode: TlsRehandshakeMode): void;
        /**
         * Sets whether or not `conn` expects a proper TLS close notification
         * before the connection is closed. If this is %TRUE (the default),
         * then `conn` will expect to receive a TLS close notification from its
         * peer before the connection is closed, and will return a
         * %G_TLS_ERROR_EOF error if the connection is closed without proper
         * notification (since this may indicate a network error, or
         * man-in-the-middle attack).
         *
         * In some protocols, the application will know whether or not the
         * connection was closed cleanly based on application-level data
         * (because the application-level data includes a length field, or is
         * somehow self-delimiting); in this case, the close notify is
         * redundant and may be omitted. You
         * can use g_dtls_connection_set_require_close_notify() to tell `conn`
         * to allow an "unannounced" connection close, in which case the close
         * will show up as a 0-length read, as in a non-TLS
         * #GDatagramBased, and it is up to the application to check that
         * the data has been fully received.
         *
         * Note that this only affects the behavior when the peer closes the
         * connection; when the application calls g_dtls_connection_close_async() on
         * `conn` itself, this will send a close notification regardless of the
         * setting of this property. If you explicitly want to do an unclean
         * close, you can close `conn'`s #GDtlsConnection:base-socket rather
         * than closing `conn` itself.
         * @param require_close_notify whether or not to require close notification
         */
        set_require_close_notify(require_close_notify: boolean): void;
        /**
         * Shut down part or all of a DTLS connection.
         *
         * If `shutdown_read` is %TRUE then the receiving side of the connection is shut
         * down, and further reading is disallowed. Subsequent calls to
         * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
         *
         * If `shutdown_write` is %TRUE then the sending side of the connection is shut
         * down, and further writing is disallowed. Subsequent calls to
         * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
         *
         * It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE  this
         * is equivalent to calling g_dtls_connection_close().
         *
         * If `cancellable` is cancelled, the #GDtlsConnection may be left
         * partially-closed and any pending untransmitted data may be lost. Call
         * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE on success, %FALSE otherwise
         */
        shutdown(shutdown_read: boolean, shutdown_write: boolean, cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously shut down part or all of the DTLS connection. See
         * g_dtls_connection_shutdown() for more information.
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the shutdown operation is complete
         */
        shutdown_async(
            shutdown_read: boolean,
            shutdown_write: boolean,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous TLS shutdown operation. See
         * g_dtls_connection_shutdown() for more information.
         * @param result a #GAsyncResult
         * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
         */
        shutdown_finish(result: AsyncResult): boolean;

        // Virtual methods

        /**
         * Check whether to accept a certificate.
         * @param peer_cert
         * @param errors
         */
        vfunc_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
        /**
         * Retrieve TLS channel binding data (Since: 2.66)
         * @param type
         * @param data
         */
        vfunc_get_binding_data(type: TlsChannelBindingType, data: Uint8Array | string): boolean;
        /**
         * Gets the name of the application-layer protocol negotiated during
         * the handshake.
         *
         * If the peer did not use the ALPN extension, or did not advertise a
         * protocol that matched one of `conn'`s protocols, or the TLS backend
         * does not support ALPN, then this will be %NULL. See
         * g_dtls_connection_set_advertised_protocols().
         */
        vfunc_get_negotiated_protocol(): string | null;
        /**
         * Attempts a TLS handshake on `conn`.
         *
         * On the client side, it is never necessary to call this method;
         * although the connection needs to perform a handshake after
         * connecting, #GDtlsConnection will handle this for you automatically
         * when you try to send or receive data on the connection. You can call
         * g_dtls_connection_handshake() manually if you want to know whether
         * the initial handshake succeeded or failed (as opposed to just
         * immediately trying to use `conn` to read or write, in which case,
         * if it fails, it may not be possible to tell if it failed before
         * or after completing the handshake), but beware that servers may reject
         * client authentication after the handshake has completed, so a
         * successful handshake does not indicate the connection will be usable.
         *
         * Likewise, on the server side, although a handshake is necessary at
         * the beginning of the communication, you do not need to call this
         * function explicitly unless you want clearer error reporting.
         *
         * Previously, calling g_dtls_connection_handshake() after the initial
         * handshake would trigger a rehandshake; however, this usage was
         * deprecated in GLib 2.60 because rehandshaking was removed from the
         * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
         * the initial handshake will no longer do anything.
         *
         * #GDtlsConnection::accept_certificate may be emitted during the
         * handshake.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_handshake(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously performs a TLS handshake on `conn`. See
         * g_dtls_connection_handshake() for more information.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the handshake is complete
         */
        vfunc_handshake_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous TLS handshake operation. See
         * g_dtls_connection_handshake() for more information.
         * @param result a #GAsyncResult.
         */
        vfunc_handshake_finish(result: AsyncResult): boolean;
        /**
         * Sets the list of application-layer protocols to advertise that the
         * caller is willing to speak on this connection. The
         * Application-Layer Protocol Negotiation (ALPN) extension will be
         * used to negotiate a compatible protocol with the peer; use
         * g_dtls_connection_get_negotiated_protocol() to find the negotiated
         * protocol after the handshake.  Specifying %NULL for the the value
         * of `protocols` will disable ALPN negotiation.
         *
         * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
         * for a list of registered protocol IDs.
         * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
         */
        vfunc_set_advertised_protocols(protocols?: string[] | null): void;
        /**
         * Shut down part or all of a DTLS connection.
         *
         * If `shutdown_read` is %TRUE then the receiving side of the connection is shut
         * down, and further reading is disallowed. Subsequent calls to
         * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
         *
         * If `shutdown_write` is %TRUE then the sending side of the connection is shut
         * down, and further writing is disallowed. Subsequent calls to
         * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
         *
         * It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE  this
         * is equivalent to calling g_dtls_connection_close().
         *
         * If `cancellable` is cancelled, the #GDtlsConnection may be left
         * partially-closed and any pending untransmitted data may be lost. Call
         * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_shutdown(shutdown_read: boolean, shutdown_write: boolean, cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously shut down part or all of the DTLS connection. See
         * g_dtls_connection_shutdown() for more information.
         * @param shutdown_read %TRUE to stop reception of incoming datagrams
         * @param shutdown_write %TRUE to stop sending outgoing datagrams
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call when the shutdown operation is complete
         */
        vfunc_shutdown_async(
            shutdown_read: boolean,
            shutdown_write: boolean,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finish an asynchronous TLS shutdown operation. See
         * g_dtls_connection_shutdown() for more information.
         * @param result a #GAsyncResult
         */
        vfunc_shutdown_finish(result: AsyncResult): boolean;
    }

    export const DtlsConnection: DtlsConnectionNamespace;

    module DtlsServerConnection {
        // Constructor properties interface

        interface ConstructorProps extends DatagramBased.ConstructorProps {
            authentication_mode: TlsAuthenticationMode;
            authenticationMode: TlsAuthenticationMode;
        }
    }

    export interface DtlsServerConnectionNamespace {
        $gtype: GObject.GType<DtlsServerConnection>;
        prototype: DtlsServerConnection;

        /**
         * Creates a new #GDtlsServerConnection wrapping `base_socket`.
         * @param base_socket the #GDatagramBased to wrap
         * @param certificate the default server certificate, or %NULL
         */
        ['new'](base_socket: DatagramBased, certificate?: TlsCertificate | null): DtlsServerConnection;
    }
    interface DtlsServerConnection extends DatagramBased {
        // Properties

        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_dtls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        get authentication_mode(): TlsAuthenticationMode;
        set authentication_mode(val: TlsAuthenticationMode);
        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_dtls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        get authenticationMode(): TlsAuthenticationMode;
        set authenticationMode(val: TlsAuthenticationMode);
    }

    export const DtlsServerConnection: DtlsServerConnectionNamespace;

    module File {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface FileNamespace {
        $gtype: GObject.GType<File>;
        prototype: File;

        /**
         * Constructs a #GFile from a vector of elements using the correct
         * separator for filenames.
         *
         * Using this function is equivalent to calling g_build_filenamev(),
         * followed by g_file_new_for_path() on the result.
         * @param args %NULL-terminated   array of strings containing the path elements.
         */
        new_build_filenamev(args: string[]): File;
        /**
         * Creates a #GFile with the given argument from the command line.
         * The value of `arg` can be either a URI, an absolute path or a
         * relative path resolved relative to the current working directory.
         * This operation never fails, but the returned object might not
         * support any I/O operation if `arg` points to a malformed path.
         *
         * Note that on Windows, this function expects its argument to be in
         * UTF-8 -- not the system code page.  This means that you
         * should not use this function with string from argv as it is passed
         * to main().  g_win32_get_command_line() will return a UTF-8 version of
         * the commandline.  #GApplication also uses UTF-8 but
         * g_application_command_line_create_file_for_arg() may be more useful
         * for you there.  It is also always possible to use this function with
         * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
         * @param arg a command line string
         */
        new_for_commandline_arg(arg: string): File;
        /**
         * Creates a #GFile with the given argument from the command line.
         *
         * This function is similar to g_file_new_for_commandline_arg() except
         * that it allows for passing the current working directory as an
         * argument instead of using the current working directory of the
         * process.
         *
         * This is useful if the commandline argument was given in a context
         * other than the invocation of the current process.
         *
         * See also g_application_command_line_create_file_for_arg().
         * @param arg a command line string
         * @param cwd the current working directory of the commandline
         */
        new_for_commandline_arg_and_cwd(arg: string, cwd: string): File;
        /**
         * Constructs a #GFile for a given path. This operation never
         * fails, but the returned object might not support any I/O
         * operation if `path` is malformed.
         * @param path a string containing a relative or absolute path.   The string must be encoded in the glib filename encoding.
         */
        new_for_path(path: string): File;
        /**
         * Constructs a #GFile for a given URI. This operation never
         * fails, but the returned object might not support any I/O
         * operation if `uri` is malformed or if the uri type is
         * not supported.
         * @param uri a UTF-8 string containing a URI
         */
        new_for_uri(uri: string): File;
        /**
         * Opens a file in the preferred directory for temporary files (as
         * returned by g_get_tmp_dir()) and returns a #GFile and
         * #GFileIOStream pointing to it.
         *
         * `tmpl` should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         *
         * Unlike the other #GFile constructors, this will return %NULL if
         * a temporary file could not be created.
         * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
         */
        new_tmp(tmpl: string | null): [File, FileIOStream];
        /**
         * Asynchronously opens a file in the preferred directory for temporary files
         *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
         *
         * `tmpl` should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        new_tmp_async(
            tmpl: string | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<File> | null,
        ): void;
        /**
         * Asynchronously creates a directory in the preferred directory for
         * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
         *
         * `tmpl` should be a string in the GLib file name encoding
         * containing a sequence of six 'X' characters, and containing no
         * directory components. If it is %NULL, a default template is used.
         * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        new_tmp_dir_async(
            tmpl: string | null,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<File> | null,
        ): void;
        /**
         * Finishes a temporary directory creation started by
         * g_file_new_tmp_dir_async().
         * @param result a #GAsyncResult
         */
        new_tmp_dir_finish(result: AsyncResult): File;
        /**
         * Finishes a temporary file creation started by g_file_new_tmp_async().
         * @param result a #GAsyncResult
         */
        new_tmp_finish(result: AsyncResult): [File, FileIOStream];
        /**
         * Constructs a #GFile with the given `parse_name` (i.e. something
         * given by g_file_get_parse_name()). This operation never fails,
         * but the returned object might not support any I/O operation if
         * the `parse_name` cannot be parsed.
         * @param parse_name a file name or path to be parsed
         */
        parse_name(parse_name: string): File;
    }
    interface File extends GObject.Object {
        // Methods

        /**
         * Gets an output stream for appending data to the file.
         * If the file doesn't already exist it is created.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * Some file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
         * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        append_to(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
        /**
         * Asynchronously opens `file` for appending.
         *
         * For more details, see g_file_append_to() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_append_to_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        append_to_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file append operation started with
         * g_file_append_to_async().
         * @param res #GAsyncResult
         * @returns a valid #GFileOutputStream   or %NULL on error.   Free the returned object with g_object_unref().
         */
        append_to_finish(res: AsyncResult): FileOutputStream;
        /**
         * Prepares the file attribute query string for copying to `file`.
         *
         * This function prepares an attribute query string to be
         * passed to g_file_query_info() to get a list of attributes
         * normally copied with the file (see g_file_copy_attributes()
         * for the detailed description). This function is used by the
         * implementation of g_file_copy_attributes() and is useful
         * when one needs to query and set the attributes in two
         * stages (e.g., for recursive move of a directory).
         * @param flags a set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns an attribute query string for g_file_query_info(),   or %NULL if an error occurs.
         */
        build_attribute_list_for_copy(flags: FileCopyFlags, cancellable?: Cancellable | null): string;
        /**
         * Copies the file `source` to the location specified by `destination`.
         * Can not handle recursive copies of directories.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
         * will be copied as symlinks, otherwise the target of the
         * `source` symlink will be copied.
         *
         * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
         * that is possible to copy is copied, not just the default subset (which,
         * for instance, does not include the owner, see #GFileInfo).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is guaranteed
         * that this callback will be called after all data has been transferred with
         * the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND error
         * is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
         * the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
         * %G_IO_ERROR_WOULD_RECURSE error is returned.
         *
         * If you are interested in copying the #GFile object itself (not the on-disk
         * file), see g_file_dup().
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback function to callback with   progress information, or %NULL if progress information is not needed
         * @returns %TRUE on success, %FALSE otherwise.
         */
        copy(
            destination: File,
            flags: FileCopyFlags,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
        ): boolean;
        /**
         * Copies the file `source` to the location specified by `destination`
         * asynchronously. For details of the behaviour, see g_file_copy().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_copy(). The callback will run in the default main context
         * of the thread calling g_file_copy_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_copy_finish() to get the result of the operation.
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback function to callback with progress information, or %NULL if   progress information is not needed
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        copy_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Copies the file attributes from `source` to `destination`.
         *
         * Normally only a subset of the file attributes are copied,
         * those that are copies in a normal file copy operation
         * (which for instance does not include e.g. owner). However
         * if %G_FILE_COPY_ALL_METADATA is specified in `flags,` then
         * all the metadata that is possible to copy is copied. This
         * is useful when implementing move by copy + delete source.
         * @param destination a #GFile to copy attributes to
         * @param flags a set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the attributes were copied successfully,   %FALSE otherwise.
         */
        copy_attributes(destination: File, flags: FileCopyFlags, cancellable?: Cancellable | null): boolean;
        /**
         * Finishes copying the file started with g_file_copy_async().
         * @param res a #GAsyncResult
         * @returns a %TRUE on success, %FALSE on error.
         */
        copy_finish(res: AsyncResult): boolean;
        /**
         * Creates a new file and returns an output stream for writing to it.
         * The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
         * be returned. Other errors are possible too, and depend on what kind
         * of filesystem the file is on.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
         */
        create(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
        /**
         * Asynchronously creates a new file and returns an output stream
         * for writing to it. The file must not already exist.
         *
         * For more details, see g_file_create() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        create_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_async().
         * @param res a #GAsyncResult
         * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_finish(res: AsyncResult): FileOutputStream;
        /**
         * Creates a new file and returns a stream for reading and
         * writing to it. The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists, the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
         * will be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         *
         * Note that in many non-local file cases read and write streams are
         * not supported, so make sure you really need to do read and write
         * streaming, rather than just opening for reading or writing.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileIOStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_readwrite(flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;
        /**
         * Asynchronously creates a new file and returns a stream
         * for reading and writing to it. The file must not already exist.
         *
         * For more details, see g_file_create_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_readwrite_finish() to get
         * the result of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        create_readwrite_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_readwrite_async().
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        create_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Deletes a file. If the `file` is a directory, it will only be
         * deleted if it is empty. This has the same semantics as g_unlink().
         *
         * If `file` doesnt exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
         * for deletion to be implemented avoiding
         * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
         *
         * ```
         * g_autoptr(GError) local_error = NULL;
         * if (!g_file_delete (my_file, my_cancellable, &local_error) &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
         *   {
         *     // deletion failed for some reason other than the file not existing:
         *     // so report the error
         *     g_warning ("Failed to delete %s: %s",
         *                g_file_peek_path (my_file), local_error->message);
         *   }
         * ```
         *
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the file was deleted. %FALSE otherwise.
         */
        ['delete'](cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously delete a file. If the `file` is a directory, it will
         * only be deleted if it is empty.  This has the same semantics as
         * g_unlink().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        delete_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes deleting a file started with g_file_delete_async().
         * @param result a #GAsyncResult
         * @returns %TRUE if the file was deleted. %FALSE otherwise.
         */
        delete_finish(result: AsyncResult): boolean;
        /**
         * Duplicates a #GFile handle. This operation does not duplicate
         * the actual file or directory represented by the #GFile; see
         * g_file_copy() if attempting to copy a file.
         *
         * g_file_dup() is useful when a second handle is needed to the same underlying
         * file, for use in a separate thread (#GFile is not thread-safe). For use
         * within the same thread, use g_object_ref() to increment the existing objects
         * reference count.
         *
         * This call does no blocking I/O.
         * @returns a new #GFile that is a duplicate   of the given #GFile.
         */
        dup(): File;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        eject_mountable(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
         */
        eject_mountable_finish(result: AsyncResult): boolean;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_with_operation_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        eject_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable_with_operation().
         * @param result a #GAsyncResult
         * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
         */
        eject_mountable_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the requested information about the files in a directory.
         * The result is a #GFileEnumerator object that will give out
         * #GFileInfo objects for all the files in the directory.
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should
         * be a comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
         * always be specified if you plan to call g_file_enumerator_get_child() or
         * g_file_enumerator_iterate() on the returned enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
         * error will be returned. Other errors are possible too.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns A #GFileEnumerator if successful,   %NULL on error. Free the returned object with g_object_unref().
         */
        enumerate_children(
            attributes: string,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): FileEnumerator;
        /**
         * Asynchronously gets the requested information about the files
         * in a directory. The result is a #GFileEnumerator object that will
         * give out #GFileInfo objects for all the files in the directory.
         *
         * For more details, see g_file_enumerate_children() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_enumerate_children_finish() to get the result of
         * the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        enumerate_children_async(
            attributes: string,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async enumerate children operation.
         * See g_file_enumerate_children_async().
         * @param res a #GAsyncResult
         * @returns a #GFileEnumerator or %NULL   if an error occurred.   Free the returned object with g_object_unref().
         */
        enumerate_children_finish(res: AsyncResult): FileEnumerator;
        /**
         * Checks if the two given #GFiles refer to the same file.
         *
         * Note that two #GFiles that differ can still refer to the same
         * file on the filesystem due to various forms of filename
         * aliasing.
         *
         * This call does no blocking I/O.
         * @param file2 the second #GFile
         * @returns %TRUE if @file1 and @file2 are equal.
         */
        equal(file2: File): boolean;
        /**
         * Gets a #GMount for the #GFile.
         *
         * #GMount is returned only for user interesting locations, see
         * #GVolumeMonitor. If the #GFileIface for `file` does not have a #mount,
         * `error` will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GMount where the @file is located   or %NULL on error.   Free the returned object with g_object_unref().
         */
        find_enclosing_mount(cancellable?: Cancellable | null): Mount;
        /**
         * Asynchronously gets the mount for the file.
         *
         * For more details, see g_file_find_enclosing_mount() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_find_enclosing_mount_finish() to
         * get the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        find_enclosing_mount_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous find mount request.
         * See g_file_find_enclosing_mount_async().
         * @param res a #GAsyncResult
         * @returns #GMount for given @file or %NULL on error.   Free the returned object with g_object_unref().
         */
        find_enclosing_mount_finish(res: AsyncResult): Mount;
        /**
         * Gets the base name (the last component of the path) for a given #GFile.
         *
         * If called for the top level of a system (such as the filesystem root
         * or a uri like sftp://host/) it will return a single directory separator
         * (and on Windows, possibly a drive letter).
         *
         * The base name is a byte string (not UTF-8). It has no defined encoding
         * or rules other than it may not contain zero bytes.  If you want to use
         * filenames in a user interface you should use the display name that you
         * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
         * attribute with g_file_query_info().
         *
         * This call does no blocking I/O.
         * @returns string containing the #GFile's   base name, or %NULL if given #GFile is invalid. The returned string   should be freed with g_free() when no longer needed.
         */
        get_basename(): string | null;
        /**
         * Gets a child of `file` with basename equal to `name`.
         *
         * Note that the file with that specific name might not exist, but
         * you can still have a #GFile that points to it. You can use this
         * for instance to create that file.
         *
         * This call does no blocking I/O.
         * @param name string containing the child's basename
         * @returns a #GFile to a child specified by @name.   Free the returned object with g_object_unref().
         */
        get_child(name: string): File;
        /**
         * Gets the child of `file` for a given `display_name` (i.e. a UTF-8
         * version of the name). If this function fails, it returns %NULL
         * and `error` will be set. This is very useful when constructing a
         * #GFile for a new file and the user entered the filename in the
         * user interface, for instance when you select a directory and
         * type a filename in the file selector.
         *
         * This call does no blocking I/O.
         * @param display_name string to a possible child
         * @returns a #GFile to the specified child, or   %NULL if the display name couldn't be converted.   Free the returned object with g_object_unref().
         */
        get_child_for_display_name(display_name: string): File;
        /**
         * Gets the parent directory for the `file`.
         * If the `file` represents the root directory of the
         * file system, then %NULL will be returned.
         *
         * This call does no blocking I/O.
         * @returns a #GFile structure to the   parent of the given #GFile or %NULL if there is no parent. Free   the returned object with g_object_unref().
         */
        get_parent(): File | null;
        /**
         * Gets the parse name of the `file`.
         * A parse name is a UTF-8 string that describes the
         * file such that one can get the #GFile back using
         * g_file_parse_name().
         *
         * This is generally used to show the #GFile as a nice
         * full-pathname kind of string in a user interface,
         * like in a location entry.
         *
         * For local files with names that can safely be converted
         * to UTF-8 the pathname is used, otherwise the IRI is used
         * (a form of URI that allows UTF-8 characters unescaped).
         *
         * This call does no blocking I/O.
         * @returns a string containing the #GFile's parse name.   The returned string should be freed with g_free()   when no longer needed.
         */
        get_parse_name(): string;
        /**
         * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
         * guaranteed to be an absolute, canonical path. It might contain symlinks.
         *
         * This call does no blocking I/O.
         * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string should be freed   with g_free() when no longer needed.
         */
        get_path(): string | null;
        /**
         * Gets the path for `descendant` relative to `parent`.
         *
         * This call does no blocking I/O.
         * @param descendant input #GFile
         * @returns string with the relative path from   @descendant to @parent, or %NULL if @descendant doesn't have @parent as   prefix. The returned string should be freed with g_free() when   no longer needed.
         */
        get_relative_path(descendant: File): string | null;
        /**
         * Gets the URI for the `file`.
         *
         * This call does no blocking I/O.
         * @returns a string containing the #GFile's URI. If the #GFile was constructed   with an invalid URI, an invalid URI is returned.   The returned string should be freed with g_free()   when no longer needed.
         */
        get_uri(): string;
        /**
         * Gets the URI scheme for a #GFile.
         * RFC 3986 decodes the scheme as:
         *
         * ```
         * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
         * ```
         *
         * Common schemes include "file", "http", "ftp", etc.
         *
         * The scheme can be different from the one used to construct the #GFile,
         * in that it might be replaced with one that is logically equivalent to the #GFile.
         *
         * This call does no blocking I/O.
         * @returns a string containing the URI scheme for the given   #GFile or %NULL if the #GFile was constructed with an invalid URI. The   returned string should be freed with g_free() when no longer needed.
         */
        get_uri_scheme(): string | null;
        /**
         * Checks if `file` has a parent, and optionally, if it is `parent`.
         *
         * If `parent` is %NULL then this function returns %TRUE if `file` has any
         * parent at all.  If `parent` is non-%NULL then %TRUE is only returned
         * if `file` is an immediate child of `parent`.
         * @param parent the parent to check for, or %NULL
         * @returns %TRUE if @file is an immediate child of @parent (or any parent in   the case that @parent is %NULL).
         */
        has_parent(parent?: File | null): boolean;
        /**
         * Checks whether `file` has the prefix specified by `prefix`.
         *
         * In other words, if the names of initial elements of `file'`s
         * pathname match `prefix`. Only full pathname elements are matched,
         * so a path like /foo is not considered a prefix of /foobar, only
         * of /foo/bar.
         *
         * A #GFile is not a prefix of itself. If you want to check for
         * equality, use g_file_equal().
         *
         * This call does no I/O, as it works purely on names. As such it can
         * sometimes return %FALSE even if `file` is inside a `prefix` (from a
         * filesystem point of view), because the prefix of `file` is an alias
         * of `prefix`.
         * @param prefix input #GFile
         * @returns %TRUE if the @file's parent, grandparent, etc is @prefix,   %FALSE otherwise.
         */
        has_prefix(prefix: File): boolean;
        /**
         * Checks to see if a #GFile has a given URI scheme.
         *
         * This call does no blocking I/O.
         * @param uri_scheme a string containing a URI scheme
         * @returns %TRUE if #GFile's backend supports the   given URI scheme, %FALSE if URI scheme is %NULL,   not supported, or #GFile is invalid.
         */
        has_uri_scheme(uri_scheme: string): boolean;
        /**
         * Creates a hash value for a #GFile.
         *
         * This call does no blocking I/O.
         * @returns 0 if @file is not a valid #GFile, otherwise an   integer that can be used as hash value for the #GFile.   This function is intended for easily hashing a #GFile to   add to a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Checks to see if a file is native to the platform.
         *
         * A native file is one expressed in the platform-native filename format,
         * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
         * as it might be on a locally mounted remote filesystem.
         *
         * On some systems non-native files may be available using the native
         * filesystem via a userspace filesystem (FUSE), in these cases this call
         * will return %FALSE, but g_file_get_path() will still return a native path.
         *
         * This call does no blocking I/O.
         * @returns %TRUE if @file is native
         */
        is_native(): boolean;
        /**
         * Loads the contents of `file` and returns it as #GBytes.
         *
         * If `file` is a resource:// based URI, the resulting bytes will reference the
         * embedded resource instead of a copy. Otherwise, this is equivalent to calling
         * g_file_load_contents() and g_bytes_new_take().
         *
         * For resources, `etag_out` will be set to %NULL.
         *
         * The data contained in the resulting #GBytes is always zero-terminated, but
         * this is not included in the #GBytes length. The resulting #GBytes should be
         * freed with g_bytes_unref() when no longer in use.
         * @param cancellable a #GCancellable or %NULL
         * @returns a #GBytes or %NULL and @error is set
         */
        load_bytes(cancellable: Cancellable | null): [GLib.Bytes, string];
        /**
         * Asynchronously loads the contents of `file` as #GBytes.
         *
         * If `file` is a resource:// based URI, the resulting bytes will reference the
         * embedded resource instead of a copy. Otherwise, this is equivalent to calling
         * g_file_load_contents_async() and g_bytes_new_take().
         *
         * `callback` should call g_file_load_bytes_finish() to get the result of this
         * asynchronous operation.
         *
         * See g_file_load_bytes() for more information.
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        load_bytes_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Completes an asynchronous request to g_file_load_bytes_async().
         *
         * For resources, `etag_out` will be set to %NULL.
         *
         * The data contained in the resulting #GBytes is always zero-terminated, but
         * this is not included in the #GBytes length. The resulting #GBytes should be
         * freed with g_bytes_unref() when no longer in use.
         *
         * See g_file_load_bytes() for more information.
         * @param result a #GAsyncResult provided to the callback
         * @returns a #GBytes or %NULL and @error is set
         */
        load_bytes_finish(result: AsyncResult): [GLib.Bytes, string];
        /**
         * Loads the content of the file into memory. The data is always
         * zero-terminated, but this is not included in the resultant `length`.
         * The returned `contents` should be freed with g_free() when no longer
         * needed.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns %TRUE if the @file's contents were successfully loaded.   %FALSE if there were errors.
         */
        load_contents(cancellable: Cancellable | null): [boolean, Uint8Array, string];
        /**
         * Starts an asynchronous load of the `file'`s contents.
         *
         * For more details, see g_file_load_contents() which is
         * the synchronous version of this call.
         *
         * When the load operation has completed, `callback` will be called
         * with `user` data. To finish the operation, call
         * g_file_load_contents_finish() with the #GAsyncResult returned by
         * the `callback`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        load_contents_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an asynchronous load of the `file'`s contents.
         * The contents are placed in `contents,` and `length` is set to the
         * size of the `contents` string. The `contents` should be freed with
         * g_free() when no longer needed. If `etag_out` is present, it will be
         * set to the new entity tag for the `file`.
         * @param res a #GAsyncResult
         * @returns %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
         */
        load_contents_finish(res: AsyncResult): [boolean, Uint8Array, string];
        /**
         * Finishes an asynchronous partial load operation that was started
         * with g_file_load_partial_contents_async(). The data is always
         * zero-terminated, but this is not included in the resultant `length`.
         * The returned `contents` should be freed with g_free() when no longer
         * needed.
         * @param res a #GAsyncResult
         * @returns %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
         */
        load_partial_contents_finish(res: AsyncResult): [boolean, Uint8Array, string];
        /**
         * Creates a directory. Note that this will only create a child directory
         * of the immediate parent directory of the path or URI given by the #GFile.
         * To recursively create directories, see g_file_make_directory_with_parents().
         * This function will fail if the parent directory does not exist, setting
         * `error` to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
         * creating directories, this function will fail, setting `error` to
         * %G_IO_ERROR_NOT_SUPPORTED.
         *
         * For a local #GFile the newly created directory will have the default
         * (current) ownership and permissions of the current process.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on successful creation, %FALSE otherwise.
         */
        make_directory(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously creates a directory.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        make_directory_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous directory creation, started with
         * g_file_make_directory_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful directory creation, %FALSE otherwise.
         */
        make_directory_finish(result: AsyncResult): boolean;
        /**
         * Creates a directory and any parent directories that may not
         * exist similar to 'mkdir -p'. If the file system does not support
         * creating directories, this function will fail, setting `error` to
         * %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
         * this function will fail setting `error` to %G_IO_ERROR_EXISTS, unlike
         * the similar g_mkdir_with_parents().
         *
         * For a local #GFile the newly created directories will have the default
         * (current) ownership and permissions of the current process.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if all directories have been successfully created, %FALSE otherwise.
         */
        make_directory_with_parents(cancellable?: Cancellable | null): boolean;
        /**
         * Creates a symbolic link named `file` which contains the string
         * `symlink_value`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on the creation of a new symlink, %FALSE otherwise.
         */
        make_symbolic_link(symlink_value: string, cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously creates a symbolic link named `file` which contains the
         * string `symlink_value`.
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        make_symbolic_link_async(
            symlink_value: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous symbolic link creation, started with
         * g_file_make_symbolic_link_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful directory creation, %FALSE otherwise.
         */
        make_symbolic_link_finish(result: AsyncResult): boolean;
        /**
         * Recursively measures the disk usage of `file`.
         *
         * This is essentially an analog of the 'du' command, but it also
         * reports the number of directories and non-directory files encountered
         * (including things like symbolic links).
         *
         * By default, errors are only reported against the toplevel file
         * itself.  Errors found while recursing are silently ignored, unless
         * %G_FILE_MEASURE_REPORT_ANY_ERROR is given in `flags`.
         *
         * The returned size, `disk_usage,` is in bytes and should be formatted
         * with g_format_size() in order to get something reasonable for showing
         * in a user interface.
         *
         * `progress_callback` and `progress_data` can be given to request
         * periodic progress updates while scanning.  See the documentation for
         * #GFileMeasureProgressCallback for information about when and how the
         * callback will be invoked.
         * @param flags #GFileMeasureFlags
         * @param cancellable optional #GCancellable
         * @param progress_callback a #GFileMeasureProgressCallback
         * @returns %TRUE if successful, with the out parameters set.   %FALSE otherwise, with @error set.
         */
        measure_disk_usage(
            flags: FileMeasureFlags,
            cancellable: Cancellable | null,
            progress_callback: FileMeasureProgressCallback | null,
        ): [boolean, number, number, number];
        /**
         * Collects the results from an earlier call to
         * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
         * more information.
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         * @returns %TRUE if successful, with the out parameters set.   %FALSE otherwise, with @error set.
         */
        measure_disk_usage_finish(result: AsyncResult): [boolean, number, number, number];
        /**
         * Obtains a file or directory monitor for the given file,
         * depending on the type of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
         */
        monitor(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
        /**
         * Obtains a directory monitor for the given file.
         * This may fail if directory monitoring is not supported.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * It does not make sense for `flags` to contain
         * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
         * directories.  It is not possible to monitor all the files in a
         * directory for changes made via hard links; if you want to do this then
         * you must register individual watches with g_file_monitor().
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error. Free the returned object with g_object_unref().
         */
        monitor_directory(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
        /**
         * Obtains a file monitor for the given file. If no file notification
         * mechanism exists, then regular polling of the file is used.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `flags` contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
         * will also attempt to report changes made to the file via another
         * filename (ie, a hard link). Without this flag, you can only rely on
         * changes made through the filename contained in `file` to be
         * reported. Using this flag may result in an increase in resource
         * usage, and may not have any effect depending on the #GFileMonitor
         * backend and/or filesystem type.
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
         */
        monitor_file(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
        /**
         * Starts a `mount_operation,` mounting the volume that contains
         * the file `location`.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_mount_enclosing_volume_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        mount_enclosing_volume(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a mount operation started by g_file_mount_enclosing_volume().
         * @param result a #GAsyncResult
         * @returns %TRUE if successful. If an error has occurred,   this function will return %FALSE and set @error   appropriately if present.
         */
        mount_enclosing_volume_finish(result: AsyncResult): boolean;
        /**
         * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
         * Using `mount_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        mount_mountable(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a mount operation. See g_file_mount_mountable() for details.
         *
         * Finish an asynchronous mount operation that was started
         * with g_file_mount_mountable().
         * @param result a #GAsyncResult
         * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
         */
        mount_mountable_finish(result: AsyncResult): File;
        /**
         * Tries to move the file or directory `source` to the location specified
         * by `destination`. If native move operations are supported then this is
         * used, otherwise a copy + delete fallback is used. The native
         * implementation may support moving directories (for instance on moves
         * inside the same filesystem), but the fallback code does not.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is
         * guaranteed that this callback will be called after all data has been
         * transferred with the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND
         * error is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
         * then the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
         * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
         * move operation isn't available).
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback #GFileProgressCallback   function for updates
         * @returns %TRUE on successful move, %FALSE otherwise.
         */
        move(
            destination: File,
            flags: FileCopyFlags,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
        ): boolean;
        /**
         * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_move(). The callback will run in the default main context
         * of the thread calling g_file_move_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_move_finish() to get the result of the operation.
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback #GFileProgressCallback function for updates
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        move_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file movement, started with
         * g_file_move_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful file move, %FALSE otherwise.
         */
        move_finish(result: AsyncResult): boolean;
        /**
         * Opens an existing file for reading and writing. The result is
         * a #GFileIOStream that can be used to read and write the contents
         * of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend on
         * what kind of filesystem the file is on. Note that in many non-local
         * file cases read and write streams are not supported, so make sure you
         * really need to do read and write streaming, rather than just opening
         * for reading or writing.
         * @param cancellable a #GCancellable
         * @returns #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        open_readwrite(cancellable?: Cancellable | null): FileIOStream;
        /**
         * Asynchronously opens `file` for reading and writing.
         *
         * For more details, see g_file_open_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_open_readwrite_finish() to get
         * the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        open_readwrite_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_open_readwrite_async().
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        open_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Exactly like g_file_get_path(), but caches the result via
         * g_object_set_qdata_full().  This is useful for example in C
         * applications which mix `g_file_*` APIs with native ones.  It
         * also avoids an extra duplicated string when possible, so will be
         * generally more efficient.
         *
         * This call does no blocking I/O.
         * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string is owned by @file.
         */
        peek_path(): string | null;
        /**
         * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        poll_mountable(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes a poll operation. See g_file_poll_mountable() for details.
         *
         * Finish an asynchronous poll operation that was polled
         * with g_file_poll_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
         */
        poll_mountable_finish(result: AsyncResult): boolean;
        /**
         * Returns the #GAppInfo that is registered as the default
         * application to handle the file specified by `file`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
         */
        query_default_handler(cancellable?: Cancellable | null): AppInfo;
        /**
         * Async version of g_file_query_default_handler().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is done
         */
        query_default_handler_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a g_file_query_default_handler_async() operation.
         * @param result a #GAsyncResult
         * @returns a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
         */
        query_default_handler_finish(result: AsyncResult): AppInfo;
        /**
         * Utility function to check if a particular file exists. This is
         * implemented using g_file_query_info() and as such does blocking I/O.
         *
         * Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
         * and then execute something based on the outcome of that, because the
         * file might have been created or removed in between the operations. The
         * general approach to handling that is to not check, but just do the
         * operation and handle the errors as they come.
         *
         * As an example of race-free checking, take the case of reading a file,
         * and if it doesn't exist, creating it. There are two racy versions: read
         * it, and on error create it; and: check if it exists, if not create it.
         * These can both result in two processes creating the file (with perhaps
         * a partially written file as the result). The correct approach is to
         * always try to create the file with g_file_create() which will either
         * atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
         *
         * However, in many cases an existence check is useful in a user interface,
         * for instance to make a menu item sensitive/insensitive, so that you don't
         * have to fool users that something is possible and then just show an error
         * dialog. If you do this, you should make sure to also handle the errors
         * that can happen due to races when you execute the operation.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the file exists (and can be detected without error),   %FALSE otherwise (or if cancelled).
         */
        query_exists(cancellable?: Cancellable | null): boolean;
        /**
         * Utility function to inspect the #GFileType of a file. This is
         * implemented using g_file_query_info() and as such does blocking I/O.
         *
         * The primary use case of this method is to check if a file is
         * a regular file, directory, or symlink.
         * @param flags a set of #GFileQueryInfoFlags passed to g_file_query_info()
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns The #GFileType of the file and %G_FILE_TYPE_UNKNOWN   if the file does not exist
         */
        query_file_type(flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileType;
        /**
         * Similar to g_file_query_info(), but obtains information
         * about the filesystem the `file` is on, rather than the file itself.
         * For instance the amount of space available and the type of
         * the filesystem.
         *
         * The `attributes` value is a string that specifies the attributes
         * that should be gathered. It is not an error if it's not possible
         * to read a particular requested attribute from a file - it just
         * won't be set. `attributes` should be a comma-separated list of
         * attributes or attribute wildcards. The wildcard "*" means all
         * attributes, and a wildcard like "filesystem::*" means all attributes
         * in the filesystem namespace. The standard namespace for filesystem
         * attributes is "filesystem". Common attributes of interest are
         * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
         * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
         * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         * @param attributes an attribute query string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileInfo or %NULL if there was an error.   Free the returned object with g_object_unref().
         */
        query_filesystem_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously gets the requested information about the filesystem
         * that the specified `file` is on. The result is a #GFileInfo object
         * that contains key-value attributes (such as type or size for the
         * file).
         *
         * For more details, see g_file_query_filesystem_info() which is the
         * synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the
         * operation.
         * @param attributes an attribute query string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_filesystem_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous filesystem info query.
         * See g_file_query_filesystem_info_async().
         * @param res a #GAsyncResult
         * @returns #GFileInfo for given @file   or %NULL on error.   Free the returned object with g_object_unref().
         */
        query_filesystem_info_finish(res: AsyncResult): FileInfo;
        /**
         * Gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value
         * attributes (such as the type or size of the file).
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should be a
         * comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * For symlinks, normally the information about the target of the
         * symlink is returned, rather than information about the symlink
         * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
         * in `flags` the information about the symlink itself will be returned.
         * Also, for symlinks that point to non-existing files the information
         * about the symlink itself will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. Other errors are possible too, and depend on what kind of
         * filesystem the file is on.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileInfo for the given @file, or %NULL   on error. Free the returned object with g_object_unref().
         */
        query_info(attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value attributes
         * (such as type or size for the file).
         *
         * For more details, see g_file_query_info() which is the synchronous
         * version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        query_info_async(
            attributes: string,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file info query.
         * See g_file_query_info_async().
         * @param res a #GAsyncResult
         * @returns #GFileInfo for given @file   or %NULL on error. Free the returned object with   g_object_unref().
         */
        query_info_finish(res: AsyncResult): FileInfo;
        /**
         * Obtain the list of settable attributes for the file.
         *
         * Returns the type and full attribute name of all the attributes
         * that can be set on this file. This doesn't mean setting it will
         * always succeed though, you might get an access failure, or some
         * specific file may not support a specific attribute.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileAttributeInfoList describing the settable attributes.   When you are done with it, release it with   g_file_attribute_info_list_unref()
         */
        query_settable_attributes(cancellable?: Cancellable | null): FileAttributeInfoList;
        /**
         * Obtain the list of attribute namespaces where new attributes
         * can be created by a user. An example of this is extended
         * attributes (in the "xattr" namespace).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileAttributeInfoList describing the writable namespaces.   When you are done with it, release it with   g_file_attribute_info_list_unref()
         */
        query_writable_namespaces(cancellable?: Cancellable | null): FileAttributeInfoList;
        /**
         * Opens a file for reading. The result is a #GFileInputStream that
         * can be used to read the contents of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend
         * on what kind of filesystem the file is on.
         * @param cancellable a #GCancellable
         * @returns #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        read(cancellable?: Cancellable | null): FileInputStream;
        /**
         * Asynchronously opens `file` for reading.
         *
         * For more details, see g_file_read() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_read_finish() to get the result
         * of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_read_async().
         * @param res a #GAsyncResult
         * @returns a #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        read_finish(res: AsyncResult): FileInputStream;
        /**
         * Returns an output stream for overwriting the file, possibly
         * creating a backup copy of the file first. If the file doesn't exist,
         * it will be created.
         *
         * This will try to replace the file in the safest way possible so
         * that any errors during the writing will not affect an already
         * existing copy of the file. For instance, for local files it
         * may write to a temporary file and then atomically rename over
         * the destination when the stream is closed.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If you pass in a non-%NULL `etag` value and `file` already exists, then
         * this value is compared to the current entity tag of the file, and if
         * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
         * generally means that the file has been changed since you last read
         * it. You can get the new etag from g_file_output_stream_get_etag()
         * after you've finished writing and closed the #GFileOutputStream. When
         * you load a new file you can use g_file_input_stream_query_info() to
         * get the etag of the file.
         *
         * If `make_backup` is %TRUE, this function will attempt to make a
         * backup of the current file before overwriting it. If this fails
         * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
         * want to replace anyway, try again with `make_backup` set to %FALSE.
         *
         * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
         * be returned, and if the file is some other form of non-regular file
         * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
         * file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
         * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @param etag an optional [entity tag](#entity-tags)   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable?: Cancellable | null,
        ): FileOutputStream;
        /**
         * Asynchronously overwrites the file, replacing the contents,
         * possibly creating a backup copy of the file first.
         *
         * For more details, see g_file_replace() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_finish() to get the result
         * of the operation.
         * @param etag an [entity tag](#entity-tags) for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        replace_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Replaces the contents of `file` with `contents` of `length` bytes.
         *
         * If `etag` is specified (not %NULL), any existing file must have that etag,
         * or the error %G_IO_ERROR_WRONG_ETAG will be returned.
         *
         * If `make_backup` is %TRUE, this function will attempt to make a backup
         * of `file`. Internally, it uses g_file_replace(), so will try to replace the
         * file contents in the safest way possible. For example, atomic renames are
         * used when replacing local files contents.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * The returned `new_etag` can be used to verify that the file hasn't
         * changed the next time it is saved over.
         * @param contents a string containing the new contents for @file
         * @param etag the old [entity-tag](#entity-tags) for the document,   or %NULL
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns %TRUE if successful. If an error has occurred, this function   will return %FALSE and set @error appropriately if present.
         */
        replace_contents(
            contents: Uint8Array | string,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable?: Cancellable | null,
        ): [boolean, string];
        /**
         * Starts an asynchronous replacement of `file` with the given
         * `contents` of `length` bytes. `etag` will replace the document's
         * current entity tag.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_replace_contents_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `make_backup` is %TRUE, this function will attempt to
         * make a backup of `file`.
         *
         * Note that no copy of `contents` will be made, so it must stay valid
         * until `callback` is called. See g_file_replace_contents_bytes_async()
         * for a #GBytes version that will automatically hold a reference to the
         * contents (without copying) for the duration of the call.
         * @param contents string of contents to replace the file with
         * @param etag a new [entity tag](#entity-tags) for the @file, or %NULL
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        replace_contents_async(
            contents: Uint8Array | string,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Same as g_file_replace_contents_async() but takes a #GBytes input instead.
         * This function will keep a ref on `contents` until the operation is done.
         * Unlike g_file_replace_contents_async() this allows forgetting about the
         * content without waiting for the callback.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_replace_contents_finish().
         * @param contents a #GBytes
         * @param etag a new [entity tag](#entity-tags) for the @file, or %NULL
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        replace_contents_bytes_async(
            contents: GLib.Bytes | Uint8Array,
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous replace of the given `file`. See
         * g_file_replace_contents_async(). Sets `new_etag` to the new entity
         * tag for the document, if present.
         * @param res a #GAsyncResult
         * @returns %TRUE on success, %FALSE on failure.
         */
        replace_contents_finish(res: AsyncResult): [boolean, string];
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_async().
         * @param res a #GAsyncResult
         * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_finish(res: AsyncResult): FileOutputStream;
        /**
         * Returns an output stream for overwriting the file in readwrite mode,
         * possibly creating a backup copy of the file first. If the file doesn't
         * exist, it will be created.
         *
         * For details about the behaviour, see g_file_replace() which does the
         * same thing but returns an output stream only.
         *
         * Note that in many non-local file cases read and write streams are not
         * supported, so make sure you really need to do read and write streaming,
         * rather than just opening for reading or writing.
         * @param etag an optional [entity tag](#entity-tags)   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_readwrite(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable?: Cancellable | null,
        ): FileIOStream;
        /**
         * Asynchronously overwrites the file in read-write mode,
         * replacing the contents, possibly creating a backup copy
         * of the file first.
         *
         * For more details, see g_file_replace_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_readwrite_finish() to get
         * the result of the operation.
         * @param etag an [entity tag](#entity-tags) for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        replace_readwrite_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_readwrite_async().
         * @param res a #GAsyncResult
         * @returns a #GFileIOStream, or %NULL on error.   Free the returned object with g_object_unref().
         */
        replace_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Resolves a relative path for `file` to an absolute path.
         *
         * This call does no blocking I/O.
         *
         * If the `relative_path` is an absolute path name, the resolution
         * is done absolutely (without taking `file` path as base).
         * @param relative_path a given relative path string
         * @returns a #GFile for the resolved path.
         */
        resolve_relative_path(relative_path: string): File;
        /**
         * Sets an attribute in the file with attribute name `attribute` to `value_p`.
         *
         * Some attributes can be unset by setting `type` to
         * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p` to %NULL.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param type The type of the attribute
         * @param value_p a pointer to the value (or the pointer   itself if the type is a pointer type)
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the attribute was set, %FALSE otherwise.
         */
        set_attribute(
            attribute: string,
            type: FileAttributeType,
            value_p: any | null,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to `value`.
         * If `attribute` is of a different type, this operation will fail,
         * returning %FALSE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a string containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_byte_string(
            attribute: string,
            value: string,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_INT32 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #gint32 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_int32(
            attribute: string,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_INT64 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #guint64 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set, %FALSE otherwise.
         */
        set_attribute_int64(
            attribute: string,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_STRING to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a string containing the attribute's value
         * @param flags #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set, %FALSE otherwise.
         */
        set_attribute_string(
            attribute: string,
            value: string,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #guint32 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_uint32(
            attribute: string,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to `value`.
         * If `attribute` is of a different type, this operation will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param value a #guint64 containing the attribute's new value
         * @param flags a #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
         */
        set_attribute_uint64(
            attribute: string,
            value: number,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Asynchronously sets the attributes of `file` with `info`.
         *
         * For more details, see g_file_set_attributes_from_info(),
         * which is the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_attributes_finish() to get
         * the result of the operation.
         * @param info a #GFileInfo
         * @param flags a #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        set_attributes_async(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes setting an attribute started in g_file_set_attributes_async().
         * @param result a #GAsyncResult
         * @returns %TRUE if the attributes were set correctly, %FALSE otherwise.
         */
        set_attributes_finish(result: AsyncResult): [boolean, FileInfo];
        /**
         * Tries to set all attributes in the #GFileInfo on the target
         * values, not stopping on the first error.
         *
         * If there is any error during this operation then `error` will
         * be set to the first error. Error on particular fields are flagged
         * by setting the "status" field in the attribute value to
         * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
         * also detect further errors.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param info a #GFileInfo
         * @param flags #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %FALSE if there was any error, %TRUE otherwise.
         */
        set_attributes_from_info(info: FileInfo, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
        /**
         * Renames `file` to the specified display name.
         *
         * The display name is converted from UTF-8 to the correct encoding
         * for the target filesystem if possible and the `file` is renamed to this.
         *
         * If you want to implement a rename operation in the user interface the
         * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
         * initial value in the rename widget, and then the result after editing
         * should be passed to g_file_set_display_name().
         *
         * On success the resulting converted filename is returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param display_name a string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns a #GFile specifying what @file was renamed to,   or %NULL if there was an error.   Free the returned object with g_object_unref().
         */
        set_display_name(display_name: string, cancellable?: Cancellable | null): File;
        /**
         * Asynchronously sets the display name for a given #GFile.
         *
         * For more details, see g_file_set_display_name() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_display_name_finish() to get
         * the result of the operation.
         * @param display_name a string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        set_display_name_async(
            display_name: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes setting a display name started with
         * g_file_set_display_name_async().
         * @param res a #GAsyncResult
         * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
         */
        set_display_name_finish(res: AsyncResult): File;
        /**
         * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
         * Using `start_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param start_operation a #GMountOperation, or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied, or %NULL
         */
        start_mountable(
            flags: DriveStartFlags,
            start_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a start operation. See g_file_start_mountable() for details.
         *
         * Finish an asynchronous start operation that was started
         * with g_file_start_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
         */
        start_mountable_finish(result: AsyncResult): boolean;
        /**
         * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_stop_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        stop_mountable(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stop operation, see g_file_stop_mountable() for details.
         *
         * Finish an asynchronous stop operation that was started
         * with g_file_stop_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        stop_mountable_finish(result: AsyncResult): boolean;
        /**
         * Checks if `file` supports
         * [thread-default contexts][g-main-context-push-thread-default-context].
         * If this returns %FALSE, you cannot perform asynchronous operations on
         * `file` in a thread that has a thread-default context.
         * @returns Whether or not @file supports thread-default contexts.
         */
        supports_thread_contexts(): boolean;
        /**
         * Sends `file` to the "Trashcan", if possible. This is similar to
         * deleting it, but the user can recover it before emptying the trashcan.
         * Not all file systems support trashing, so this call can return the
         * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
         * mount option can be used to disable g_file_trash() support for certain
         * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @returns %TRUE on successful trash, %FALSE otherwise.
         */
        trash(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously sends `file` to the Trash location, if possible.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        trash_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file trashing operation, started with
         * g_file_trash_async().
         * @param result a #GAsyncResult
         * @returns %TRUE on successful trash, %FALSE otherwise.
         */
        trash_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        unmount_mountable(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an unmount operation, see g_file_unmount_mountable() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        unmount_mountable_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        unmount_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an unmount operation,
         * see g_file_unmount_mountable_with_operation() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable_with_operation().
         * @param result a #GAsyncResult
         * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
         */
        unmount_mountable_with_operation_finish(result: AsyncResult): boolean;
        replace_contents_async(
            contents: Uint8Array,
            etag: string,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable: Cancellable,
            callback: AsyncReadyCallback,
        ): void;

        // Virtual methods

        /**
         * Gets an output stream for appending data to the file.
         * If the file doesn't already exist it is created.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * Some file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
         * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_append_to(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
        /**
         * Asynchronously opens `file` for appending.
         *
         * For more details, see g_file_append_to() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_append_to_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_append_to_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file append operation started with
         * g_file_append_to_async().
         * @param res #GAsyncResult
         */
        vfunc_append_to_finish(res: AsyncResult): FileOutputStream;
        /**
         * Copies the file `source` to the location specified by `destination`.
         * Can not handle recursive copies of directories.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
         * will be copied as symlinks, otherwise the target of the
         * `source` symlink will be copied.
         *
         * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
         * that is possible to copy is copied, not just the default subset (which,
         * for instance, does not include the owner, see #GFileInfo).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is guaranteed
         * that this callback will be called after all data has been transferred with
         * the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND error
         * is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
         * the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
         * %G_IO_ERROR_WOULD_RECURSE error is returned.
         *
         * If you are interested in copying the #GFile object itself (not the on-disk
         * file), see g_file_dup().
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback function to callback with   progress information, or %NULL if progress information is not needed
         */
        vfunc_copy(
            destination: File,
            flags: FileCopyFlags,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
        ): boolean;
        /**
         * Copies the file `source` to the location specified by `destination`
         * asynchronously. For details of the behaviour, see g_file_copy().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_copy(). The callback will run in the default main context
         * of the thread calling g_file_copy_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_copy_finish() to get the result of the operation.
         * @param destination destination #GFile
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback function to callback with progress information, or %NULL if   progress information is not needed
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_copy_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes copying the file started with g_file_copy_async().
         * @param res a #GAsyncResult
         */
        vfunc_copy_finish(res: AsyncResult): boolean;
        /**
         * Creates a new file and returns an output stream for writing to it.
         * The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
         * be returned. Other errors are possible too, and depend on what kind
         * of filesystem the file is on.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_create(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
        /**
         * Asynchronously creates a new file and returns an output stream
         * for writing to it. The file must not already exist.
         *
         * For more details, see g_file_create() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_finish() to get the result
         * of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_create_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_async().
         * @param res a #GAsyncResult
         */
        vfunc_create_finish(res: AsyncResult): FileOutputStream;
        /**
         * Creates a new file and returns a stream for reading and
         * writing to it. The file must not already exist.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level
         * that is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If a file or directory with this name already exists, the
         * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
         * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
         * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
         * will be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         *
         * Note that in many non-local file cases read and write streams are
         * not supported, so make sure you really need to do read and write
         * streaming, rather than just opening for reading or writing.
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_create_readwrite(flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;
        /**
         * Asynchronously creates a new file and returns a stream
         * for reading and writing to it. The file must not already exist.
         *
         * For more details, see g_file_create_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_create_readwrite_finish() to get
         * the result of the operation.
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_create_readwrite_async(
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file create operation started with
         * g_file_create_readwrite_async().
         * @param res a #GAsyncResult
         */
        vfunc_create_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Deletes a file. If the `file` is a directory, it will only be
         * deleted if it is empty. This has the same semantics as g_unlink().
         *
         * If `file` doesnt exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
         * for deletion to be implemented avoiding
         * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
         *
         * ```
         * g_autoptr(GError) local_error = NULL;
         * if (!g_file_delete (my_file, my_cancellable, &local_error) &&
         *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
         *   {
         *     // deletion failed for some reason other than the file not existing:
         *     // so report the error
         *     g_warning ("Failed to delete %s: %s",
         *                g_file_peek_path (my_file), local_error->message);
         *   }
         * ```
         *
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_delete_file(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously delete a file. If the `file` is a directory, it will
         * only be deleted if it is empty.  This has the same semantics as
         * g_unlink().
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_delete_file_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes deleting a file started with g_file_delete_async().
         * @param result a #GAsyncResult
         */
        vfunc_delete_file_finish(result: AsyncResult): boolean;
        /**
         * Duplicates a #GFile handle. This operation does not duplicate
         * the actual file or directory represented by the #GFile; see
         * g_file_copy() if attempting to copy a file.
         *
         * g_file_dup() is useful when a second handle is needed to the same underlying
         * file, for use in a separate thread (#GFile is not thread-safe). For use
         * within the same thread, use g_object_ref() to increment the existing objects
         * reference count.
         *
         * This call does no blocking I/O.
         */
        vfunc_dup(): File;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_eject_mountable(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable().
         * @param result a #GAsyncResult
         */
        vfunc_eject_mountable_finish(result: AsyncResult): boolean;
        /**
         * Starts an asynchronous eject on a mountable.
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_eject_mountable_with_operation_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_eject_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous eject operation started by
         * g_file_eject_mountable_with_operation().
         * @param result a #GAsyncResult
         */
        vfunc_eject_mountable_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the requested information about the files in a directory.
         * The result is a #GFileEnumerator object that will give out
         * #GFileInfo objects for all the files in the directory.
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should
         * be a comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
         * always be specified if you plan to call g_file_enumerator_get_child() or
         * g_file_enumerator_iterate() on the returned enumerator.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
         * error will be returned. Other errors are possible too.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_enumerate_children(
            attributes: string,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): FileEnumerator;
        /**
         * Asynchronously gets the requested information about the files
         * in a directory. The result is a #GFileEnumerator object that will
         * give out #GFileInfo objects for all the files in the directory.
         *
         * For more details, see g_file_enumerate_children() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_enumerate_children_finish() to get the result of
         * the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_enumerate_children_async(
            attributes: string,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async enumerate children operation.
         * See g_file_enumerate_children_async().
         * @param res a #GAsyncResult
         */
        vfunc_enumerate_children_finish(res: AsyncResult): FileEnumerator;
        /**
         * Checks if the two given #GFiles refer to the same file.
         *
         * Note that two #GFiles that differ can still refer to the same
         * file on the filesystem due to various forms of filename
         * aliasing.
         *
         * This call does no blocking I/O.
         * @param file2 the second #GFile
         */
        vfunc_equal(file2: File): boolean;
        /**
         * Gets a #GMount for the #GFile.
         *
         * #GMount is returned only for user interesting locations, see
         * #GVolumeMonitor. If the #GFileIface for `file` does not have a #mount,
         * `error` will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_find_enclosing_mount(cancellable?: Cancellable | null): Mount;
        /**
         * Asynchronously gets the mount for the file.
         *
         * For more details, see g_file_find_enclosing_mount() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_find_enclosing_mount_finish() to
         * get the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_find_enclosing_mount_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous find mount request.
         * See g_file_find_enclosing_mount_async().
         * @param res a #GAsyncResult
         */
        vfunc_find_enclosing_mount_finish(res: AsyncResult): Mount;
        /**
         * Gets the base name (the last component of the path) for a given #GFile.
         *
         * If called for the top level of a system (such as the filesystem root
         * or a uri like sftp://host/) it will return a single directory separator
         * (and on Windows, possibly a drive letter).
         *
         * The base name is a byte string (not UTF-8). It has no defined encoding
         * or rules other than it may not contain zero bytes.  If you want to use
         * filenames in a user interface you should use the display name that you
         * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
         * attribute with g_file_query_info().
         *
         * This call does no blocking I/O.
         */
        vfunc_get_basename(): string | null;
        /**
         * Gets the child of `file` for a given `display_name` (i.e. a UTF-8
         * version of the name). If this function fails, it returns %NULL
         * and `error` will be set. This is very useful when constructing a
         * #GFile for a new file and the user entered the filename in the
         * user interface, for instance when you select a directory and
         * type a filename in the file selector.
         *
         * This call does no blocking I/O.
         * @param display_name string to a possible child
         */
        vfunc_get_child_for_display_name(display_name: string): File;
        /**
         * Gets the parent directory for the `file`.
         * If the `file` represents the root directory of the
         * file system, then %NULL will be returned.
         *
         * This call does no blocking I/O.
         */
        vfunc_get_parent(): File | null;
        /**
         * Gets the parse name of the `file`.
         * A parse name is a UTF-8 string that describes the
         * file such that one can get the #GFile back using
         * g_file_parse_name().
         *
         * This is generally used to show the #GFile as a nice
         * full-pathname kind of string in a user interface,
         * like in a location entry.
         *
         * For local files with names that can safely be converted
         * to UTF-8 the pathname is used, otherwise the IRI is used
         * (a form of URI that allows UTF-8 characters unescaped).
         *
         * This call does no blocking I/O.
         */
        vfunc_get_parse_name(): string;
        /**
         * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
         * guaranteed to be an absolute, canonical path. It might contain symlinks.
         *
         * This call does no blocking I/O.
         */
        vfunc_get_path(): string | null;
        /**
         * Gets the path for `descendant` relative to `parent`.
         *
         * This call does no blocking I/O.
         * @param descendant input #GFile
         */
        vfunc_get_relative_path(descendant: File): string | null;
        /**
         * Gets the URI for the `file`.
         *
         * This call does no blocking I/O.
         */
        vfunc_get_uri(): string;
        /**
         * Gets the URI scheme for a #GFile.
         * RFC 3986 decodes the scheme as:
         *
         * ```
         * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
         * ```
         *
         * Common schemes include "file", "http", "ftp", etc.
         *
         * The scheme can be different from the one used to construct the #GFile,
         * in that it might be replaced with one that is logically equivalent to the #GFile.
         *
         * This call does no blocking I/O.
         */
        vfunc_get_uri_scheme(): string | null;
        /**
         * Checks to see if a #GFile has a given URI scheme.
         *
         * This call does no blocking I/O.
         * @param uri_scheme a string containing a URI scheme
         */
        vfunc_has_uri_scheme(uri_scheme: string): boolean;
        /**
         * Creates a hash value for a #GFile.
         *
         * This call does no blocking I/O.
         */
        vfunc_hash(): number;
        /**
         * Checks to see if a file is native to the platform.
         *
         * A native file is one expressed in the platform-native filename format,
         * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
         * as it might be on a locally mounted remote filesystem.
         *
         * On some systems non-native files may be available using the native
         * filesystem via a userspace filesystem (FUSE), in these cases this call
         * will return %FALSE, but g_file_get_path() will still return a native path.
         *
         * This call does no blocking I/O.
         */
        vfunc_is_native(): boolean;
        /**
         * Creates a directory. Note that this will only create a child directory
         * of the immediate parent directory of the path or URI given by the #GFile.
         * To recursively create directories, see g_file_make_directory_with_parents().
         * This function will fail if the parent directory does not exist, setting
         * `error` to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
         * creating directories, this function will fail, setting `error` to
         * %G_IO_ERROR_NOT_SUPPORTED.
         *
         * For a local #GFile the newly created directory will have the default
         * (current) ownership and permissions of the current process.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_make_directory(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously creates a directory.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_make_directory_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous directory creation, started with
         * g_file_make_directory_async().
         * @param result a #GAsyncResult
         */
        vfunc_make_directory_finish(result: AsyncResult): boolean;
        /**
         * Creates a symbolic link named `file` which contains the string
         * `symlink_value`.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_make_symbolic_link(symlink_value: string, cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously creates a symbolic link named `file` which contains the
         * string `symlink_value`.
         * @param symlink_value a string with the path for the target   of the new symlink
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_make_symbolic_link_async(
            symlink_value: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous symbolic link creation, started with
         * g_file_make_symbolic_link_async().
         * @param result a #GAsyncResult
         */
        vfunc_make_symbolic_link_finish(result: AsyncResult): boolean;
        /**
         * Recursively measures the disk usage of `file`.
         *
         * This is essentially an analog of the 'du' command, but it also
         * reports the number of directories and non-directory files encountered
         * (including things like symbolic links).
         *
         * By default, errors are only reported against the toplevel file
         * itself.  Errors found while recursing are silently ignored, unless
         * %G_FILE_MEASURE_REPORT_ANY_ERROR is given in `flags`.
         *
         * The returned size, `disk_usage,` is in bytes and should be formatted
         * with g_format_size() in order to get something reasonable for showing
         * in a user interface.
         *
         * `progress_callback` and `progress_data` can be given to request
         * periodic progress updates while scanning.  See the documentation for
         * #GFileMeasureProgressCallback for information about when and how the
         * callback will be invoked.
         * @param flags #GFileMeasureFlags
         * @param cancellable optional #GCancellable
         * @param progress_callback a #GFileMeasureProgressCallback
         */
        vfunc_measure_disk_usage(
            flags: FileMeasureFlags,
            cancellable: Cancellable | null,
            progress_callback: FileMeasureProgressCallback | null,
        ): [boolean, number, number, number];
        /**
         * Collects the results from an earlier call to
         * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
         * more information.
         * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
         */
        vfunc_measure_disk_usage_finish(result: AsyncResult): [boolean, number, number, number];
        /**
         * Obtains a directory monitor for the given file.
         * This may fail if directory monitoring is not supported.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * It does not make sense for `flags` to contain
         * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
         * directories.  It is not possible to monitor all the files in a
         * directory for changes made via hard links; if you want to do this then
         * you must register individual watches with g_file_monitor().
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_monitor_dir(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
        /**
         * Obtains a file monitor for the given file. If no file notification
         * mechanism exists, then regular polling of the file is used.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `flags` contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
         * will also attempt to report changes made to the file via another
         * filename (ie, a hard link). Without this flag, you can only rely on
         * changes made through the filename contained in `file` to be
         * reported. Using this flag may result in an increase in resource
         * usage, and may not have any effect depending on the #GFileMonitor
         * backend and/or filesystem type.
         * @param flags a set of #GFileMonitorFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_monitor_file(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
        /**
         * Starts a `mount_operation,` mounting the volume that contains
         * the file `location`.
         *
         * When this operation has completed, `callback` will be called with
         * `user_user` data, and the operation can be finalized with
         * g_file_mount_enclosing_volume_finish().
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        vfunc_mount_enclosing_volume(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a mount operation started by g_file_mount_enclosing_volume().
         * @param result a #GAsyncResult
         */
        vfunc_mount_enclosing_volume_finish(result: AsyncResult): boolean;
        /**
         * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
         * Using `mount_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_mount_mountable(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a mount operation. See g_file_mount_mountable() for details.
         *
         * Finish an asynchronous mount operation that was started
         * with g_file_mount_mountable().
         * @param result a #GAsyncResult
         */
        vfunc_mount_mountable_finish(result: AsyncResult): File;
        /**
         * Tries to move the file or directory `source` to the location specified
         * by `destination`. If native move operations are supported then this is
         * used, otherwise a copy + delete fallback is used. The native
         * implementation may support moving directories (for instance on moves
         * inside the same filesystem), but the fallback code does not.
         *
         * If the flag %G_FILE_COPY_OVERWRITE is specified an already
         * existing `destination` file is overwritten.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If `progress_callback` is not %NULL, then the operation can be monitored
         * by setting this to a #GFileProgressCallback function.
         * `progress_callback_data` will be passed to this function. It is
         * guaranteed that this callback will be called after all data has been
         * transferred with the total number of bytes copied during the operation.
         *
         * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND
         * error is returned, independent on the status of the `destination`.
         *
         * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
         * then the error %G_IO_ERROR_EXISTS is returned.
         *
         * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error is returned. If trying to overwrite a directory with a directory the
         * %G_IO_ERROR_WOULD_MERGE error is returned.
         *
         * If the source is a directory and the target does not exist, or
         * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
         * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
         * move operation isn't available).
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback #GFileProgressCallback   function for updates
         */
        vfunc_move(
            destination: File,
            flags: FileCopyFlags,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
        ): boolean;
        /**
         * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
         *
         * If `progress_callback` is not %NULL, then that function that will be called
         * just like in g_file_move(). The callback will run in the default main context
         * of the thread calling g_file_move_async()  the same context as `callback` is
         * run in.
         *
         * When the operation is finished, `callback` will be called. You can then call
         * g_file_move_finish() to get the result of the operation.
         * @param destination #GFile pointing to the destination location
         * @param flags set of #GFileCopyFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param progress_callback #GFileProgressCallback function for updates
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_move_async(
            destination: File,
            flags: FileCopyFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            progress_callback?: FileProgressCallback | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file movement, started with
         * g_file_move_async().
         * @param result a #GAsyncResult
         */
        vfunc_move_finish(result: AsyncResult): boolean;
        /**
         * Opens an existing file for reading and writing. The result is
         * a #GFileIOStream that can be used to read and write the contents
         * of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend on
         * what kind of filesystem the file is on. Note that in many non-local
         * file cases read and write streams are not supported, so make sure you
         * really need to do read and write streaming, rather than just opening
         * for reading or writing.
         * @param cancellable a #GCancellable
         */
        vfunc_open_readwrite(cancellable?: Cancellable | null): FileIOStream;
        /**
         * Asynchronously opens `file` for reading and writing.
         *
         * For more details, see g_file_open_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_open_readwrite_finish() to get
         * the result of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_open_readwrite_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_open_readwrite_async().
         * @param res a #GAsyncResult
         */
        vfunc_open_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        vfunc_poll_mountable(cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes a poll operation. See g_file_poll_mountable() for details.
         *
         * Finish an asynchronous poll operation that was polled
         * with g_file_poll_mountable().
         * @param result a #GAsyncResult
         */
        vfunc_poll_mountable_finish(result: AsyncResult): boolean;
        /**
         * Checks whether `file` has the prefix specified by `prefix`.
         *
         * In other words, if the names of initial elements of `file'`s
         * pathname match `prefix`. Only full pathname elements are matched,
         * so a path like /foo is not considered a prefix of /foobar, only
         * of /foo/bar.
         *
         * A #GFile is not a prefix of itself. If you want to check for
         * equality, use g_file_equal().
         *
         * This call does no I/O, as it works purely on names. As such it can
         * sometimes return %FALSE even if `file` is inside a `prefix` (from a
         * filesystem point of view), because the prefix of `file` is an alias
         * of `prefix`.
         * @param file input #GFile
         */
        vfunc_prefix_matches(file: File): boolean;
        /**
         * Similar to g_file_query_info(), but obtains information
         * about the filesystem the `file` is on, rather than the file itself.
         * For instance the amount of space available and the type of
         * the filesystem.
         *
         * The `attributes` value is a string that specifies the attributes
         * that should be gathered. It is not an error if it's not possible
         * to read a particular requested attribute from a file - it just
         * won't be set. `attributes` should be a comma-separated list of
         * attributes or attribute wildcards. The wildcard "*" means all
         * attributes, and a wildcard like "filesystem::*" means all attributes
         * in the filesystem namespace. The standard namespace for filesystem
         * attributes is "filesystem". Common attributes of interest are
         * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
         * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
         * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
         * be returned. Other errors are possible too, and depend on what
         * kind of filesystem the file is on.
         * @param attributes an attribute query string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_query_filesystem_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously gets the requested information about the filesystem
         * that the specified `file` is on. The result is a #GFileInfo object
         * that contains key-value attributes (such as type or size for the
         * file).
         *
         * For more details, see g_file_query_filesystem_info() which is the
         * synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the
         * operation.
         * @param attributes an attribute query string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_filesystem_info_async(
            attributes: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous filesystem info query.
         * See g_file_query_filesystem_info_async().
         * @param res a #GAsyncResult
         */
        vfunc_query_filesystem_info_finish(res: AsyncResult): FileInfo;
        /**
         * Gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value
         * attributes (such as the type or size of the file).
         *
         * The `attributes` value is a string that specifies the file
         * attributes that should be gathered. It is not an error if
         * it's not possible to read a particular requested attribute
         * from a file - it just won't be set. `attributes` should be a
         * comma-separated list of attributes or attribute wildcards.
         * The wildcard "*" means all attributes, and a wildcard like
         * "standard::*" means all attributes in the standard namespace.
         * An example attribute query be "standard::*,owner::user".
         * The standard attributes are available as defines, like
         * %G_FILE_ATTRIBUTE_STANDARD_NAME.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * For symlinks, normally the information about the target of the
         * symlink is returned, rather than information about the symlink
         * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
         * in `flags` the information about the symlink itself will be returned.
         * Also, for symlinks that point to non-existing files the information
         * about the symlink itself will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. Other errors are possible too, and depend on what kind of
         * filesystem the file is on.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_query_info(attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileInfo;
        /**
         * Asynchronously gets the requested information about specified `file`.
         * The result is a #GFileInfo object that contains key-value attributes
         * (such as type or size for the file).
         *
         * For more details, see g_file_query_info() which is the synchronous
         * version of this call.
         *
         * When the operation is finished, `callback` will be called. You can
         * then call g_file_query_info_finish() to get the result of the operation.
         * @param attributes an attribute query string
         * @param flags a set of #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_query_info_async(
            attributes: string,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file info query.
         * See g_file_query_info_async().
         * @param res a #GAsyncResult
         */
        vfunc_query_info_finish(res: AsyncResult): FileInfo;
        /**
         * Obtain the list of settable attributes for the file.
         *
         * Returns the type and full attribute name of all the attributes
         * that can be set on this file. This doesn't mean setting it will
         * always succeed though, you might get an access failure, or some
         * specific file may not support a specific attribute.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_query_settable_attributes(cancellable?: Cancellable | null): FileAttributeInfoList;
        /**
         * Obtain the list of attribute namespaces where new attributes
         * can be created by a user. An example of this is extended
         * attributes (in the "xattr" namespace).
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_query_writable_namespaces(cancellable?: Cancellable | null): FileAttributeInfoList;
        /**
         * Asynchronously opens `file` for reading.
         *
         * For more details, see g_file_read() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_read_finish() to get the result
         * of the operation.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_read_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file read operation started with
         * g_file_read_async().
         * @param res a #GAsyncResult
         */
        vfunc_read_finish(res: AsyncResult): FileInputStream;
        /**
         * Opens a file for reading. The result is a #GFileInputStream that
         * can be used to read the contents of the file.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
         * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
         * error will be returned. Other errors are possible too, and depend
         * on what kind of filesystem the file is on.
         * @param cancellable a #GCancellable
         */
        vfunc_read_fn(cancellable?: Cancellable | null): FileInputStream;
        /**
         * Returns an output stream for overwriting the file, possibly
         * creating a backup copy of the file first. If the file doesn't exist,
         * it will be created.
         *
         * This will try to replace the file in the safest way possible so
         * that any errors during the writing will not affect an already
         * existing copy of the file. For instance, for local files it
         * may write to a temporary file and then atomically rename over
         * the destination when the stream is closed.
         *
         * By default files created are generally readable by everyone,
         * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
         * will be made readable only to the current user, to the level that
         * is supported on the target filesystem.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled
         * by triggering the cancellable object from another thread. If the
         * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
         * returned.
         *
         * If you pass in a non-%NULL `etag` value and `file` already exists, then
         * this value is compared to the current entity tag of the file, and if
         * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
         * generally means that the file has been changed since you last read
         * it. You can get the new etag from g_file_output_stream_get_etag()
         * after you've finished writing and closed the #GFileOutputStream. When
         * you load a new file you can use g_file_input_stream_query_info() to
         * get the etag of the file.
         *
         * If `make_backup` is %TRUE, this function will attempt to make a
         * backup of the current file before overwriting it. If this fails
         * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
         * want to replace anyway, try again with `make_backup` set to %FALSE.
         *
         * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
         * be returned, and if the file is some other form of non-regular file
         * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
         * file systems don't allow all file names, and may return an
         * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
         * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
         * possible too, and depend on what kind of filesystem the file is on.
         * @param etag an optional [entity tag](#entity-tags)   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_replace(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable?: Cancellable | null,
        ): FileOutputStream;
        /**
         * Asynchronously overwrites the file, replacing the contents,
         * possibly creating a backup copy of the file first.
         *
         * For more details, see g_file_replace() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_finish() to get the result
         * of the operation.
         * @param etag an [entity tag](#entity-tags) for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_replace_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_async().
         * @param res a #GAsyncResult
         */
        vfunc_replace_finish(res: AsyncResult): FileOutputStream;
        /**
         * Returns an output stream for overwriting the file in readwrite mode,
         * possibly creating a backup copy of the file first. If the file doesn't
         * exist, it will be created.
         *
         * For details about the behaviour, see g_file_replace() which does the
         * same thing but returns an output stream only.
         *
         * Note that in many non-local file cases read and write streams are not
         * supported, so make sure you really need to do read and write streaming,
         * rather than just opening for reading or writing.
         * @param etag an optional [entity tag](#entity-tags)   for the current #GFile, or #NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_replace_readwrite(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            cancellable?: Cancellable | null,
        ): FileIOStream;
        /**
         * Asynchronously overwrites the file in read-write mode,
         * replacing the contents, possibly creating a backup copy
         * of the file first.
         *
         * For more details, see g_file_replace_readwrite() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_replace_readwrite_finish() to get
         * the result of the operation.
         * @param etag an [entity tag](#entity-tags) for the current #GFile,   or %NULL to ignore
         * @param make_backup %TRUE if a backup should be created
         * @param flags a set of #GFileCreateFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_replace_readwrite_async(
            etag: string | null,
            make_backup: boolean,
            flags: FileCreateFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file replace operation started with
         * g_file_replace_readwrite_async().
         * @param res a #GAsyncResult
         */
        vfunc_replace_readwrite_finish(res: AsyncResult): FileIOStream;
        /**
         * Resolves a relative path for `file` to an absolute path.
         *
         * This call does no blocking I/O.
         *
         * If the `relative_path` is an absolute path name, the resolution
         * is done absolutely (without taking `file` path as base).
         * @param relative_path a given relative path string
         */
        vfunc_resolve_relative_path(relative_path: string): File;
        /**
         * Sets an attribute in the file with attribute name `attribute` to `value_p`.
         *
         * Some attributes can be unset by setting `type` to
         * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p` to %NULL.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param attribute a string containing the attribute's name
         * @param type The type of the attribute
         * @param value_p a pointer to the value (or the pointer   itself if the type is a pointer type)
         * @param flags a set of #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_set_attribute(
            attribute: string,
            type: FileAttributeType,
            value_p: any | null,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Asynchronously sets the attributes of `file` with `info`.
         *
         * For more details, see g_file_set_attributes_from_info(),
         * which is the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_attributes_finish() to get
         * the result of the operation.
         * @param info a #GFileInfo
         * @param flags a #GFileQueryInfoFlags
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_set_attributes_async(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes setting an attribute started in g_file_set_attributes_async().
         * @param result a #GAsyncResult
         */
        vfunc_set_attributes_finish(result: AsyncResult): [boolean, FileInfo];
        /**
         * Tries to set all attributes in the #GFileInfo on the target
         * values, not stopping on the first error.
         *
         * If there is any error during this operation then `error` will
         * be set to the first error. Error on particular fields are flagged
         * by setting the "status" field in the attribute value to
         * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
         * also detect further errors.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param info a #GFileInfo
         * @param flags #GFileQueryInfoFlags
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_set_attributes_from_info(
            info: FileInfo,
            flags: FileQueryInfoFlags,
            cancellable?: Cancellable | null,
        ): boolean;
        /**
         * Renames `file` to the specified display name.
         *
         * The display name is converted from UTF-8 to the correct encoding
         * for the target filesystem if possible and the `file` is renamed to this.
         *
         * If you want to implement a rename operation in the user interface the
         * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
         * initial value in the rename widget, and then the result after editing
         * should be passed to g_file_set_display_name().
         *
         * On success the resulting converted filename is returned.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param display_name a string
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_set_display_name(display_name: string, cancellable?: Cancellable | null): File;
        /**
         * Asynchronously sets the display name for a given #GFile.
         *
         * For more details, see g_file_set_display_name() which is
         * the synchronous version of this call.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_set_display_name_finish() to get
         * the result of the operation.
         * @param display_name a string
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_set_display_name_async(
            display_name: string,
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes setting a display name started with
         * g_file_set_display_name_async().
         * @param res a #GAsyncResult
         */
        vfunc_set_display_name_finish(res: AsyncResult): File;
        /**
         * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
         * Using `start_operation,` you can request callbacks when, for instance,
         * passwords are needed during authentication.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_mount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param start_operation a #GMountOperation, or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied, or %NULL
         */
        vfunc_start_mountable(
            flags: DriveStartFlags,
            start_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a start operation. See g_file_start_mountable() for details.
         *
         * Finish an asynchronous start operation that was started
         * with g_file_start_mountable().
         * @param result a #GAsyncResult
         */
        vfunc_start_mountable_finish(result: AsyncResult): boolean;
        /**
         * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_stop_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
         */
        vfunc_stop_mountable(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes a stop operation, see g_file_stop_mountable() for details.
         *
         * Finish an asynchronous stop operation that was started
         * with g_file_stop_mountable().
         * @param result a #GAsyncResult
         */
        vfunc_stop_mountable_finish(result: AsyncResult): boolean;
        /**
         * Sends `file` to the "Trashcan", if possible. This is similar to
         * deleting it, but the user can recover it before emptying the trashcan.
         * Not all file systems support trashing, so this call can return the
         * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
         * mount option can be used to disable g_file_trash() support for certain
         * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         */
        vfunc_trash(cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously sends `file` to the Trash location, if possible.
         * @param io_priority the [I/O priority][io-priority] of the request
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
         */
        vfunc_trash_async(
            io_priority: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous file trashing operation, started with
         * g_file_trash_async().
         * @param result a #GAsyncResult
         */
        vfunc_trash_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_unmount_mountable(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an unmount operation, see g_file_unmount_mountable() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable().
         * @param result a #GAsyncResult
         */
        vfunc_unmount_mountable_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_file_unmount_mountable_finish() to get
         * the result of the operation.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object,   %NULL to ignore
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_unmount_mountable_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an unmount operation,
         * see g_file_unmount_mountable_with_operation() for details.
         *
         * Finish an asynchronous unmount operation that was started
         * with g_file_unmount_mountable_with_operation().
         * @param result a #GAsyncResult
         */
        vfunc_unmount_mountable_with_operation_finish(result: AsyncResult): boolean;
    }

    export const File: FileNamespace;

    module FileDescriptorBased {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface FileDescriptorBasedNamespace {
        $gtype: GObject.GType<FileDescriptorBased>;
        prototype: FileDescriptorBased;
    }
    interface FileDescriptorBased extends GObject.Object {
        // Methods

        /**
         * Gets the underlying file descriptor.
         * @returns The file descriptor
         */
        get_fd(): number;

        // Virtual methods

        /**
         * Gets the underlying file descriptor.
         */
        vfunc_get_fd(): number;
    }

    export const FileDescriptorBased: FileDescriptorBasedNamespace;

    module Icon {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IconNamespace {
        $gtype: GObject.GType<Icon>;
        prototype: Icon;

        /**
         * Deserializes a #GIcon previously serialized using g_icon_serialize().
         * @param value a #GVariant created with g_icon_serialize()
         */
        deserialize(value: GLib.Variant): Icon | null;
        /**
         * Generate a #GIcon instance from `str`. This function can fail if
         * `str` is not valid - see g_icon_to_string() for discussion.
         *
         * If your application or library provides one or more #GIcon
         * implementations you need to ensure that each #GType is registered
         * with the type system prior to calling g_icon_new_for_string().
         * @param str A string obtained via g_icon_to_string().
         */
        new_for_string(str: string): Icon;
    }
    interface Icon extends GObject.Object {
        // Methods

        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
         */
        equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         * @returns a #guint containing a hash for the @icon, suitable for   use in a #GHashTable or similar data structure.
         */
        hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
         */
        serialize(): GLib.Variant | null;
        /**
         * Generates a textual representation of `icon` that can be used for
         * serialization such as when passing `icon` to a different process or
         * saving it to persistent storage. Use g_icon_new_for_string() to
         * get `icon` back from the returned string.
         *
         * The encoding of the returned string is proprietary to #GIcon except
         * in the following two cases
         *
         * - If `icon` is a #GFileIcon, the returned string is a native path
         *   (such as `/path/to/my icon.png`) without escaping
         *   if the #GFile for `icon` is a native file.  If the file is not
         *   native, the returned string is the result of g_file_get_uri()
         *   (such as `sftp://path/to/my%20icon.png`).
         *
         * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
         *   the encoding is simply the name (such as `network-server`).
         * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
         */
        to_string(): string | null;

        // Virtual methods

        /**
         * Checks if two icons are equal.
         * @param icon2 pointer to the second #GIcon.
         */
        vfunc_equal(icon2?: Icon | null): boolean;
        /**
         * Gets a hash for an icon.
         */
        vfunc_hash(): number;
        /**
         * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
         * back by calling g_icon_deserialize() on the returned value.
         * As serialization will avoid using raw icon data when possible, it only
         * makes sense to transfer the #GVariant between processes on the same machine,
         * (as opposed to over the network), and within the same file system namespace.
         */
        vfunc_serialize(): GLib.Variant | null;
        /**
         * Serializes the `icon` into string tokens.
         * This is can be invoked when g_icon_new_for_string() is called.
         */
        vfunc_to_tokens(): [boolean, string[], number];
    }

    export const Icon: IconNamespace;

    module Initable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface InitableNamespace {
        $gtype: GObject.GType<Initable>;
        prototype: Initable;

        /**
         * Helper function for constructing #GInitable object. This is
         * similar to g_object_newv() but also initializes the object
         * and returns %NULL, setting an error on failure.
         * @param object_type a #GType supporting #GInitable.
         * @param parameters the parameters to use to construct the object
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        newv<T = GObject.Object>(
            object_type: GObject.GType,
            parameters: GObject.Parameter[],
            cancellable?: Cancellable | null,
        ): T;
        newv(...args: never[]): any;
    }
    interface Initable extends GObject.Object {
        // Methods

        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
         */
        init(cancellable?: Cancellable | null): boolean;

        // Virtual methods

        /**
         * Initializes the object implementing the interface.
         *
         * This method is intended for language bindings. If writing in C,
         * g_initable_new() should typically be used instead.
         *
         * The object must be initialized before any real use after initial
         * construction, either with this function or g_async_initable_init_async().
         *
         * Implementations may also support cancellation. If `cancellable` is not %NULL,
         * then initialization can be cancelled by triggering the cancellable object
         * from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
         * the object doesn't support cancellable initialization the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * If the object is not initialized, or initialization returns with an
         * error, then all operations on the object except g_object_ref() and
         * g_object_unref() are considered to be invalid, and have undefined
         * behaviour. See the [introduction][ginitable] for more details.
         *
         * Callers should not assume that a class which implements #GInitable can be
         * initialized multiple times, unless the class explicitly documents itself as
         * supporting this. Generally, a class implementation of init() can assume
         * (and assert) that it will only be called once. Previously, this documentation
         * recommended all #GInitable implementations should be idempotent; that
         * recommendation was relaxed in GLib 2.54.
         *
         * If a class explicitly supports being initialized multiple times, it is
         * recommended that the method is idempotent: multiple calls with the same
         * arguments should return the same results. Only the first call initializes
         * the object; further calls return the result of the first call.
         *
         * One reason why a class might need to support idempotent initialization is if
         * it is designed to be used via the singleton pattern, with a
         * #GObjectClass.constructor that sometimes returns an existing instance.
         * In this pattern, a caller would expect to be able to call g_initable_init()
         * on the result of g_object_new(), regardless of whether it is in fact a new
         * instance.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_init(cancellable?: Cancellable | null): boolean;
    }

    export const Initable: InitableNamespace;

    module ListModel {
        // Constructor properties interface

        interface ConstructorProps<A extends GObject.Object = GObject.Object> extends GObject.Object.ConstructorProps {}
    }

    export interface ListModelNamespace {
        $gtype: GObject.GType<ListModel>;
        prototype: ListModel;
    }
    interface ListModel<A extends GObject.Object = GObject.Object> extends GObject.Object {
        // Methods

        /**
         * Gets the type of the items in `list`.
         *
         * All items returned from g_list_model_get_item() are of the type
         * returned by this function, or a subtype, or if the type is an
         * interface, they are an implementation of that interface.
         *
         * The item type of a #GListModel can not change during the life of the
         * model.
         * @returns the #GType of the items contained in @list.
         */
        get_item_type(): GObject.GType;
        /**
         * Gets the number of items in `list`.
         *
         * Depending on the model implementation, calling this function may be
         * less efficient than iterating the list with increasing values for
         * `position` until g_list_model_get_item() returns %NULL.
         * @returns the number of items in @list.
         */
        get_n_items(): number;
        /**
         * Get the item at `position`.
         *
         * If `position` is greater than the number of items in `list,` %NULL is
         * returned.
         *
         * %NULL is never returned for an index that is smaller than the length
         * of the list.
         *
         * This function is meant to be used by language bindings in place
         * of g_list_model_get_item().
         *
         * See also: g_list_model_get_n_items()
         * @param position the position of the item to fetch
         * @returns the object at @position.
         */
        get_item(position: number): A | null;
        /**
         * Emits the #GListModel::items-changed signal on `list`.
         *
         * This function should only be called by classes implementing
         * #GListModel. It has to be called after the internal representation
         * of `list` has been updated, because handlers connected to this signal
         * might query the new state of the list.
         *
         * Implementations must only make changes to the model (as visible to
         * its consumer) in places that will not cause problems for that
         * consumer.  For models that are driven directly by a write API (such
         * as #GListStore), changes can be reported in response to uses of that
         * API.  For models that represent remote data, changes should only be
         * made from a fresh mainloop dispatch.  It is particularly not
         * permitted to make changes in response to a call to the #GListModel
         * consumer API.
         *
         * Stated another way: in general, it is assumed that code making a
         * series of accesses to the model via the API, without returning to the
         * mainloop, and without calling other code, will continue to view the
         * same contents of the model.
         * @param position the position at which @list changed
         * @param removed the number of items removed
         * @param added the number of items added
         */
        items_changed(position: number, removed: number, added: number): void;

        // Virtual methods

        /**
         * Get the item at `position`. If `position` is greater than the number of
         * items in `list,` %NULL is returned.
         *
         * %NULL is never returned for an index that is smaller than the length
         * of the list.  See g_list_model_get_n_items().
         *
         * The same #GObject instance may not appear more than once in a #GListModel.
         * @param position the position of the item to fetch
         */
        vfunc_get_item(position: number): A | null;
        /**
         * Gets the type of the items in `list`.
         *
         * All items returned from g_list_model_get_item() are of the type
         * returned by this function, or a subtype, or if the type is an
         * interface, they are an implementation of that interface.
         *
         * The item type of a #GListModel can not change during the life of the
         * model.
         */
        vfunc_get_item_type(): GObject.GType;
        /**
         * Gets the number of items in `list`.
         *
         * Depending on the model implementation, calling this function may be
         * less efficient than iterating the list with increasing values for
         * `position` until g_list_model_get_item() returns %NULL.
         */
        vfunc_get_n_items(): number;
    }

    export const ListModel: ListModelNamespace;

    module LoadableIcon {
        // Constructor properties interface

        interface ConstructorProps extends Icon.ConstructorProps {}
    }

    export interface LoadableIconNamespace {
        $gtype: GObject.GType<LoadableIcon>;
        prototype: LoadableIcon;
    }
    interface LoadableIcon extends Icon {
        // Methods

        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns a #GInputStream to read the icon from.
         */
        load(size: number, cancellable?: Cancellable | null): [InputStream, string];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        load_async(size: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @param res a #GAsyncResult.
         * @returns a #GInputStream to read the icon from.
         */
        load_finish(res: AsyncResult): [InputStream, string];

        // Virtual methods

        /**
         * Loads a loadable icon. For the asynchronous version of this function,
         * see g_loadable_icon_load_async().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_load(size: number, cancellable?: Cancellable | null): [InputStream, string];
        /**
         * Loads an icon asynchronously. To finish this function, see
         * g_loadable_icon_load_finish(). For the synchronous, blocking
         * version of this function, see g_loadable_icon_load().
         * @param size an integer.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback   to call when the request is satisfied
         */
        vfunc_load_async(
            size: number,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
         * @param res a #GAsyncResult.
         */
        vfunc_load_finish(res: AsyncResult): [InputStream, string];
    }

    export const LoadableIcon: LoadableIconNamespace;

    module MemoryMonitor {
        // Constructor properties interface

        interface ConstructorProps extends Initable.ConstructorProps {}
    }

    export interface MemoryMonitorNamespace {
        $gtype: GObject.GType<MemoryMonitor>;
        prototype: MemoryMonitor;

        /**
         * Gets a reference to the default #GMemoryMonitor for the system.
         */
        dup_default(): MemoryMonitor;
    }
    interface MemoryMonitor extends Initable {
        // Virtual methods

        /**
         * the virtual function pointer for the
         *  #GMemoryMonitor::low-memory-warning signal.
         * @param level
         */
        vfunc_low_memory_warning(level: MemoryMonitorWarningLevel): void;
    }

    export const MemoryMonitor: MemoryMonitorNamespace;

    module Mount {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface MountNamespace {
        $gtype: GObject.GType<Mount>;
        prototype: Mount;
    }
    interface Mount extends GObject.Object {
        // Methods

        /**
         * Checks if `mount` can be ejected.
         * @returns %TRUE if the @mount can be ejected.
         */
        can_eject(): boolean;
        /**
         * Checks if `mount` can be unmounted.
         * @returns %TRUE if the @mount can be unmounted.
         */
        can_unmount(): boolean;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
         */
        eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
         */
        eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the default location of `mount`. The default location of the given
         * `mount` is a path that reflects the main entry point for the user (e.g.
         * the home directory, or the root of the volume).
         * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_default_location(): File;
        /**
         * Gets the drive for the `mount`.
         *
         * This is a convenience method for getting the #GVolume and then
         * using that object to get the #GDrive.
         * @returns a #GDrive or %NULL if @mount is not      associated with a volume or a drive.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_drive(): Drive | null;
        /**
         * Gets the icon for `mount`.
         * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_icon(): Icon;
        /**
         * Gets the name of `mount`.
         * @returns the name for the given @mount.     The returned string should be freed with g_free()     when no longer needed.
         */
        get_name(): string;
        /**
         * Gets the root directory on `mount`.
         * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_root(): File;
        /**
         * Gets the sort key for `mount,` if any.
         * @returns Sorting key for @mount or %NULL if no such key is available.
         */
        get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `mount`.
         * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `mount`. The reference is typically based on
         * the file system UUID for the mount in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         * @returns the UUID for @mount or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
         */
        get_uuid(): string | null;
        /**
         * Gets the volume for the `mount`.
         * @returns a #GVolume or %NULL if @mount is not      associated with a volume.      The returned object should be unreffed with      g_object_unref() when no longer needed.
         */
        get_volume(): Volume | null;
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is an asynchronous operation (see
         * g_mount_guess_content_type_sync() for the synchronous version), and
         * is finished by calling g_mount_guess_content_type_finish() with the
         * `mount` and #GAsyncResult data returned in the `callback`.
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback
         */
        guess_content_type(
            force_rescan: boolean,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes guessing content types of `mount`. If any errors occurred
         * during the operation, `error` will be set to contain the errors and
         * %FALSE will be returned. In particular, you may get an
         * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
         * guessing.
         * @param result a #GAsyncResult
         * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
         */
        guess_content_type_finish(result: AsyncResult): string[];
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is a synchronous operation and as such may block doing IO;
         * see g_mount_guess_content_type() for the asynchronous version.
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
         */
        guess_content_type_sync(force_rescan: boolean, cancellable?: Cancellable | null): string[];
        /**
         * Determines if `mount` is shadowed. Applications or libraries should
         * avoid displaying `mount` in the user interface if it is shadowed.
         *
         * A mount is said to be shadowed if there exists one or more user
         * visible objects (currently #GMount objects) with a root that is
         * inside the root of `mount`.
         *
         * One application of shadow mounts is when exposing a single file
         * system that is used to address several logical volumes. In this
         * situation, a #GVolumeMonitor implementation would create two
         * #GVolume objects (for example, one for the camera functionality of
         * the device and one for a SD card reader on the device) with
         * activation URIs `gphoto2://[usb:001,002]/store1/`
         * and `gphoto2://[usb:001,002]/store2/`. When the
         * underlying mount (with root
         * `gphoto2://[usb:001,002]/`) is mounted, said
         * #GVolumeMonitor implementation would create two #GMount objects
         * (each with their root matching the corresponding volume activation
         * root) that would shadow the original mount.
         *
         * The proxy monitor in GVfs 2.26 and later, automatically creates and
         * manage shadow mounts (and shadows the underlying mount) if the
         * activation root on a #GVolume is set.
         * @returns %TRUE if @mount is shadowed.
         */
        is_shadowed(): boolean;
        /**
         * Remounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_remount_finish() with the `mount`
         * and #GAsyncResults data returned in the `callback`.
         *
         * Remounting is useful when some setting affecting the operation
         * of the volume has been changed, as these may need a remount to
         * take affect. While this is semantically equivalent with unmounting
         * and then remounting not all backends might need to actually be
         * unmounted.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        remount(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes remounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully remounted. %FALSE otherwise.
         */
        remount_finish(result: AsyncResult): boolean;
        /**
         * Increments the shadow count on `mount`. Usually used by
         * #GVolumeMonitor implementations when creating a shadow mount for
         * `mount,` see g_mount_is_shadowed() for more information. The caller
         * will need to emit the #GMount::changed signal on `mount` manually.
         */
        shadow(): void;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        unmount(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
         */
        unmount_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        unmount_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
         */
        unmount_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Decrements the shadow count on `mount`. Usually used by
         * #GVolumeMonitor implementations when destroying a shadow mount for
         * `mount,` see g_mount_is_shadowed() for more information. The caller
         * will need to emit the #GMount::changed signal on `mount` manually.
         */
        unshadow(): void;

        // Virtual methods

        /**
         * Checks if `mount` can be ejected.
         */
        vfunc_can_eject(): boolean;
        /**
         * Checks if `mount` can be unmounted.
         */
        vfunc_can_unmount(): boolean;
        /**
         * Changed signal that is emitted when the mount's state has changed.
         */
        vfunc_changed(): void;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         */
        vfunc_eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_eject_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         */
        vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the default location of `mount`. The default location of the given
         * `mount` is a path that reflects the main entry point for the user (e.g.
         * the home directory, or the root of the volume).
         */
        vfunc_get_default_location(): File;
        /**
         * Gets the drive for the `mount`.
         *
         * This is a convenience method for getting the #GVolume and then
         * using that object to get the #GDrive.
         */
        vfunc_get_drive(): Drive | null;
        /**
         * Gets the icon for `mount`.
         */
        vfunc_get_icon(): Icon;
        /**
         * Gets the name of `mount`.
         */
        vfunc_get_name(): string;
        /**
         * Gets the root directory on `mount`.
         */
        vfunc_get_root(): File;
        /**
         * Gets the sort key for `mount,` if any.
         */
        vfunc_get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `mount`.
         */
        vfunc_get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `mount`. The reference is typically based on
         * the file system UUID for the mount in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         */
        vfunc_get_uuid(): string | null;
        /**
         * Gets the volume for the `mount`.
         */
        vfunc_get_volume(): Volume | null;
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is an asynchronous operation (see
         * g_mount_guess_content_type_sync() for the synchronous version), and
         * is finished by calling g_mount_guess_content_type_finish() with the
         * `mount` and #GAsyncResult data returned in the `callback`.
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback
         */
        vfunc_guess_content_type(
            force_rescan: boolean,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes guessing content types of `mount`. If any errors occurred
         * during the operation, `error` will be set to contain the errors and
         * %FALSE will be returned. In particular, you may get an
         * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
         * guessing.
         * @param result a #GAsyncResult
         */
        vfunc_guess_content_type_finish(result: AsyncResult): string[];
        /**
         * Tries to guess the type of content stored on `mount`. Returns one or
         * more textual identifiers of well-known content types (typically
         * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
         * memory cards. See the
         * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
         * specification for more on x-content types.
         *
         * This is a synchronous operation and as such may block doing IO;
         * see g_mount_guess_content_type() for the asynchronous version.
         * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
         * @param cancellable optional #GCancellable object, %NULL to ignore
         */
        vfunc_guess_content_type_sync(force_rescan: boolean, cancellable?: Cancellable | null): string[];
        /**
         * The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
         */
        vfunc_pre_unmount(): void;
        /**
         * Remounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_remount_finish() with the `mount`
         * and #GAsyncResults data returned in the `callback`.
         *
         * Remounting is useful when some setting affecting the operation
         * of the volume has been changed, as these may need a remount to
         * take affect. While this is semantically equivalent with unmounting
         * and then remounting not all backends might need to actually be
         * unmounted.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_remount(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes remounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         */
        vfunc_remount_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_unmount(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         */
        vfunc_unmount_finish(result: AsyncResult): boolean;
        /**
         * Unmounts a mount. This is an asynchronous operation, and is
         * finished by calling g_mount_unmount_with_operation_finish() with the `mount`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback, or %NULL.
         */
        vfunc_unmount_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes unmounting a mount. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult.
         */
        vfunc_unmount_with_operation_finish(result: AsyncResult): boolean;
        /**
         * The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
         */
        vfunc_unmounted(): void;
    }

    export const Mount: MountNamespace;

    module NetworkMonitor {
        // Constructor properties interface

        interface ConstructorProps extends Initable.ConstructorProps {
            connectivity: NetworkConnectivity;
            network_available: boolean;
            networkAvailable: boolean;
            network_metered: boolean;
            networkMetered: boolean;
        }
    }

    export interface NetworkMonitorNamespace {
        $gtype: GObject.GType<NetworkMonitor>;
        prototype: NetworkMonitor;

        /**
         * Gets the default #GNetworkMonitor for the system.
         */
        get_default(): NetworkMonitor;
    }
    interface NetworkMonitor extends Initable {
        // Properties

        /**
         * More detailed information about the host's network connectivity.
         * See g_network_monitor_get_connectivity() and
         * #GNetworkConnectivity for more details.
         */
        get connectivity(): NetworkConnectivity;
        /**
         * Whether the network is considered available. That is, whether the
         * system has a default route for at least one of IPv4 or IPv6.
         *
         * Real-world networks are of course much more complicated than
         * this; the machine may be connected to a wifi hotspot that
         * requires payment before allowing traffic through, or may be
         * connected to a functioning router that has lost its own upstream
         * connectivity. Some hosts might only be accessible when a VPN is
         * active. Other hosts might only be accessible when the VPN is
         * not active. Thus, it is best to use g_network_monitor_can_reach()
         * or g_network_monitor_can_reach_async() to test for reachability
         * on a host-by-host basis. (On the other hand, when the property is
         * %FALSE, the application can reasonably expect that no remote
         * hosts at all are reachable, and should indicate this to the user
         * in its UI.)
         *
         * See also #GNetworkMonitor::network-changed.
         */
        get network_available(): boolean;
        /**
         * Whether the network is considered available. That is, whether the
         * system has a default route for at least one of IPv4 or IPv6.
         *
         * Real-world networks are of course much more complicated than
         * this; the machine may be connected to a wifi hotspot that
         * requires payment before allowing traffic through, or may be
         * connected to a functioning router that has lost its own upstream
         * connectivity. Some hosts might only be accessible when a VPN is
         * active. Other hosts might only be accessible when the VPN is
         * not active. Thus, it is best to use g_network_monitor_can_reach()
         * or g_network_monitor_can_reach_async() to test for reachability
         * on a host-by-host basis. (On the other hand, when the property is
         * %FALSE, the application can reasonably expect that no remote
         * hosts at all are reachable, and should indicate this to the user
         * in its UI.)
         *
         * See also #GNetworkMonitor::network-changed.
         */
        get networkAvailable(): boolean;
        /**
         * Whether the network is considered metered.
         *
         * That is, whether the
         * system has traffic flowing through the default connection that is
         * subject to limitations set by service providers. For example, traffic
         * might be billed by the amount of data transmitted, or there might be a
         * quota on the amount of traffic per month. This is typical with tethered
         * connections (3G and 4G) and in such situations, bandwidth intensive
         * applications may wish to avoid network activity where possible if it will
         * cost the user money or use up their limited quota. Anything more than a
         * few hundreds of kilobytes of data usage per hour should be avoided without
         * asking permission from the user.
         *
         * If more information is required about specific devices then the
         * system network management API should be used instead (for example,
         * NetworkManager or ConnMan).
         *
         * If this information is not available then no networks will be
         * marked as metered.
         *
         * See also #GNetworkMonitor:network-available.
         */
        get network_metered(): boolean;
        /**
         * Whether the network is considered metered.
         *
         * That is, whether the
         * system has traffic flowing through the default connection that is
         * subject to limitations set by service providers. For example, traffic
         * might be billed by the amount of data transmitted, or there might be a
         * quota on the amount of traffic per month. This is typical with tethered
         * connections (3G and 4G) and in such situations, bandwidth intensive
         * applications may wish to avoid network activity where possible if it will
         * cost the user money or use up their limited quota. Anything more than a
         * few hundreds of kilobytes of data usage per hour should be avoided without
         * asking permission from the user.
         *
         * If more information is required about specific devices then the
         * system network management API should be used instead (for example,
         * NetworkManager or ConnMan).
         *
         * If this information is not available then no networks will be
         * marked as metered.
         *
         * See also #GNetworkMonitor:network-available.
         */
        get networkMetered(): boolean;

        // Methods

        /**
         * Attempts to determine whether or not the host pointed to by
         * `connectable` can be reached, without actually trying to connect to
         * it.
         *
         * This may return %TRUE even when #GNetworkMonitor:network-available
         * is %FALSE, if, for example, `monitor` can determine that
         * `connectable` refers to a host on a local network.
         *
         * If `monitor` believes that an attempt to connect to `connectable`
         * will succeed, it will return %TRUE. Otherwise, it will return
         * %FALSE and set `error` to an appropriate error (such as
         * %G_IO_ERROR_HOST_UNREACHABLE).
         *
         * Note that although this does not attempt to connect to
         * `connectable,` it may still block for a brief period of time (eg,
         * trying to do multicast DNS on the local network), so if you do not
         * want to block, you should use g_network_monitor_can_reach_async().
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @returns %TRUE if @connectable is reachable, %FALSE if not.
         */
        can_reach(connectable: SocketConnectable, cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously attempts to determine whether or not the host
         * pointed to by `connectable` can be reached, without actually
         * trying to connect to it.
         *
         * For more details, see g_network_monitor_can_reach().
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_network_monitor_can_reach_finish()
         * to get the result of the operation.
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        can_reach_async(
            connectable: SocketConnectable,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async network connectivity test.
         * See g_network_monitor_can_reach_async().
         * @param result a #GAsyncResult
         * @returns %TRUE if network is reachable, %FALSE if not.
         */
        can_reach_finish(result: AsyncResult): boolean;
        /**
         * Gets a more detailed networking state than
         * g_network_monitor_get_network_available().
         *
         * If #GNetworkMonitor:network-available is %FALSE, then the
         * connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
         *
         * If #GNetworkMonitor:network-available is %TRUE, then the
         * connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
         * is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
         * the host has a default route, but appears to be unable to actually
         * reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
         * host is trapped behind a "captive portal" that requires some sort
         * of login or acknowledgement before allowing full Internet access).
         *
         * Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
         * %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
         * reachable but others are not. In this case, applications can
         * attempt to connect to remote servers, but should gracefully fall
         * back to their "offline" behavior if the connection attempt fails.
         * @returns the network connectivity state
         */
        get_connectivity(): NetworkConnectivity;
        /**
         * Checks if the network is available. "Available" here means that the
         * system has a default route available for at least one of IPv4 or
         * IPv6. It does not necessarily imply that the public Internet is
         * reachable. See #GNetworkMonitor:network-available for more details.
         * @returns whether the network is available
         */
        get_network_available(): boolean;
        /**
         * Checks if the network is metered.
         * See #GNetworkMonitor:network-metered for more details.
         * @returns whether the connection is metered
         */
        get_network_metered(): boolean;

        // Virtual methods

        /**
         * Attempts to determine whether or not the host pointed to by
         * `connectable` can be reached, without actually trying to connect to
         * it.
         *
         * This may return %TRUE even when #GNetworkMonitor:network-available
         * is %FALSE, if, for example, `monitor` can determine that
         * `connectable` refers to a host on a local network.
         *
         * If `monitor` believes that an attempt to connect to `connectable`
         * will succeed, it will return %TRUE. Otherwise, it will return
         * %FALSE and set `error` to an appropriate error (such as
         * %G_IO_ERROR_HOST_UNREACHABLE).
         *
         * Note that although this does not attempt to connect to
         * `connectable,` it may still block for a brief period of time (eg,
         * trying to do multicast DNS on the local network), so if you do not
         * want to block, you should use g_network_monitor_can_reach_async().
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_can_reach(connectable: SocketConnectable, cancellable?: Cancellable | null): boolean;
        /**
         * Asynchronously attempts to determine whether or not the host
         * pointed to by `connectable` can be reached, without actually
         * trying to connect to it.
         *
         * For more details, see g_network_monitor_can_reach().
         *
         * When the operation is finished, `callback` will be called.
         * You can then call g_network_monitor_can_reach_finish()
         * to get the result of the operation.
         * @param connectable a #GSocketConnectable
         * @param cancellable a #GCancellable, or %NULL
         * @param callback a #GAsyncReadyCallback     to call when the request is satisfied
         */
        vfunc_can_reach_async(
            connectable: SocketConnectable,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes an async network connectivity test.
         * See g_network_monitor_can_reach_async().
         * @param result a #GAsyncResult
         */
        vfunc_can_reach_finish(result: AsyncResult): boolean;
        /**
         * the virtual function pointer for the
         *  GNetworkMonitor::network-changed signal.
         * @param network_available
         */
        vfunc_network_changed(network_available: boolean): void;
    }

    export const NetworkMonitor: NetworkMonitorNamespace;

    module PollableInputStream {
        // Constructor properties interface

        interface ConstructorProps extends InputStream.ConstructorProps {}
    }

    export interface PollableInputStreamNamespace {
        $gtype: GObject.GType<PollableInputStream>;
        prototype: PollableInputStream;
    }
    interface PollableInputStream extends InputStream {
        // Methods

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
         */
        is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        read_nonblocking(cancellable?: Cancellable | null): [number, Uint8Array];

        // Virtual methods

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableInputStream but have only certain instances of that class
         * be pollable. If this method returns %FALSE, then the behavior of
         * other #GPollableInputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be read, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_input_stream_is_readable(), it is possible that
         * the stream may not actually be readable even after the source
         * triggers, so you should use g_pollable_input_stream_read_nonblocking()
         * rather than g_input_stream_read() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be read.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_input_stream_read()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_input_stream_read_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_readable(): boolean;
        /**
         * Attempts to read up to `count` bytes from `stream` into `buffer,` as
         * with g_input_stream_read(). If `stream` is not currently readable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_input_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is readable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * The behaviour of this method is undefined if
         * g_pollable_input_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_read_nonblocking(): [number, Uint8Array | null];
    }

    export const PollableInputStream: PollableInputStreamNamespace;

    module PollableOutputStream {
        // Constructor properties interface

        interface ConstructorProps extends OutputStream.ConstructorProps {}
    }

    export interface PollableOutputStreamNamespace {
        $gtype: GObject.GType<PollableOutputStream>;
        prototype: PollableOutputStream;
    }
    interface PollableOutputStream extends OutputStream {
        // Methods

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         * @returns %TRUE if @stream is pollable, %FALSE if not.
         */
        can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         * @returns a new #GSource
         */
        create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
         */
        is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         * @param cancellable a #GCancellable, or %NULL
         * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
         */
        write_nonblocking(buffer: Uint8Array | string, cancellable?: Cancellable | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         * @param cancellable a #GCancellable, or %NULL
         * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
         */
        writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [PollableReturn, number];

        // Virtual methods

        /**
         * Checks if `stream` is actually pollable. Some classes may implement
         * #GPollableOutputStream but have only certain instances of that
         * class be pollable. If this method returns %FALSE, then the behavior
         * of other #GPollableOutputStream methods is undefined.
         *
         * For any given stream, the value returned by this method is constant;
         * a stream cannot switch from pollable to non-pollable or vice versa.
         */
        vfunc_can_poll(): boolean;
        /**
         * Creates a #GSource that triggers when `stream` can be written, or
         * `cancellable` is triggered or an error occurs. The callback on the
         * source is of the #GPollableSourceFunc type.
         *
         * As with g_pollable_output_stream_is_writable(), it is possible that
         * the stream may not actually be writable even after the source
         * triggers, so you should use g_pollable_output_stream_write_nonblocking()
         * rather than g_output_stream_write() from the callback.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_create_source(cancellable?: Cancellable | null): GLib.Source;
        /**
         * Checks if `stream` can be written.
         *
         * Note that some stream types may not be able to implement this 100%
         * reliably, and it is possible that a call to g_output_stream_write()
         * after this returns %TRUE would still block. To guarantee
         * non-blocking behavior, you should always use
         * g_pollable_output_stream_write_nonblocking(), which will return a
         * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         */
        vfunc_is_writable(): boolean;
        /**
         * Attempts to write up to `count` bytes from `buffer` to `stream,` as
         * with g_output_stream_write(). If `stream` is not currently writable,
         * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `buffer` and
         * `count` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param buffer a buffer to write     data from
         */
        vfunc_write_nonblocking(buffer?: Uint8Array | null): number;
        /**
         * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
         * as with g_output_stream_writev(). If `stream` is not currently writable,
         * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
         * use g_pollable_output_stream_create_source() to create a #GSource
         * that will be triggered when `stream` is writable. `error` will *not* be
         * set in that case.
         *
         * Note that since this method never blocks, you cannot actually
         * use `cancellable` to cancel it. However, it will return an error
         * if `cancellable` has already been cancelled when you call, which
         * may happen if you call this method after a source triggers due
         * to having been cancelled.
         *
         * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
         * transports like D/TLS require that you re-send the same `vectors` and
         * `n_vectors` in the next write call.
         *
         * The behaviour of this method is undefined if
         * g_pollable_output_stream_can_poll() returns %FALSE for `stream`.
         * @param vectors the buffer containing the #GOutputVectors to write.
         */
        vfunc_writev_nonblocking(vectors: OutputVector[]): [PollableReturn, number];
    }

    export const PollableOutputStream: PollableOutputStreamNamespace;

    module PowerProfileMonitor {
        // Constructor properties interface

        interface ConstructorProps extends Initable.ConstructorProps {
            power_saver_enabled: boolean;
            powerSaverEnabled: boolean;
        }
    }

    export interface PowerProfileMonitorNamespace {
        $gtype: GObject.GType<PowerProfileMonitor>;
        prototype: PowerProfileMonitor;

        /**
         * Gets a reference to the default #GPowerProfileMonitor for the system.
         */
        dup_default(): PowerProfileMonitor;
    }
    interface PowerProfileMonitor extends Initable {
        // Properties

        /**
         * Whether Power Saver mode is enabled on the system.
         */
        get power_saver_enabled(): boolean;
        /**
         * Whether Power Saver mode is enabled on the system.
         */
        get powerSaverEnabled(): boolean;

        // Methods

        /**
         * Gets whether the system is in Power Saver mode.
         *
         * You are expected to listen to the
         * #GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
         * changed.
         * @returns Whether the system is in Power Saver mode.
         */
        get_power_saver_enabled(): boolean;
    }

    export const PowerProfileMonitor: PowerProfileMonitorNamespace;

    module Proxy {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ProxyNamespace {
        $gtype: GObject.GType<Proxy>;
        prototype: Proxy;

        /**
         * Find the `gio-proxy` extension point for a proxy implementation that supports
         * the specified protocol.
         * @param protocol the proxy protocol name (e.g. http, socks, etc)
         */
        get_default_for_protocol(protocol: string): Proxy | null;
    }
    interface Proxy extends GObject.Object {
        // Methods

        /**
         * Given `connection` to communicate with a proxy (eg, a
         * #GSocketConnection that is connected to the proxy server), this
         * does the necessary handshake to connect to `proxy_address,` and if
         * required, wraps the #GIOStream to handle proxy payload.
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @returns a #GIOStream that will replace @connection. This might               be the same as @connection, in which case a reference               will be added.
         */
        connect(connection: IOStream, proxy_address: ProxyAddress, cancellable?: Cancellable | null): IOStream;
        connect(...args: never[]): any;
        /**
         * Asynchronous version of g_proxy_connect().
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback
         */
        connect_async(
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * See g_proxy_connect().
         * @param result a #GAsyncResult
         * @returns a #GIOStream.
         */
        connect_finish(result: AsyncResult): IOStream;
        /**
         * Some proxy protocols expect to be passed a hostname, which they
         * will resolve to an IP address themselves. Others, like SOCKS4, do
         * not allow this. This function will return %FALSE if `proxy` is
         * implementing such a protocol. When %FALSE is returned, the caller
         * should resolve the destination hostname first, and then pass a
         * #GProxyAddress containing the stringified IP address to
         * g_proxy_connect() or g_proxy_connect_async().
         * @returns %TRUE if hostname resolution is supported.
         */
        supports_hostname(): boolean;

        // Virtual methods

        /**
         * Given `connection` to communicate with a proxy (eg, a
         * #GSocketConnection that is connected to the proxy server), this
         * does the necessary handshake to connect to `proxy_address,` and if
         * required, wraps the #GIOStream to handle proxy payload.
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         */
        vfunc_connect(connection: IOStream, proxy_address: ProxyAddress, cancellable?: Cancellable | null): IOStream;
        /**
         * Asynchronous version of g_proxy_connect().
         * @param connection a #GIOStream
         * @param proxy_address a #GProxyAddress
         * @param cancellable a #GCancellable
         * @param callback a #GAsyncReadyCallback
         */
        vfunc_connect_async(
            connection: IOStream,
            proxy_address: ProxyAddress,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * See g_proxy_connect().
         * @param result a #GAsyncResult
         */
        vfunc_connect_finish(result: AsyncResult): IOStream;
        /**
         * Some proxy protocols expect to be passed a hostname, which they
         * will resolve to an IP address themselves. Others, like SOCKS4, do
         * not allow this. This function will return %FALSE if `proxy` is
         * implementing such a protocol. When %FALSE is returned, the caller
         * should resolve the destination hostname first, and then pass a
         * #GProxyAddress containing the stringified IP address to
         * g_proxy_connect() or g_proxy_connect_async().
         */
        vfunc_supports_hostname(): boolean;
    }

    export const Proxy: ProxyNamespace;

    module ProxyResolver {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ProxyResolverNamespace {
        $gtype: GObject.GType<ProxyResolver>;
        prototype: ProxyResolver;

        /**
         * Gets the default #GProxyResolver for the system.
         */
        get_default(): ProxyResolver;
    }
    interface ProxyResolver extends GObject.Object {
        // Methods

        /**
         * Checks if `resolver` can be used on this system. (This is used
         * internally; g_proxy_resolver_get_default() will only return a proxy
         * resolver that returns %TRUE for this method.)
         * @returns %TRUE if @resolver is supported.
         */
        is_supported(): boolean;
        /**
         * Looks into the system proxy configuration to determine what proxy,
         * if any, to use to connect to `uri`. The returned proxy URIs are of
         * the form `<protocol>://[user[:password]`]`host[:port]` or
         * `direct://`, where <protocol> could be http, rtsp, socks
         * or other proxying protocol.
         *
         * If you don't know what network protocol is being used on the
         * socket, you should use `none` as the URI protocol.
         * In this case, the resolver might still return a generic proxy type
         * (such as SOCKS), but would not return protocol-specific proxy types
         * (such as http).
         *
         * `direct://` is used when no proxy is needed.
         * Direct connection should not be attempted unless it is part of the
         * returned array of proxies.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        lookup(uri: string, cancellable?: Cancellable | null): string[];
        /**
         * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
         * details.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        lookup_async(uri: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback<this> | null): void;
        /**
         * Call this function to obtain the array of proxy URIs when
         * g_proxy_resolver_lookup_async() is complete. See
         * g_proxy_resolver_lookup() for more details.
         * @param result the result passed to your #GAsyncReadyCallback
         * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
         */
        lookup_finish(result: AsyncResult): string[];

        // Virtual methods

        /**
         * Checks if `resolver` can be used on this system. (This is used
         * internally; g_proxy_resolver_get_default() will only return a proxy
         * resolver that returns %TRUE for this method.)
         */
        vfunc_is_supported(): boolean;
        /**
         * Looks into the system proxy configuration to determine what proxy,
         * if any, to use to connect to `uri`. The returned proxy URIs are of
         * the form `<protocol>://[user[:password]`]`host[:port]` or
         * `direct://`, where <protocol> could be http, rtsp, socks
         * or other proxying protocol.
         *
         * If you don't know what network protocol is being used on the
         * socket, you should use `none` as the URI protocol.
         * In this case, the resolver might still return a generic proxy type
         * (such as SOCKS), but would not return protocol-specific proxy types
         * (such as http).
         *
         * `direct://` is used when no proxy is needed.
         * Direct connection should not be attempted unless it is part of the
         * returned array of proxies.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         */
        vfunc_lookup(uri: string, cancellable?: Cancellable | null): string[];
        /**
         * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
         * details.
         * @param uri a URI representing the destination to connect to
         * @param cancellable a #GCancellable, or %NULL
         * @param callback callback to call after resolution completes
         */
        vfunc_lookup_async(
            uri: string,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Call this function to obtain the array of proxy URIs when
         * g_proxy_resolver_lookup_async() is complete. See
         * g_proxy_resolver_lookup() for more details.
         * @param result the result passed to your #GAsyncReadyCallback
         */
        vfunc_lookup_finish(result: AsyncResult): string[];
    }

    export const ProxyResolver: ProxyResolverNamespace;

    module RemoteActionGroup {
        // Constructor properties interface

        interface ConstructorProps extends ActionGroup.ConstructorProps {}
    }

    export interface RemoteActionGroupNamespace {
        $gtype: GObject.GType<RemoteActionGroup>;
        prototype: RemoteActionGroup;
    }
    interface RemoteActionGroup extends ActionGroup {
        // Methods

        /**
         * Activates the remote action.
         *
         * This is the same as g_action_group_activate_action() except that it
         * allows for provision of "platform data" to be sent along with the
         * activation request.  This typically contains details such as the user
         * interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to activate
         * @param parameter the optional parameter to the activation
         * @param platform_data the platform data to send
         */
        activate_action_full(action_name: string, parameter: GLib.Variant | null, platform_data: GLib.Variant): void;
        /**
         * Changes the state of a remote action.
         *
         * This is the same as g_action_group_change_action_state() except that
         * it allows for provision of "platform data" to be sent along with the
         * state change request.  This typically contains details such as the
         * user interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to change the state of
         * @param value the new requested value for the state
         * @param platform_data the platform data to send
         */
        change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;

        // Virtual methods

        /**
         * Activates the remote action.
         *
         * This is the same as g_action_group_activate_action() except that it
         * allows for provision of "platform data" to be sent along with the
         * activation request.  This typically contains details such as the user
         * interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to activate
         * @param parameter the optional parameter to the activation
         * @param platform_data the platform data to send
         */
        vfunc_activate_action_full(
            action_name: string,
            parameter: GLib.Variant | null,
            platform_data: GLib.Variant,
        ): void;
        /**
         * Changes the state of a remote action.
         *
         * This is the same as g_action_group_change_action_state() except that
         * it allows for provision of "platform data" to be sent along with the
         * state change request.  This typically contains details such as the
         * user interaction timestamp or startup notification information.
         *
         * `platform_data` must be non-%NULL and must have the type
         * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
         * @param action_name the name of the action to change the state of
         * @param value the new requested value for the state
         * @param platform_data the platform data to send
         */
        vfunc_change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
    }

    export const RemoteActionGroup: RemoteActionGroupNamespace;

    module Seekable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface SeekableNamespace {
        $gtype: GObject.GType<Seekable>;
        prototype: Seekable;
    }
    interface Seekable extends GObject.Object {
        // Methods

        /**
         * Tests if the stream supports the #GSeekableIface.
         * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
         */
        can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
         */
        can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
         */
        tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
         */
        truncate(offset: number, cancellable?: Cancellable | null): boolean;

        // Virtual methods

        /**
         * Tests if the stream supports the #GSeekableIface.
         */
        vfunc_can_seek(): boolean;
        /**
         * Tests if the length of the stream can be adjusted with
         * g_seekable_truncate().
         */
        vfunc_can_truncate(): boolean;
        /**
         * Seeks in the stream by the given `offset,` modified by `type`.
         *
         * Attempting to seek past the end of the stream will have different
         * results depending on if the stream is fixed-sized or resizable.  If
         * the stream is resizable then seeking past the end and then writing
         * will result in zeros filling the empty space.  Seeking past the end
         * of a resizable stream and reading will result in EOF.  Seeking past
         * the end of a fixed-sized stream will fail.
         *
         * Any operation that would result in a negative offset will fail.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
         * @param offset a #goffset.
         * @param type a #GSeekType.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
        /**
         * Tells the current position within the stream.
         */
        vfunc_tell(): number;
        /**
         * Sets the length of the stream to `offset`. If the stream was previously
         * larger than `offset,` the extra data is discarded. If the stream was
         * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
         *
         * If `cancellable` is not %NULL, then the operation can be cancelled by
         * triggering the cancellable object from another thread. If the operation
         * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
         * operation was partially finished when the operation was cancelled the
         * partial result will be returned, without an error.
         * @param offset new length for @seekable, in bytes.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        vfunc_truncate_fn(offset: number, cancellable?: Cancellable | null): boolean;
    }

    export const Seekable: SeekableNamespace;

    module SocketConnectable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface SocketConnectableNamespace {
        $gtype: GObject.GType<SocketConnectable>;
        prototype: SocketConnectable;
    }
    interface SocketConnectable extends GObject.Object {
        // Methods

        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         * @returns a new #GSocketAddressEnumerator.
         */
        enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         * @returns a new #GSocketAddressEnumerator.
         */
        proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         * @returns the formatted string
         */
        to_string(): string;

        // Virtual methods

        /**
         * Creates a #GSocketAddressEnumerator for `connectable`.
         */
        vfunc_enumerate(): SocketAddressEnumerator;
        /**
         * Creates a #GSocketAddressEnumerator for `connectable` that will
         * return a #GProxyAddress for each of its addresses that you must connect
         * to via a proxy.
         *
         * If `connectable` does not implement
         * g_socket_connectable_proxy_enumerate(), this will fall back to
         * calling g_socket_connectable_enumerate().
         */
        vfunc_proxy_enumerate(): SocketAddressEnumerator;
        /**
         * Format a #GSocketConnectable as a string. This is a human-readable format for
         * use in debugging output, and is not a stable serialization format. It is not
         * suitable for use in user interfaces as it exposes too much information for a
         * user.
         *
         * If the #GSocketConnectable implementation does not support string formatting,
         * the implementations type name will be returned as a fallback.
         */
        vfunc_to_string(): string;
    }

    export const SocketConnectable: SocketConnectableNamespace;

    module TlsBackend {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface TlsBackendNamespace {
        $gtype: GObject.GType<TlsBackend>;
        prototype: TlsBackend;

        /**
         * Gets the default #GTlsBackend for the system.
         */
        get_default(): TlsBackend;
    }
    interface TlsBackend extends GObject.Object {
        // Methods

        /**
         * Gets the #GType of `backend'`s #GTlsCertificate implementation.
         * @returns the #GType of @backend's #GTlsCertificate   implementation.
         */
        get_certificate_type(): GObject.GType;
        /**
         * Gets the #GType of `backend'`s #GTlsClientConnection implementation.
         * @returns the #GType of @backend's #GTlsClientConnection   implementation.
         */
        get_client_connection_type(): GObject.GType;
        /**
         * Gets the default #GTlsDatabase used to verify TLS connections.
         * @returns the default database, which should be               unreffed when done.
         */
        get_default_database(): TlsDatabase;
        /**
         * Gets the #GType of `backend`s #GDtlsClientConnection implementation.
         * @returns the #GType of @backends #GDtlsClientConnection   implementation, or %G_TYPE_INVALID if this backend doesnt support DTLS.
         */
        get_dtls_client_connection_type(): GObject.GType;
        /**
         * Gets the #GType of `backend`s #GDtlsServerConnection implementation.
         * @returns the #GType of @backends #GDtlsServerConnection   implementation, or %G_TYPE_INVALID if this backend doesnt support DTLS.
         */
        get_dtls_server_connection_type(): GObject.GType;
        /**
         * Gets the #GType of `backend'`s #GTlsFileDatabase implementation.
         * @returns the #GType of backend's #GTlsFileDatabase implementation.
         */
        get_file_database_type(): GObject.GType;
        /**
         * Gets the #GType of `backend'`s #GTlsServerConnection implementation.
         * @returns the #GType of @backend's #GTlsServerConnection   implementation.
         */
        get_server_connection_type(): GObject.GType;
        /**
         * Set the default #GTlsDatabase used to verify TLS connections
         *
         * Any subsequent call to g_tls_backend_get_default_database() will return
         * the database set in this call.  Existing databases and connections are not
         * modified.
         *
         * Setting a %NULL default database will reset to using the system default
         * database as if g_tls_backend_set_default_database() had never been called.
         * @param database the #GTlsDatabase
         */
        set_default_database(database?: TlsDatabase | null): void;
        /**
         * Checks if DTLS is supported. DTLS support may not be available even if TLS
         * support is available, and vice-versa.
         * @returns whether DTLS is supported
         */
        supports_dtls(): boolean;
        /**
         * Checks if TLS is supported; if this returns %FALSE for the default
         * #GTlsBackend, it means no "real" TLS backend is available.
         * @returns whether or not TLS is supported
         */
        supports_tls(): boolean;

        // Virtual methods

        /**
         * Gets the default #GTlsDatabase used to verify TLS connections.
         */
        vfunc_get_default_database(): TlsDatabase;
        /**
         * Checks if DTLS is supported. DTLS support may not be available even if TLS
         * support is available, and vice-versa.
         */
        vfunc_supports_dtls(): boolean;
        /**
         * Checks if TLS is supported; if this returns %FALSE for the default
         * #GTlsBackend, it means no "real" TLS backend is available.
         */
        vfunc_supports_tls(): boolean;
    }

    export const TlsBackend: TlsBackendNamespace;

    module TlsClientConnection {
        // Constructor properties interface

        interface ConstructorProps extends TlsConnection.ConstructorProps {
            accepted_cas: any[];
            acceptedCas: any[];
            server_identity: SocketConnectable;
            serverIdentity: SocketConnectable;
            use_ssl3: boolean;
            useSsl3: boolean;
            validation_flags: TlsCertificateFlags;
            validationFlags: TlsCertificateFlags;
        }
    }

    export interface TlsClientConnectionNamespace {
        $gtype: GObject.GType<TlsClientConnection>;
        prototype: TlsClientConnection;

        /**
         * Creates a new #GTlsClientConnection wrapping `base_io_stream` (which
         * must have pollable input and output streams) which is assumed to
         * communicate with the server identified by `server_identity`.
         *
         * See the documentation for #GTlsConnection:base-io-stream for restrictions
         * on when application code can run operations on the `base_io_stream` after
         * this function has returned.
         * @param base_io_stream the #GIOStream to wrap
         * @param server_identity the expected identity of the server
         */
        ['new'](base_io_stream: IOStream, server_identity?: SocketConnectable | null): TlsClientConnection;
    }
    interface TlsClientConnection extends TlsConnection {
        // Properties

        /**
         * A list of the distinguished names of the Certificate Authorities
         * that the server will accept client certificates signed by. If the
         * server requests a client certificate during the handshake, then
         * this property will be set after the handshake completes.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         */
        get accepted_cas(): any[];
        /**
         * A list of the distinguished names of the Certificate Authorities
         * that the server will accept client certificates signed by. If the
         * server requests a client certificate during the handshake, then
         * this property will be set after the handshake completes.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         */
        get acceptedCas(): any[];
        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         *
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GTlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GTlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         *
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        get server_identity(): SocketConnectable;
        set server_identity(val: SocketConnectable);
        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         *
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GTlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GTlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         *
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        get serverIdentity(): SocketConnectable;
        set serverIdentity(val: SocketConnectable);
        /**
         * SSL 3.0 is no longer supported. See
         * g_tls_client_connection_set_use_ssl3() for details.
         */
        get use_ssl3(): boolean;
        set use_ssl3(val: boolean);
        /**
         * SSL 3.0 is no longer supported. See
         * g_tls_client_connection_set_use_ssl3() for details.
         */
        get useSsl3(): boolean;
        set useSsl3(val: boolean);
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GTlsConnection::accept-certificate.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GTlsConnection::accept-certificate.
         */
        get validation_flags(): TlsCertificateFlags;
        set validation_flags(val: TlsCertificateFlags);
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GTlsConnection::accept-certificate.
         *
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GTlsConnection::accept-certificate.
         */
        get validationFlags(): TlsCertificateFlags;
        set validationFlags(val: TlsCertificateFlags);

        // Methods

        /**
         * Possibly copies session state from one connection to another, for use
         * in TLS session resumption. This is not normally needed, but may be
         * used when the same session needs to be used between different
         * endpoints, as is required by some protocols, such as FTP over TLS.
         * `source` should have already completed a handshake and, since TLS 1.3,
         * it should have been used to read data at least once. `conn` should not
         * have completed a handshake.
         *
         * It is not possible to know whether a call to this function will
         * actually do anything. Because session resumption is normally used
         * only for performance benefit, the TLS backend might not implement
         * this function. Even if implemented, it may not actually succeed in
         * allowing `conn` to resume `source'`s TLS session, because the server
         * may not have sent a session resumption token to `source,` or it may
         * refuse to accept the token from `conn`. There is no way to know
         * whether a call to this function is actually successful.
         *
         * Using this function is not required to benefit from session
         * resumption. If the TLS backend supports session resumption, the
         * session will be resumed automatically if it is possible to do so
         * without weakening the privacy guarantees normally provided by TLS,
         * without need to call this function. For example, with TLS 1.3,
         * a session ticket will be automatically copied from any
         * #GTlsClientConnection that has previously received session tickets
         * from the server, provided a ticket is available that has not
         * previously been used for session resumption, since session ticket
         * reuse would be a privacy weakness. Using this function causes the
         * ticket to be copied without regard for privacy considerations.
         * @param source a #GTlsClientConnection
         */
        copy_session_state(source: TlsClientConnection): void;
        /**
         * Gets the list of distinguished names of the Certificate Authorities
         * that the server will accept certificates from. This will be set
         * during the TLS handshake if the server requests a certificate.
         * Otherwise, it will be %NULL.
         *
         * Each item in the list is a #GByteArray which contains the complete
         * subject DN of the certificate authority.
         * @returns the list of CA DNs. You should unref each element with g_byte_array_unref() and then the free the list with g_list_free().
         */
        get_accepted_cas(): GLib.List;
        /**
         * Gets `conn'`s expected server identity
         * @returns a #GSocketConnectable describing the expected server identity, or %NULL if the expected identity is not known.
         */
        get_server_identity(): SocketConnectable | null;
        /**
         * SSL 3.0 is no longer supported. See
         * g_tls_client_connection_set_use_ssl3() for details.
         * @returns %FALSE
         */
        get_use_ssl3(): boolean;
        /**
         * Gets `conn'`s validation flags
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GTlsClientConnection:validation-flags for more
         * information.
         * @returns the validation flags
         */
        get_validation_flags(): TlsCertificateFlags;
        /**
         * Sets `conn'`s expected server identity, which is used both to tell
         * servers on virtual hosts which certificate to present, and also
         * to let `conn` know what name to look for in the certificate when
         * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
         * @param identity a #GSocketConnectable describing the expected server identity
         */
        set_server_identity(identity: SocketConnectable): void;
        /**
         * Since GLib 2.42.1, SSL 3.0 is no longer supported.
         *
         * From GLib 2.42.1 through GLib 2.62, this function could be used to
         * force use of TLS 1.0, the lowest-supported TLS protocol version at
         * the time. In the past, this was needed to connect to broken TLS
         * servers that exhibited protocol version intolerance. Such servers
         * are no longer common, and using TLS 1.0 is no longer considered
         * acceptable.
         *
         * Since GLib 2.64, this function does nothing.
         * @param use_ssl3 a #gboolean, ignored
         */
        set_use_ssl3(use_ssl3: boolean): void;
        /**
         * Sets `conn'`s validation flags, to override the default set of
         * checks performed when validating a server certificate. By default,
         * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
         *
         * This function does not work as originally designed and is impossible
         * to use correctly. See #GTlsClientConnection:validation-flags for more
         * information.
         * @param flags the #GTlsCertificateFlags to use
         */
        set_validation_flags(flags: TlsCertificateFlags): void;

        // Virtual methods

        /**
         * Possibly copies session state from one connection to another, for use
         * in TLS session resumption. This is not normally needed, but may be
         * used when the same session needs to be used between different
         * endpoints, as is required by some protocols, such as FTP over TLS.
         * `source` should have already completed a handshake and, since TLS 1.3,
         * it should have been used to read data at least once. `conn` should not
         * have completed a handshake.
         *
         * It is not possible to know whether a call to this function will
         * actually do anything. Because session resumption is normally used
         * only for performance benefit, the TLS backend might not implement
         * this function. Even if implemented, it may not actually succeed in
         * allowing `conn` to resume `source'`s TLS session, because the server
         * may not have sent a session resumption token to `source,` or it may
         * refuse to accept the token from `conn`. There is no way to know
         * whether a call to this function is actually successful.
         *
         * Using this function is not required to benefit from session
         * resumption. If the TLS backend supports session resumption, the
         * session will be resumed automatically if it is possible to do so
         * without weakening the privacy guarantees normally provided by TLS,
         * without need to call this function. For example, with TLS 1.3,
         * a session ticket will be automatically copied from any
         * #GTlsClientConnection that has previously received session tickets
         * from the server, provided a ticket is available that has not
         * previously been used for session resumption, since session ticket
         * reuse would be a privacy weakness. Using this function causes the
         * ticket to be copied without regard for privacy considerations.
         * @param source a #GTlsClientConnection
         */
        vfunc_copy_session_state(source: TlsClientConnection): void;
    }

    export const TlsClientConnection: TlsClientConnectionNamespace;

    module TlsFileDatabase {
        // Constructor properties interface

        interface ConstructorProps extends TlsDatabase.ConstructorProps {
            anchors: string;
        }
    }

    export interface TlsFileDatabaseNamespace {
        $gtype: GObject.GType<TlsFileDatabase>;
        prototype: TlsFileDatabase;

        /**
         * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
         * in `anchors` to verify certificate chains.
         *
         * The certificates in `anchors` must be PEM encoded.
         * @param anchors filename of anchor certificate authorities.
         */
        ['new'](anchors: string): TlsFileDatabase;
    }
    interface TlsFileDatabase extends TlsDatabase {
        // Properties

        /**
         * The path to a file containing PEM encoded certificate authority
         * root anchors. The certificates in this file will be treated as
         * root authorities for the purpose of verifying other certificates
         * via the g_tls_database_verify_chain() operation.
         */
        get anchors(): string;
        set anchors(val: string);
    }

    export const TlsFileDatabase: TlsFileDatabaseNamespace;

    module TlsServerConnection {
        // Constructor properties interface

        interface ConstructorProps extends TlsConnection.ConstructorProps {
            authentication_mode: TlsAuthenticationMode;
            authenticationMode: TlsAuthenticationMode;
        }
    }

    export interface TlsServerConnectionNamespace {
        $gtype: GObject.GType<TlsServerConnection>;
        prototype: TlsServerConnection;

        /**
         * Creates a new #GTlsServerConnection wrapping `base_io_stream` (which
         * must have pollable input and output streams).
         *
         * See the documentation for #GTlsConnection:base-io-stream for restrictions
         * on when application code can run operations on the `base_io_stream` after
         * this function has returned.
         * @param base_io_stream the #GIOStream to wrap
         * @param certificate the default server certificate, or %NULL
         */
        ['new'](base_io_stream: IOStream, certificate?: TlsCertificate | null): TlsServerConnection;
    }
    interface TlsServerConnection extends TlsConnection {
        // Properties

        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_tls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        get authentication_mode(): TlsAuthenticationMode;
        set authentication_mode(val: TlsAuthenticationMode);
        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_tls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        get authenticationMode(): TlsAuthenticationMode;
        set authenticationMode(val: TlsAuthenticationMode);
    }

    export const TlsServerConnection: TlsServerConnectionNamespace;

    module Volume {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface VolumeNamespace {
        $gtype: GObject.GType<Volume>;
        prototype: Volume;
    }
    interface Volume extends GObject.Object {
        // Methods

        /**
         * Checks if a volume can be ejected.
         * @returns %TRUE if the @volume can be ejected. %FALSE otherwise
         */
        can_eject(): boolean;
        /**
         * Checks if a volume can be mounted.
         * @returns %TRUE if the @volume can be mounted. %FALSE otherwise
         */
        can_mount(): boolean;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        eject(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult
         * @returns %TRUE, %FALSE if operation failed
         */
        eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_with_operation_finish() with the `volume`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to     avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult
         * @returns %TRUE if the volume was successfully ejected. %FALSE otherwise
         */
        eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of [identifiers](#volume-identifiers) that `volume` has.
         * Use g_volume_get_identifier() to obtain the identifiers themselves.
         * @returns a %NULL-terminated array   of strings containing kinds of identifiers. Use g_strfreev() to free.
         */
        enumerate_identifiers(): string[];
        /**
         * Gets the activation root for a #GVolume if it is known ahead of
         * mount time. Returns %NULL otherwise. If not %NULL and if `volume`
         * is mounted, then the result of g_mount_get_root() on the
         * #GMount object obtained from g_volume_get_mount() will always
         * either be equal or a prefix of what this function returns. In
         * other words, in code
         *
         *
         * ```c
         *   GMount *mount;
         *   GFile *mount_root
         *   GFile *volume_activation_root;
         *
         *   mount = g_volume_get_mount (volume); // mounted, so never NULL
         *   mount_root = g_mount_get_root (mount);
         *   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
         * ```
         *
         * then the expression
         *
         * ```c
         *   (g_file_has_prefix (volume_activation_root, mount_root) ||
         *    g_file_equal (volume_activation_root, mount_root))
         * ```
         *
         * will always be %TRUE.
         *
         * Activation roots are typically used in #GVolumeMonitor
         * implementations to find the underlying mount to shadow, see
         * g_mount_is_shadowed() for more details.
         * @returns the activation root of @volume     or %NULL. Use g_object_unref() to free.
         */
        get_activation_root(): File | null;
        /**
         * Gets the drive for the `volume`.
         * @returns a #GDrive or %NULL if @volume is not     associated with a drive. The returned object should be unreffed     with g_object_unref() when no longer needed.
         */
        get_drive(): Drive | null;
        /**
         * Gets the icon for `volume`.
         * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `volume`.
         * See the [introduction](#volume-identifiers) for more
         * information about volume identifiers.
         * @param kind the kind of identifier to return
         * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GVolume     doesn't have this kind of identifier
         */
        get_identifier(kind: string): string | null;
        /**
         * Gets the mount for the `volume`.
         * @returns a #GMount or %NULL if @volume isn't mounted.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        get_mount(): Mount | null;
        /**
         * Gets the name of `volume`.
         * @returns the name for the given @volume. The returned string should     be freed with g_free() when no longer needed.
         */
        get_name(): string;
        /**
         * Gets the sort key for `volume,` if any.
         * @returns Sorting key for @volume or %NULL if no such key is available
         */
        get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `volume`.
         * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
         */
        get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `volume`. The reference is typically based on
         * the file system UUID for the volume in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         * @returns the UUID for @volume or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
         */
        get_uuid(): string | null;
        /**
         * Mounts a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_mount_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        mount(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes mounting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         *
         * If the mount operation succeeded, g_volume_get_mount() on `volume`
         * is guaranteed to return the mount right after calling this
         * function; there's no need to listen for the 'mount-added' signal on
         * #GVolumeMonitor.
         * @param result a #GAsyncResult
         * @returns %TRUE, %FALSE if operation failed
         */
        mount_finish(result: AsyncResult): boolean;
        /**
         * Returns whether the volume should be automatically mounted.
         * @returns %TRUE if the volume should be automatically mounted
         */
        should_automount(): boolean;

        // Virtual methods

        /**
         * Checks if a volume can be ejected.
         */
        vfunc_can_eject(): boolean;
        /**
         * Checks if a volume can be mounted.
         */
        vfunc_can_mount(): boolean;
        /**
         * Changed signal that is emitted when the volume's state has changed.
         */
        vfunc_changed(): void;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        vfunc_eject(
            flags: MountUnmountFlags,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult
         */
        vfunc_eject_finish(result: AsyncResult): boolean;
        /**
         * Ejects a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_eject_with_operation_finish() with the `volume`
         * and #GAsyncResult data returned in the `callback`.
         * @param flags flags affecting the unmount if required for eject
         * @param mount_operation a #GMountOperation or %NULL to     avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        vfunc_eject_with_operation(
            flags: MountUnmountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes ejecting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         * @param result a #GAsyncResult
         */
        vfunc_eject_with_operation_finish(result: AsyncResult): boolean;
        /**
         * Gets the kinds of [identifiers](#volume-identifiers) that `volume` has.
         * Use g_volume_get_identifier() to obtain the identifiers themselves.
         */
        vfunc_enumerate_identifiers(): string[];
        /**
         * Gets the activation root for a #GVolume if it is known ahead of
         * mount time. Returns %NULL otherwise. If not %NULL and if `volume`
         * is mounted, then the result of g_mount_get_root() on the
         * #GMount object obtained from g_volume_get_mount() will always
         * either be equal or a prefix of what this function returns. In
         * other words, in code
         *
         *
         * ```c
         *   GMount *mount;
         *   GFile *mount_root
         *   GFile *volume_activation_root;
         *
         *   mount = g_volume_get_mount (volume); // mounted, so never NULL
         *   mount_root = g_mount_get_root (mount);
         *   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
         * ```
         *
         * then the expression
         *
         * ```c
         *   (g_file_has_prefix (volume_activation_root, mount_root) ||
         *    g_file_equal (volume_activation_root, mount_root))
         * ```
         *
         * will always be %TRUE.
         *
         * Activation roots are typically used in #GVolumeMonitor
         * implementations to find the underlying mount to shadow, see
         * g_mount_is_shadowed() for more details.
         */
        vfunc_get_activation_root(): File | null;
        /**
         * Gets the drive for the `volume`.
         */
        vfunc_get_drive(): Drive | null;
        /**
         * Gets the icon for `volume`.
         */
        vfunc_get_icon(): Icon;
        /**
         * Gets the identifier of the given kind for `volume`.
         * See the [introduction](#volume-identifiers) for more
         * information about volume identifiers.
         * @param kind the kind of identifier to return
         */
        vfunc_get_identifier(kind: string): string | null;
        /**
         * Gets the mount for the `volume`.
         */
        vfunc_get_mount(): Mount | null;
        /**
         * Gets the name of `volume`.
         */
        vfunc_get_name(): string;
        /**
         * Gets the sort key for `volume,` if any.
         */
        vfunc_get_sort_key(): string | null;
        /**
         * Gets the symbolic icon for `volume`.
         */
        vfunc_get_symbolic_icon(): Icon;
        /**
         * Gets the UUID for the `volume`. The reference is typically based on
         * the file system UUID for the volume in question and should be
         * considered an opaque string. Returns %NULL if there is no UUID
         * available.
         */
        vfunc_get_uuid(): string | null;
        /**
         * Finishes mounting a volume. If any errors occurred during the operation,
         * `error` will be set to contain the errors and %FALSE will be returned.
         *
         * If the mount operation succeeded, g_volume_get_mount() on `volume`
         * is guaranteed to return the mount right after calling this
         * function; there's no need to listen for the 'mount-added' signal on
         * #GVolumeMonitor.
         * @param result a #GAsyncResult
         */
        vfunc_mount_finish(result: AsyncResult): boolean;
        /**
         * Mounts a volume. This is an asynchronous operation, and is
         * finished by calling g_volume_mount_finish() with the `volume`
         * and #GAsyncResult returned in the `callback`.
         * @param flags flags affecting the operation
         * @param mount_operation a #GMountOperation or %NULL to avoid user interaction
         * @param cancellable optional #GCancellable object, %NULL to ignore
         * @param callback a #GAsyncReadyCallback, or %NULL
         */
        vfunc_mount_fn(
            flags: MountMountFlags,
            mount_operation?: MountOperation | null,
            cancellable?: Cancellable | null,
            callback?: AsyncReadyCallback<this> | null,
        ): void;
        /**
         * The removed signal that is emitted when the #GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.
         */
        vfunc_removed(): void;
        /**
         * Returns whether the volume should be automatically mounted.
         */
        vfunc_should_automount(): boolean;
    }

    export const Volume: VolumeNamespace;

    export interface DBusNamespace {
        prototype: DBus;
        readonly session: DBusConnection;
        readonly system: DBusConnection;
        /**
         * Asynchronously connects to the message bus specified by `bus_type`.
         *
         * When the operation is finished, `callback` will be invoked. You can
         * then call g_bus_get_finish() to get the result of the operation.
         *
         * This is an asynchronous failable function. See g_bus_get_sync() for
         * the synchronous version.
         * @param bus_type a #GBusType
         * @param cancellable a #GCancellable or %NULL
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        get(bus_type: BusType, cancellable?: Cancellable | null, callback?: AsyncReadyCallback<BusType> | null): void;
        /**
         * Finishes an operation started with g_bus_get().
         *
         * The returned object is a singleton, that is, shared with other
         * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
         * event that you need a private message bus connection, use
         * g_dbus_address_get_for_bus_sync() and
         * g_dbus_connection_new_for_address() with
         * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
         * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
         *
         * Note that the returned #GDBusConnection object will (usually) have
         * the #GDBusConnection:exit-on-close property set to %TRUE.
         * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_bus_get()
         */
        get_finish(res: AsyncResult): DBusConnection;
        /**
         * Synchronously connects to the message bus specified by `bus_type`.
         * Note that the returned object may shared with other callers,
         * e.g. if two separate parts of a process calls this function with
         * the same `bus_type,` they will share the same object.
         *
         * This is a synchronous failable function. See g_bus_get() and
         * g_bus_get_finish() for the asynchronous version.
         *
         * The returned object is a singleton, that is, shared with other
         * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
         * event that you need a private message bus connection, use
         * g_dbus_address_get_for_bus_sync() and
         * g_dbus_connection_new_for_address() with
         * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
         * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
         *
         * Note that the returned #GDBusConnection object will (usually) have
         * the #GDBusConnection:exit-on-close property set to %TRUE.
         * @param bus_type a #GBusType
         * @param cancellable a #GCancellable or %NULL
         */
        get_sync(bus_type: BusType, cancellable?: Cancellable | null): DBusConnection;
        /**
         * Version of g_bus_own_name() using closures instead of callbacks for
         * easier binding in other languages.
         * @param bus_type the type of bus to own a name on
         * @param name the well-known name to own
         * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
         * @param bus_acquired_closure #GClosure to invoke when connected to     the bus of type @bus_type or %NULL
         * @param name_acquired_closure #GClosure to invoke when @name is     acquired or %NULL
         * @param name_lost_closure #GClosure to invoke when @name is lost or     %NULL
         */
        own_name(
            bus_type: BusType,
            name: string,
            flags: BusNameOwnerFlags,
            bus_acquired_closure?: GObject.Closure | null,
            name_acquired_closure?: GObject.Closure | null,
            name_lost_closure?: GObject.Closure | null,
        ): number;
        /**
         * Version of g_bus_own_name_on_connection() using closures instead of
         * callbacks for easier binding in other languages.
         * @param connection a #GDBusConnection
         * @param name the well-known name to own
         * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
         * @param name_acquired_closure #GClosure to invoke when @name is     acquired or %NULL
         * @param name_lost_closure #GClosure to invoke when @name is lost     or %NULL
         */
        own_name_on_connection(
            connection: DBusConnection,
            name: string,
            flags: BusNameOwnerFlags,
            name_acquired_closure?: GObject.Closure | null,
            name_lost_closure?: GObject.Closure | null,
        ): number;
        /**
         * Stops owning a name.
         *
         * Note that there may still be D-Bus traffic to process (relating to owning
         * and unowning the name) in the current thread-default #GMainContext after
         * this function has returned. You should continue to iterate the #GMainContext
         * until the #GDestroyNotify function passed to g_bus_own_name() is called, in
         * order to avoid memory leaks through callbacks queued on the #GMainContext
         * after its stopped being iterated.
         * @param owner_id an identifier obtained from g_bus_own_name()
         */
        unown_name(owner_id: number): void;
        /**
         * Version of g_bus_watch_name() using closures instead of callbacks for
         * easier binding in other languages.
         * @param bus_type The type of bus to watch a name on.
         * @param name The name (well-known or unique) to watch.
         * @param flags Flags from the #GBusNameWatcherFlags enumeration.
         * @param name_appeared_closure #GClosure to invoke when @name is known to exist or %NULL.
         * @param name_vanished_closure #GClosure to invoke when @name is known to not exist or %NULL.
         */
        watch_name(
            bus_type: BusType,
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure?: GObject.Closure | null,
            name_vanished_closure?: GObject.Closure | null,
        ): number;
        /**
         * Stops watching a name.
         *
         * Note that there may still be D-Bus traffic to process (relating to watching
         * and unwatching the name) in the current thread-default #GMainContext after
         * this function has returned. You should continue to iterate the #GMainContext
         * until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
         * order to avoid memory leaks through callbacks queued on the #GMainContext
         * after its stopped being iterated.
         * @param watcher_id An identifier obtained from g_bus_watch_name()
         */
        unwatch_name(watcher_id: number): void;
        /**
         * Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
         * easier binding in other languages.
         * @param connection A #GDBusConnection.
         * @param name The name (well-known or unique) to watch.
         * @param flags Flags from the #GBusNameWatcherFlags enumeration.
         * @param name_appeared_closure #GClosure to invoke when @name is known to exist or %NULL.
         * @param name_vanished_closure #GClosure to invoke when @name is known to not exist or %NULL.
         */
        watch_name_on_connection(
            connection: DBusConnection,
            name: string,
            flags: BusNameWatcherFlags,
            name_appeared_closure?: GObject.Closure | null,
            name_vanished_closure?: GObject.Closure | null,
        ): number;
    }
    interface DBus {}

    export const DBus: DBusNamespace;

    class DBusExportedObject {
        static $gtype: GObject.GType<DBusExportedObject>;

        // Constructors

        _init(...args: any[]): void;

        // Static methods

        static wrapJSObject(info: string, obj: any): DBusExportedObject;

        // Methods

        get_info(): DBusInterfaceInfo;
        get_connection(): DBusConnection;
        get_object_path(): string;
        unexport_from_connection(connection: DBusConnection): void;
        ['export'](busConnection: DBusConnection, objectPath: string): void;
        unexport(): void;
        flush(): void;
        emit_signal(name: string, variant: GLib.Variant): void;
        emit_property_changed(name: string, variant: GLib.Variant): void;
    }

    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default Gio;

// END
